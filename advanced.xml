<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS : 20070311 -->

 <chapter id="tutorial-advanced">
  <title>Fonctionnalités avancées</title>

  <sect1 id="tutorial-advanced-intro">
   <title>Introduction</title>

   <para>
    Le chapitre précédant couvre les bases de l'utilisation
    de <acronym>SQL</acronym> pour le stockage et l'accès aux données avec
    <productname>PostgreSQL</productname>. Il est temps d'aborder
    quelques fonctionnalités avancées du <acronym>SQL</acronym>
    qui simplifient la gestion et empêchent la perte ou la corruption des
    données. Quelques extensions de <productname>PostgreSQL</productname> sont
    également abordées.
   </para>

   <para>
    Ce chapitre fait occasionnellement référence aux exemples disponibles dans le
    <xref linkend="tutorial-sql"/> pour les modifier ou les améliorer. Il est donc
    préférable d'avoir lu ce chapitre. Quelques exemples de ce
    chapitre sont également disponibles dans <filename>advanced.sql</filename>
    situé dans le répertoire du tutoriel. Ce fichier contient, de plus, quelques
    données à charger pour utiliser l'exemple. Cela n'est pas repris ici 
    (on peut se référer à la <xref linkend="tutorial-sql-intro"/> pour savoir comment
    utiliser ce fichier).
   </para>
  </sect1>


  <sect1 id="tutorial-views">
   <title>Vues</title>

   <indexterm zone="tutorial-views">
    <primary>vue</primary>
    <secondary>view</secondary>
   </indexterm>

   <para>
    Se référer aux requêtes de la <xref linkend="tutorial-join"/>.
    Si la liste des enregistrements du temps et des villes est d'un
    intérêt particulier pour l'application considérée mais qu'il devient
    contraignant de saisir la requête à chaque utilisation, il est possible
    de créer une <firstterm>vue</firstterm> avec la requête. De ce fait, la
    requête est nommée et il peut y être fait référence de la même façon
    qu'il est fait référence à une table&nbsp;:

<programlisting>CREATE VIEW ma_vue AS
    SELECT ville, t_basse, t_haute, prcp, date, emplacement
        FROM temps, villes
        WHERE ville = nom;

SELECT * FROM ma_vue;</programlisting>
   </para>

   <para>
    L'utilisation des vues est un aspect clé d'une bonne
    conception des bases de données SQL. Les vues permettent
    d'encapsuler les détails de la structure des tables. Celle-ci peut
    alors changer avec l'évolution de l'application, tandis que l'interface reste
    constante.
   </para>

   <para>
    Les vues peuvent être utilisées dans quasiment toutes les situations
    où une vraie table est utilisable. Il n'est, de plus, pas
    inhabituel de construire des vues reposant sur d'autres vues.
   </para>
  </sect1>


  <sect1 id="tutorial-fk">
   <title>Clés étrangères</title>

   <indexterm zone="tutorial-fk">
    <primary>clé étrangère</primary>
    <secondary>foreign key</secondary>
   </indexterm>

   <indexterm zone="tutorial-fk">
    <primary>intégrité référentielle</primary>
    <secondary>referential integrity</secondary>
   </indexterm>

   <para>
    Soient les tables 
    <classname>temps</classname> et <classname>villes</classname> définies
    dans le <xref linkend="tutorial-sql"/>.
    Il s'agit maintenant de s'assurer que personne
    n'insère de ligne dans la table <classname>temps</classname> qui ne
    corresponde à une entrée dans la table <classname>villes</classname>.
    On appelle cela maintenir l'<firstterm>intégrité
    référentielle</firstterm> des données. Dans les systèmes de bases de
    données simplistes, lorsqu'au moins c'est possible, cela est parfois
    obtenu par la vérification préalable de l'existence d'un enregistrement
    correspondant dans la table <classname>villes</classname>, puis par
    l'insertion, ou l'interdiction, du nouvel enregistrement dans 
    <classname>temps</classname>. Puisque cette approche, peu pratique, 
    présente un certain nombre d'inconvénients, 
    <productname>PostgreSQL</productname> peut se charger du maintien de
    l'<firstterm>intégrité référentielle</firstterm>.
   </para>

   <para>
    La nouvelle déclaration des tables ressemble alors à ceci&nbsp;:

<programlisting>CREATE TABLE villes (
	ville       varchar(80) primary key,
	emplacement point
);

CREATE TABLE temps (
	ville      varchar(80) references villes,
	t_haute int,
	t_basse int,
	prcp       real,
	date       date
);</programlisting>

    Lors d'une tentative d'insertion d'enregistrement non valide&nbsp;:

<programlisting>INSERT INTO temps VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');</programlisting>

<screen>ERROR:  insert or update on table "temps" violates foreign key constraint "temps_ville_fkey"
DETAIL : Key (ville)=(a) is not present in table "villes".</screen>

<!-- SAS 20061109
Pourquoi ne pas traduire les messages d'erreur ?
<screen>ERROR:  insert or update on table "temps" violates foreign key constraint "temps_ville_fkey"
DETAIL:  Key (ville)=(Berkeley) is not present in table "villes".</screen>
-->
   </para>

<!-- SAS 20080225
Clé secondaire ? -->
   <para>
    Le comportement des clés étrangères peut être adapté très finement à
    une application particulière. Ce tutoriel ne va pas plus loin que cet exemple simple.
    De plus amples informations sont accessibles dans le <xref linkend="ddl"/>.
    Une utilisation efficiente des clés étrangères améliore la
    qualité des applications accédant aux bases de données. Il est donc
    fortement conseillé d'apprendre à les utiliser.
   </para>
  </sect1>


  <sect1 id="tutorial-transactions">
   <title>Transactions</title>

   <indexterm zone="tutorial-transactions">
    <primary>transaction</primary>
   </indexterm>

   <para>
    Les <firstterm>transactions</firstterm> sont un concept fondamental de tous les
    systèmes de bases de données. Une transaction assemble plusieurs étapes
    en une seule opération tout-ou-rien.
    Les états intermédiaires entre les étapes ne sont pas visibles par les
    transactions concurrentes. De plus, si un échec survient qui empêche le
    succès de la transaction, alors aucune des étapes n'affecte la base
    de données.
   </para>

   <para>
    Si l'on considère, par exemple, la base de données d'une banque qui
    contient le solde de différents comptes clients et le solde total des
    dépôts par branches et que l'on veuille enregistrer un virement de
    100 euros du compte d'Alice vers celui de Bob, 
    les commandes SQL peuvent ressembler à cela (après simplification)&nbsp;:

<programlisting>UPDATE comptes SET balance = balance - 100.00
    WHERE nom = 'Alice';
UPDATE branches SET balance = balance - 100.00
    WHERE nom = (SELECT nom_branche FROM comptes WHERE nom = 'Alice');
UPDATE comptes SET balance = balance + 100.00
    WHERE nom = 'Bob';
UPDATE branches SET balance = balance + 100.00
    WHERE nom = (SELECT nom_branche FROM comptes WHERE nom = 'Bob');</programlisting>
   </para>

   <para>
    Ce ne sont pas les détails des commandes qui importent ici&nbsp;; le point
    important est la nécessité de plusieurs mises à jour séparées pour
    accomplir cette opération assez simple. Les employés de la banque
    veulent être assurés que, soit toutes les commandes sont effectuées,
    soit aucune ne l'est. Il n'est pas envisageable que, suite à une erreur
    du système, Bob reçoive 100 euros qui n'ont pas été débités du compte
    d'Alice. De la même façon, Alice ne restera pas longtemps une cliente fidèle
    si elle est débitée du montant sans que celui-ci ne soit crédité sur le compte
    de Bob.
   </para>
   <para>
    Il est important de garantir que si quelque chose se
    passe mal, aucune des étapes déjà exécutées n'est prise en compte. Le
    regroupement des mises à jour au sein d'une <firstterm>transaction</firstterm>
    apporte cette garantie.
    Une transaction est dite <firstterm>atomique</firstterm>&nbsp;:
    du point de vue des autres transactions, elle passe complètement ou pas du tout.
   </para>

   <para>
    Il est également nécessaire de garantir qu'une fois la transaction
    terminée et validée par la base de données, les transactions sont
    enregistrées définitivement et ne peuvent être perdues, même si une
    panne survient peu après.
   </para>
   <para>
    Ainsi, si un retrait d'argent est effectué par Bob, il ne faut
    absolument pas que le débit de son compte disparaisse avec l'apparition
    d'une panne juste après son départ de la banque. 
   </para>
   <para>
    Une base de données transactionnelle garantit que toutes les mises à jour
    faites lors d'une transaction sont stockées de manière persistante
    (c'est-à-dire sur disque) avant que la transaction ne soit déclarée validée.
   </para>

   <para>
    Une autre propriété importante des bases de données transactionnelles est
    en relation étroite avec la notion de mises à jour atomiques&nbsp;: quand
    plusieurs transactions sont lancées en parallèle, aucune d'entre elles
    ne doit être capable de voir les modifications incomplètes effectuées
    par les autres.
   </para>
   <para>
    Ainsi, si une transaction calcule le total de toutes les branches,
    inclure le débit de la branche d'Alice sans le crédit de la branche de
    Bob, ou vice-versa, est une véritable erreur.
   </para>
   <para>
    Les transactions doivent donc être tout-ou-rien, non seulement pour leur
    effet persistant sur la base de données, mais aussi pour leur visibilité
    au moment de leur exécution. Les mises à jour faites jusque-là par une
    transaction ouverte sont invisibles aux autres transactions jusqu'à la fin
    de celle-là. À ce moment toutes les mises à jours deviennent
    simultanément visibles.
   </para>

   <para>
    Sous <productname>PostgreSQL</productname>, une transaction est déclarée 
    en entourant les commandes SQL de la transaction par les commandes
    <command>BEGIN</command> et <command>COMMIT</command>. 
   </para>
   <para>
    La transaction bancaire ressemble alors à ceci&nbsp;:

<programlisting>BEGIN;
UPDATE comptes SET balance = balance - 100.00
    WHERE nom = 'Alice';
-- etc etc
COMMIT;</programlisting>
   </para>

   <para>
    Si, au cours de la transaction, il est décidé de ne pas valider
    (peut-être la banque s'aperçoit-elle que la balance d'Alice passe en 
    négatif), la commande <command>ROLLBACK</command> peut être utilisée à
    la place de <command>COMMIT</command>. Toutes les mises à jour réalisées
    jusque-là sont alors annulées.
   </para>

   <para>
    En fait, <productname>PostgreSQL</productname> traite chaque instruction SQL comme
    si elle était exécutée dans une transaction. En l'absence de commande
    <command>BEGIN</command> explicite, chaque instruction individuelle se trouve
    implicitement entourée d'un <command>BEGIN</command> et (en cas de succès) d'un
    <command>COMMIT</command>. 
   </para>
   <para>
    Un groupe d'instructions entourées par 
    <command>BEGIN</command> et <command>COMMIT</command> est parfois appelé 
    <firstterm>bloc transactionnel</firstterm>.
   </para>

   <note>
    <para>
     Quelques bibliothèques clientes lancent les commandes
     <command>BEGIN</command> et <command>COMMIT</command> automatiquement.
     L'utilisateur bénéficie alors des effets des blocs transactionnels
     sans les demander. Ces informations se trouvent en général dans la
     documentation de l'interface utilisée.
    </para>
   </note>
   
   <para>
    Il est possible d'augmenter la granularité du contrôle des instructions
    au sein d'une transaction en utilisant des 
    <firstterm>points de retournement</firstterm>
    (<foreignphrase>savepoint</foreignphrase>). Ceux-ci permettent d'annuler des
    parties de la transaction tout en validant le reste.
   </para>
   <para>
    Après avoir défini un point de retournement à l'aide de
    <command>SAVEPOINT</command>, les instructions exécutées depuis ce point
    peuvent, au besoin, être annulées avec <command>ROLLBACK TO</command>. 
    Toutes les modifications de la base de données effectuées par la
    transaction entre le moment où le point de retournement a été défini et
    celui où l'annulation est demandée sont annulées mais les modifications
    antérieures à ce point sont conservées.
   </para> 

   <para>
    Le retour à un point de retournement ne l'annule pas. Il reste défini et
    peut donc être utilisé plusieurs fois. À l'inverse, lorsqu'il n'est plus
    nécessaire de revenir à un point de sauvegarde pariculier, il peut être
    relâché, ce qui permet de libérer des ressources systèmes. Il faut
    savoir toutefois que relâcher un point de retournement, ou y revenir
    relâche tous les points de sauvegarde qui ont été définis après.
   </para> 

   <para>
    Tout ceci survient à l'intérieur du bloc de transaction, et n'est donc pas
    visible par les autres sessions en cours sur la base de données. Si le
    bloc est validé, et à ce moment-là seulement, toutes les actions validées
    deviennent immédiatement visibles par les autres sessions, tandis que
    les actions annulées ne le seront jamais.
   </para> 

   <para>
    Reconsidérant la base de données de la banque, on peut supposer vouloir
    débiter le compte d'Alice de $100.00, somme à créditer sur le compte de Bob,
    mais considérer plus tard que c'est le compte de Wally qu'il convient de
    créditer. À l'aide des points de retournement, cela peut-être réalisé
    ainsi&nbsp;:

<programlisting>BEGIN;
UPDATE comptes SET balance = balance - 100.00
    WHERE nom = 'Alice';
SAVEPOINT mon_pointdesauvegarde;
UPDATE comptes SET balance = balance + 100.00
    WHERE nom = 'Bob';
-- oups ... oublions ça et créditons le compte de Wally
ROLLBACK TO mon_pointdesauvegarde;
UPDATE comptes SET balance = balance + 100.00
    WHERE nom = 'Wally';
COMMIT;</programlisting>
   </para>

   <para>
    Cet exemple est bien sûr très simplifié mais de nombreux contrôles sont
    réalisables au sein d'un bloc de transaction grâce à l'utilisation des points de
    retournement. Qui plus est, <command>ROLLBACK TO</command> est le seul moyen
    de regagner le contrôle d'un bloc de transaction placé dans un état
    d'annulation par le système du fait d'une erreur. C'est plus rapide que
    de tout annuler pour tout recommencer.
   </para>
  </sect1>


  <sect1 id="tutorial-window">
   <title id="tutorial-window-title">Window Functions</title>

   <indexterm zone="tutorial-window">
    <primary>window function</primary>
   </indexterm>

   <para>
    A <firstterm>window function</firstterm> performs a calculation across a set of
    table rows that are somehow related to the current row.  This is comparable
    to the type of calculation that can be done with an aggregate function.
    But unlike regular aggregate functions, use of a window function does not
    cause rows to become grouped into a single output row &mdash; the
    rows retain their separate identities.  Behind the scenes, the window
    function is able to access more than just the current row of the query
    result.
   </para>

   <para>
    Here is an example that shows how to compare each employee's salary
    with the average salary in his or her department:

<programlisting>
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary |          avg          
-----------+-------+--------+-----------------------
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel |     5 |   3500 | 3700.0000000000000000
 personnel |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
(10 rows)
</screen>

    The first three output columns come directly from the table
    <structname>empsalary</structname>, and there is one output row for each row in the
    table.  The fourth column represents an average taken across all the table
    rows that have the same <structfield>depname</structfield> value as the current row.
    (This actually is the same function as the regular <function>avg</function>
    aggregate function, but the <literal>OVER</literal> clause causes it to be
    treated as a window function and computed across an appropriate set of
    rows.)
   </para>

   <para>
    A window function call always contains an <literal>OVER</literal> clause
    following the window function's name and argument(s).  This is what
    syntactically distinguishes it from a regular function or aggregate
    function.  The <literal>OVER</literal> clause determines exactly how the
    rows of the query are split up for processing by the window function.
    The <literal>PARTITION BY</literal> list within <literal>OVER</literal> specifies
    dividing the rows into groups, or partitions, that share the same
    values of the <literal>PARTITION BY</literal> expression(s).  For each row,
    the window function is computed across the rows that fall into the
    same partition as the current row.
   </para>

   <para>
    Although <function>avg</function> will produce the same result no matter
    what order it processes the partition's rows in, this is not true of all
    window functions.  When needed, you can control that order using
    <literal>ORDER BY</literal> within <literal>OVER</literal>.  Here is an example:

<programlisting>
SELECT depname, empno, salary, rank() OVER (PARTITION BY depname ORDER BY salary DESC) FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary | rank 
-----------+-------+--------+------
 develop   |     8 |   6000 |    1
 develop   |    10 |   5200 |    2
 develop   |    11 |   5200 |    2
 develop   |     9 |   4500 |    4
 develop   |     7 |   4200 |    5
 personnel |     2 |   3900 |    1
 personnel |     5 |   3500 |    2
 sales     |     1 |   5000 |    1
 sales     |     4 |   4800 |    2
 sales     |     3 |   4800 |    2
(10 rows)
</screen>

    As shown here, the <function>rank</function> function produces a numerical rank
    within the current row's partition for each distinct <literal>ORDER
    BY</literal>
    value, in the order defined by the <literal>ORDER BY</literal> clause.
    <function>rank</function> needs no explicit parameter, because its behavior
    is entirely determined by the <literal>OVER</literal> clause.
   </para>

   <para>
    The rows considered by a window function are those of the <quote>virtual
    table</quote> produced by the query's <literal>FROM</literal> clause as filtered by its
    <literal>WHERE</literal>, <literal>GROUP BY</literal>, and
    <literal>HAVING</literal> clauses
    if any.  For example, a row removed because it does not meet the
    <literal>WHERE</literal> condition is not seen by any window function.
    A query can contain multiple window functions that slice up the data
    in different ways by means of different <literal>OVER</literal> clauses, but
    they all act on the same collection of rows defined by this virtual table.
   </para>

   <para>
    We already saw that <literal>ORDER BY</literal> can be omitted if the ordering
    of rows is not important.  It is also possible to omit <literal>PARTITION
    BY</literal>, in which case there is just one partition containing all the rows.
   </para>

   <para>
    There is another important concept associated with window functions:
    for each row, there is a set of rows within its partition called its
    <firstterm>window frame</firstterm>.  Many (but not all) window functions act only
    on the rows of the window frame, rather than of the whole partition.
    By default, if <literal>ORDER BY</literal> is supplied then the frame consists of
    all rows from the start of the partition up through the current row, plus
    any following rows that are equal to the current row according to the
    <literal>ORDER BY</literal> clause.  When <literal>ORDER BY</literal> is omitted the
    default frame consists of all rows in the partition.
     <footnote>
      <para>
       There are options to define the window frame in other ways, but
       this tutorial does not cover them.  See
       <xref linkend="syntax-window-functions"/> for details.
      </para>
     </footnote>
    Here is an example using <function>sum</function>:
   </para>

<programlisting>
SELECT salary, sum(salary) OVER () FROM empsalary;
</programlisting>

<screen>
 salary |  sum  
--------+-------
   5200 | 47100
   5000 | 47100
   3500 | 47100
   4800 | 47100
   3900 | 47100
   4200 | 47100
   4500 | 47100
   4800 | 47100
   6000 | 47100
   5200 | 47100
(10 rows)
</screen>

   <para>
    Above, since there is no <literal>ORDER BY</literal> in the
    <literal>OVER</literal>
    clause, the window frame is the same as the partition, which for lack of
    <literal>PARTITION BY</literal> is the whole table; in other words each sum is
    taken over the whole table and so we get the same result for each output
    row.  But if we add an <literal>ORDER BY</literal> clause, we get very different
    results:
   </para>

<programlisting>
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
</programlisting>

<screen>
 salary |  sum  
--------+-------
   3500 |  3500
   3900 |  7400
   4200 | 11600
   4500 | 16100
   4800 | 25700
   4800 | 25700
   5000 | 30700
   5200 | 41100
   5200 | 41100
   6000 | 47100
(10 rows)
</screen>

   <para>
    Here the sum is taken from the first (lowest) salary up through the
    current one, including any duplicates of the current one (notice the
    results for the duplicated salaries).
   </para>

   <para>
    Window functions are permitted only in the <literal>SELECT</literal> list
    and the <literal>ORDER BY</literal> clause of the query. They are forbidden
    elsewhere, such as in <literal>GROUP BY</literal>,
<literal>HAVING</literal>
    and <literal>WHERE</literal> clauses.  This is because they logically
    execute after the processing of those clauses.  Also, window functions
    execute after regular aggregate functions.  This means it is valid to
    include an aggregate function call in the arguments of a window function,
    but not vice versa.
   </para>

   <para>
    If there is a need to filter or group rows after the window calculations
    are performed, you can use a sub-select.  For example:

<programlisting>
SELECT depname, empno, salary, enroll_date
FROM
  (SELECT depname, empno, salary, enroll_date,
          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
     FROM empsalary
  ) AS ss
WHERE pos &lt; 3;
</programlisting>

    The above query only shows the rows from the inner query having
    <literal>rank</literal> less than <literal>3</literal>.
   </para>

   <para>
    When a query involves multiple window functions, it is possible to write
    out each one with a separate <literal>OVER</literal> clause, but this is
    duplicative and error-prone if the same windowing behavior is wanted
    for several functions.  Instead, each windowing behavior can be named
    in a <literal>WINDOW</literal> clause and then referenced in
    <literal>OVER</literal>.
    For example:

<programlisting>
SELECT sum(salary) OVER w, avg(salary) OVER w
  FROM empsalary
  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
</programlisting>
   </para>

   <para>
    More details about window functions can be found in
    <xref linkend="syntax-window-functions"/>,
    <xref linkend="queries-window"/>, and the
    <xref linkend="sql-select" endterm="sql-select-title"/> reference page.
   </para>
  </sect1>


  <sect1 id="tutorial-inheritance">
   <title>Héritage</title>

   <indexterm zone="tutorial-inheritance">
    <primary>héritage</primary>
    <secondary>inheritance</secondary>
   </indexterm>

   <para>
    L'héritage est un concept issu des bases de données orientées objet.
    Il ouvre de nouvelles possibilités intéressantes en conception de
    bases de données.
   </para>

   <para>
    Soient deux tables&nbsp;: une table <classname>villes</classname> et une
    table <classname>capitales</classname>. Les capitales étant également
    des villes, il est intéressant d'avoir la possibilité d'afficher
    implicitement les capitales lorsque les villes sont listées. Un
    utilisateur particulièrement brillant peut écrire ceci&nbsp;

<programlisting>CREATE TABLE capitales (
  nom        text,
  population real,
  altitude   int,    -- (en pied)
  etat       char(2)
);

CREATE TABLE non_capitales (
  nom        text,
  population real,
  altitude   int     -- (en pied)
);

CREATE VIEW villes AS
  SELECT nom, population, altitude FROM capitales
    UNION
  SELECT nom, population, altitude FROM non_capitales;</programlisting>

    Cela fonctionne bien pour les requêtes, mais la mise à jour d'une même
    donnée sur plusieurs lignes devient vite un horrible casse-tête.
   </para>

   <para>
    Une meilleure solution peut-être&nbsp;:

<programlisting>CREATE TABLE villes (
  nom        text,
  population real,
  altitude   int     -- (en pied)
);

CREATE TABLE capitales (
  etat      char(2)
) INHERITS (villes);</programlisting>
   </para>

   <para>
    Dans ce cas, une ligne de <classname>capitales</classname>
    <firstterm>hérite</firstterm> de toutes les colonnes (<structfield>nom</structfield>,
    <structfield>population</structfield> et <structfield>altitude</structfield>) de son
    <firstterm>parent</firstterm>, <classname>villes</classname>. Le type de la
    colonne <structfield>nom</structfield> est <type>text</type>, un type natif
    de <productname>PostgreSQL</productname> pour les chaînes de caractères à
    longueur variable. Les capitales d'état ont une colonne supplémentaire,
    <structfield>etat</structfield>, qui affiche l'état dont elles sont la
    capitale. Sous <productname>PostgreSQL</productname>,
    une table peut hériter de zéro à plusieurs autres tables.
   </para>

   <para>
    La requête qui suit fournit un exemple de récupération des noms de
    toutes les villes, en incluant les capitales des états, situées à une
    altitude de plus de 500 pieds&nbsp;:

<programlisting>SELECT nom, altitude
  FROM villes
  WHERE altitude &gt; 500;</programlisting>

    ce qui renvoie&nbsp;:

<screen>   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
(3 rows)</screen>
   </para>

   <para>
    À l'inverse, la requête qui suit récupère toutes les villes qui ne sont pas des
    capitales et qui sont situées à une altitude d'au moins 500 pieds&nbsp;:

<programlisting>SELECT nom, altitude
    FROM ONLY villes
    WHERE altitude &gt; 500;</programlisting>

<screen>   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
(2 rows)</screen>
   </para>

   <para>
    Ici, <literal>ONLY</literal> avant <literal>villes</literal>
    indique que la requête ne doit être exécutée que sur la table
    <classname>villes</classname>, et non pas sur les tables en dessous de
    <classname>villes</classname> dans la hiérarchie des héritages. La plupart
    des commandes déjà évoquées &mdash;
    <command>SELECT</command>, <command>UPDATE</command> et
    <command>DELETE</command> &mdash; supportent cette
    notation (<literal>ONLY</literal>).
   </para>

   <note>
    <para>
     Bien que l'héritage soit fréquemment utile, il n'a pas été intégré avec
     les contraintes d'unicité et les clés étrangères, ce qui limite son utilité.
     Voir la <xref linkend="ddl-inherit"/> pour plus de détails.
    </para>
   </note>
  </sect1>


  <sect1 id="tutorial-conclusion">
   <title>Conclusion</title>
 
   <para>
    <productname>PostgreSQL</productname> dispose d'autres fonctionnalités
    non décrites dans ce tutoriel d'introduction orienté vers
    les nouveaux utilisateurs de <acronym>SQL</acronym>. Ces fonctionnalités
    sont discutées plus en détails dans le reste de ce livre.
   </para>

   <para>
    Si une introduction plus approfondie est nécessaire, le lecteur peut
    visiter le <ulink url="http://www.postgresql.org">site web</ulink>
    de PostgreSQL qui fournit des liens vers d'autres ressources.
   </para>
  </sect1>
 </chapter>

