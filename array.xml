<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS : 20070423, PG824 -->

<sect1 id="arrays">
 <title>Tableaux</title>

 <indexterm>
  <primary>tableau</primary>
  <secondary>array</secondary>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname> permet de définir des colonnes de
  table comme des tableaux multidimensionnels de longueur variable. Il est
  possible de créer des tableaux de n'importe quel type utilisateur&nbsp;:
  de base, composé, enum. Toutefois, les tableaux de domaines ne sont pas
  encore supportés.
 </para>

 <sect2>
  <title>Déclaration des types de tableaux</title>

 <para>
  La création de la table suivante permet d'illustrer l'utilisation des types
  tableaux&nbsp;:
<programlisting>CREATE TABLE sal_emp (
    nom              text,
    paye_par_semaine integer[],
    planning         text[][]
);</programlisting>
  Comme indiqué ci-dessus, un type de données tableau est nommé en ajoutant des
  crochets (<literal>[]</literal>) au type de données des éléments du tableau. La
  commande ci-dessus crée une table nommée <structname>sal_emp</structname>
  avec une colonne de type <type>text</type> (<structfield>nom</structfield>),
  un tableau à une dimension de type <type>integer</type>
  (<structfield>paye_par_semaine</structfield>), représentant le salaire d'un
  employé par semaine et un tableau à deux dimensions de type
  <type>text</type> (<structfield>planning</structfield>), représentant le
  planning hebdomadaire de l'employé.
 </para>

 <para>
  La syntaxe de <command>CREATE TABLE</command> permet de préciser la taille
  exacte des tableaux, par exemple&nbsp;:

<programlisting>CREATE TABLE tictactoe (
    carres   integer[3][3]
);</programlisting>

  Néanmoins, les développements actuels n'imposent pas le respect de la
  taille du tableau -- le comportement est identique à celui des tableaux dont
  la longueur n'est pas précisée.
 </para>

 <para>
  En fait, l'implantation actuelle n'oblige pas non plus à déclarer le
  nombre de dimensions. Les tableaux d'un type d'élément particulier sont tous
  considérés comme étant du même type, quelque soit leur taille ou le
  nombre de dimensions. Déclarer le nombre de dimensions ou la taille dans
  <command>CREATE TABLE</command> n'a qu'un but documentaire. Le
  comportement de l'application n'en est pas affecté.
 </para>

 <para>
  Une autre syntaxe, conforme au standard SQL, peut être
  utilisée pour les tableaux à une dimension.
  <structfield>paye_par_semaine</structfield> peut être définie ainsi&nbsp;:
<programlisting>paye_par_semaine  integer ARRAY[4],</programlisting>
  Cette syntaxe nécessite une constante de type entier pour indiquer la taille
  du tableau. Néanmoins, comme indiqué précédemment, <productname>PostgreSQL</productname>
  n'impose aucune restriction sur la taille.
 </para>
 </sect2>

 <sect2>
  <title>Saisie de valeurs de type tableau</title>

  <indexterm>
   <primary>tableau</primary>
   <secondary>constante</secondary>
  </indexterm>

  <para>
   Pour écrire une valeur de type tableau comme une constante littérale,
   on encadre les valeurs des éléments par des accolades et on les sépare par des
   virgules (ce n'est pas différent de la syntaxe C utilisée
   pour initialiser les structures). Des guillemets doubles peuvent être
   positionnés autour des valeurs des éléments. C'est d'ailleurs obligatoire
   si elles
   contiennent des virgules ou des accolades (plus de détails ci-dessous).
   Le format général d'une constante de type tableau est donc le
   suivant&nbsp;:
<synopsis>'{ <replaceable>val1</replaceable> <replaceable>delim</replaceable> <replaceable>val2</replaceable> <replaceable>delim</replaceable> ... }'</synopsis>
   où <replaceable>delim</replaceable> est le caractère de délimitation pour ce
   type, tel qu'il est enregistré dans son entrée <literal>pg_type</literal>.
   Parmi les types de données standard fournis par la distribution
   <productname>PostgreSQL</productname>, le type <literal>box</literal> utilise un
   point-virgule (<literal>;</literal>) mais tous les autres utilisent une virgule
   (<literal>,</literal>). Chaque <replaceable>val</replaceable> est soit une constante
   du type des éléments du tableau soit un sous-tableau. Voici un exemple d'une
   constante tableau&nbsp;:
<programlisting>'{{1,2,3},{4,5,6},{7,8,9}}'</programlisting>
   Cette constante a deux dimensions, un tableau 3 par 3 consistant en trois
   sous-tableaux d'entiers.
  </para>

  <para>
   Pour initialiser un élément d'un tableau à NULL, on écrit <literal>NULL</literal>
   pour la valeur de cet élément. (Toute variante majuscule et/ou minuscule de
   <literal>NULL</literal> est acceptée.) Si <quote>NULL</quote> doit être
   utilisé comme valeur de chaîne, on place des guillemets doubles autour.
  </para>

  <para>
   Ces types de constantes de tableau sont en fait un cas particulier
   des constantes de type générique abordées dans la <xref
   linkend="sql-syntax-constants-generic"/>. La constante est traitée
   initialement comme une chaîne et passée à la routine de conversion d'entrées
   de tableau. Une spécification explicite du type peut être nécessaire.
  </para>

 <para>
  Quelques instructions <command>INSERT</command>&nbsp;:

<programlisting>INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"rendez-vous", "repas"}, {"entrainement", "présentation"}}');

INSERT INTO sal_emp
    VALUES ('Carol',
    '{20000, 25000, 25000, 25000}',
    '{{"petit-déjeuner", "consultation"}, {"rendez-vous", "repas"}}');</programlisting>
 </para>

 <para>
  Le résultat des deux insertions précédentes ressemble à ceci&nbsp;:
<programlisting>SELECT * FROM sal_emp;
 nom   |      paye_par_semaine     |      planning
-------+---------------------------+--------------------
Bill   | {10000,10000,10000,10000} | {{rendez-vous,repas},{entrainement,présentation}}
Carol  | {20000,25000,25000,25000} | {{petit-déjeuner,consultation},{rendez-vous,repas}}
(2 rows)</programlisting>
 </para>

 <para>
  La syntaxe du constructeur <literal>ARRAY</literal> peut aussi être
  utilisée&nbsp;:
<programlisting>INSERT INTO sal_emp
    VALUES ('Bill',
    ARRAY[10000, 10000, 10000, 10000],
    ARRAY[['rendez-vous', 'repas'], ['entrainement','présentation']]);

INSERT INTO sal_emp
    VALUES ('Carol',
    ARRAY[20000, 25000, 25000, 25000],
    ARRAY[['petit-déjeuner', 'consultation'], ['rendez-vous', 'repas']]);</programlisting>
 </para>
 <para>
  Les éléments du tableau sont des constantes SQL ordinaires ou
  des expressions&nbsp;; par exemple, les chaînes de caractères littérales sont
  encadrées par des guillemets simples au lieu de guillemets doubles comme cela
  est le cas dans un tableau littéral. La syntaxe du constructeur
  <literal>ARRAY</literal> est discutée plus en profondeur dans la <xref
  linkend="sql-syntax-array-constructors"/>.
 </para>

 <para>
  Les tableaux multi-dimensionnels doivent avoir des échelles correspondantes
  pour chaque dimension. Une différence cause la levée d'une erreur. Par
  exemple&nbsp;:

<programlisting>
INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"rendez-vous", "repas"}, {"rendez-vous"}}');
ERROR:  multidimensional arrays must have array expressions with matching dimensions
</programlisting>
 </para>
 </sect2>

 <sect2>
  <title>Accès aux tableaux</title>

 <para>
  Quelques requêtes lancées sur la table permettent d'éclairer le propos
  précédent. Tout d'abord, l'accès à un seul élément du tableau
  à la fois. Cette requête retrouve le nom des employés dont la paye a
  changé au cours de la deuxième semaine&nbsp;:
     
<programlisting>SELECT nom FROM sal_emp WHERE paye_par_semaine[1] &lt;&gt; paye_par_semaine[2];

 nom
-------
 Carol
(1 row)</programlisting>

  Les indices du tableau sont écrits entre crochets. Par défaut,
  <productname>PostgreSQL</productname> utilise la convention des indices
  commençant à 1 pour les tableaux, c'est-à-dire un tableau à
  <replaceable>n</replaceable> éléments commence avec <literal>array[1]</literal> et finit
  avec <literal>array[<replaceable>n</replaceable>]</literal>.
 </para>

 <para>
  Récupérer la paye de la troisième semaine de tous les
  employés&nbsp;:
     
<programlisting>SELECT paye_par_semaine[3] FROM sal_emp;

 paye_par_semaine
------------------
          10000
          25000
(2 rows)</programlisting>
 </para>

 <para>
  Il est également possible d'accéder à des parties rectangulaires arbitraires ou à des
  sous-tableaux. Une partie de tableau est indiquée par l'écriture
  <literal><replaceable>extrémité basse</replaceable>:<replaceable>extrémité haute</replaceable></literal>
  sur n'importe quelle dimension. Ainsi, La requête suivante retourne
  le premier élément du planning de Bill pour les deux premiers jours de la
  semaine&nbsp;:
     
<programlisting>SELECT planning[1:2][1:1] FROM sal_emp WHERE nom = 'Bill';

      planning
--------------------
 {{rendez-vous},{entrainement}}
(1 row)</programlisting>

  Si l'une des dimensions est écrite comme une partie, c'est-à-dire si elle contient
  le caractère deux-points, alors toutes les dimensions sont traitées comme
  des parties. Toute dimension qui n'a qu'un numéro (pas de
  deux-points), est traitée comme allant de <literal>1</literal>
  au nombre indiqué. Par exemple, <literal>[2]</literal> est traitée comme
  <literal>[1:2]</literal>, comme le montre cet exemple&nbsp;:

<programlisting>SELECT planning[1:2][2] FROM sal_emp WHERE nom = 'Bill';

         planning
---------------------------
 {{rendez-vous,repas},{entrainement,présentation}}
(1 row)</programlisting>
 </para>

 <para>
  Une expression indicée de tableau retourne NULL si, soit le tableau, soit une
  des expressions est NULL. De plus, NULL est renvoyé si un indice se trouve en
  dehors de la plage du tableau (ce cas n'amène pas d'erreur).
  Par exemple, si <literal>planning</literal> a les dimensions
  <literal>[1:3][1:2]</literal>, alors faire référence à
  <literal>planning[3][3]</literal> donne un
  résultat NULL. De la même façon, une référence sur un tableau avec une
  valeur d'indices incorrecte retourne une valeur NULL plutôt qu'une erreur.
 </para>

 <para>
  Une expression de découpage d'un tableau est aussi NULL si, soit le
  tableau, soit une des expressions indicées est NULL. Néanmoins, dans
  certains cas particuliers comme la sélection d'une partie d'un tableau
  complètement en dehors de la plage de ce dernier, l'expression de
  cette partie est un tableau vide (zéro dimension) et non pas un tableau
  NULL. Si la partie demandée surcharge partiellement les limites du
  tableau, alors elle est réduite silencieusement à la partie surchargée.
 </para>

 <para>
  Les dimensions actuelles de toute valeur d'un tableau sont disponibles avec la
  fonction <function>array_dims</function>&nbsp;:

<programlisting>SELECT array_dims(planning) FROM sal_emp WHERE nom = 'Carol';

 array_dims
------------
 [1:2][1:2]
(1 row)</programlisting>

  <function>array_dims</function> donne un résultat de type <type>text</type>,
  ce qui est pratique à lire mais peut s'avérer plus difficile à interpréter
  par les
  programmes. Les dimensions sont aussi récupérables avec
  <function>array_upper</function> et <function>array_lower</function>, qui
  renvoient respectivement la limite haute et et la limite basse du tableau
  précisé&nbsp;:

<programlisting>SELECT array_upper(planning, 1) FROM sal_emp WHERE nom = 'Carol';

 array_upper
-------------
           2
(1 row)</programlisting>
 </para>
 </sect2>

 <sect2>
  <title>Modification de tableaux</title>

 <para>
  La valeur d'un tableau peut être complètement remplacée&nbsp;:

<programlisting>UPDATE sal_emp SET paye_par_semaine = '{25000,25000,27000,27000}'
    WHERE nom = 'Carol';</programlisting>

  ou en utilisant la syntaxe de l'expression <literal>ARRAY</literal>&nbsp;:

<programlisting>UPDATE sal_emp SET paye_par_semaine = ARRAY[25000,25000,27000,27000]
    WHERE nom = 'Carol';</programlisting>

  On peut aussi mettre à jour un seul élément d'un tableau&nbsp;:

<programlisting>UPDATE sal_emp SET paye_par_semaine[4] = 15000
    WHERE nom = 'Bill';</programlisting>

  ou faire une mise à jour par tranche&nbsp;:

<programlisting>UPDATE sal_emp SET paye_par_semaine[1:2] = '{27000,27000}'
    WHERE nom = 'Carol';</programlisting>

 </para>

 <para>
  Un tableau peut être agrandi en y stockant des éléments qui n'y sont pas
  déjà présents. Toute position entre ceux déjà présents et les nouveaux
  éléments est remplie avec la valeur NULL. Par exemple, si le tableau
  <literal>mon_tableau</literal> a actuellement quatre éléments, il en aura
  six après une mise à jour qui affecte <literal>mon_tableau[6]</literal>
  car <literal>mon_tableau[5]</literal> est alors rempli avec une valeur NULL.
  Actuellement, l'agrandissement de cette façon est seulement autorisé pour
  les tableaux à une dimension, et non pas pour les tableaux multidimensionnels.
 </para>

 <para>
  L'affectation par parties d'un tableau permet la création de tableaux dont
  l'indice de départ n'est pas 1. On peut ainsi affecter, par exemple, 
  <literal>mon_tableau[-2:7]</literal> pour créer un tableau avec des valeurs d'indices
  allant de -2 à 7.
 </para>

 <para>
  Les valeurs de nouveaux tableaux peuvent aussi être construites en utilisant
  l'opérateur de concaténation,
  <literal>||</literal>&nbsp;:
<programlisting>SELECT ARRAY[1,2] || ARRAY[3,4];
   ?column?
---------------
 {1,2,3,4}
(1 row)

SELECT ARRAY[5,6] || ARRAY[[1,2],[3,4]];
      ?column?
---------------------
 {{5,6},{1,2},{3,4}}
(1 row)</programlisting>
</para>

  <para>
  L'opérateur de concaténation autorise un élément à être placé au début ou à
  la fin d'un tableau à une dimension. Il accepte aussi deux tableaux à
  <replaceable>N</replaceable> dimensions, ou un tableau à <replaceable>N</replaceable> dimensions
  et un à <replaceable>N+1</replaceable> dimensions.
  </para>

 <para>
  Quand un élément seul est poussé soit au début soit à la fin d'un tableau à
  une dimension, le résultat est un tableau avec le même indice bas que l'opérande
  du tableau. Par exemple&nbsp;:
<programlisting>SELECT array_dims(1 || '[0:1]={2,3}'::int[]);
 array_dims
------------
 [0:2]
(1 row)

SELECT array_dims(ARRAY[1,2] || 3);
 array_dims
------------
 [1:3]
(1 row)</programlisting>
 </para>

 <para>
  Lorsque deux tableaux ayant un même nombre de dimensions sont concaténés, le
  résultat conserve la limite inférieure de l'opérande gauche. Le résultat est
  un tableau comprenant chaque élément de l'opérande gauche suivi de chaque
  élément de l'opérande droit. Par exemple&nbsp;:
<programlisting>SELECT array_dims(ARRAY[1,2] || ARRAY[3,4,5]);
 array_dims
------------
 [1:5]
(1 row)

SELECT array_dims(ARRAY[[1,2],[3,4]] || ARRAY[[5,6],[7,8],[9,0]]);
 array_dims
------------
 [1:5][1:2]
(1 row)</programlisting>
 </para>

 <para>
  Lorsqu'un tableau à <replaceable>N</replaceable> dimensions est placé au début ou à la
  fin d'un tableau à <replaceable>N+1</replaceable> dimensions, le résultat est analogue au
  cas ci-dessus. Chaque sous-tableau de dimension <replaceable>N</replaceable> est en
  quelque sorte un élément de la dimension externe d'un tableau à
  <replaceable>N+1</replaceable> dimensions. Par exemple&nbsp;:
<programlisting>SELECT array_dims(ARRAY[1,2] || ARRAY[[3,4],[5,6]]);
 array_dims
------------
 [1:3][1:2]
(1 row)</programlisting>
 </para>

 <para>
  Un tableau peut aussi être construit en utilisant les fonctions
  <function>array_prepend</function>, <function>array_append</function>
  ou <function>array_cat</function>. Les deux premières ne supportent que les
  tableaux à une dimension alors que <function>array_cat</function> supporte les
  tableaux multidimensionnels.

  L'opérateur de concaténation vu plus haut est préférable à
  l'utilisation directe de ces fonctions. En fait, les fonctions existent
  principalement pour l'implantation de l'opérateur de concaténation.
  Néanmoins, elles peuvent être directement utiles dans la création
  d'agrégats utilisateur. Quelques exemples&nbsp;:

<programlisting>SELECT array_prepend(1, ARRAY[2,3]);
 array_prepend
---------------
 {1,2,3}
(1 row)

SELECT array_append(ARRAY[1,2], 3);
 array_append
--------------
 {1,2,3}
(1 row)

SELECT array_cat(ARRAY[1,2], ARRAY[3,4]);
   array_cat
---------------
 {1,2,3,4}
(1 row)

SELECT array_cat(ARRAY[[1,2],[3,4]], ARRAY[5,6]);
      array_cat
---------------------
 {{1,2},{3,4},{5,6}}
(1 row)

SELECT array_cat(ARRAY[5,6], ARRAY[[1,2],[3,4]]);
      array_cat
---------------------
 {{5,6},{1,2},{3,4}}</programlisting>
 </para>
 </sect2>

 <sect2>
  <title>Recherche dans les tableaux</title>

 <para>
  Pour rechercher une valeur dans un tableau, il faut vérifier chaque valeur
  dans le tableau. Ceci peut se faire à la main lorque la taille du
  tableau est connue. Par exemple&nbsp;:

<programlisting>SELECT * FROM sal_emp WHERE paye_par_semaine[1] = 10000 OR
                            paye_par_semaine[2] = 10000 OR
                            paye_par_semaine[3] = 10000 OR
                            paye_par_semaine[4] = 10000;</programlisting>

  Ceci devient toutefois rapidement fastidieux pour les gros tableaux et n'est
  pas très utile si la taille du tableau n'est pas connue. Une autre méthode
  est décrite dans la <xref linkend="functions-comparisons"/>. La requête ci-dessus
  est remplaçable par&nbsp;:

<programlisting>SELECT * FROM sal_emp WHERE 10000 = ANY (paye_par_semaine);</programlisting>

  De la même façon, on trouve les lignes où le tableau n'a que des valeurs
  égales à 10000 avec&nbsp;:

<programlisting>SELECT * FROM sal_emp WHERE 10000 = ALL (paye_par_semaine);</programlisting>

 </para>

 <tip>
  <para>
   Les tableaux ne sont pas toujours initialisés&nbsp;; rechercher des éléments
   spécifiques dans un tableau peut être un signe d'une mauvaise conception de
   la base de données. On utilise plutôt une table séparée avec une
   ligne pour chaque élément faisant parti du tableau. Cela simplifie
   la recherche et fonctionne mieux dans le cas d'un grand nombre
   d'éléments.
  </para>
 </tip>
 </sect2>

 <sect2>
  <title>Syntaxe d'entrée et de sortie des tableaux</title>

  <para>
   La représentation externe du type texte d'une valeur de tableau consiste en
   des éléments interprétés suivant les règles de conversion d'entrées/sorties
   pour le type de l'élément du tableau, plus des décorations indiquant la
   structure du tableau. L'affichage est constitué d'accolades (<literal>{</literal>
   et <literal>}</literal>) autour des valeurs du tableau et de caractères de
   délimitation entre éléments adjacents. Le caractère délimiteur est
   habituellement une virgule (<literal>,</literal>) mais peut être
   différent&nbsp;:
   il est déterminé par le paramètre <literal>typdelim</literal> du type de l'élément
   tableau (parmi les types de données standards supportés par l'implémentation
   de <productname>PostgreSQL</productname>, le type <literal>box</literal> utilise un
   point-virgule (<literal>;</literal>) mais tous les autres utilisent la virgule).
   Dans un tableau multidimensionnel, chaque dimension (row, plane, cube, etc.)
   utilise son propre niveau d'accolades et les délimiteurs doivent être
   utilisés entre des entités adjacentes au sein d'accolades de même niveau.
  </para>

  <para>
   La routine de sortie du tableau place des guillemets doubles autour des
   valeurs des éléments si ce sont des chaînes vides, si elles contiennent des
   accolades, des caractères délimiteurs, des guillemets doubles, des antislashs
   ou des espaces ou si elles correspondent à <literal>NULL</literal>. Les guillemets
   doubles et les antislashs intégrés aux valeurs
   des éléments sont échappés à l'aide d'un antislash. Pour les types de données
   numériques, on peut supposer sans risque que les doubles guillemets
   n'apparaissent jamais, mais pour les types de données texte, il faut être
   préparé à gérer la présence et l'absence de guillemets.
  </para>

  <para>
   Par défaut, la valeur de la limite basse d'un tableau est initialisée à 1.
   Pour représenter des tableaux avec des limites basses différentes, les
   indices du tableau doivent être indiqués explicitement avant d'écrire le
   contenu du tableau.
   Cet affichage est consititué de crochets (<literal>[]</literal>) autour
   de chaque limite basse et haute d'une
   dimension avec un délimiteur deux-points (<literal>:</literal>) entre
   les deux.
   L'affichage des dimensions du tableau est suivie par un signe d'égalité
   (<literal>=</literal>). Par exemple&nbsp;:
<programlisting>
SELECT f1[1][-2][3] AS e1, f1[1][-1][5] AS e2
 FROM (SELECT '[1:1][-2:-1][3:5]={{{1,2,3},{4,5,6}}}'::int[] AS f1) AS ss;

 e1 | e2
----+----
  1 |  6
(1 row)
</programlisting>
   La routine de sortie du tableau inclut les dimensions explicites dans
   le resultat uniquement lorsqu'au moins une limite basse est différente
   de 1.
  </para>

  <para>
   Si la valeur écrite pour un élément est <literal>NULL</literal> (toute
   variante), l'élément est considéré NULL. La présence de guillemets ou
   d'antislashs désactive ce fonctionnement et autorise la saisie de la valeur litérale de
   la chaîne <quote>NULL</quote>. De plus, pour une compatibilité ascendante
   avec les versions antérieures à la version 8.2 de 
   <productname>PostgreSQL</productname>,
   le paramètre de configuration <xref linkend="guc-array-nulls"/> doit être
   désactivé (<literal>off</literal>) pour supprimer la reconnaissance de
   <literal>NULL</literal> comme un NULL.
  </para>
  
  <para>
   Comme indiqué précédemment, lors de l'écriture d'une valeur de tableau,
   des guillemets doubles peuvent être positionnés autour de chaque élément
   individuel du
   tableau. Il <emphasis>faut</emphasis> le faire si leur absence autour d'un élément
   induit en erreur l'analyseur de la valeur du tableau. Par exemple, les
   éléments contenant des crochets, virgules (ou tout caractère délimiteur),
   guillemets doubles, antislashs ou espace (en début comme en fin) doivent
   avoir des guillemets doubles. Les chaînes vides et les chaînes <literal>NULL</literal>
   doivent aussi être entre guillemets. Pour placer un guillemet double ou un antislash
   dans une valeur d'élément d'un tableau, on utilise la syntaxe d'échappement des
   chaînes et on le précède d'un antislash.
   Au-delà, tous les caractères de données qui sont utilisés dans la syntaxe
   du tableau peuvent être échappés.
  </para>

  <para>
   Des espaces peuvent être ajoutées avant un crochet gauche ou après un crochet
   droit. Comme avant tout élément individuel.
   Dans tous les cas, les espaces sont ignorées. En revanche, les espaces à
   l'intérieur des éléments entre guillemets doubles ou entourées de
   caractères autres que des espaces ne sont pas ignorées.
  </para>

 <note>
  <para>
   Toute ce qui est écrit dans une commande SQL est d'abord
   interprété en tant que chaîne littérale puis en tant que tableau. Ceci
   double le nombre d'antislash nécessaire. Par exemple, pour
   insérer une valeur de tableau de type <type>text</type> contenant un antislash
   et un guillemet double, il faut écrire&nbsp;:
<programlisting>INSERT ... VALUES (E'{"\\\\","\\""}');</programlisting>
   Le processeur de la chaîne d'échappement supprime un niveau d'antislash, donc
   l'analyseur de tableau reçoit <literal>{"\\","\""}</literal>.
   En conséquence, les chaînes remplissant l'entrée du type de données
   <type>text</type> deviennent respectivement <literal>\</literal> et <literal>"</literal>.
   (Si la routine d'entrée du type de données utilisé
   traite aussi les antislash de manière spéciale, <type>bytea</type> par
   exemple, il peut être nécessaire d'avoir jusqu'à huit antislash dans la
   commande pour en obtenir un dans l'élément stocké.)
   Les guillemets dollar (voir <xref linkend="sql-syntax-dollar-quoting"/>)
   peuvent être utilisés pour éviter de doubler les antislash.
  </para>
 </note>

 <tip>
  <para>
   La syntaxe du constructeur <literal>ARRAY</literal> (voir <xref
   linkend="sql-syntax-array-constructors"/>) est souvent plus facile à utiliser
   que la syntaxe de tableau littéral lors de l'écriture des valeurs du tableau
   en commandes SQL. Avec <literal>ARRAY</literal>, les valeurs de l'élément individuel
   sont écrites comme elles le seraient si elles ne faisaient pas partie d'un tableau.
  </para>
 </tip>
 </sect2>

</sect1>
