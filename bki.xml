<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/bki.sgml,v 1.7 2005/09/15 07:03:14 guillaume Exp $
 -->

<chapter id="bki">
 <title>Interface du moteur <acronym>BKI</acronym></title>

 <para>
  Les fichiers d'interface du moteur (<acronym>BKI</acronym>) sont des scripts
  écrits dans un langage spécial, qui est compris par le serveur
  <productname>PostgreSQL</productname> quand il est lancé dans le mode spécial
  <quote>bootstrap</quote>. Ce mode autorise la création des catalogues
  systèmes alors que les commandes SQL requièrent l'existence des catalogues.
  Les fichiers <acronym>BKI</acronym> peuvent donc être utilisés pour créer le
  système de base de données en tout premier lieu. (Et ils ne sont probablement
  pas utiles pour un autre emploi.)
 </para>

 <para>
  <application>initdb</application> utilise un fichier <acronym>BKI</acronym>
  pour faire une partie de son travail lors de la création d'un nouveau groupe
  de base de données. Le fichier en entrée utilisé par
  <application>initdb</application> est créé lors de la construction et de
  l'installation de <productname>PostgreSQL</productname> par un programme
  nommé <filename>genbki.sh</filename> qui lit les quelques fichiers d'en-têtes
  C spécialement formatés dans le répertoire
  <filename>src/include/catalog</filename> des sources. Le fichier
  <acronym>BKI</acronym> créé est appelé <filename>postgres.bki</filename> et
  est normalement installé dans le sous-répertoire <filename>share</filename>
  du répertoire d'installation.
 </para>

 <para>
  Des informations plus complètes sont disponibles dans la documentation pour
  <application>initdb</application>.
 </para>

 <sect1 id="bki-format">
  <title>Format des fichiers <acronym>BKI</acronym></title>

  <para>
   Cette section décrit comment le serveur <productname>PostgreSQL</productname>
   interprète les fichiers <acronym>BKI</acronym>. Cette description
   sera plus simple à comprendre si le fichier <filename>postgres.bki</filename>
   se trouve à portée de main comme exemple.
  </para>

  <para>
   L'entrée <acronym>BKI</acronym> consiste en une séquence de commandes. Les
   commandes sont constituées d'un certain nombre d'éléments, suivant la syntaxe de
   la commande. Les éléments sont habituellement séparés par des espaces blancs
   mais n'ont pas besoin de l'être s'il n'y a pas d'ambiguïté. Il n'existe pas
   de séparateur spécial pour les commandes&nbsp;; le prochain élément qui ne
   peut syntaxiquement pas appartenir à la commande précédente en lance une
   autre. (Habituellement, vous devriez mettre une nouvelle commande sur une
   nouvelle ligne pour plus de clarté.) Les éléments peuvent être certains mots
   clés, des caractères spéciaux (parenthèses, virgules, etc.), nombres ou
   chaînes de caractères entre guillemets doubles. Tous sont sensibles à la
   casse.
  </para>

  <para>
   Les lignes commençant avec <literal>#</literal> sont ignorées.
  </para>

 </sect1>

 <sect1 id="bki-commands">
  <title>Commandes <acronym>BKI</acronym></title>

  <variablelist>
   <varlistentry>
    <term>
     <literal>create</literal> 
     <optional><literal>bootstrap</literal></optional>
     <optional><literal>shared_relation</literal></optional>
     <optional><literal>without_oids</literal></optional>
     <replaceable class="parameter">tablename</replaceable>
     <replaceable class="parameter">tableoid</replaceable>
     (<replaceable class="parameter">name1</replaceable> =
     <replaceable class="parameter">type1</replaceable> <optional>,
     <replaceable class="parameter">name2</replaceable> = <replaceable
     class="parameter">type2</replaceable>, ...</optional>)
    </term>

    <listitem>
     <para>
      Crée une table nommée <replaceable
      class="parameter">nomtable</replaceable>, et avoir l'OID
      <replaceable class="parameter">tableoid</replaceable>, avec les colonnes
      données entre parenthèses.
     </para>

     <para>
      Les types de colonnes suivants sont supportés directement par
      <filename>bootstrap.c</filename>: <type>bool</type>,
      <type>bytea</type>, <type>char</type> (1 byte),
      <type>name</type>, <type>int2</type>,
      <type>int4</type>, <type>regproc</type>, <type>regclass</type>,
      <type>regtype</type>, <type>text</type>,
      <type>oid</type>, <type>tid</type>, <type>xid</type>,
      <type>cid</type>, <type>int2vector</type>, <type>oidvector</type>,
      <type>_int4</type> (array), <type>_text</type> (array),
      <type>_oid</type> (array), <type>_char</type> (array),
      <type>_aclitem</type> (array). Bien qu'il soit possible de créer des
      tables contenant des colonnes d'autres types, ceci ne peut pas être fait
      tant que <structname>pg_type</structname> n'est pas créé et rempli avec les entrées
      appropriées. (Ceci signifie réellement que seuls ces types de colonnes
      peuvent être utilisés dans les tables utilisant le
      <quote>bootstrap</quote> mais que les catalogues ne l'utilisant pas
      peuvent contenir tout type interne.)
     </para>

     <para>
      Quand <literal>bootstrap</literal> est spécifié, la table sera seulement
      construite sur disque&nbsp;; rien n'est saisi dans
      <structname>pg_class</structname>, <structname>pg_attribute</structname>,
      etc, pour elle. Du coup, la table ne sera pas accessible par des
      opérations SQL standards jusqu'à ce que de nouvelles entrées sont
      réalisées (avec des commandes <literal>insert</literal>). Cette option est
      utilisée pour créer <structname>pg_class</structname>, etc.
     </para>

     <para>
      La table est créée comme partagée si <literal>shared_relation</literal> est
      spécifié. Elle aura des OID sauf si <literal>without_oids</literal> est spécifié.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>open</literal> <replaceable class="parameter">nomtable</replaceable>
    </term>

    <listitem>
     <para>
      Ouvre la table nommée
      <replaceable class="parameter">nomtable</replaceable>
      pour des ajouts de données. Toute table actuellement ouverte est fermée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>close</literal> <optional><replaceable class="parameter">nomtable</replaceable></optional>
    </term>

    <listitem>
     <para>
      Ferme la table ouverte appelée <replaceable
      class="parameter">nomtable</replaceable>. Le nom de la table peut-être
      indiqué pour une vérification croisée mais ce n'est pas nécessaire.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>insert</literal> <optional><literal>OID =</literal> <replaceable class="parameter">valeur_oid</replaceable></optional> <literal>(</literal><replaceable class="parameter">valeur1</replaceable> <replaceable class="parameter">valeur2</replaceable> ...<literal>)</literal>
    </term>

    <listitem>
     <para>
      Insère une nouvelle ligne dans la table ouverte en utilisant <replaceable
      class="parameter">valeur1</replaceable>, <replaceable
      class="parameter">valeur2</replaceable>, etc., comme valeurs de ses
      colonnes et <replaceable
      class="parameter">valeur_oid</replaceable> pour son OID. Si
      <replaceable class="parameter">valeur_oid</replaceable> vaut zéro
      (0) ou si la clause est omise, et que la table a des OID, alors le
      prochain OID disponible est utilisé.
     </para>

     <para>
      Les valeurs NULL peuvent être indiquées en utilisant le mot clé spécial
      <literal>_null_</literal>. Les valeurs contenant des espaces doivent être
      entre des guillemets doubles.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>declare</literal> <optional><literal>unique</literal></optional>
     <literal>index</literal> <replaceable class="parameter">nomindex</replaceable>
     <replaceable class="parameter">oidindex</replaceable>
     <literal>on</literal> <replaceable class="parameter">nomtable</replaceable>
     <literal>using</literal> <replaceable class="parameter">nomam</replaceable>
     <literal>(</literal> <replaceable class="parameter">classeop1</replaceable>
     <replaceable class="parameter">nom1</replaceable>
     <optional>, ...</optional> <literal>)</literal>
    </term>

    <listitem>
     <para>
      Crée un index nommé <replaceable
      class="parameter">nomindex</replaceable>, ayant l'OID
      <replaceable class="parameter">indexoid</replaceable>, sur la table nommée
      <replaceable class="parameter">nomtable</replaceable> en utilisant la
      méthode d'accès nommée <replaceable class="parameter">nomam</replaceable>.
      Les champs de l'index sont appelés <replaceable
      class="parameter">nom1</replaceable>, <replaceable
      class="parameter">nom2</replaceable> etc., et les classes d'opérateur à
      utiliser sont respectivement <replaceable
      class="parameter">classeop1</replaceable>, <replaceable
      class="parameter">classeop2</replaceable> etc.
      Le fichier index est créé et les entrées du catalogue appropriées sont
      ajoutées pour lui, mais le contenu de l'index n'est pas initialisé par
      cette commande.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>declare toast</literal>
     <replaceable class="parameter">toasttableoid</replaceable>
     <replaceable class="parameter">toastindexoid</replaceable>
     <literal>on</literal> <replaceable class="parameter">tablename</replaceable>
    </term>

    <listitem>
     <para>
      Create a TOAST table for the table named
      <replaceable class="parameter">tablename</replaceable>.
      The TOAST table is assigned OID
      <replaceable class="parameter">toasttableoid</replaceable>
      and its index is assigned OID
      <replaceable class="parameter">toastindexoid</replaceable>.
      As with <literal>declare index</>, filling of the index
      is postponed.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>build indices</literal></term>

    <listitem>
     <para>
      Remplit les index précédemment déclarés.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="bki-structure">
  <title>Structure du fichier <quote>bootstrap</quote> <acronym>BKI</acronym></title>

  <para>
   La commande <literal>open</literal> ne peut pas être utilisée jusqu'à ce que les
   tables qu'ils utilisent existent et ont des entrées pour la table devant
   être ouverte. (Ces tables minimums sont <structname>pg_class</structname>,
   <structname>pg_attribute</structname>, <structname>pg_proc</structname> et
   <structname>pg_type</structname>.) Pour permettre de remplir ces tables,
   <literal>create</literal> avec l'option <literal>bootstrap</literal> ouvre implicitement
   la table créée pour l'insertion des données.
  </para>

  <para>
   Also, the <literal>declare index</literal> and <literal>declare toast</literal>
   commands cannot be used until the system catalogs they need have been
   created and filled in.
  </para>

  <para>
   Du coup, la structure du fichier <filename>postgres.bki</filename> doit
   être&nbsp;:
   <orderedlist>
    <listitem>
     <para>
      <literal>create bootstrap</literal> une des tables critiques
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal> les données décrivant au moins les tables critiques
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Répétez pour les autres tables critiques.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>create</literal> (sans <literal>bootstrap</literal>) une table non critique
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>open</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal> les données souhaitées
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Répétez pour les autres tables non critiques.
     </para>
    </listitem>
    <listitem>
     <para>
      Définissez les index et les tables TOAST.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>build indices</literal>
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Il y a peu de risque qu'il existe d'autres dépendances d'ordre non
   documentées.
  </para>
 </sect1>

 <sect1 id="bki-example">
  <title>Exemple</title>

  <para>
   La séquence suivante de commandes créera la table
   <literal>test_table</literal> avec l'OID 420, ayant deux colonnes
   <literal>cola</literal> et <literal>colb</literal> de type, respectivement,
   <type>int4</type> et <type>text</type> et insèrera deux lignes dans la
   table.
<programlisting>create test_table 420 (cola = int4, colb = text)
open test_table
insert OID=421 ( 1 "value1" )
insert OID=422 ( 2 _null_ )
close test_table
</programlisting>
  </para>
 </sect1>
</chapter>
