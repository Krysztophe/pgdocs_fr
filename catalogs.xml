<?xml version="1.0" encoding="ISO-8859-1"?>
<!--  $Header: /var/lib/cvs/pgsql-fr/sgml/catalogs.sgml,v 1.11 2005/09/22 18:34:39 guillaume Exp $ -->
<!--
 Documentation of the system catalogs, directed toward PostgreSQL developers
 -->

<chapter id="catalogs">
 <title>Catalogues système</title>

  <para>
   Les catalogues système représentent l'endroit où une base de données relationnelle
   stocke les métadonnées des schémas, telles que les informations sur les tables 
   et les colonnes, et des données de suivi interne.
   Les catalogues système de <productname>PostgreSQL</productname> sont de
   simples tables. Elle peuvent être supprimées et recrées. Il est possible
   de leur ajouter des colonnes, d'y insérer et modifier des valeurs, et de
   mettre un joyeux bazar dans le système. En temps normal, on ne devrait pas
   modifier les catalogues
   système soi-même, il y a toujours des commandes SQL pour le faire. (Par
   exemple, <command>CREATE DATABASE</command> insère une ligne dans le 
   catalogue <structname>pg_database</structname> &mdash; et crée physiquement
   la base de données sur le disque.) Il y a des exceptions pour certaines 
   opérations particulièrement ésotériques, comme l'ajout de méthodes d'accès
   aux index.
  </para>

 <sect1 id="catalogs-overview">
  <title>Aperçu</title>

  <para>
   <xref linkend="catalog-table"/> liste les catalogues système.
   Une documentation plus détaillée des catalogues systèmes suit.
  </para>

  <para>
   La plupart des catalogues système sont recopiés de la base de données modèle
   lors de la création de la base de données et deviennent alors spécifiques à 
   chaque base de données. Un petit nombre de catalogues sont physiquement 
   partagés par toutes les bases de données d'une installation de 
   <productname>PostgreSQL</productname>. Ils sont indiqués dans les 
   descriptions des catalogues.
  </para>

  <table id="catalog-table">
   <title>Catalogues système</title>

   <tgroup cols="2">
    <colspec colnum="1" colwidth="1*"/>
    <colspec colnum="2" colwidth="2*"/>
    <thead>
     <row>
      <entry>Nom du catalogue</entry>
      <entry>Contenu</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <entry>fonctions d'agrégat</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <entry>méthodes d'accès aux index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <entry>opérateurs des méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <entry>procédures de support des méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <entry>valeurs par défaut des colonnes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <entry>colonnes des tables (<quote>attributs</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link></entry>
      <entry>identifiants d'autorisation (rôles)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link></entry>
      <entry>relations d'appartenance aux identifiants d'autorisation</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-autovacuum"><structname>pg_autovacuum</structname></link></entry>
      <entry>paramètres de configuration de l'autovacuum par relation</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <entry>conversions de types de données (<foreignphrase>cast</foreignphrase>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <entry>tables, index, séquences, vues (<quote>relations</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <entry>contraintes de vérification, contraintes uniques, contraintes de clés primaires, contraintes de clés étrangères</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <entry>informations de conversions de codage</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <entry>bases de données du cluster <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <entry>dépendances entre objets de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <entry>descriptions ou commentaires des objets de base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <entry>informations supplémentaires des index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <entry>hiérarchie d'héritage de tables</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <entry>langages d'écriture de fonctions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <entry>gros objets</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-listener"><structname>pg_listener</structname></link></entry>
      <entry>support de notification asynchrone</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <entry>schémas</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <entry>classes d'opérateurs de méthodes d'accès aux index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <entry>opérateurs</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link></entry>
      <entry>données modèles pour les langages de procédures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <entry>fonctions et procédures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <entry>règles de réécriture de requêtes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link></entry>
      <entry>dépendances sur les objets partagés</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link></entry>
      <entry>commentaires sur les objets partagés</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <entry>statistiques de l'optimiseur de requêtes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link></entry>
      <entry><foreignphrase>tablespaces</foreignphrase> du cluster de bases de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <entry>déclencheurs</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <entry>types de données</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-aggregate">
  <title><structname>pg_aggregate</structname></title>

  <indexterm zone="catalog-pg-aggregate">
   <primary>pg_aggregate</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_aggregate</structname> stocke les informations 
   concernant les fonctions d'agrégat. Une fonction d'agrégat est une fonction
   qui opère sur un ensemble de données (typiquement une colonne de chaque ligne
   qui correspond à une condition de requête) et retourne une valeur unique 
   calculée à partir de toutes ces valeurs.
   Les fonctions d'agrégat classiques sont
   <function>sum</function> (somme), <function>count</function> (compteur) et
   <function>max</function> (plus grande valeur). Chaque entrée de
   <structname>pg_aggregate</structname> est une extension d'une entrée de
   <structname>pg_proc</structname>. L'entrée de <structname>pg_proc</structname>
   contient le nom de l'agrégat, les types de données d'entrée et de sortie, et
   d'autres informations similaires aux fonctions ordinaires.
  </para>

  <table>
   <title>Les colonnes de <structname>pg_aggregate</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>aggfnoid</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID <structname>pg_proc</structname> de la fonction d'agrégat</entry>
     </row>
     <row>
      <entry><structfield>aggtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>fonction de transition</entry>
     </row>
     <row>
      <entry><structfield>aggfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>fonction finale (0 s'il n'y en a pas)</entry>
     </row>
     <row>
      <entry><structfield>aggsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Opérateur de tri associé (0 s'il n'y en a pas)</entry>
     </row>
     <row>
      <entry><structfield>aggtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de la donnée interne de transition (état) de la fonction d'agrégat</entry>
     </row>
     <row>
      <entry><structfield>agginitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Valeur initiale de la fonction de transition. C'est un champ texte qui
       contient la valeur initiale dans sa représentation externe en chaîne de 
       caractères. Si ce champ est NULL, la valeur d'état de transition 
       est initialement NULL.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les nouvelles fonctions d'agrégat sont enregistrées avec la commande
   <xref linkend="sql-createaggregate" endterm="sql-createaggregate-title"/>.
   La <xref linkend="xaggr"/>  fournit de plus amples informations sur
   l'écriture des fonctions d'agrégat et sur
   la signification des fonctions de transition, etc.
  </para>

 </sect1>


 <sect1 id="catalog-pg-am">
  <title><structname>pg_am</structname></title>

  <indexterm zone="catalog-pg-am">
   <primary>pg_am</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_am</structname> stocke les informations
   concernant les méthodes d'accès aux index. On trouve une ligne par méthode d'accès
   supportée par le système. Le contenu de ce catalogue est discuté en détails
   dans <xref linkend="indexam"/>.
   </para>

  <table>
   <title>Colonnes de <structname>pg_am</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la méthode d'accès</entry>
     </row>

     <row>
      <entry><structfield>amstrategies</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de stratégies d'opérateur pour cette méthode d'accès</entry>
     </row>

     <row>
      <entry><structfield>amsupport</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de routines de support pour cette méthode d'accès</entry>
     </row>

     <row>
      <entry><structfield>amorderstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>0 si l'index n'a pas d'ordre de tri, sinon, le numéro 
      de stratégie de l'opérateur de stratégie qui décrit l'ordre de tri</entry>
     </row>

     <row>
      <entry><structfield>amcanunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La méthode d'accès supporte-t-elle les index
       uniques&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amcanmulticol</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La méthode d'accès supporte-t-elle les index
       multicolonnes&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amoptionalkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La méthode d'accès supporte-t-elle un parcours sans
      contrainte pour la première colonne de l'index&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amindexnulls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La méthode d'accès supporte-t-elle les entrées d'index NULL&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amstorage</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le type de données de stockage d'index peut-il différer du type de
      données de la colonne&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amclusterable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La commande CLUSTER peut-elle être utilisée avec un index de ce
      type&nbsp;?</entry>
     </row>

<!-- Pas dans les sources de la Beta3
     <row>
      <entry><structfield>amgettuple</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>prochaine ligne valide</quote></entry>
     </row>
-->
     <row>
      <entry><structfield>aminsert</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>insérer cette ligne</quote></entry>
     </row>

     <row>
      <entry><structfield>ambeginscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>commencer un nouveau parcours</quote></entry>
     </row>

<!-- Déjà traitées
     <row>
      <entry><structfield>aminsert</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>insérer cette ligne</quote></entry>
     </row>

     <row>
      <entry><structfield>ambeginscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>exécuter un nouveau parcours</quote></entry>
     </row>
-->
     <row>
      <entry><structfield>amgettuple</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>prochaine ligne valide</quote></entry>
     </row>

     <row>
      <entry><structfield>amgetmulti</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>récupérer plusieurs lignes</quote></entry>
     </row>

     <row>
      <entry><structfield>amrescan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>redémarrer ce parcours</quote></entry>
     </row>

     <row>
      <entry><structfield>amendscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>arrêter ce parcours</quote></entry>
     </row>

     <row>
      <entry><structfield>ammarkpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>marquer la position actuelle du parcours</quote></entry>
     </row>

     <row>
      <entry><structfield>amrestrpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>restaurer une position de parcours marquée</quote></entry>
     </row>

     <row>
      <entry><structfield>ambuild</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>construire un nouvel index</quote></entry>
     </row>

     <row>
      <entry><structfield>ambulkdelete</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de destruction en masse</entry>
     </row>

     <row>
      <entry><structfield>amvacuumcleanup</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de nettoyage post-<command>VACUUM</command></entry>
     </row>

     <row>
      <entry><structfield>amcostestimate</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction d'estimation du coût de parcours d'un index</entry>
     </row>

     <row>
      <entry><structfield>amoptions</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction d'analyse et de validation du champ
       <structfield>reloptions</structfield> d'un index</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-amop">
  <title><structname>pg_amop</structname></title>

  <indexterm zone="catalog-pg-amop">
   <primary>pg_amop</primary>
  </indexterm>

  <para> Le catalogue <structname>pg_amop</structname> stocke les informations 
  concernant les opérateurs associés aux classes d'opérateurs des méthodes d'accès aux index.
  Il y a une ligne pour chaque opérateur membre d'une classe.
  </para>

  <table>
   <title>Colonnes de <structname>pg_amop</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amopclaid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>La classe d'opérateur d'index de cette entrée</entry>
     </row>

     <row>
      <entry><structfield>amopsubtype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Sous-type qui permet de distinguer les différentes entrées d'une stratégie&nbsp;;
       0 par défaut</entry>
     </row>

     <row>
      <entry><structfield>amopstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Numéro de stratégie d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>amopreqcheck</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'entrée de l'index doit être revérifiée</entry>
     </row>

     <row>
      <entry><structfield>amopopr</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>OID de l'opérateur</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-amproc">
  <title><structname>pg_amproc</structname></title>

  <indexterm zone="catalog-pg-amproc">
   <primary>pg_amproc</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_amproc</structname> stocke les informations
   concernant les procédures de support associées aux classes d'opérateurs de méthodes 
   d'accès. Il y a une ligne pour chaque procédure de support appartenant à
   une classe.
  </para>

  <table>
   <title>Colonnes de <structname>pg_amproc</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amopclaid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>La classe d'opérateurs d'index de cette entrée</entry>
     </row>

     <row>
      <entry><structfield>amprocsubtype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Sous-type dans le cas d'une routine intertype, 0 sinon</entry>
     </row>

     <row>
      <entry><structfield>amprocnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Numéro de procédure de support</entry>
     </row>

     <row>
      <entry><structfield>amproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID de la procédure</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title><structname>pg_attrdef</structname></title>

  <indexterm zone="catalog-pg-attrdef">
   <primary>pg_attrdef</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_attrdef</structname> stocke les valeurs par
   défaut des colonnes. Les informations principales des colonnes sont stockées
   dans <structname>pg_attribute</structname> (voir plus loin). Seules les
   colonnes pour lesquelles une valeur par défaut est explicitement spécifiée
   (quand la table est créée ou quand une colonne est ajoutée) ont une entrée dans 
   <structname>pg_attrdef</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_attrdef</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>adrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>La table à laquelle appartient la colonne</entry>
     </row>

     <row>
      <entry><structfield>adnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Numéro de la colonne</entry>
     </row>

     <row>
      <entry><structfield>adbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Représentation interne de la valeur par défaut de la colonne</entry>
     </row>

     <row>
      <entry><structfield>adsrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Représentation lisible de la valeur par défaut</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Le champ <structfield>adsrc</structfield> est historique. Il est
   préférable 
   de ne pas l'utiliser parce qu'il ne conserve pas de trace des modifications qui
   peuvent affecter la représentation de la valeur par défaut. La
   compilation inverse du champ <structfield>adbin</structfield> (avec
   <function>pg_get_expr</function> par exemple) est une meilleure façon d'afficher la
   valeur par défaut.
  </para>

 </sect1>


 <sect1 id="catalog-pg-attribute">
  <title><structname>pg_attribute</structname></title>

  <indexterm zone="catalog-pg-attribute">
   <primary>pg_attribute</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_attribute</structname> stocke les informations
   concernant les colonnes des tables. Il y a exactement une ligne de 
   <structname>pg_attribute</structname> pour chaque colonne de chaque table de
   la base de données. (Il y a aussi des attributs pour les index et, en fait,
   tous les objets qui possèdent des entrées dans <structname>pg_class</structname>.)
  </para>

  <para>
   Le terme attribut, équivalent à colonne, est utilisé pour des raisons 
   historiques.
  </para>

  <table>
   <title>Colonnes de <structname>pg_attribute</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>attrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>La table à laquelle appartient la colonne</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Le nom de la colonne</entry>
     </row>

     <row>
      <entry><structfield>atttypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Le type de données de la colonne</entry>
     </row>

     <row>
      <entry><structfield>attstattarget</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Contrôle le niveau de détail des
       statistiques accumulées pour la colonne par
       <xref linkend="sql-analyze" endterm="sql-analyze-title"/>.
       Une valeur 0 indique qu'aucune statistique ne doit être collectée.
       Une valeur négative indique d'utiliser l'objectif de statistiques 
       par défaut.
       Le sens exact d'une valeur positive dépend du type de données.
       Pour les données scalaires, <structfield>attstattarget</structfield>
       est à la fois le nombre de <quote>valeurs les plus courantes</quote>
       à collecter et le nombre d'histogrammes à créer.
      </entry>
     </row>

     <row>
      <entry><structfield>attlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Une copie de <literal>pg_type.typlen</literal> pour le type de la
       colonne
      </entry>
     </row>

     <row>
      <entry><structfield>attnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Le numéro de la colonne. La numérotation des colonnes ordinaires
       démarre à 1. Les colonnes système, comme les 
       <structfield>oid</structfield>, ont des numéros négatifs arbitraires.
      </entry>
     </row>

     <row>
      <entry><structfield>attndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Nombre de dimensions, si la colonne est de type tableau, sinon 0.
       (Pour l'instant, le nombre de dimensions des tableaux n'est pas contrôlé,
       donc une valeur autre que 0 indique que <quote>c'est un tableau</quote>.)
      </entry>
     </row>

     <row>
      <entry><structfield>attcacheoff</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Toujours -1 sur disque, mais peut être mis à jour lorsque la ligne
       est chargée en mémoire, pour 
       mettre en cache l'emplacement de l'attribut dans la ligne.
      </entry>
     </row>

     <row>
      <entry><structfield>atttypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Stocke des données spécifiques au type
       de données précisé lors de la création de la table (par exemple, la
       taille maximale d'une colonne de type <type>varchar</type>). Il est
       transmis aux fonctions spécifiques au type d'entrée de données et de
       vérification de taille. La valeur est généralement -1 pour les types
       de données qui n'ont pas besoin de <structfield>atttypmod</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>attbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Une copie de <literal>pg_type.typbyval</literal> du type de la
       colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>attstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Contient normalement une copie de
       <literal>pg_type.typstorage</literal> du type de la colonne.
       Pour les types de données TOASTables, cette valeur 
       peut être modifiée après la création de la colonne pour en contrôler
       les règles de stockage.
      </entry>
     </row>

     <row>
      <entry><structfield>attalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Une copie de <literal>pg_type.typalign</literal> du type de 
       la colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>attnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique une contrainte de non-nullité de colonne. Il est possible de changer
       cette colonne pour activer ou désactiver cette contrainte. 
       </entry>
     </row>

     <row>
      <entry><structfield>atthasdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique que la colonne a une valeur par défaut. Dans ce cas, il y 
       a une entrée correspondante dans le catalogue 
       <structname>pg_attrdef</structname> pour définir cette valeur.
      </entry>
     </row>

     <row>
      <entry><structfield>attisdropped</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique que la colonne a été supprimée et n'est plus valide. Une 
       colonne supprimée est toujours présente physiquement dans la table,
       mais elle est ignorée par l'analyseur de requête et ne peut être
       accédée en SQL.
      </entry>
     </row>

     <row>
      <entry><structfield>attislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       La colonne est définie localement dans la relation. Une
       colonne peut être simultnément définie localement et héritée.
      </entry>
     </row>

     <row>
      <entry><structfield>attinhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Nombre d'ancêtres directs de la colonne. Une colonne qui a au moins un
       ancêtre ne peut être ni supprimée ni renommée.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
	Dans l'entrée <structname>pg_attribute</structname> d'une colonne
	supprimée, <structfield>atttypid</structfield> est réinitialisée à
	0 mais <structfield>attlen</structfield> et les autres champs copiés à
	partir de <structname>pg_type</structname> sont toujours valides. Cet arrangement est
	nécessaire pour s'adapter à la situation où le type de données de la
	colonne supprimée a été ensuite supprimé et qu'il n'existe donc plus de
	ligne <structname>pg_type</structname>. <structfield>attlen</structfield> et les
	autres champs peuvent être utilisés pour interpréter le contenu
	d'une ligne de la table.
  </para>
 </sect1>


 <sect1 id="catalog-pg-authid">
  <title><structname>pg_authid</structname></title>

  <indexterm zone="catalog-pg-authid">
   <primary>pg_authid</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_authid</structname> contient les informations
   concernant les identifiants pour les autorisations d'accès aux bases de données
   (rôles). Un rôle englobe les concepts d'<quote>utilisateurs</quote> et de
   <quote>groupes</quote>. Un utilisateur est essentiellement un rôle qui a
   l'attribut de connexion (<structfield>rolcanlogin</structfield>). Tout rôle (avec ou
   sans <structfield>rolcanlogin</structfield>) peut avoir d'autres rôles comme
   membres&nbsp;; voir
   <link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link>.
  </para>

  <para>
   Comme ce catalogue contient les mots de passe, il ne doit pas être lisible par
   tout le monde.
   <link linkend="view-pg-roles"><structname>pg_roles</structname></link>
   est une vue, lisible par tout le monde, de 
   <structname>pg_authid</structname> qui masque le champ du mot de passe.
  </para>

  <para>
   <xref linkend="user-manag"/> contient des informations détaillées sur les
   utilisateurs et sur la gestion des droits.
  </para>

  <para>
   Comme l'identité des utilisateurs est identique pour tout le cluster de bases
   de données, <structname>pg_authid</structname> est partagé par toutes les
   bases du cluster&nbsp;; il n'existe qu'une seule copie de
   <structname>pg_authid</structname> par cluster, non pas une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_authid</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Nom du rôle</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Le rôle est superutilisateur</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Le rôle hérite automatiquement des droits des rôles dont il est
       membre</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Le rôle peut créer d'autres rôles</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Le rôle peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       Le rôle peut mettre à jour les catalogues système directement. (Même
       un superutilisateur ne peut le faire si cette colonne n'est pas à
       <literal>true</literal>.)
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       Le rôle peut se connecter, c'est-à-dire que ce rôle peut être donné
       comme identifiant d'autorisation de session.
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>
       Pour les rôles qui peuvent se connecter, indique le nombre maximum
       de connexions concurrentes initiables par le rôle. -1 signifie sans
       limite.
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Le mot de passe (éventuellement chiffré)&nbsp;; NULL si aucun</entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>Date d'expiration du mot de passe (seulement utilisé pour
       l'authentification par mot de passe)&nbsp;; NULL si indéfiniment
       valable
       </entry>
     </row>

     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>Valeurs par défaut des variables de configuration de session</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-auth-members">
  <title><structname>pg_auth_members</structname></title>

  <indexterm zone="catalog-pg-auth-members">
   <primary>pg_auth_members</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_auth_members</structname> contient les relations
   d'appartenance entre les rôles. Tout ensemble non circulaire d'appartenances est
   autorisé.
  </para>

  <para>
   Parce que les identités de l'utilisateur sont valables sur l'ensemble du
   cluster, <structname>pg_auth_members</structname> est partagé par toutes les bases
   de données d'un cluster&nbsp;: il n'existe qu'une seule copie de
   <structname>pg_auth_members</structname> par cluster, pas une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_auth_members</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>roleid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant d'un rôle qui a un membre</entry>
     </row>

     <row>
      <entry><structfield>member</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant d'un rôle qui est membre d'un
        <structfield>roleid</structfield></entry>
     </row>

     <row>
      <entry><structfield>grantor</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant du rôle qui a autorisé cet appartenance</entry>
     </row>

     <row>
      <entry><structfield>admin_option</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si <structfield>member</structfield> peut donner
      l'appartenance à <structfield>roleid</structfield> aux autres</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-autovacuum">
  <title><structname>pg_autovacuum</structname></title>

  <indexterm zone="catalog-pg-autovacuum">
   <primary>pg_autovacuum</primary>
  </indexterm>

  <indexterm zone="catalog-pg-autovacuum">
   <primary>autovacuum</primary>
   <secondary>configuration de table</secondary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_autovacuum</structname> stocke les paramètres de
   configuration optionnelle par relation pour le démon autovacuum. S'il existe
   une entrée pour une relation particulière, les paramètres donnés sont
   utilisés par autovacuum pour cette table. Si aucune entrée n'est présente, 
   les paramètres par défaut du système sont utilisés. Pour plus d'informations
   sur le démon autovacuum, voir <xref linkend="autovacuum"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_autovacuum</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>vacrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Le table concernée par l'entrée</entry>
     </row>

     <row>
      <entry><structfield>enabled</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si <literal>false</literal>, la table n'est jamais prise en compte 
        par autovacuum</entry>
     </row>

     <row>
      <entry><structfield>vac_base_thresh</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Nombre minimum de lignes modifiées avant de lancer un
        vacuum</entry>
     </row>

     <row>
      <entry><structfield>vac_scale_factor</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Multiplicateur pour <structfield>reltuples</structfield> à ajouter à
       <structfield>vac_base_thresh</structfield></entry>
     </row>

     <row>
      <entry><structfield>anl_base_thresh</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Nombre minimum de lignes modifiées avant de lancer une
        analyse</entry>
     </row>

     <row>
      <entry><structfield>anl_scale_factor</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Multiplicateur pour <structfield>reltuples</structfield> à ajouter à
        <structfield>anl_base_thresh</structfield></entry>
     </row>

     <row>
      <entry><structfield>vac_cost_delay</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Paramètre <varname>vacuum_cost_delay</varname> personnalisé</entry>
     </row>

     <row>
      <entry><structfield>vac_cost_limit</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Paramètre <varname>vacuum_cost_limit</varname> personnalisé</entry>
     </row>

     <row>
      <entry><structfield>freeze_min_age</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Paramètre <varname>vacuum_freeze_min_age</varname> personnalisé</entry>
     </row>

     <row>
      <entry><structfield>freeze_max_age</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Paramètre <varname>autovacuum_freeze_max_age</varname> personnalisé</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Le démon autovacuum lance une opération de <command>VACUUM</command> sur une
   table particulière quand le nombre de lignes mises à jour ou supprimées
   dépasse <structfield>vac_base_thresh</structfield> plus
   <structfield>vac_scale_factor</structfield> multiplié par le nombre de lignes
   actives alors estimées pour la relation. De façon similaire, il
   initie une opération <command>ANALYZE</command> quand le nombre de lignes
   insérées, mises à jour ou supprimées dépasse
   <structfield>anl_base_thresh</structfield> plus
   <structfield>anl_scale_factor</structfield> multiplié par le nombre de
   lignes actives alors estimées pour la relation.
  </para>

  <para>
   De plus, le démon autovacuum réalise une opération de <command>VACUUM</command>
   pour prévenir la réinitialisation de l'ID de transaction si le champ
   <structname>pg_class</structname>.<structfield>relfrozenxid</structfield>
   de la table atteint un âge de plus de <structfield>freeze_max_age</structfield>
   transactions, que la table ait été modifiée ou non. Le système lance
   autovacuum pour exécuter de tels <command>VACUUM</command> même si autovacuum
   est désactivé. Voir <xref linkend="vacuum-for-wraparound"/> pour plus
   d'informations sur la réinitialisation de l'ID de transaction.
  </para>

  <para>
   Tout champ numérique peut contenir <literal>-1</literal> (ou une autre valeur
   négative) pour indiquer que la valeur par défaut du système doit être
   utilisée pour cette valeur particulière. La variable
   <structfield>vac_cost_delay</structfield> hérite sa valeur par défaut du paramètre
   de configuration <xref linkend="guc-autovacuum-vacuum-cost-delay"/> ou de
   <varname>vacuum_cost_delay</varname> si le premier est négatif. La même logique
   s'applique à <structfield>vac_cost_limit</structfield>.
   De plus, autovacuum ignore les tentatives d'initialisation par table d'un
   <structfield>freeze_max_age</structfield> plus grand que celui du
   sysstème (il peut seulement être plus petit).
   <structfield>freeze_min_age</structfield> est limité à la moitié
   du paramètre <xref linkend="guc-autovacuum-freeze-max-age"/> du système.
  </para>

 </sect1>


 <sect1 id="catalog-pg-cast">
  <title><structname>pg_cast</structname></title>

  <indexterm zone="catalog-pg-cast">
   <primary>pg_cast</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_cast</structname> stocke les chemins de 
   conversion de type de donnée, qu'il s'agisse de ceux par défaut ou ceux 
   définis avec la commande <xref linkend="sql-createcast"
   endterm="sql-createcast-title"/>.
  </para>

  <table>
   <title>Colonnes de <structfield>pg_cast</structfield></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>castsource</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID du type de données source</entry>
     </row>

     <row>
      <entry><structfield>casttarget</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID du type de données cible</entry>
     </row>

     <row>
      <entry><structfield>castfunc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       OID de la fonction à utiliser pour réaliser la conversion. 0 si
       les types de données sont binairement compatibles (c'est-à-dire si aucune
       opération n'est nécessaire pour effectuer la transformation).
      </entry>
     </row>

     <row>
      <entry><structfield>castcontext</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indique dans quel contexte la conversion peut être utilisée.
       <literal>e</literal> si seules les conversions explicites sont autorisées (avec
       <literal>CAST</literal> ou <literal>::</literal>).
       <literal>a</literal> si les conversions implicites lors de l'affectation à une
       colonne sont autorisées, en plus des conversions explicites.
       <literal>i</literal> si les conversions implicites dans les expressions sont 
       autorisées en plus des autres cas.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
    Les fonctions de transtypage listées dans <structname>pg_cast</structname>
    doivent toujours prendre le type source de la conversion comme type du
    premier argument et renvoyer le type de destination de la conversion comme
    type de retour. Une fonction de conversion peut avoir jusqu'à trois
    arguments. Le deuxième argument, s'il est présent, doit être de type
    <type>integer</type>&nbsp;; il reçoit le modificateur de type associé avec le
    type de destination ou <literal>-1</literal> s'il n'y en a pas. Le troisième
    argument, s'il est présent, doit être de type <type>boolean</type>&nbsp;; il
    reçoit <literal>true</literal> si la conversion est une conversion explicite,
    <literal>false</literal> sinon.
  </para>

<!-- C'est lourd et assez indigeste. Surtout un vendredi soir ! -->
<!-- coercion ? -->
  <para>
    Il est légitime de créer une entrée <structname>pg_cast</structname>
    pour
    laquelle les types source et cible sont identiques	 si la fonction associée
    prend plus d'un argument. De telles entrées représentent les
    <quote>fonctions de forçage de longueur</quote> qui forcent les valeurs du type
    à être légales pour une valeur particulière du modificateur de type.
    Néanmoins, à ce jour, il n'existe aucun support qui permette d'associer des
    modificateurs de type différents de ceux de base avec des types de
    données utilisateur. De ce fait, cette fonctionnalité n'a d'utilité que
    pour un petit nombre de types intégrés dont la syntaxe du modificateur de
    type est construite dans leur grammaire.
  </para>

  <para>
    Quand une entrée <structname>pg_cast</structname> possède des types différents
    pour la source et la cible et une fonction qui prend plus d'un
    argument, le transtypage et le forçage de longueur s'effectuent en une
    seule étape. Lorsqu'une telle entrée n'est pas disponible, le forçage
    vers un type qui utilise un modificateur de type implique deux étapes,
    une de transtypage, l'autre pour appliquer le modificateur.
  </para>
 </sect1>

 <sect1 id="catalog-pg-class">
  <title><structname>pg_class</structname></title>

  <indexterm zone="catalog-pg-class">
   <primary>pg_class</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_class</structname> liste les tables, et 
   à peu près tout ce qui contient des colonnes ou ressemble de près ou de loin à
   une table. Cela inclut les index (mais il faut aussi aller voir dans
   <structname>pg_index</structname>), les séquences, les vues, les types
   composites et les tables TOAST&nbsp;; voir
   <structfield>relkind</structfield>.
   Par la suite, lorsque l'on parle de <quote>relation</quote>, on
   sous-entend tous ces types d'objets. Les colonnes ne sont pas toutes
   significatives pour tous les types de relations.
  </para>

<!-- namespace ? (doit-il être traduit ?) -->
  <table>
   <title>Colonnes de <structname>pg_class</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la table, vue, index, etc.</entry>
     </row>

     <row>
      <entry><structfield>relnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace nommé qui contient la relation.
      </entry>
     </row>

     <row>
      <entry><structfield>reltype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>
       OID du type de données qui correspond au type de ligne de la table,
       s'il y en a un.
       0 pour les index qui n'ont pas d'entrée dans <structname>pg_type</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>relowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
       .oid</literal></entry>
      <entry>Propriétaire de la relation.</entry>
     </row>

     <row>
      <entry><structfield>relam</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-am"><structname>pg_am</structname></link>
       .oid</literal></entry>
      <entry>S'il s'agit d'un index, OID de la méthode d'accès utilisée (B-tree,
       hash, etc.)</entry>
     </row>

     <row>
      <entry><structfield>relfilenode</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Nom du fichier disque de la relation&nbsp;; 0 s'il n'y en a
       pas.</entry>
     </row>

     <row>
      <entry><structfield>reltablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       Le <foreignphrase>tablespace</foreignphrase> dans lequel est stocké
       la relation. Si 0, il s'agit du
       <foreignphrase>tablespace</foreignphrase> par défaut de la base de
       données. (Sans intérêt si la relation n'est pas liée à un fichier disque.)
     </entry>
     </row>

     <row>
      <entry><structfield>relpages</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Taille du fichier disque, exprimée en pages (de taille 
       <symbol>BLCKSZ</symbol>).
       Ce n'est qu'une estimation utilisée par le planificateur. Elle est mise à 
       jour par les commandes <command>VACUUM</command>,
       <command>ANALYZE</command> et quelques commandes DDL comme <command>CREATE
       INDEX</command>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltuples</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       Nombre de lignes de la table.
       Ce n'est qu'une estimation utilisée par le planificateur. Elle est mise à 
       jour par les commandes <command>VACUUM</command>,
       <command>ANALYZE</command> et quelques commandes DDL comme
       <command>CREATE INDEX</command>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>
       OID de la table TOAST associée à cette table. 0 s'il n'y en a pas.
       La table TOAST stocke les attributs de grande taille <quote>hors 
       ligne</quote> dans une table secondaire.
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastidxid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>
       Pour une table TOAST, OID de son index. 0 si ce n'est pas une table
       TOAST.
      </entry>
     </row>

     <row>
      <entry><structfield>relhasindex</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si c'est une table et qu'elle possède (ou possédait encore
       récemment) quelque index.
       Ce champ est mis à jour par <command>CREATE INDEX</command>, mais pas
       réinitialisé immédiatement après <command>DROP INDEX</command>.
       <command>VACUUM</command> réinitialise <structfield>relhasindex</structfield>
       s'il s'aperçoit que la table n'a pas d'index.
      </entry>
     </row>

     <row>
      <entry><structfield>relisshared</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si cette table est partagée par toutes les bases de données
      du cluster. Seuls certains catalogues système (comme
      <structname>pg_database</structname>) sont partagés.</entry>
     </row>

     <row>
      <entry><structfield>relkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>r</literal> = table ordinaire, <literal>i</literal> = index,
       <literal>S</literal> = séquence, <literal>v</literal> = vue, <literal>c</literal> =
       type composite, <literal>t</literal> = table TOAST.
      </entry>
     </row>

     <row>
      <entry><structfield>relnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Nombre de colonnes utilisateur dans la relation (sans compter les
       colonnes système). Il doit y avoir le même nombre d'entrées dans
       <structname>pg_attribute</structname>. Voir aussi
       <literal>pg_attribute.attnum</literal>.
      </entry>
     </row>

     <row>
      <entry><structfield>relchecks</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Nombre de contraintes de vérification sur la table&nbsp;; voir le
       catalogue <link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltriggers</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Nombre de déclencheurs sur la table&nbsp;; voir le catalogue
       <link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link>.
      </entry>
     </row>

     <row>
      <entry><structfield>relukeys</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Inutilisé. (Ce n'est <emphasis>pas</emphasis> le nombre de clés
       uniques de la table.)</entry>
     </row>

     <row>
      <entry><structfield>relfkeys</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Inutilisé. (Ce n'est <emphasis>pas</emphasis> le nombre de clés 
      étrangères de la table.)</entry>
     </row>

     <row>
      <entry><structfield>relrefs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Inutilisé</entry>
     </row>

     <row>
      <entry><structfield>relhasoids</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si un OID est engendré pour chaque ligne de la relation.
      </entry>
     </row>

     <row>
      <entry><structfield>relhaspkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si la table a (ou a eu) une clé primaire.
      </entry>
     </row>

     <row>
      <entry><structfield>relhasrules</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la table contient des règles&nbsp;; voir le catalogue
       <link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.
      </entry>
     </row>

     <row>
      <entry><structfield>relhassubclass</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si au moins une table hérite ou a hérité de la table
      considérée.</entry>
     </row>

     <row>
      <entry><structfield>relfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       Tous les ID de transaction avant celui-ci ont été remplacés par un ID de
       transaction permanent (<quote>frozen</quote>). Ceci est utilisé pour
       déterminer si la table doit être nettoyée (VACUUM) pour éviter un
       bouclage des ID de transaction 
       (<foreignphrase>ID wraparound</foreignphrase>) ou pour compacter
       <literal>pg_clog</literal>.
       0 (<symbol>InvalidTransactionId</symbol>) si la relation n'est pas
       une table.
      </entry>
     </row>

     <row>
      <entry><structfield>relacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Droits d'accès&nbsp;; voir
       <xref linkend="sql-grant" endterm="sql-grant-title"/> et
       <xref linkend="sql-revoke" endterm="sql-revoke-title"/> pour plus de
       détails.
      </entry>
     </row>

     <row>
      <entry><structfield>reloptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Options spécifiques de la méthode d'accès, représentées par des chaînes du type
       <quote>motclé=valeur</quote>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-constraint">
  <title><structname>pg_constraint</structname></title>

  <indexterm zone="catalog-pg-constraint">
   <primary>pg_constraint</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_constraint</structname> stocke les vérifications,
   clés primaires, clés uniques et étrangères des tables. (Les contraintes de
   colonnes ne sont pas traitées de manière particulière. Elles sont 
   équivalentes à des contraintes de tables.) Les contraintes NOT NULL sont
   représentées dans le catalogue <structname>pg_attribute</structname>.
  </para>

  <para>
   Les contraintes de vérification de domaine sont également stockées dans
   ce catalogue.
  </para>

  <table>
   <title>Colonnes de <structname>pg_constraint</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la contrainte (pas nécessairement unique&nbsp;!)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient la contrainte.
      </entry>
     </row>

     <row>
      <entry><structfield>contype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
        <literal>c</literal> = contrainte de vérification,
        <literal>f</literal> = contrainte de clé étrangère,
        <literal>p</literal> = contrainte de clé primaire,
        <literal>u</literal> = contrainte d'unicité
      </entry>
     </row>

     <row>
      <entry><structfield>condeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La contrainte peut-elle être retardée
      (<foreignphrase>differable</foreignphrase>&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>condeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La contrainte est-elle retardée par défaut&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>conrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid
       </literal></entry>
      <entry>Table à laquelle appartient la contrainte&nbsp;; 0 si ce n'est pas
       une contrainte de table.
      </entry>
     </row>

     <row>
      <entry><structfield>contypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>Domaine auquel appartient la contrainte&nbsp;; 0 si ce n'est pas
       une contrainte de domaine.
      </entry>
     </row>

     <row>
      <entry><structfield>confrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>Si c'est une clé étrangère, la table référencée&nbsp;; sinon
       0</entry>
     </row>

     <row>
      <entry><structfield>confupdtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Code de l'action de mise à jour de la clé étrangère</entry>
     </row>

     <row>
      <entry><structfield>confdeltype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Code de l'action de suppression de clé étrangère</entry>
     </row>

     <row>
      <entry><structfield>confmatchtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Type de concordance de la clé étrangère</entry>
     </row>

     <row>
      <entry><structfield>conkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link
       linkend="catalog-pg-attribute"><structname>pg_attribute</structname>
       </link>.attnum</literal></entry>
      <entry>S'il s'agit d'une contrainte de table, liste des colonnes
       contraintes</entry>
     </row>

     <row>
      <entry><structfield>confkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link
       linkend="catalog-pg-attribute"><structname>pg_attribute</structname>
       </link>.attnum</literal></entry>
      <entry>S'il s'agit d'une clé étrangère, liste des colonnes référencées</entry>
     </row>

     <row>
      <entry><structfield>conbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>S'il s'agit d'une contrainte de vérification, représentation
       interne de l'expression</entry>
     </row>

     <row>
      <entry><structfield>consrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>S'il s'agit d'une contrainte de vérification, représentation
       compréhensible de l'expression</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <structfield>consrc</structfield> n'est pas actualisé lors de la modification
    d'objets référencés&nbsp;; par exemple, il ne piste pas les renommages de
    colonnes. Plutôt que se fier à ce champ, il est préférable d'utiliser
    <function>pg_get_constraintdef()</function> pour extraire la définition d'une
    contrainte de vérification.
   </para>
  </note>

  <note>
   <para>
    <literal>pg_class.relchecks</literal> doit accepter le même nombre de 
    contraintes de vérification pour la relation considérée.
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-conversion">
  <title><structname>pg_conversion</structname></title>

  <indexterm zone="catalog-pg-conversion">
   <primary>pg_conversion</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_conversion</structname> décrit les procédures
   de conversion de codage disponibles. Voir la commande
   <xref linkend="sql-createconversion" endterm="sql-createconversion-title"/> pour
   plus d'information.
  </para>

  <table>
   <title>Colonnes de <structname>pg_conversion</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la conversion (unique au sein d'un
      <foreignphrase>namespace</foreignphrase>)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient la conversion.
      </entry>
     </row>

     <row>
      <entry><structfield>conowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid">
      <structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de la conversion</entry>
     </row>

     <row>
      <entry><structfield>conforencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>ID du codage source</entry>
     </row>

     <row>
      <entry><structfield>contoencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>ID du codage de destination</entry>
     </row>

     <row>
      <entry><structfield>conproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc">
      <structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Procédure de conversion</entry>
     </row>

     <row>
      <entry><structfield>condefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai s'il s'agit de la conversion par défaut</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-database">
  <title><structname>pg_database</structname></title>

  <indexterm zone="catalog-pg-database">
   <primary>pg_database</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_database</structname> stocke les informations sur
   les bases de données disponibles. Celles-ci sont créées avec la
   commande <xref
   linkend="sql-createdatabase" endterm="sql-createdatabase-title"/>. Consulter le
   <xref linkend="managing-databases"/> pour les détails sur la signification de
   certains paramètres.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_database</structname> est partagé par toutes les bases de
   données d'un cluster&nbsp;: il n'y a qu'une seule copie de
   <structname>pg_database</structname> par cluster, pas une par base.
  </para>

  <table>
   <title>Colonnes de <structname>pg_database</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la base de données</entry>
     </row>

     <row>
      <entry><structfield>datdba</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid">
      <structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de la base, généralement l'utilisateur qui l'a
       créée</entry>
     </row>

     <row>
      <entry><structfield>encoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Encodage de la base de données (la fonction
       <function>pg_encoding_to_char()</function> peut convertir ce nombre en
       nom de l'encodage)</entry>
     </row>

     <row>
      <entry><structfield>datistemplate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si ce champ est vrai, alors la base peut être utilisée dans la clause
       <literal>TEMPLATE</literal> de la commande
       <command>CREATE DATABASE</command> pour créer une nouvelle base comme clone de 
       celle-ci.
      </entry>
     </row>

     <row>
      <entry><structfield>datallowconn</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si ce champ est faux, alors personne ne peut se connecter à cette
       base de données. Ceci est utilisé pour interdire toute modification de la base 
       <literal>template0</literal>.
      </entry>
     </row>

     <row>
      <entry><structfield>datconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Configure le nombre maximum de connexions concurrentes effectuées sur
       la base de données. -1 indique l'absence de limite.
      </entry>
     </row>

     <row>
      <entry><structfield>datlastsysoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       Dernier OID système de la base de données&nbsp;; utile en particulier
       pour <application>pg_dump</application>.
      </entry>
     </row>

     <row>
      <entry><structfield>datfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       Tous les ID de transaction avant celui-ci ont été remplacés par un ID
       de transaction permanent (<quote>frozen</quote>). Ceci est
       utilisé pour déterminer si la table doit être nettoyée (VACUUM) pour
       éviter un bouclage des ID de transaction 
       (<foreignphrase>ID wraparound</foreignphrase>) ou pour compacter
       <literal>pg_clog</literal>.
       C'est la valeur minimale des valeurs par table de  
       <structname>pg_class</structname>.<structfield>relfrozenxid</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>dattablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       Le <foreignphrase>tablespace</foreignphrase> par défaut de la base de données.
       Dans cette base de données, toutes les tables pour lesquelles
       <structname>pg_class</structname>.<structfield>reltablespace</structfield>
       vaut 0 sont stockées dans celui-ci&nbsp;; en particulier, tous les catalogues
       système non partagés s'y trouvent.
      </entry>
     </row>

     <row>
      <entry><structfield>datconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Valeurs de session par défaut des variables modifiables en 
       cours de fonctionnement.
      </entry>
     </row>

     <row>
      <entry><structfield>datacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir
       <xref linkend="sql-grant" endterm="sql-grant-title"/> et
       <xref linkend="sql-revoke" endterm="sql-revoke-title"/> pour des détails.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-depend">
  <title><structname>pg_depend</structname></title>

  <indexterm zone="catalog-pg-depend">
   <primary>pg_depend</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_depend</structname> enregistre les relations de
   dépendances entre les objets de la base de données. Cette information permet
   à la commande <command>DROP</command> de trouver les objets qui doivent être
   supprimés conjointement par la commande <command>DROP CASCADE</command>
   ou au contraire empêchent la suppression dans le cas de
   <command>DROP RESTRICT</command>.
  </para>

  <para>
   Voir aussi <link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link>,
   qui remplit la même fonction pour les dépendances impliquant des
   objets partagés sur tout le cluster.
  </para>

  <table>
   <title>Colonnes de <structname>pg_depend</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>OID du catalogue système dans lequel l'objet dépendant se
       trouve.</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet dépendant</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour une colonne de table, ce champ indique le numéro de colonne (les
       champs <structfield>objid</structfield> et
       <structfield>classid</structfield> font référence à 
       la table elle-même). Pour tous les autres types d'objets, cette colonne
       est à 0.
      </entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID du catalogue système dans lequel l'objet référencé se trouve.
      </entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet référencé</entry>
     </row>

     <row>
      <entry><structfield>refobjsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour une colonne de table, ce champ indique le numéro de colonne (les
       champs <structfield>refobjid</structfield> et
       <structfield>refclassid</structfield> font référence
       à la table elle même). Pour tous les autres types d'objets, cette colonne
       est à 0.
      </entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Code définissant la sémantique particulière de la relation de dépendance. Voir le 
       texte.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Dans tous les cas, une entrée de <structname>pg_depend</structname> indique
   que l'objet de référence ne peut pas être supprimé sans supprimer aussi l'objet
   dépendant. Néanmoins, il y a des nuances, identifiées par
   <structfield>deptype</structfield>&nbsp;:

   <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</symbol> (<literal>n</literal>)</term>
     <listitem>
      <para>
       Une relation normale entre des objets créés séparément. L'objet dépendant
       peut être supprimé sans affecter l'objet référencé. Ce dernier ne
       peut être supprimé qu'en précisant l'option <literal>CASCADE</literal>,
       auquel cas l'objet dépendant est supprimé lui-aussi. Exemple&nbsp;: une
       colonne de table a une dépendance normale avec ses types de données. 
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant peut être supprimé séparément de l'objet référencé,
       mais il l'est automatiquement avec la suppression de ce dernier,
       quel que soit le mode <literal>RESTRICT</literal> ou <literal>CASCADE</literal>.
       Exemple&nbsp;: une contrainte nommée sur une table est auto-dépendante
       de la table, elle est automatiquement supprimée avec celle-ci.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</symbol> (<literal>i</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant est créé conjointement à l'objet référencé et 
       fait partie intégrante de son implantation interne. Un
       <command>DROP</command> de l'objet dépendant est interdit
       (l'utilisateur est averti qu'il peut effectuer un
       <command>DROP</command> de l'objet référencé à la place). La suppression
       de l'objet référencé est propagée à l'objet dépendant que
       <command>CASCADE</command> soit précisé ou non.
       Exemple&nbsp;: un trigger créé pour vérifier une contrainte de
       clé étrangère est rendu dépendant de l'entrée de la contrainte dans
       <structname>pg_constraint</structname>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>
       Il n'y a pas d'objet dépendant&nbsp;; ce type d'entrée signale que le
       système lui-même dépend de l'objet référencé, et donc que l'objet ne doit
       jamais être supprimé. Les entrées de ce type sont créées uniquement par
       <command>initdb</command>. Les colonnes de l'objet dépendant 
       contiennent des zéros.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   D'autres types de dépendance peuvent apparaître dans le futur.
  </para>

 </sect1>


 <sect1 id="catalog-pg-description">
  <title><structname>pg_description</structname></title>

  <indexterm zone="catalog-pg-description">
   <primary>pg_description</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_description</structname> stocke les descriptions 
   (commentaires) optionnels pour chaque objet de la base de données. Les
   descriptions sont manipulées avec la commande <xref linkend="sql-comment"
   endterm="sql-comment-title"/> et lues avec les commandes <literal>\d</literal>
   de <application>psql</application>. <structname>pg_description</structname>
   contient les descriptions prédifinies de nombreux objets internes.
  </para>

  <para>
   Voir aussi 
   <link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link>,
   qui offre la même fonction pour les descriptions des
   objets partagés au sein d'un cluster.
  </para>

  <table>
   <title>Colonnes de <structname>pg_description</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet commenté</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal>
      <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID du catalogue système dans lequel apparaît l'objet</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour un commentaire de colonne de table, le numéro de la colonne. Les champs
       <structfield>objoid</structfield> et <structfield>classoid</structfield>
       font référence à la
       table elle-même. Pour tous les autres types de données, cette colonne 
       est à 0.
      </entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Texte quelconque commentant l'objet</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-index">
  <title><structname>pg_index</structname></title>

  <indexterm zone="catalog-pg-index">
   <primary>pg_index</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_index</structname> contient une partie des 
   informations concernant les index. Le reste se trouve pour l'essentiel dans
   <structname>pg_class</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_index</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>indexrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID de l'entrée dans <structname>pg_class</structname> de
      l'index</entry>
     </row>

     <row>
      <entry><structfield>indrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID de l'entrée dans <structname>pg_class</structname> de la table sur 
       laquelle porte l'index
      </entry>
     </row>

     <row>
      <entry><structfield>indnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de colonnes de l'index (duplique
      <literal>pg_class.relnatts</literal>)</entry>
     </row>

     <row>
      <entry><structfield>indisunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai s'il s'agit d'un index d'unicité</entry>
     </row>

     <row>
      <entry><structfield>indisprimary</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai s'il s'agit de l'index de clé primaire de la table
      (<structfield>indisunique</structfield> doit toujours être vrai quand ce champ l'est.)</entry>
     </row>

     <row>
      <entry><structfield>indisclustered</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la table a été réorganisée en fonction de l'index</entry>
     </row>

     <row>
      <entry><structfield>indisvalid</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, l'index est valide pour les requêtes. Faux signifie
       que l'index peut être incomplet&nbsp;: les opérations INSERT/UPDATE
       peuvent toujours l'utiliser, mais il ne peut pas être utilisé
       sans risque pour les requêtes, et, dans le cas d'un index d'unicité,
       celle-ci n'est plus non-plus garantie.</entry>
     </row>

     <row>
      <entry><structfield>indkey</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       C'est un tableau de valeurs <structfield>indnatts</structfield> qui
       indique les colonnes de la table indexées. Par
       exemple, une valeur <literal>1 3</literal> signifie que la première et
       la troisième colonne de la table composent la clé de l'index. Un 0 dans
       ce tableau indique que l'attribut de l'index correspondant est une
       expression sur les colonnes de la table plutôt qu'une simple référence
       de colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>indclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       Pour chaque colonne de la clé d'indexation, contient l'OID de la
       classe d'opérateur à utiliser. Voir
       <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>
       pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structfield>indexprs</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Arbres d'expression (en représentation
      <function>nodeToString()</function>)
      pour les attributs d'index qui ne sont pas de simples références de 
      colonnes. Il s'agit d'une liste qui contient un élément par entrée à
      0 dans <structfield>indkey</structfield>. Nul si tous les attributs d'index sont 
      de simples références.</entry>
      </row>

     <row>
      <entry><structfield>indpred</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry> Arbre d'expression (en représentation
       <function>nodeToString()</function>) pour les prédicats d'index partiels.
       Nul s'il ne s'agit pas d'un index partiel.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title><structname>pg_inherits</structname></title>

  <indexterm zone="catalog-pg-inherits">
   <primary>pg_inherits</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_inherits</structname> enregistre l'information sur la 
   hiérarchie d'héritage des tables. Il existe une entrée pour chaque table enfant
   direct dans la base de données. (L'héritage indirect peut être déterminé en
   suivant les chaînes d'entrées.)
  </para>

  <table>
   <title>Colonnes de <structname>pg_inherits</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>inhrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID de la table fille
      </entry>
     </row>

     <row>
      <entry><structfield>inhparent</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID de la table mère
      </entry>
     </row>

     <row>
      <entry><structfield>inhseqno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       S'il y a plus d'un parent direct pour une table fille (héritage multiple), ce 
       nombre indique dans quel ordre les colonnes héritées doivent être 
       arrangées. Le compteur commence à 1.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-language">
  <title><structname>pg_language</structname></title>

  <indexterm zone="catalog-pg-language">
   <primary>pg_language</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_language</structname> enregistre les langages
   utilisables pour l'écriture de fonctions ou 
   procédures stockées. Voir 
   <xref linkend="sql-createlanguage" endterm="sql-createlanguage-title"/> et dans le
   <xref linkend="xplang"/> pour plus d'information sur les gestionnaires
   de langages.
  </para>

  <table>
   <title>Colonnes de <structname>pg_language</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>lanname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du langage</entry>
     </row>

     <row>
      <entry><structfield>lanispl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Faux pour les langages internes (comme <acronym>SQL</acronym>) et
       vrai pour les langages utilisateur. À l'heure actuelle, 
       <application>pg_dump</application> utilise ce champ pour déterminer 
       les langages à sauvegarder mais cela peut être 
       un jour remplacé par un mécanisme différent.
      </entry>
     </row>

     <row>
      <entry><structfield>lanpltrusted</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai s'il s'agit d'un langage de confiance, ce qui signifie qu'il
       est supposé ne pas donner accès à ce qui dépasse
       l'exécution normale des requêtes SQL. Seuls les superutilisateurs
       peuvent créer des fonctions dans des langages qui ne sont pas de
       confiance.
      </entry>
     </row>

     <row>
      <entry><structfield>lanplcallfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       Pour les langages non-internes, ceci référence le gestionnaire de
       langage, fonction spéciale en charge de l'exécution de toutes
       les fonctions écrites dans ce langage.
      </entry>
     </row>

     <row>
      <entry><structfield>lanvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       Ceci référence une fonction de validation de langage, en charge de 
       vérifier la syntaxe et la validité des nouvelles fonctions lors de
       leur création. 0 si aucun validateur n'est fourni.
      </entry>
     </row>

     <row>
      <entry><structfield>lanacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;;; voir
      <xref linkend="sql-grant" endterm="sql-grant-title"/> et
      <xref linkend="sql-revoke" endterm="sql-revoke-title"/> pour les détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title><structname>pg_largeobject</structname></title>

  <indexterm zone="catalog-pg-largeobject">
   <primary>pg_largeobject</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_largeobject</structname> contient les données
   qui décrivent les <quote>objets volumineux</quote>
   (<foreignphrase>large objects</foreignphrase>). Un objet volumineux
   est identifié par un OID qui lui est affecté lors de sa création.
   Chaque objet volumineux est coupé en segments ou <quote>pages</quote>
   suffisamment petits pour être facilement stockés dans des lignes de 
   <structname>pg_largeobject</structname>.
   La taille de données par page est définie par <symbol>LOBLKSIZE</symbol>, qui vaut
   actuellement <literal>BLCKSZ/4</literal>, soit habituellement 2&nbsp;Ko).
  </para>

  <table>
   <title>Colonnes de <structname>pg_largeobject</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>loid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>Identifiant de l'objet volumineux qui contient la page</entry>
     </row>

     <row>
      <entry><structfield>pageno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>Numéro de la page au sein de l'objet volumineux, en partant
       de 0</entry>
     </row>

     <row>
      <entry><structfield>data</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry>
       Données effectivement stockées dans l'objet volumineux. Il ne fait
       jamais plus de <symbol>LOBLKSIZE</symbol> mais peut faire moins.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Chaque ligne de <structname>pg_largeobject</structname> contient les données
   d'une page de l'objet volumineux, en commençant au décalage d'octet
   (<literal>pageno * LOBLKSIZE</literal>) dans l'objet. Ceci permet un stockage
   diffus&nbsp;: des pages peuvent manquer, d'autres faire moins de
   <literal>LOBLKSIZE</literal> octets même si elles ne sont pas la dernière de
   l'objet. Les parties manquantes sont considérées comme des suites de zéro.
  </para>

 </sect1>


 <sect1 id="catalog-pg-listener">
  <title><structname>pg_listener</structname></title>

  <indexterm zone="catalog-pg-listener">
   <primary>pg_listener</primary>
  </indexterm>

<!-- 
notifieur est proprement affreux !
notifié <-> notifiant est certainement une mauvaise traduction, mais je
n'en vois pas de meilleure -->
  <para>
   Le catalogue <structname>pg_listener</structname> supporte les commandes
   <xref linkend="sql-listen" endterm="sql-listen-title"/> et
   <xref linkend="sql-notify" endterm="sql-notify-title"/>. Un notifié
   (<foreignphrase>listener</foreignphrase>) crée une entrée dans
   <structname>pg_listener</structname> pour le nom de chaque notification qu'il
   surveille. Un notifiant parcourt <structname>pg_listener</structname>
   et actualise toute entrée concordante pour signaler une notification arrivée.
   Le notifiant envoie aussi un signal (en utilisant le numéro de processus
   PID) enregistré dans la table pour réveillé le notifié.
  </para>

  <table>
   <title>Colonnes de <structname>pg_listener</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Nom de la notification. (Il ne doit pas nécessairement correspondre
      à un nom de relation dans la base. Le nom <structfield>relname</structfield>
      est historique.)
      </entry>
     </row>

     <row>
      <entry><structfield>listenerpid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>PID du processus serveur qui a créé l'entrée</entry>
     </row>

     <row>
      <entry><structfield>notification</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>
       0 si aucun événement n'est en attente pour le notifié. Si un 
       événement est en attente, ce champ contient le PID du processus serveur
       qui a envoyé la notification.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-namespace">
  <title><structname>pg_namespace</structname></title>

  <indexterm zone="catalog-pg-namespace">
   <primary>pg_namespace</primary>
  </indexterm>

<!-- espace de nom, c'est comme espace de table, ca ne signifie pas
grand-chose -->
  <para>
   Le catalogue <structname>pg_namespace</structname> stocke les
   <foreignphrase>namespace</foreignphrase>. Un
   <foreignphrase>namespace</foreignphrase> est la structure sous-jacente
   aux schémas SQL&nbsp;: chaque <foreignphrase>namespace</foreignphrase>
   peut contenir un ensemble séparé de relations, types, etc. sans
   qu'il y ait de conflit de nommage.
  </para>

  <table>
   <title>Colonnes de <structname>pg_namespace</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>nspname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du <foreignphrase>namespace</foreignphrase></entry>
     </row>

     <row>
      <entry><structfield>nspowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire du <foreignphrase>namespace</foreignphrase></entry>
     </row>

     <row>
      <entry><structfield>nspacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir
      <xref linkend="sql-grant" endterm="sql-grant-title"/> et
      <xref linkend="sql-revoke" endterm="sql-revoke-title"/> pour les détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
  <title><structname>pg_opclass</structname></title>

  <indexterm zone="catalog-pg-opclass">
   <primary>pg_opclass</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_opclass</structname> définit les classes
   d'opérateurs de méthodes d'accès aux index. Chaque classe d'opérateurs définit
   la sémantique pour les colonnes d'index d'un type particulier et d'une
   méthode d'accès particulière. Il peut y avoir plusieurs classes
   d'opérateurs pour une combinaison donnée de type/méthode d'accès, ce qui
   permet de supporter différents comportements.
  </para>

  <para>
   Les classes d'opérateurs sont longuement décrites dans la
   <xref linkend="xindex"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_opclass</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>opcamid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Méthode d'accès à l'index pour lequel est définie la classe
       d'opérateurs</entry>
     </row>

     <row>
      <entry><structfield>opcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la classe d'opérateurs</entry>
     </row>

     <row>
      <entry><structfield>opcnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry><foreignphrase>Namespace</foreignphrase> de la classe d'opérateurs</entry>
     </row>

     <row>
      <entry><structfield>opcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de la classe d'opérateurs</entry>
     </row>

     <row>
      <entry><structfield>opcintype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de données que la classe d'opérateurs indexe</entry>
     </row>

     <row>
      <entry><structfield>opcdefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la classe d'opérateurs est la classe par défaut pour
       <structfield>opcintype</structfield></entry>
     </row>

     <row>
      <entry><structfield>opckeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de données stocké dans l'index ou 0 s'il s'agit du même que
       <structfield>opcintype</structfield></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   La plus grande partie des informations définissant une classe d'opérateurs
   n'est pas dans les lignes de <structname>pg_opclass</structname> mais
   dans les lignes correspondantes de <structname>pg_amop</structname> et
   <structname>pg_amproc</structname>.
   Ces lignes font partie intégrante de la définition de la classe
   d'opérateurs, un peu de la même façon qu'une relation est définie par une
   ligne unique de <structname>pg_class</structname> et par les lignes 
   associées de <structname>pg_attribute</structname> et d'autres tables.
  </para>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title><structname>pg_operator</structname></title>

  <indexterm zone="catalog-pg-operator">
   <primary>pg_operator</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_operator</structname> stocke les informations
   concernant les opérateurs. Voir la commande
   <xref linkend="sql-createoperator" endterm="sql-createoperator-title"/> et la
   <xref linkend="xoper"/> pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_operator</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oprname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient l'opérateur
      </entry>
     </row>

     <row>
      <entry><structfield>oprowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>b</literal> = infix (<quote>les deux</quote>), <literal>l</literal> = prefix
       (<quote>gauche</quote>), <literal>r</literal> = postfix (<quote>droit</quote>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprcanhash</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'opérateur supporte les jointures par découpage</entry>
     </row>

     <row>
      <entry><structfield>oprleft</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de l'opérande de gauche</entry>
     </row>

     <row>
      <entry><structfield>oprright</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de l'opérande de droite</entry>
     </row>

     <row>
      <entry><structfield>oprresult</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type du résultat</entry>
     </row>

     <row>
      <entry><structfield>oprcom</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Commutateur de l'opérateur, s'il existe</entry>
     </row>

     <row>
      <entry><structfield>oprnegate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Négateur de l'opérateur, s'il existe</entry>
     </row>

     <row>
      <entry><structfield>oprlsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       Si l'opérateur supporte les jointures par fusion
       (<foreignphrase>merge join</foreignphrase>), ce champ
       contient l'opérateur de tri du type de l'opérande de gauche
       (<literal>L&lt;L</literal>).
      </entry>
     </row>

     <row>
      <entry><structfield>oprrsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       Si l'opérateur supporte les jointures par fusion
       (<foreignphrase>merge join</foreignphrase>), ce champ
       contient l'opérateur de tri du type de l'opérande de droite
       (<literal>R&lt;R</literal>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprltcmpop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       Si l'opérateur supporte les jointures par fusion
       (<foreignphrase>merge join</foreignphrase>), ce champ
       contient l'opérateur inférieur de comparaison des types des opérandes 
       de gauche et de droite(<literal>L&lt;R</literal>).
      </entry>
     </row>

     <row>
      <entry><structfield>oprgtcmpop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       Si l'opérateur supporte les jointures par fusion
       (<foreignphrase>merge join</foreignphrase>), ce champ
       contient l'opérateur supérieur de comparaison des types
       des opérandes de gauche et de droite (<literal>L&gt;R</literal>).
      </entry>
     </row>

     <row>
      <entry><structfield>oprcode</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction codant l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprrest</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction d'estimation de la sélectivité de restriction de
      l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprjoin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction d'estimation de la sélectivité de jointure de
       l'opérateur</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les colonnes inutilisées contiennent des zérosi. 
   <structfield>oprleft</structfield> vaut, par exemple, 0 pour un opérateur préfixe.
  </para>

 </sect1>


 <sect1 id="catalog-pg-pltemplate">
  <title><structname>pg_pltemplate</structname></title>

  <indexterm zone="catalog-pg-pltemplate">
   <primary>pg_pltemplate</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_pltemplate</structname> stocke les informations
   modèles (<quote>template</quote>) des langages de procédures. Un modèle
   de langage permet la création de ce langage dans une base de données
   particulière à l'aide d'une simple commande <command>CREATE LANGUAGE</command>, sans
   qu'il soit nécessaire de spécifier les détails de l'implémentation.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_pltemplate</structname> est partagé par toutes les bases
   de données d'un cluster&nbsp;: il n'existe qu'une seule copie de
   <structname>pg_pltemplate</structname> par cluster, et non pas une par base
   de données. L'information est de ce fait accessible à toute base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_pltemplate</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Nom du langage auquel est associé le modèle</entry>
     </row>

     <row>
      <entry><structfield>tmpltrusted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>True</literal> s'il s'agit d'un langage de
       confiance</entry>
     </row>

     <row>
      <entry><structfield>tmplhandler</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom de la fonction de gestion des appels</entry>
     </row>

     <row>
      <entry><structfield>tmplvalidator</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom de la fonction validateur, ou NULL si aucune</entry>
     </row>

     <row>
      <entry><structfield>tmpllibrary</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Chemin de la bibliothèque partagée qui code le
       langage</entry>
     </row>

     <row>
      <entry><structfield>tmplacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry>Droits d'accès au modèle (actuellement inutilisé)</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Il n'existe actuellement aucune commande de manipulation des modèles de
   langages procéduraux&nbsp;; pour modifier l'information intégrée, un
   superutilisateur doit modifier la table en utilisant les commandes
   <command>INSERT</command>, <command>DELETE</command> ou
   <command>UPDATE</command> habituelles. Il est probable qu'une future version
   de <productname>PostgreSQL</productname> propose des commandes permettant
   de modifier les entrées d'une façon plus propre.
  </para>

  <para>
   Lorsqu'il est renseigné, le champ <structfield>tmplacl</structfield>
   gère le contrôle des accès au modèle (c'est-à-dire le droit de créer un langage
   à partir de ce modèle), mais pas le contrôle des accès aux langages créés
   à partir de ce modèle.
  </para>

 </sect1>


 <sect1 id="catalog-pg-proc">
  <title><structname>pg_proc</structname></title>

  <indexterm zone="catalog-pg-proc">
   <primary>pg_proc</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_proc</structname> stocke les informations
   concernant les fonctions (ou procédures). Voir
   <xref linkend="sql-createfunction" endterm="sql-createfunction-title"/>
   et <xref linkend="xfunc"/> pour plus
   d'informations.
  </para>

  <para>
   Cette table contient des données pour les fonctions d'agrégat et
   les fonctions simples. Si <structfield>proisagg</structfield> est vrai, il
   doit y avoir une ligne correspondante dans
   <structfield>pg_aggregate</structfield>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_proc</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>proname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la fonction</entry>
     </row>

     <row>
      <entry><structfield>pronamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> auquel appartient la fonction
      </entry>
     </row>

     <row>
      <entry><structfield>proowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire de la fonction</entry>
     </row>

     <row>
      <entry><structfield>prolang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_language</structname></link>.oid</literal></entry>
      <entry>Langage de codage ou interface d'appel de la fonction</entry>
     </row>

     <row>
      <entry><structfield>proisagg</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, la fonction est une fonction d'agrégat</entry>
     </row>

     <row>
      <entry><structfield>prosecdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, la fonction définit la sécurité (c'est une
       fonction <quote>setuid</quote>)
      </entry>
     </row>

     <row>
      <entry><structfield>proisstrict</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si vrai, la fonction retourne NULL si l'un de ses arguments est
       NULL. Dans ce cas, la fonction n'est en fait pas appelée du tout. 
       Les fonctions qui ne sont pas <quote>strictes</quote> doivent 
       traiter les paramètres NULL.
      </entry>
     </row>

     <row>
      <entry><structfield>proretset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, la fonction retourne un ensemble (c'est-à-dire des valeurs
       multiples du type défini)
      </entry>
     </row>

     <row>
      <entry><structfield>provolatile</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indique si le résultat de la 
       fonction dépend uniquement de ses arguments ou s'il est affecté par
       des facteurs externes. Il vaut <literal>i</literal> pour les fonctions
       <quote>immuables</quote>, qui, pour un jeu de paramètres identique en
       entrée, donnent toujours le même résultat. Il vaut <literal>s</literal> pour les
       fonctions <quote>stables</quote>, dont le résultat (pour les mêmes paramètres
       en entrée) ne change pas au cours du parcours (de table). Il vaut
       <literal>v</literal> pour les fonctions <quote>volatiles</quote>, dont le
       résultat peut varier à tout instant. (<literal>v</literal> est
       également utilisé pour les fonctions qui ont des effets de bord, afin que les appels
       à ces fonctions ne soient pas optimisés.)
      </entry>
     </row>

     <row>
      <entry><structfield>pronargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre d'arguments</entry>
     </row>

     <row>
      <entry><structfield>prorettype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de données renvoyé</entry>
     </row>

     <row>
      <entry><structfield>proargtypes</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       Un tableau contenant les types de données des arguments de la fonction.
       Ceci n'inclut que les arguments en entrée (dont les
       arguments <literal>INOUT</literal>) et représente, du coup, la signature d'appel de la
       fonction.
      </entry>
     </row>

     <row>
      <entry><structfield>proallargtypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       Un tableau contenant les types de données des arguments de la fonction. Ceci
       inclut tous les arguments (y compris les arguments <literal>OUT</literal>
       et <literal>INOUT</literal>)&nbsp;; néanmoins, si tous les arguments sont
       <literal>IN</literal>, ce champ est NULL. L'indice commence à 1 alors
       que, pour des raisons historiques, <structfield>proargtypes</structfield>
       commence à 0.
      </entry>
     </row>

     <row>
      <entry><structfield>proargmodes</structfield></entry>
      <entry><type>char[]</type></entry>
      <entry></entry>
      <entry>
        Un tableau contenant les modes des arguments de la fonction, codés avec
        <literal>i</literal> pour les arguments <literal>IN</literal>,
        <literal>o</literal> pour les arguments <literal>OUT</literal>,
        <literal>b</literal> pour les arguments <literal>INOUT</literal>.
        Si tous les arguments sont des arguments <literal>IN</literal>, ce
	champ est NULL.
        Les indices correspondent aux positions de
        <structfield>proallargtypes</structfield>, et non à celles de
        <structfield>proargtypes</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>proargnames</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Un tableau contenant les noms des arguments de la fonction. Les arguments
       sans nom sont initialisés à des chaînes vides dans le tableau.
       Si aucun des arguments n'a de nom, ce champ est NULL.
       Les indices correspondent aux positions de
       <structfield>proallargtypes</structfield>, et non à celles de
       <structfield>proargtypes</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>prosrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Ce champ indique au gestionnaire de fonctions la façon d'invoquer la
       fonction. Il peut s'agir du code source pour un langage interprété, d'un
       symbole de lien, d'un nom de fichier ou de toute autre chose, en
       fonction du langage ou de la convention d'appel.
      </entry>
     </row>

     <row>
      <entry><structfield>probin</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>Information supplémentaire sur la façon d'invoquer la fonction.
       Encore une fois, l'interprétation dépend du langage.
      </entry>
     </row>

     <row>
      <entry><structfield>proacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir
       <xref linkend="sql-grant" endterm="sql-grant-title"/> et
       <xref linkend="sql-revoke" endterm="sql-revoke-title"/> pour plus de détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Pour les fonctions compilées, intégrées ou chargées dynamiquement,
   <structfield>prosrc</structfield> contient le nom de la fonction en langage C
   (symbole de lien). Pour tous les autres types
   de langages, <structfield>prosrc</structfield> contient le code source de la
   fonction. <structfield>probin</structfield> est inutilisé, sauf pour les 
   fonctions C chargées dynamiquement, pour lesquelles il donne le nom de 
   fichier de la bibliothèque partagée qui contient la fonction.
  </para>

 </sect1>

 <sect1 id="catalog-pg-rewrite">
  <title><structname>pg_rewrite</structname></title>

  <indexterm zone="catalog-pg-rewrite">
   <primary>pg_rewrite</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_rewrite</structname> stocke les règles de 
   réécriture pour les tables et les vues.
  </para>

  <table>
   <title>Colonnes de <structname>pg_rewrite</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la règle</entry>
     </row>

     <row>
      <entry><structfield>ev_class</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Table sur laquelle porte la règle</entry>
     </row>

     <row>
      <entry><structfield>ev_attr</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Colonne sur laquelle porte la règle. Actuellement, cette colonne
       vaut toujours 0 pour indiquer qu'il s'agit de la table entière.
      </entry>
     </row>

     <row>
      <entry><structfield>ev_type</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Type d'évènement associé à la règle&nbsp;:
        1 = <command>SELECT</command>,
	2 = <command>UPDATE</command>,
	3 = <command>INSERT</command>, 
        4 = <command>DELETE</command>
      </entry>
     </row>

     <row>
      <entry><structfield>is_instead</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai s'il s'agit d'une règle <literal>INSTEAD</literal> 
       (à la place de).
      </entry>
     </row>

     <row>
      <entry><structfield>ev_qual</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Arbre d'expression (sous la forme d'une représentation
       <function>nodeToString()</function>) pour la condition qualifiant la
       règle.
      </entry>
     </row>

     <row>
      <entry><structfield>ev_action</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Arbre de requête (sous la forme d'une représentation
       <function>nodeToString()</function>) pour l'action de la règle.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>pg_class.relhasrules</literal>
    doit être vrai si une table possède une règle dans ce catalogue.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-shdepend">
  <title><structname>pg_shdepend</structname></title>

  <indexterm zone="catalog-pg-shdepend">
   <primary>pg_shdepend</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_shdepend</structname> enregistre les relations
   de dépendance entre les objets de la base de données et les objets partagés,
   comme les rôles. Cette information permet à
   <productname>PostgreSQL</productname> de s'assurer que tous ces objets sont
   déréférencés avant toute tentative de suppression.
  </para>

  <para>
   Voir aussi
   <link linkend="catalog-pg-depend"><structname>pg_depend</structname></link>, qui
   réalise une fonction similaire pour les dépendances impliquant les objets
   contenus dans une seule base de données.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_shdepend</structname> est partagé par toutes les bases de
   données d'un cluster&nbsp;: il n'existe qu'une seule copie de
   <structname>pg_shdepend</structname> par cluster, pas une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shdepend</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>L'OID de la base de données dont fait partie l'objet dépendant.
      0 pour un objet partagé</entry>
     </row>

     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'OID du catalogue système dont fait partie l'objet
        dépendant</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>L'OID de l'objet dépendant</entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'OID du catalogue système dont fait partie l'objet référencé
        (doit être un catalogue partagé)</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>L'OID de l'objet référencé</entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Un code définissant les sémantiques spécifiques des relations de cette
       dépendance&nbsp;; voir le texte.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Dans tous les cas, une entrée <structname>pg_shdepend</structname> indique
   que l'objet référencé ne peut pas être supprimé sans supprimer aussi
   l'objet dépendant. Néanmoins, il existe quelques différences identifiées
   par le <structfield>deptype</structfield>&nbsp;:

   <variablelist>
    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_OWNER</symbol> (<literal>o</literal>)</term>
     <listitem>
      <para>
       L'objet référencé (qui doit être un rôle) est le propriétaire de
       l'objet dépendant.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_ACL</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       L'objet référencé (qui doit être un rôle) est mentionné dans la liste
       de contrôle des accès (<acronym>ACL</acronym>, acronyme de
       <foreignphrase>access control list</foreignphrase>) de l'objet
       dépendant. (Une entrée <symbol>SHARED_DEPENDENCY_ACL</symbol> n'est
       pas créée
       pour le propriétaire de l'objet car ce dernier a toujours une
       entrée <symbol>SHARED_DEPENDENCY_OWNER</symbol>.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>
       Il n'existe pas d'objet dépendant&nbsp;; ce type d'entrée est un signal
       indiquant que le système lui-même dépend de l'objet référencé et que,
       cet objet ne doit donc jamais être supprimé. Les entrées de ce type
       ne sont créées que par <command>initdb</command>. Les colonnes
       pour l'objet dépendant contiennent des zéros.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   D'autres types de dépendances peuvent s'avérer nécessaires dans le futur.
   La définition actuelle ne supporte que les rôles comme objets référencés.
  </para>

 </sect1>

 <sect1 id="catalog-pg-shdescription">
  <title><structname>pg_shdescription</structname></title>

  <indexterm zone="catalog-pg-shdescription">
   <primary>pg_shdescription</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_shdescription</structname> stocke les descriptions
   optionelles (commentaires) des objets partagés de la base. Les
   descriptions peuvent être manipulées avec la commande <xref linkend="sql-comment"
   endterm="sql-comment-title"/> et visualisées avec les commandes
   <literal>\d</literal> de <application>psql</application>.
  </para>

  <para>
   Voir aussi
   <link linkend="catalog-pg-description"><structname>pg_description</structname></link>,
   qui assure les mêmes fonctions, mais pour les objets d'une seule base.
  </para>

  <para>
   Contrairement à la plupart des catalogues systèmes,
   <structname>pg_shdescription</structname>
   est partagée par toutes les bases d'un cluster&nbsp;: il n'existe qu'une seule copie
   de <structname>pg_shdescription</structname> par cluster, et non pas une par
   base.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shdescription</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>L'OID de l'objet concerné par la description</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'OID du catalogue système où cet objet apparaît</entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Texte arbitraire servant de description de l'objet</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-statistic">
  <title><structname>pg_statistic</structname></title>

  <indexterm zone="catalog-pg-statistic">
   <primary>pg_statistic</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_statistic</structname> stocke des données
   statistiques sur le contenu de la base de données. Les entrées sont créées 
   par <command>ANALYZE</command>, puis utilisées par le planificateur de requêtes.
   Il y a une entrée pour chaque colonne de table qui a été analysée.
   Les données statistiques sont, par définition des approximations, 
   même si elles sont à jour.
  </para>

  <para>
   <structname>pg_statistic</structname> stocke aussi les données
   statistiques des valeurs des expressions d'index. Elles sont décrites
   comme si elles étaient de vraies colonnes&nbsp;; en particulier,
   <structfield>starelid</structfield> référence l'index. Néanmoins, aucune
   entrée n'est effectuée pour une colonne d'index ordinaire sans expression
   car cela est redondant avec l'entrée correspondant à la colonne sous-jacente de la
   table.
  </para>

  <para>
   Comme des statistiques différentes peuvent être appropriées pour des types de 
   données différents, <structname>pg_statistic</structname> ne fait
   qu'un minimum de suppositions sur les types de statistiques qu'il
   stocke. Seules des statistiques extrêmement générales (comme les valeurs
   NULL) ont des colonnes dédiées. Tout le reste est stocké dans des 
   <quote>connecteurs</quote>, groupes de colonnes associées 
   dont le contenu est identifié par un numéro de code dans l'une des colonnes
   du connecteur. Pour plus d'information, voir 
   <filename>src/include/catalog/pg_statistic.h</filename>.
  </para>

  <para>
   <structname>pg_statistic</structname> ne doit pas être lisible par le
   public,
   car même les données statistiques sont sensibles.
   (Exemple&nbsp;: les valeurs maximales et minimales d'une colonne de salaire
   peuvent être intéressantes).
   <link linkend="view-pg-stats"><structname>pg_stats</structname></link> est
   une vue sur <structname>pg_statistic</structname> accessible à tous, qui
   n'expose que les informations sur les tables accessibles à
   l'utilisateur courant.
  </para>

  <table>
   <title>Colonnes de <structname>pg_statistic</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>starelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Table ou index à qui la colonne décrite appartient</entry>
     </row>

     <row>
      <entry><structfield>staattnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Numéro de la colonne décrite</entry>
     </row>

     <row>
      <entry><structfield>stanullfrac</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Fraction des entrées de la colonne qui ont une valeur
       NULL</entry>
     </row>

     <row>
      <entry><structfield>stawidth</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Taille moyenne, en octets, des entrées non NULL</entry>
     </row>

     <row>
      <entry><structfield>stadistinct</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry> 
       Nombre de valeurs distinctes non NULL dans la colonne. Une 
       valeurs positive est le nombre réel de valeurs distinctes. Une valeur
       négative est le négatif d'une fraction du nombre de lignes dans la table
       (par exemple, une colonne dans laquelle les valeurs apparaissent environ
       deux fois en moyenne peut être représentée par 
       <structfield>stadistinct</structfield> = -0.5). 0 indique que le
       nombre de valeurs distinctes est inconnu.
      </entry>
     </row>

     <row>
      <entry><structfield>stakind<replaceable>N</replaceable></structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Numéro de code indiquant le type de statistiques stocké dans
       <quote>le connecteur</quote> numéro <replaceable>N</replaceable> de la ligne de
       <structname>pg_statistic</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>staop<replaceable>N</replaceable></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       Opérateur utilisé pour dériver les statistiques stockées dans 
       <quote>le connecteur</quote> numéro <replaceable>N</replaceable>. Par exemple, un
       connecteur d'histogramme montre l'opérateur <literal>&lt;</literal>,
       qui définit l'ordre de tri des données.
      </entry>
     </row>

     <row>
      <entry><structfield>stanumbers<replaceable>N</replaceable></structfield></entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>
       Statistiques numériques du type approprié pour
       <quote>le connecteur</quote> numéro <replaceable>N</replaceable> ou NULL si le type
       de connecteur n'implique pas de valeurs numériques.
      </entry>
     </row>

     <row>
      <entry><structfield>stavalues<replaceable>N</replaceable></structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       Valeurs de données de la colonne du type approprié pour 
       <quote>le connecteur</quote> numéro <replaceable>N</replaceable> ou NULL si
       le type de connecteur ne stocke aucune valeur de données. Chaque valeur
       d'élément du tableau est en fait du type de données de la colonne 
       indiquée, si bien qu'il n'y a aucun moyen de définir le type de ces colonnes 
       plus précisément qu'avec le type <type>anyarray</type> (tableau quelconque).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-tablespace">
   <title><structname>pg_tablespace</structname></title>
   
   <indexterm zone="catalog-pg-tablespace">
     <primary>pg_tablespace</primary>
   </indexterm>
   
   <para>
     Le catalogue <structname>pg_tablespace</structname> enregistre les
     informations des <foreignphrase>tablespaces</foreignphrase> disponibles.
     Les tables peuvent être placées dans des
     <foreignphrase>tablespaces</foreignphrase> particuliers pour faciliter 
     l'administration des espaces de stockage.
   </para>
   
   <para>
     Contrairement à la plupart des catalogues système, 
     <structname>pg_tablespace</structname> est partagée par toutes les bases
     de données du cluster&nbsp;: il n'y a donc qu'une copie de
     <structname>pg_tablespace</structname> par cluster, et non pas une par
     base.
   </para>
   
   <table>
     <title>Colonnes de <structname>pg_tablespace</structname></title>
   
   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
     <thead>
       <row>
         <entry>Nom</entry>
         <entry>Type</entry>
         <entry>Références</entry>
         <entry>Description</entry>
       </row>
     </thead>
     
     <tbody>
       <row>
         <entry><structfield>spcname</structfield></entry>
         <entry><type>name</type></entry>
         <entry></entry>
         <entry>Nom du <foreignphrase>tablespace</foreignphrase></entry>
       </row>
       
       <row>
         <entry><structfield>spcowner</structfield></entry>
         <entry><type>oid</type></entry>
         <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
         <entry>Propriétaire du <foreignphrase>tablespace</foreignphrase>,
	 habituellement l'utilisateur qui l'a créé</entry>
       </row>
       
       <row>
         <entry><structfield>spclocation</structfield></entry>
         <entry><type>text</type></entry>
         <entry></entry>
         <entry>Emplacement (chemin vers le répertoire) du
	 <foreignphrase>tablespace</foreignphrase></entry>
       </row>
       
       <row>
         <entry><structfield>spcacl</structfield></entry>
         <entry><type>aclitem[]</type></entry>
         <entry></entry>
         <entry>
           Droits d'accès&nbsp;; voir
           <xref linkend="sql-grant" endterm="sql-grant-title"/> et
           <xref linkend="sql-revoke" endterm="sql-revoke-title"/> pour les
           détails.
           </entry>
           </row>
         </tbody>
       </tgroup>
     </table>
   </sect1>


   <sect1 id="catalog-pg-trigger">
  <title><structname>pg_trigger</structname></title>

  <indexterm zone="catalog-pg-trigger">
   <primary>pg_trigger</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_trigger</structname> stocke les informations sur
   les déclencheurs des tables. Voir la commande
   <xref linkend="sql-createtrigger" endterm="sql-createtrigger-title"/>
   pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_trigger</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tgrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Table sur laquelle porte le déclencheur</entry>
     </row>

     <row>
      <entry><structfield>tgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>
       Nom du déclencheur (doit être unique parmi les déclencheurs 
       d'une table)
      </entry>
     </row>

     <row>
      <entry><structfield>tgfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction à appeler</entry>
     </row>

     <row>
      <entry><structfield>tgtype</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Masque de bits identifiant les conditions du déclencheur</entry>
     </row>

     <row>
      <entry><structfield>tgenabled</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur est activé</entry>
     </row>

     <row>
      <entry><structfield>tgisconstraint</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur code une contrainte d'intégrité 
       référentielle
      </entry>
     </row>

     <row>
      <entry><structfield>tgconstrname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la contrainte d'intégrité référentielle</entry>
     </row>

     <row>
      <entry><structfield>tgconstrrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>La table référencée par une contrainte d'intégrité
       référentielle</entry>
     </row>

<!-- différable, déférable... retardable ? -->
     <row>
      <entry><structfield>tgdeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur est retardable</entry>
     </row>

     <row>
      <entry><structfield>tginitdeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur est initialement retardé</entry>
     </row>

     <row>
      <entry><structfield>tgnargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de chaînes d'arguments passées à la fonction du
       déclencheur</entry>
     </row>

     <row>
      <entry><structfield>tgattr</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>Actuellement inutilisé</entry>
     </row>

     <row>
      <entry><structfield>tgargs</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       Chaînes d'arguments à passer au déclencheur, chacune terminée par un
       NULL
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>pg_class.reltriggers</literal> doit être en accord avec le nombre
    de déclencheurs trouvés dans cette table.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-type">
  <title><structname>pg_type</structname></title>

  <indexterm zone="catalog-pg-type">
   <primary>pg_type</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_type</structname> stocke les informations sur les
   types de données. Les types de base (types scalaires) sont créés avec la 
   commande <xref linkend="sql-createtype" endterm="sql-createtype-title"/> et
   les domaines avec
   <xref linkend="sql-createdomain" endterm="sql-createdomain-title"/>.
   Un type composite est créé automatiquement pour chaque table de la base
   pour représenter la structure des lignes de la table. Il est aussi possible
   de créer des types composites avec <command>CREATE TYPE AS</command>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_type</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>typname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du type</entry>
     </row>

     <row>
      <entry><structfield>typnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       OID du <foreignphrase>namespace</foreignphrase> qui contient le type
      </entry>
     </row>

     <row>
      <entry><structfield>typowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Propriétaire du type</entry>
     </row>

     <row>
      <entry><structfield>typlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Pour les types de taille fixe, <structfield>typlen</structfield> est le
       nombre d'octets de la représentation interne du type. Mais pour les types
       de longueur variable, <structfield>typlen</structfield> est négatif.
       -1 indique un type <quote>varlena</quote>  (qui a un attribut de longueur),
       -2 indique une chaîne C terminée par le caractère NULL.
      </entry>
     </row>

     <row>
      <entry><structfield>typbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <structfield>typbyval</structfield> détermine si les routines internes
       passent une valeur de ce type par valeur ou par référence.
       <structfield>typbyval</structfield> doit être faux si 
       <structfield>typlen</structfield> ne vaut pas 1, 2 ou 4 (ou 8 sur les
       machines dont le mot-machine est de 8 octets). Les types de longueur
       variable sont toujours passés par référence. 
       <structfield>typbyval</structfield> peut être faux même si la longueur
       permet un passage par valeur&nbsp;; c'est le cas pour le type 
       <type>float4</type>, par exemple.
      </entry>
     </row>

     <row>
      <entry><structfield>typtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typtype</structfield> vaut <literal>b</literal> pour un
       type de base, <literal>c</literal> pour un type composite
       (le type d'une ligne de table, par exemple),
       <literal>d</literal> pour un domaine
       ou <literal>p</literal> pour un pseudo-type. 
       Voir aussi <structfield>typrelid</structfield> et
       <structfield>typbasetype</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>typisdefined</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si le type est défini et faux s'il ne s'agit que d'un conteneur
       pour un type qui n'est pas encore défini. Lorsque 
       <structfield>typisdefined</structfield> est faux, rien, à part le nom du
       type, le <foreignphrase>namespace</foreignphrase> et l'OID, n'est fiable.
      </entry>
     </row>

     <row>
      <entry><structfield>typdelim</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Caractère qui sépare deux valeurs de ce type lorsque le programme
       lit les valeurs d'un tableau en entrée. Le délimiteur est
       associé au type d'élément du tableau, pas au type tableau.
      </entry>
     </row>

     <row>
      <entry><structfield>typrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       S'il s'agit d'un type composite (voir
       <structfield>typtype</structfield>), alors cette colonne pointe vers la
       ligne de <structname>pg_class</structname> qui définit la table
       correspondante. Pour un type composite sans table, l'entrée dans
       <structname>pg_class</structname> ne représente pas vraiment une table,
       mais elle est néanmoins nécessaire pour trouver les lignes de
       <structname>pg_attribute</structname> liées au type. 0 pour les types
       autres que composites.
      </entry>
     </row>

     <row>
      <entry><structfield>typelem</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       Si <structfield>typelem</structfield> ne vaut pas 0, alors il identifie
       une autre ligne de <structname>pg_type</structname>. Le type courant peut
       alors être utilisé comme un tableau contenant des valeurs de type
       <structfield>typelem</structfield>. Un <quote>vrai</quote> type tableau a
       une longueur variable (<structfield>typlen</structfield> = -1), mais
       certains types de longueur fixe (<structfield>typlen</structfield> &gt;
       0) ont aussi un <structfield>typelem</structfield> non nul, par exemple 
       <type>name</type> et <type>point</type>. Si un type de longueur fixe 
       a un <structfield>typelem</structfield>, alors sa représentation interne
       est composé d'un certain nombre de valeurs du type
       <structfield>typelem</structfield>, sans autre donnée. Les types de
       données tableau de taille variable ont un en-tête défini par les
       sous-routines de tableau.
       </entry>
     </row>

     <row>
      <entry><structfield>typinput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de conversion en entrée (format texte)</entry>
     </row>

     <row>
      <entry><structfield>typoutput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de conversion en sortie (format texte)</entry>
     </row>

     <row>
      <entry><structfield>typreceive</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de conversion en entrée (format binaire), 
       ou 0 s'il n'y en a pas</entry>
     </row>

     <row>
      <entry><structfield>typsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de conversion en sortie (format binaire), 
       ou 0 s'il n'y en a pas</entry>
     </row>

     <row>
      <entry><structfield>typanalyze</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction ANALYZE personnalisée ou 0 pour utiliser la fonction standard</entry>
     </row>

     <row>
      <entry><structfield>typalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>

       <structfield>typalign</structfield> est l'alignement requis pour stocker
       une valeur de ce type. Cela s'applique au stockage sur disque ainsi
       qu'à la plupart des représentations de cette valeur dans
       <productname>PostgreSQL</productname>.
       Lorsque des valeurs multiples sont stockées consécutivement, comme dans
       la représentation d'une ligne complète sur disque, un remplissage est 
       inséré avant la donnée de ce type pour qu'elle commence à l'alignement
       indiqué. La référence de l'alignement est le début de la première donnée
       de la séquence.
      </para><para>
       Les valeurs possibles sont&nbsp;:
       <itemizedlist>
        <listitem>
         <para><literal>c</literal> = alignement <type>char</type>, 
          aucun alignement n'est nécessaire&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>s</literal> = alignement <type>short</type> (deux octets sur la
          plupart des machines)&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>i</literal> = alignement <type>int</type> (quatre octets sur la
          plupart des machines)&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>d</literal> = alignement <type>double</type> (huit octets sur
          la plupart des machines, mais pas sur toutes).</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <para>
        Pour les types utilisés dans les tables systèmes il est indispensable
        que les tailles et alignements définis dans
        <structname>pg_type</structname> soient en accord avec la façon dont le 
        compilateur dispose la colonne dans une structure représentant une 
        ligne de table.
       </para>
      </note></entry>
     </row>

     <row>
      <entry><structfield>typstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typstorage</structfield> indique, pour les types varlena 
       (ceux pour lesquels <structfield>typlen</structfield> = -1), si le type
       accepte le TOASTage et la stratégie par défaut à 
       utiliser pour les attributs de ce type. Les valeurs possibles sont&nbsp;:
       <itemizedlist>
        <listitem>
         <para><literal>p</literal>&nbsp;: La valeur doit être stockée
          normalement&nbsp;;</para>
        </listitem>
        <listitem>
         <para>
          <literal>e</literal>&nbsp;: La valeur peut être stockée dans une relation
           <quote>secondaire </quote> (si la relation en a une, voir 
           <literal>pg_class.reltoastrelid</literal>)&nbsp;;
          </para>
        </listitem>
        <listitem>
         <para><literal>m</literal>&nbsp;: La valeurs peut être stockée compressée sur
          place&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>x</literal>&nbsp;: La valeurs peut être stockée compressée sur
          place ou stockée dans une relation <quote>secondaire</quote>.
         </para>
        </listitem>
       </itemizedlist>
       Les colonnes <literal>m</literal> peuvent aussi être déplacées dans 
       une table de stockage secondaire, mais seulement en dernier recours
       (les colonnes <literal>e</literal> et <literal>x</literal> sont
       déplacées les premières).
      </para></entry>
     </row>

     <row>
      <entry><structfield>typnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry><para>
       Représente une contrainte non NULL
       pour le type. Ceci n'est utilisé que pour les domaines.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typbasetype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry><para>
       S'il s'agit d'un domaine (voir <structfield>typtype</structfield>),
       alors <structfield>typbasetype</structfield> identifie le type sur
       lequel celui-ci est fondé. 0 s'il ne s'agit pas d'un domaine.
       </para></entry>
     </row>

     <row>
      <entry><structfield>typtypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       Les domaines utilisent ce champ pour 
       enregistrer le <literal>typmod</literal> à appliquer à leur type de base (-1 si
       le type de base n'utilise pas de <literal>typmod</literal>). -1 si ce type
       n'est pas un domaine.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       Le nombre de dimensions de
       tableau pour un domaine tableau (c'est-à-dire dont
       <structfield>typbasetype</structfield> est un type tableau&nbsp;; le
       <structfield>typelem</structfield> du domaine correspond à celui
       du type de base). 0 pour les types autres que les domaines tableaux.
     </para></entry>
     </row>

     <row>
      <entry><structfield>typdefaultbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       Si <structfield>typdefaultbin</structfield> n'est pas NULL, ce champ est la 
       représentation <function>nodeToString()</function> d'une expression par 
       défaut pour le type. Ceci n'est utilisé que pour les domaines.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typdefault</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       NULL si le type n'a pas de valeur par
       défaut associée. Si <structfield>typdefaultbin</structfield> est non NULL,
       ce champ doit contenir une version lisible de 
       l'expression par défaut représentée par <structfield>typdefaultbin</structfield>.
       Si <structfield>typdefaultbin</structfield> est NULL et si
       ce champ ne l'est pas, alors il stocke la représentation externe de la valeur par
       défaut du type, qui peut être passée à la fonction de conversion en
       entrée du type pour produire une constante.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="views-overview">
  <title>Vues système</title>

  <para>
   En plus des catalogues système, <productname>PostgreSQL</productname>
   fournit un certain nombre de vues internes. Certaines fournissent un
   moyen simple d'accéder à des requêtes habituellement utilisées
   dans les catalogues systèmes. D'autres vues donnent accès à l'état
   interne du serveur.
  </para>

  <para>
   Le schéma d'information (<xref linkend="information-schema"/>) fournit un autre
   ensemble de vues qui recouvrent les fonctionnalités des vues système. Comme
   le schéma d'information fait parti du standard SQL, alors que les vues décrites ici
   sont spécifiques à <productname>PostgreSQL</productname>, il est généralement
   préférable d'utiliser le schéma d'information si celui-ci apporte toutes les
   informations nécessaires.
  </para>

  <para>
   <xref linkend="view-table"/> liste les vues systèmes décrites plus en
   détails dans la suite du document.
   Il existe de plus
   des vues permettant d'accéder aux résultats du collecteur de
   statistiques&nbsp; elles sont décrites dans le
   <xref linkend="monitoring-stats-views-table"/>.
  </para>

  <para>
   Sauf lorsque c'est indiqué, toutes les vues décrites ici sont en lecture seule.
  </para>

  <table id="view-table">
   <title>Vues système</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>But</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="view-pg-cursors"><structname>pg_cursors</structname></link></entry>
      <entry>curseurs ouverts</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-group"><structname>pg_group</structname></link></entry>
      <entry>groupe d'utilisateurs de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-indexes"><structname>pg_indexes</structname></link></entry>
      <entry>index</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-locks"><structname>pg_locks</structname></link></entry>
      <entry>verrous actuellement posés</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-statements"><structname>pg_prepared_statements</structname></link></entry>
      <entry>instructions préparées</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link></entry>
      <entry>transactions préparées</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-roles"><structname>pg_roles</structname></link></entry>
      <entry>rôles de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-rules"><structname>pg_rules</structname></link></entry>
      <entry>règles</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-settings"><structname>pg_settings</structname></link></entry>
      <entry>configuration</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-shadow"><structname>pg_shadow</structname></link></entry>
      <entry>utilisateurs de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-stats"><structname>pg_stats</structname></link></entry>
      <entry>statistiques du planificateur</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-tables"><structname>pg_tables</structname></link></entry>
      <entry>tables</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link></entry>
      <entry>abréviations des fuseaux horaires</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-names"><structname>pg_timezone_names</structname></link></entry>
      <entry>noms des fuseaux horaires</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user"><structname>pg_user</structname></link></entry>
      <entry>utilisateurs de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-views"><structname>pg_views</structname></link></entry>
      <entry>vues</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-cursors">
  <title><structname>pg_cursors</structname></title>

  <indexterm zone="view-pg-cursors">
   <primary>pg_cursors</primary>
  </indexterm>

  <para>
   La vue <structname>pg_cursors</structname> liste les curseurs actuellement
   disponibles. Les curseurs peuvent être définis de plusieurs façons&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      via l'instruction SQL
      <xref linkend="sql-declare" endterm="sql-declare-title"/>&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      via le message Bind du protocole frontend/backend, décrit
      dans le <xref linkend="protocol-flow-ext-query"/>&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      via l'interface de programmation du serveur (SPI), décrite dans le
      <xref linkend="spi-interface"/>.
     </para>
    </listitem>
   </itemizedlist>

   La vue <structname>pg_cursors</structname> affiche les curseurs créés par
   tout moyen précédent. Les curseurs n'existent que pour la durée de la
   transaction qui les définit, sauf s'ils ont été déclarés avec
   <literal>WITH HOLD</literal>. De ce fait, les curseurs volatils
   (<foreignphrase>non-holdable</foreignphrase>) ne sont
   présents dans la vue que jusqu'à la fin de la transaction qui les a créés.

   <note>
    <para>
     Les curseurs sont utilisés en interne pour coder certains
     composants de <productname>PostgreSQL</productname>, comme les langages
     procéduraux. La vue <structname>pg_cursors</structname> peut ainsi
     inclure des curseurs qui n'ont pas été créés explicitement par
     l'utilisateur.
    </para>
   </note>
  </para>

  <table>
   <title>Colonnes de <structname>pg_cursors</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Le nom du curseur</entry>
     </row>

     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>La chaîne utilisée comme requête pour créer le curseur</entry>
     </row>

     <row>
      <entry><structfield>is_holdable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> si le curseur est persistant
       (<foreignphrase>holdable</foreignphrase>)
       (c'est-à-dire s'il peut être accédé après la validation de la transaction
       qui l'a déclaré)&nbsp;; <literal>false</literal> sinon
       </entry>
     </row>

     <row>
      <entry><structfield>is_binary</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> si le curseur a été déclaré binaire
       (<literal>BINARY</literal>)&nbsp;; <literal>false</literal>
       sinon
       </entry>
     </row>

     <row>
      <entry><structfield>is_scrollable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> si le curseur autorise une récupération non
       séquentielle des lignes&nbsp;; <literal>false</literal> sinon
       </entry>
     </row>

     <row>
      <entry><structfield>creation_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>L'heure à laquelle le curseur a été déclaré</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_cursors</structname> est en lecture seule.
  </para>

 </sect1>

 <sect1 id="view-pg-group">
  <title><structname>pg_group</structname></title>

  <indexterm zone="view-pg-group">
   <primary>pg_group</primary>
  </indexterm>

  <para>
   La vue <structname>pg_group</structname> existe pour des raisons de
   compatibilité ascendante&nbsp;: elle émule un catalogue qui a existé avant
   la version 8.1 de <productname>PostgreSQL</productname>. Elle affiche les
   noms et membres de tous les rôles dont l'attribut
   <structfield>rolcanlogin</structfield> est dévalidé, ce qui est une
   approximation des rôles utilisés comme groupes.
  </para>

  <table>
   <title>Colonnes de <structname>pg_group</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>groname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Nom du groupe</entry>
     </row>

     <row>
      <entry><structfield>grosysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant du groupe</entry>
     </row>

     <row>
      <entry><structfield>grolist</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Un tableau contenant les identifiants des rôles du
      groupe</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-indexes">
  <title><structname>pg_indexes</structname></title>

  <indexterm zone="view-pg-indexes">
   <primary>pg_indexes</primary>
  </indexterm>

  <para>
   La vue <structname>pg_indexes</structname> fournit un accès aux
   informations utiles sur chaque index de la base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_indexes</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.4*"/>
    <colspec colnum="3" colwidth="1.3*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma contenant les tables et index</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la table portant l'index</entry>
     </row>
     <row>
      <entry><structfield>indexname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de l'index</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Nom du <foreignphrase>tablespace</foreignphrase> contenant
      l'index (NULL s'il s'agit de celui par défaut pour la base de données)</entry>
     </row>
     <row>
      <entry><structfield>indexdef</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Définition de l'index (une commande <command>CREATE INDEX</command>
       reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-locks">
  <title><structname>pg_locks</structname></title>

  <indexterm zone="view-pg-locks">
   <primary>pg_locks</primary>
  </indexterm>

  <para>
   La vue <structname>pg_locks</structname> fournit un accès aux informations
   concernant les verrous détenus par les transactions ouvertes
   sur le serveur de bases de données. Voir le <xref linkend="mvcc"/>
   pour une discussion plus importante sur les verrous.
  </para>

  <para>
   <structname>pg_locks</structname> contient une ligne par objet verrouillable
   actif, type de verrou demandé et transaction associée. Un même
   objet verrouillable peut apparaître plusieurs fois si plusieurs
   transactions ont posé ou attendent des verrous sur celui-ci. Toutefois, un
   objet qui n'est pas actuellement verrouillé n'apparaît pas.
  </para>

  <para>
   Il existe plusieurs types distincts d'objets verrouillables&nbsp;: les
   relations complètes (tables, par exemple), les pages individuelles de
   relations, des tuples individuels de relations, les identifiants de
   transaction et les objets généraux de la base de données (identifiés par
   l'OID de la classe et l'OID de l'objet, de la même façon que dans
   <structname>pg_description</structname> ou
   <structname>pg_depend</structname>). De plus, le droit d'étendre une
   relation est représenté comme un objet verrouillable distinct.
  </para>

  <table>
   <title>Colonnes <structname>pg_locks</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>locktype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Type de l'objet verrouillable&nbsp;:
       <literal>relation</literal>,
       <literal>extend</literal>,
       <literal>page</literal>,
       <literal>tuple</literal>,
       <literal>transactionid</literal>,
       <literal>object</literal>,
       <literal>userlock</literal> ou
       <literal>advisory</literal>
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>
       L'OID de la base de données dans laquelle existe l'objet, 0 si
       l'objet est partagé ou NULL si l'objet est un identifiant de
       transaction
      </entry>
     </row>
     <row>
      <entry><structfield>relation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       L'OID de la relation ou NULL si l'objet n'est pas une relation ni
       une partie de relation
      </entry>
     </row>
     <row>
      <entry><structfield>page</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       Le numéro de page à l'intérieur de cette relation ou NULL si l'objet
       n'est pas un tuple ou une page de relation
      </entry>
     </row>
     <row>
      <entry><structfield>tuple</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       Le numéro du tuple dans la page ou NULL si l'objet n'est pas un tuple
      </entry>
     </row>
     <row>
      <entry><structfield>transactionid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       L'identifiant d'une transaction ou NULL si l'objet n'est pas un
       identifiant de transaction
      </entry>
     </row>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       L'OID du catalogue système contenant l'objet ou NULL si l'objet n'est
       pas un objet général de la base de données
      </entry>
     </row>
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>
       L'OID de l'objet dans son catalogue système ou NULL si l'objet n'est
       pas un objet général de la base de données
      </entry>
     </row>
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       Pour une colonne de table, c'est le numéro de la colonne
       (<structfield>classid</structfield> et <structfield>objid</structfield>
       font référence à la
       table elle-même). Pour tous les autres types d'objets, cette colonne
       vaut 0. NULL si l'objet n'est pas un objet général de la base de
       données.
      </entry>
     </row>
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       L'ID de la transaction qui détient ou attend le verrou.
      </entry>
     </row>
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       L'identifiant du processus serveur détenant ou attendant le verrou.
       NULL si le verrou est possédé par une transaction préparée.
      </entry>
     </row>
     <row>
      <entry><structfield>mode</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Nom du type de verrou détenu ou attendu par ce processus (voir la
       <xref linkend="locking-tables"/>)</entry>
     </row>
     <row>
      <entry><structfield>granted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry><literal>True</literal> si le verrou est détenu,
      <literal>false</literal> s'il est attendu</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structfield>granted</structfield> est <literal>true</literal> sur une ligne
   représentant un verrou tenu par la transaction indiquée. Une valeur
   <literal>false</literal> indique que cette
   transaction attend l'acquisition du verrou, ce qui implique qu'une autre
   transaction a choisi un mode de verrouillage conflictuel sur le même objet
   verrouillable. La transaction en attente dort jusqu'au relâchement du verrou
   (ou jusqu'à ce qu'une situation de blocage soit détectée). Une transaction
   unique peut attendre l'acquisition d'au plus un verrou à la fois.
  </para>

  <para>
   Chaque transaction détient un verrou exclusif sur son identifiant de
   transaction pour toute sa durée. Si une transaction trouve
   nécessaire d'attendre spécifiquement une autre transaction, elle le fait en
   essayant d'acquérir un verrou partagé sur l'identifiant de l'autre
   transaction. Ceci n'est couronné de succès que lorsque l'autre
   transaction termine et relâche son verrou.
  </para>

  <para>
   Bien que les lignes constituent un type d'objet verrouillable, les informations sur
   les verroux de niveau ligne sont stockées sur disque, et non en mémoire.
   Ainsi, les verroux de niveau ligne n'apparaissent normalement pas dans cette
   vue. Si une transaction attend un verrou de niveau ligne, elle
   apparaît sur la vue comme en attente de l'identifiant de la transaction
   actuellement détentrice de ce verrou de niveau ligne.
  </para>

  <para>
   Les verrous consultatifs peuvent être acquis par des clés constituées soit
   d'une seule valeur <type>bigint</type> soit de deux valeurs
   <type>integer</type>. Une clé <type>bigint</type> est affichée avec
   sa moitié haute dans la colonne <structfield>classid</structfield>, sa
   partie basse dans la colonne <structfield>objid</structfield> et
   <structfield>objsubid</structfield> à 1. Les clés <type>integer</type> sont
   affichées avec la première clé dans la colonne
   <structfield>classid</structfield>, la
   deuxième clé dans la colonne <structfield>objid</structfield> et
   <structfield>objsubid</structfield> à 2. La signification réelle des clés
   est laissée à l'utilisateur. Les verrous consultatifs sont locaux à chaque base,
   la colonne <structfield>database</structfield> a donc un sens dans ce cas.
  </para>

  <para>
   Lorsque la vue <structname>pg_locks</structname> est accédée, les structures de
   données du gestionnaire interne de verrous sont momentanément verrouillées 
   et une copie est faite pour que la vue s'affiche. Ceci assure que la
   vue produit un ensemble consistant de résultats, tout en ne bloquant pas
   les opérations habituelles du gestionnaire de verrous plus longuement que
   nécessaire. Toutefois, si la vue est accédée trop fréquemment, cela peut
   avoir un impact sur les performances de la base de données.
  </para>

  <para>
   <structname>pg_locks</structname> fournit une vue globale de tous les verrous
   du cluster, pas seulement de ceux de la base en cours d'utilisation. Bien que
   la colonne <structfield>relation</structfield> puisse être jointe avec
   <structname>pg_class</structname>.<structfield>oid</structfield> pour identifier
   les relations verrouillées, ceci ne fonctionne correctement qu'avec les
   relations de la base accédée (celles pour lesquelles la colonne
   <structfield>database</structfield> est l'OID de la base actuelle ou 0).
  </para>

  <para>
   Si le collecteur de statistiques est activé, la colonne
   <structfield>pid</structfield> peut être jointe à la colonne
   <structfield>procpid</structfield> de la vue
   <structname>pg_stat_activity</structname> pour obtenir plus
   d'informations sur la session détenant ou attendant de détenir le verrou.
   De plus, si des transactions préparées sont utilisées, la colonne
   <structfield>transaction</structfield> peut être jointe à la colonne
   <structfield>transaction</structfield> de la vue
   <structname>pg_prepared_xacts</structname> pour obtenir plus d'informations
   sur les transactions préparées qui détiennent des verroux. (Une
   transaction préparée ne peut jamais être en attente d'un verrou mais elle
   continue à détenir les verroux qu'elle a acquis pendant son exécution.)
  </para>

 </sect1>

 <sect1 id="view-pg-prepared-statements">
  <title><structname>pg_prepared_statements</structname></title>

  <indexterm zone="view-pg-prepared-statements">
   <primary>pg_prepared_statements</primary>
  </indexterm>

  <para>
   La vue <structname>pg_prepared_statements</structname> affiche toutes les
   instructions préparées disponibles pour la session en cours. Voir
   <xref linkend="sql-prepare" endterm="sql-prepare-title"/> pour de plus
   amples informations sur les instructions préparées.
  </para>

  <para>
   <structname>pg_prepared_statements</structname> contient une ligne pour
   chaque instruction préparée. Les lignes sont ajoutées à la vue quand une
   nouvelle instruction préparée est créée et supprimée quand une instruction
   préparée est abandonnée (par exemple, via la commande
   <xref linkend="sql-deallocate" endterm="sql-deallocate-title"/>).
  </para>

  <table>
   <title>Colonnes de <structname>pg_prepared_statements</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       L'identifiant de l'instruction préparée
      </entry>
     </row>
     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       La requête soumise par le client pour créer cette instruction
       préparée. Pour les instructions préparées créées en SQL, c'est
       l'instruction <command>PREPARE</command> soumise par le client.
       Pour les instructions préparées créées via le protocole
       frontend/backend, c'est le texte de l'intruction préparée
       elle-même.
      </entry>
     </row>
     <row>
      <entry><structfield>prepare_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       L'heure de création de l'instruction préparée
      </entry>
     </row>
     <row>
      <entry><structfield>parameter_types</structfield></entry>
      <entry><type>regtype[]</type></entry>
      <entry>
       Les types des paramètres attendus par l'instruction préparée sous la
       forme d'un tableau de <type>regtype</type>. L'OID correspondant à un
       élément de ce tableau peut être obtenu en convertissant la valeur
       <type>regtype</type> en <type>oid</type>.
      </entry>
     </row>
     <row>
      <entry><structfield>from_sql</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> si l'instruction préparée a été créée via
       l'instruction SQL <command>PREPARE</command>&nbsp;;
       <literal>false</literal> si l'instruction a été préparée via le protocole
       frontend/backend
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_prepared_statements</structname> est en lecture seule.
  </para>
 </sect1>

<!-- ICI -->
 <sect1 id="view-pg-prepared-xacts">
  <title><structname>pg_prepared_xacts</structname></title>

  <indexterm zone="view-pg-prepared-xacts">
   <primary>pg_prepared_xacts</primary>
  </indexterm>

  <para>
   La vue <structname>pg_prepared_xacts</structname> affiche des informations
   sur les transactions actuellement préparées pour une validation en deux
   phases (voir <xref linkend="sql-prepare-transaction"
   endterm="sql-prepare-transaction-title"/> pour les détails).
  </para>

  <para>
   <structname>pg_prepared_xacts</structname> contient une ligne par
   transaction préparée. Une entrée est supprimée quand la transaction est
   validée ou annulée.
  </para>

  <table>
   <title>Colonnes de <structname>pg_prepared_xacts</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       Identifiant numérique de la transaction préparée
      </entry>
     </row>
     <row>
      <entry><structfield>gid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Identifiant global de transaction
      </entry>
     </row>
     <row>
      <entry><structfield>prepared</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry></entry>
      <entry>
       Heure à laquelle la transaction a été préparée pour la validation
      </entry>
     </row>
     <row>
      <entry><structfield>owner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>
       Nom de l'utilisateur qui a exécuté la transaction
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>
       Nom de la base de données dans laquelle a été exécutée la transaction
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Quand une personne accède à la vue
   <structname>pg_prepared_xacts</structname>, les structures de données du
   gestionnaire interne des transactions sont momentanément verrouillées et
   une copie de la vue est faite pour affichage. Ceci nous assure que la vue
   produit un ensemble cohérent de résultats tout en ne bloquant pas les
   opérations normales plus longtemps que nécessaire. Néanmoins, il pourrait
   y avoir un impact sur les performances de la base de données si cette vue
   est accèdée fréquemment.
  </para>

 </sect1>


 <sect1 id="view-pg-roles">
  <title><structname>pg_roles</structname></title>

  <indexterm zone="view-pg-roles">
   <primary>pg_roles</primary>
  </indexterm>

  <para>
   La vue <structname>pg_roles</structname> fournit un accès aux informations
   des rôles de la base de données. C'est tout simplement une vue accessible
   de <link
   linkend="catalog-pg-authid"><structname>pg_authid</structname></link> et qui
   vide le champ du mot de passe.
  </para>

  <para>
   Cette vue expose explicitement la colonne OID de la table sous-jacente car
   cela est nécessaire pour réaliser des jointures avec les autres catalogues.
  </para>

  <table>
   <title>Colonnes de <structname>pg_roles</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du rôle</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle est un superutilisateur</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle hérite automatiquement des droits des rôles dont il est
       membre</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle peut créer d'autres rôles</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Le rôle peut mettre à jour explicitement les catalogues système. 
       (Même un superutilisateur ne peut pas le faire si cette colonne ne
       vaut pas <literal>true</literal>.)
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Le rôle peut se connecter, c'est-à-dire que ce rôle peut être indiqué
       comme identiant initial d'autorisation de session.
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour les rôles pouvant se connecter, ceci configure le nombre
       maximum de connexions concurrentes que peut réaliser ce rôle. -1
       signifie qu'il n'y a pas de limite.
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Ce n'est pas le mot de passe (toujours
        <literal>********</literal>)</entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry></entry>
      <entry>Date/heure d'expiration du mot de passe (utilisées seulement pour
       l'authentification du mot de passe)&nbsp;; NULL s'il est toujours
       valable</entry>
     </row>

     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Variables de configuration par défaut pour la session</entry>
     </row>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant du rôle</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-rules">
  <title><structname>pg_rules</structname></title>

  <indexterm zone="view-pg-rules">
   <primary>pg_rules</primary>
  </indexterm>

  <para>
   La vue <structname>pg_rules</structname> fournit un accès à des informations
   utiles sur les règles de réécriture des requêtes.
  </para>

  <table>
   <title>Colonnes de <structname>pg_rules</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la table pour laquelle est créée la règle</entry>
     </row>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.rulename</literal></entry>
      <entry>Nom de la règle</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Définition de la règle (une commande de création reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_rules</structname> exclut les règles <literal>ON SELECT</literal>
   des vues&nbsp;; elles sont disponibles dans <structname>pg_views</structname>.
  </para>

 </sect1>

 <sect1 id="view-pg-settings">
  <title><structname>pg_settings</structname></title>

  <indexterm zone="view-pg-settings">
   <primary>pg_settings</primary>
  </indexterm>

  <para>
   La vue <structname>pg_settings</structname> fournit un accès aux paramètres
   d'exécution du serveur. C'est essentiellement une autre interface aux
   commandes <command>SHOW</command> et <command>SET</command>. Elle fournit aussi un accès à
   certaines informations sur chaque paramètre qui ne sont pas directement
   accessibles avec <command>SHOW</command>, telles que les valeurs minimales et maximales.
  </para>

  <table>
   <title>Colonnes de <structname>pg_settings</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom du paramètres d'exécution</entry>
     </row>
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Valeur actuelle du paramètre</entry>
     </row>
     <row>
      <entry><structfield>unit</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Unité implicite du paramètre</entry>
     </row>
     <row>
      <entry><structfield>category</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Groupe logique du paramètre</entry>
     </row>
     <row>
      <entry><structfield>short_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Une description brève du paramètre</entry>
     </row>
     <row>
      <entry><structfield>extra_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Information supplémentaire, plus détaillée, sur le paramètre</entry>
     </row>
     <row>
      <entry><structfield>context</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Contexte requis pour initialiser la valeur du paramètre</entry>
     </row>
     <row>
      <entry><structfield>vartype</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Type du paramètre (<literal>bool</literal>, <literal>integer</literal>,
       <literal>real</literal> ou <literal>string</literal>)
      </entry>
     </row>
     <row>
      <entry><structfield>source</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Source de la valeur du paramètre actuel</entry>
     </row>
     <row>
      <entry><structfield>min_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Valeur minimum autorisée du paramètre (NULL pour les valeurs non
       numériques)</entry>
     </row>
     <row>
      <entry><structfield>max_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Valeur maximum autorisée du paramètre (NULL pour les valeurs non
       numériques)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  
  <para>
   La vue <structname>pg_settings</structname> n'accepte pas d'insertion ou de
   suppression mais peut être mise à jour. Un <command>UPDATE</command> appliqué
   à une ligne de <structname>pg_settings</structname> est équivalent à
   l'exécution de la commande <xref linkend="sql-set" endterm="sql-set-title"/>
   sur ce paramètre nommé. Le changement affecte seulement la valeur utilisée
   par la session actuelle. Si un <command>UPDATE</command> est lancé à
   l'intérieur d'une transaction qui est annulée plus tard, les effets de la
   commande <command>UPDATE</command> disparaissent lorsque les effets de la
   transaction sont annulés. Une fois que la transaction est validée, les effets
   persistent jusqu'à la fin de la session, à moins qu'un autre
   <command>UPDATE</command> ou <command>SET</command> ne modifie la valeur.
  </para>

 </sect1>

 <sect1 id="view-pg-shadow">
  <title><structname>pg_shadow</structname></title>

  <indexterm zone="view-pg-shadow">
   <primary>pg_shadow</primary>
  </indexterm>

  <para>
   La vue <structname>pg_shadow</structname> existe pour des raisons de
   compatibilité ascendante&nbsp;: elle émule un catalogue qui a existé avant
   la version 8.1 de <productname>PostgreSQL</productname>. Elle affiche les
   propriétés de tous les rôles marqués <structfield>rolcanlogin</structfield>.
  </para>

  <para>
   Le nom vient du fait que cette table ne devait pas être lisible par le
   public car elle contient les mots de passe.
   <link linkend="view-pg-user"><structname>pg_user</structname></link>
   est une vue sur <structname>pg_shadow</structname>, lisible publiquement car
   elle vide le contenu du champ du mot de passe.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shadow</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Nom de l'utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant de cet utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur est un superutilisateur</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       L'utilisateur peut mettre à jour les catalogues système. (Même un
       superutilisateur ne peut pas le faire si cette colonne ne vaut pas
       <literal>true</literal>.)
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Mot de passe (pouvant être crypté)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>Date/heure d'expiration du mot de passe (seulement utilisé pour
      l'authentification par mot de passe)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Valeurs par défaut des variables de configuration pour la session
        </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-stats">
  <title><structname>pg_stats</structname></title>

  <indexterm zone="view-pg-stats">
   <primary>pg_stats</primary>
  </indexterm>

  <para>
   La vue <structname>pg_stats</structname> fournit un accès aux informations
   stockées dans la table système <link
   linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>.
   Cette vue autorise un accès aux seules lignes de
   <structname>pg_statistic</structname> correspondant aux tables pour lequel
   l'utilisateur a un droit de lecture et, donc, aucun problème de sécurité
   n'empêche l'accès en lecture de cette vue au public.
  </para>

  <para>
   <structname>pg_stats</structname> est aussi conçu pour afficher l'information
   dans un format plus lisible que le catalogue sous-jacent, au prix d'un schéma
   qui doit être étendu lorsque de nouveaux types sont définis dans
   <structname>pg_statistic</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_stats</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <entry>Nom de la colonne décrite par cette ligne</entry>
     </row>

     <row>
      <entry><structfield>null_frac</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Fraction d'entrées de colonnes qui sont NULL</entry>
     </row>

     <row>
      <entry><structfield>avg_width</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Largeur moyenne en octets des entrées de la colonne</entry>
     </row>

     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Si plus grand que zéro, le nombre estimé de valeurs distinctes dans
      la colonne. Si négatif, le nombre de valeurs distinctes divisé par le
      nombre de lignes, le tout muliplié par -1. (La forme négative est utilisée
      quand <command>ANALYZE</command> croit que le nombre de valeurs distinctes a
      tendance à grossir au fur et à mesure que la table grossit&nbsp;; la forme
      positive est utilisé lorsque la commande semble avoir un nombre fixe de
      valeurs possibles.) Par exemple, -1 indique une colonne unique pour
      laquelle le nombre de valeurs distinctes est identique aux nombres de
      lignes.
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>Une liste des valeurs habituelles dans cette colonne. (NULL si
       aucune valeur ne semble identique aux autres.)</entry>
     </row>

     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>Une liste des fréquences des valeurs les plus habituelles,
       c'est-à-dire le nombre d'occurrences de chacune divisé par le nombre
       total de lignes. (NULL lorsque
       <structfield>most_common_vals</structfield> l'est.)
     </entry>
     </row>

     <row>
      <entry><structfield>histogram_bounds</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>Une liste des valeurs qui divisent les valeurs de la colonne en
       groupes de population approximativement identique. Les valeurs dans
       <structfield>most_common_vals</structfield>, s'ils existent, sont omises de ce
       calcul d'histogramme. (Cette colonne est NULL si le type de données de la
       colonne ne dispose pas de l'opérateur <literal>&lt;</literal> ou si la liste
       <structfield>most_common_vals</structfield> tient compte de la population complète.)
      </entry>
     </row>

     <row>
      <entry><structfield>correlation</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Corrélation statistique entre l'ordre physique des lignes et
       l'ordre logique des valeurs de la colonne. Ceci va de -1 à +1. Lorsque la
       valeur est plus près de -1 ou +1, un parcours de l'index sur la colonne
       sera estimé moins cher que si cette valeur tend vers 0, à cause de la
       réduction d'accès aléatoire au disque. (Cette colonne est NULL si le type
       de données de la colonne n'a pas l'opérateur <literal>&lt;</literal> operator.)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Le nombre maximum d'entrées dans <structfield>most_common_vals</structfield>
   et <structfield>histogram_bounds</structfield> est configurable colonne par colonne en
   utilisant la commande <command>ALTER TABLE SET STATISTICS</command> ou globalement
   avec le paramètre d'exécution <xref linkend="guc-default-statistics-target"/>.
  </para>

 </sect1>

 <sect1 id="view-pg-tables">
  <title><structname>pg_tables</structname></title>

  <indexterm zone="view-pg-tables">
   <primary>pg_tables</primary>
  </indexterm>

  <para>
   La vue <structname>pg_tables</structname> fournit un accès à des informations
   utiles sur chaque table de la base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_tables</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la table</entry>
     </row>
     <row>
      <entry><structfield>tableowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Nom du propriétaire de la table</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link
       linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Nom de l'espace logique contenant la table (NULL s'il s'agit de
       l'espace logique par défaut pour cette base)</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasindex</literal></entry>
      <entry>Vrai si la table a (ou a récemment eu) des index</entry>
     </row>
     <row>
      <entry><structfield>hasrules</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasrules</literal></entry>
      <entry>Vrai si la table dispose de règles</entry>
     </row>
     <row>
      <entry><structfield>hastriggers</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.reltriggers</literal></entry>
      <entry>Vrai si la table dispose de déclencheurs (triggers)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-abbrevs">
  <title><structname>pg_timezone_abbrevs</structname></title>

  <indexterm zone="view-pg-timezone-abbrevs">
   <primary>pg_timezone_abbrevs</primary>
  </indexterm>

  <para>
   La vue <structname>pg_timezone_abbrevs</structname> fournit une liste des
   abréviations de fuseaux horaires actuellement reconnues par les routines
   de saisie de champs datetime. Le contenu de cette vue change quand le
   paramètre d'exécution <xref linkend="guc-timezone-abbreviations"/> est
   modifiée.
  </para>

  <table>
   <title>Colonnes de <structname>pg_timezone_abbrevs</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Abréviation du fuseau horaire</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>Décalage de l'UTC (positif signifiant à l'est de Greenwich)</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True s'il s'agit d'une abréviation gérant les changements d'heure</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-names">
  <title><structname>pg_timezone_names</structname></title>

  <indexterm zone="view-pg-timezone-names">
   <primary>pg_timezone_names</primary>
  </indexterm>

  <para>
   La vue <structname>pg_timezone_names</structname> fournit une liste des
   noms de fuseaux horaires qui sont reconnus par <command>SET TIMEZONE</command>,
   avec les abréviations acceptées, les décalages UTC, et l'état du changement
   d'heure. Contrairement aux abréviations indiquées dans <link
   linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link>,
   beaucoup de ces noms impliquent un ensemble de règles pour les dates de
   changement d'heure. Du coup, l'information associée change par rapport aux
   limites du DST local. L'information affichée est calculée suivant la valeur
   actuelle du <function>CURRENT_TIMESTAMP</function>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_timezone_names</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Nom du fuseau horaire</entry>
     </row>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Abréviation du fuseau horaire</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>Décalage à partir d'UTC (positif signifiant à l'est de Greenwich)</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True si changement d'heure prévu</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user">
  <title><structname>pg_user</structname></title>

  <indexterm zone="view-pg-user">
   <primary>pg_user</primary>
  </indexterm>

  <para>
   La vue <structname>pg_user</structname> fournit un accès aux informations
   concernant les utilisateurs de la base de données. C'est une simple vue
   lisible publiquement de
   <link linkend="view-pg-shadow"><structname>pg_shadow</structname></link>
   mais qui n'affiche pas le champ du mot de passe.
  </para>

  <table>
   <title>Colonnes de <structname>pg_user</structname></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Nom de l'utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>Identifiant de l'utilisateur (un nombre arbitraire utilisé en
       référence à cet utilisateur)</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>L'utilisateur peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>L'utilisateur est un super-utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       L'utilisateur pourrait mettre à jour les tables systèmes. (Même un
       super-utilisateur ne pourrait pas le faire tant que cette colonne n'est
       pas initialisée à vrai.
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Ce n'est pas le mot de passe (toujours <literal>********</literal>)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry>Temps d'expiration du mot de passe (utilisé seulement pour
       l'authentification des mots de passe)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>Variables d'exécution par défaut de la session</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-views">
  <title><structname>pg_views</structname></title>

  <indexterm zone="view-pg-views">
   <primary>pg_views</primary>
  </indexterm>

  <para>
   La vue <structname>pg_views</structname> fournit un accès à d'importantes
   informations de chaque vue de la base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_views</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma contenant la vue</entry>
     </row>
     <row>
      <entry><structfield>viewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la vue</entry>
     </row>
     <row>
      <entry><structfield>viewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Nom du propriétaire de la vue</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Définition de la vue (une requête <command>SELECT</command> reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

</chapter>
