<!-- $PostgreSQL: pgsql/doc/src/sgml/contrib-spi.sgml,v 1.2 2007/12/06 04:12:09 tgl Exp $ -->

<sect1 id="contrib-spi">
 <title>spi</title>

 <indexterm zone="contrib-spi">
  <primary>SPI</primary>
  <secondary>examples</secondary>
 </indexterm>

 <para>
  Le module <filename>contrib/spi</filename> fournit plusieurs exemples
  fonctionnels utilisant SPI et les triggers. Bien que ces fonctons ont une
  certaine valeur en soi, elles sont encore plus utiles en tant qu'exemples
  à modifier pour atteindre vos propres buts. Les fonctions sont suffisament
  généralistes pour être utilisées avec toute table mais vous devez spécifier
  les noms des tables et des champs (comme décrit ci-dessous) lors de la
  création d'un trigger.
 </para>

 <sect2>
  <title>refint.c &mdash; fonctions pour réimplémenter l'intégrité
  référentielle</title>

  <para>
   <function>check_primary_key()</function> et
   <function>check_foreign_key()</function> sont utilisées pour vérifier les
   contraintes de clé étrangère. (Cette fonctionnalité est dépassée depuis
   longtemps par le mécanisme interne, mais le module reste utile comme
   exemple.)
  </para>

  <para>
   <function>check_primary_key()</function> vérifie la table de référence.
   Pour l'utiliser, créez un trigger <literal>BEFORE INSERT OR UPDATE</literal>
   en utilisant cette fonction sur une table référençant une autre table.
   Spécifiez les arguments du trigger&nbsp;: le nom de la colonne de
   référence de la table qui forme la clé étrangère, le nom de la table
   référencée et le nom de la colonne pour la table référencée qui forme la
   clé primaire/unique. Il peut y avoir plusieurs colonnes. Pour gérer
   plusieurs clés étrangères, créez un trigger pour chaque référence.
  </para>

  <para>
   <function>check_foreign_key()</function> vérifie la table référencée.
   Pour l'utiliser, créez un trigger <literal>BEFORE DELETE OR UPDATE</literal>
   en utilisant cette fonction sur une table référencée par d'autres tables.
   Spécifiez les arguments du trigger&nbsp;: nombre de tables référantes pour
   lesquelles la fonction va réaliser la vérification, l'action si une clé
   de référence est trouvée (<literal>cascade</literal> &mdash; pour supprimer
   une ligne référante, <literal>restrict</literal> &mdash; pour annuler la
   transaction si des clés référantes existent, <literal>setnull</literal>
   &mdash; pour initialiser les champs des clés référantes à NULL), les noms
   des colonnes de la table contenant le trigger, colonnes qui forment une
   clé primaire/unique, puis le nom de la table référante et les noms des
   colonnes (répété pour toutes les tables référantes le nombre de fois
   spécifié par le premier argument). Notez que les colonnes de clé
   primaire/unique devraient être marquées NOT NULL et devraient avoir un
   index unique.
  </para>

  <para>
   Il y a des exemples dans <filename>refint.example</filename>.
  </para>
 </sect2>

 <sect2>
  <title>timetravel.c &mdash; fonctions pour implémenter le voyage dans le
  temps</title>

  <para>
   Auparavant, <productname>PostgreSQL</productname> avait une fonctionnalité
   de voyage dans le temps, permettant de conserver l'heure d'insertion et
   de suppression pour chaque ligne. Ce comportement peut être émulé en
   utilisant ces fonctions. Pour les utiliser, vous devez ajouter deux champs
   de type <type>abstime</type> à la table pour stocker le moment où une
   ligne a été insérée (start_date) et le moment où elle a été
   modifiée/supprimée (stop_date)&nbsp;:

<programlisting>
CREATE TABLE mytab (
        ...             ...
        start_date      abstime,
        stop_date       abstime
        ...             ...
);
</programlisting>

   Les colonnes peuvent être nommées comme vous le voulez, mais dans ce
   chapitre, nous les appelerons start_date et stop_date.
  </para>

  <para>
   Quand une nouvelle ligne est insérée, start_date doit normalement
   être initialisée avec l'heure actuelle et stop_date doit valoir
   <literal>infinity</literal>. Le trigger substituera automatiquement ces
   valeurs si la donnée insérée contient des NULL dans ces colonnes.
   Généralement, insérer des données explicites non NULL dans ces colonnes
   ne sera fait qu'au chargement de données sauvegardées.
  </para>

  <para>
   Les lignes avec stop_date égales à <literal>infinity</literal> sont des
   lignes <quote>actuellement valides</quote>, et peuvent être modifiées.
   Les lignes avec un stop_date fini ne peuvent plus être modifiées &mdash;
   le trigger les protège. (si vous avez besoin de les modifier, vous
   pouvez désactiver le voyage dans le temps comme indiqué ci-dessous.)
  </para>

  <para>
   Pour une ligne modifiable, en cas de mise à jour, seul stop_date sera
   modifié (à l'heure actuelle) et une nouvelle ligne avec la donnée modifiée
   sera insérée. Start_date dans cette nouvelle ligne sera initialisée avec
   l'heure courante et stop_date vaudra <literal>infinity</literal>.
  </para>

  <para>
   Une suppression ne supprime pas réellement la ligne mais initialise
   stop_date à l'heure actuelle.
  </para>

  <para>
   Pour trouver les lignes <quote>actuellement valides</quote>, ajoutez la
   clause <literal>stop_date = 'infinity'</literal> dans la condition
   WHERE de la requête. (Vous pouvez l'incorporer dans une vue.) De façon
   similaire, vous pouvez exécuter une requête sur les lignes valides à
   tout moment dans le passé avec les conditions adéquates sur
   start_date et stop_date.
  </para>

  <para>
   <function>timetravel()</function> est la fonction trigger généraliste qui
   supporte ce comportement. Créez un trigger <literal>BEFORE INSERT OR UPDATE
   OR DELETE</literal> utilisant cette fonction pour chaque table pour laquelle
   la fonctionnalité de voyage dans le temps est activée. Spécifiez deux
   arguments pour le trigger&nbsp;: les noms réels des colonnes start_date et
   stop_date. En option, vous pouvez spécifier entre un et trois arguments
   supplémentaires qui doivent faire référence aux colonnes de type
   <type>text</type>. Le trigger stockera le nom de l'utilisation courant
   dans la première de ces colonnes lors d'un INSERT, dans la seconde lors
   d'un UPDATE et dans la troisième pour un DELETE.
  </para>

  <para>
   <function>set_timetravel()</function> vous permet d'activer et de
   désactiver la fonctionnalité du voyage dans le temps pour une table.
   <literal>set_timetravel('ma_table', 1)</literal> l'activera pour la table
   ma_table.
   <literal>set_timetravel('mytab', 0)</literal> la désactivera pour la table
   ma_table.
   Dans les deux cas, l'ancien statut est rapporté. Quand elle est
   désactivée, vous pouvez modifier librement les colonnes start_date et
   stop_date. Notez que le statut activé/désactivé est local à la session
   de la base &mdash; les nouvelles commenceront toujours avec cette
   fonctionnalité activée pour toutes les tables.
  </para>

  <para>
   <function>get_timetravel()</function> renvoie l'état de la fonctionnalité
   du voyage dans le temps pour une table sans la modifier.
  </para>

  <para>
   Il y a un exemple dans <filename>timetravel.example</filename>.
  </para>
 </sect2>

 <sect2>
  <title>autoinc.c &mdash; fonctions pour l'incrémentation automatique
  d'un champ</title>

  <para>
   <function>autoinc()</function> est un trigger qui stocke la prochaine valeur
   d'une séquence dans un champ de type integer. Ceci est en partie couvert
   par la fonctionnalité interne de la colonne <quote>serial</quote>, mais
   n'est pas strictement identique&nbsp;: <function>autoinc()</function>
   surchargera les tentatives de substituer une valeur différente pour ce
   champ lors des insertions et, en option, il peut aussi être utilisé pour
   incrémenter le champ lors des mises à jour.
  </para>

  <para>
   Pour l'utiliser, créez un trigger <literal>BEFORE INSERT</literal> (ou
   en option <literal>BEFORE INSERT OR UPDATE</literal>) en utilisant cette
   fonction. Spécifiez deux arguments pour le trigger&nbsp;: le nom de la
   colonne de type integer à modifier, et le nom de la séquence qui fournira
   les valeurs. (En fait, vous pouvez spécifier plusieurs paires de noms si
   vous voulez mettre à jour plus d'une colonne.)
  </para>

  <para>
   Il existe un exemple dans <filename>autoinc.example</filename>.
  </para>

 </sect2>

 <sect2>
  <title>insert_username.c &mdash; fonctions pour tracer les utilisateurs qui
  ont modifié une table</title>

  <para>
   <function>insert_username()</function> est un trigger qui stocke le
   nom de l'utilisateur en cours dans un champ texte. Ceci est utile pour
   tracer le dernier utilisateur qui a modifié une ligne particulière d'une
   table.
  </para>

  <para>
   Pour l'utiliser, créez un trigger <literal>BEFORE INSERT</literal> et/ou
   <literal>UPDATE</literal> en utilisant cette fonction. Le seul argument
   du trigger correspond au nom de la colonne texte à modifier.
  </para>

  <para>
   Il existe un exemple dans <filename>insert_username.example</filename>.
  </para>

 </sect2>

 <sect2>
  <title>moddatetime.c &mdash; fonctions pour tracer la date et l'heure
  de la dernière modification</title>

  <para>
   <function>moddatetime()</function> est un trigger qui stocke la date et
   l'heure de la dernière modification dans un champ de type
   <type>timestamp</type>. Ceci peut être utile pour savoir quand a eu lieu la
   dernière modification pour une ligne particulière d'une table.
  </para>

  <para>
   Pour l'utiliser, créez un trigger <literal>BEFORE UPDATE</literal> en
   utilisant cette fonction. Le seul argument de ce trigger correspond au
   nom de la colonne de type <type>timestamp</type> à modifier.
  </para>

  <para>
   Il existe un exemple dans <filename>moddatetime.example</filename>.
  </para>

 </sect2>

</sect1>
