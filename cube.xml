
<sect1 id="cube">
 <title>cube</title>
 
 <indexterm zone="cube">
  <primary>cube</primary>
 </indexterm>

 <para>
  Ce module contient le type utilisateur CUBE, représentant des cubes à
  plusieurs dimensions.
 </para>

 <sect2>
  <title>Syntaxe</title>

  <para>
   Ce qui suit est plusieurs représentations externes valides pour le
   type CUBE&nbsp;:
  </para>

  <table>
   <title>Représentations externes d'un cube</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>'x'</entry>
      <entry>Une valeur en virgule flottante représentation un point sur
       une dimension ou un élément cube zéro à une dimension
      </entry>
     </row>
     <row>
      <entry>'(x)'</entry>
      <entry>Identique à ci-dessus</entry>
     </row>
     <row>
      <entry>'x1,x2,x3,...,xn'</entry>
      <entry>Un point dans un espace à n dimensions, représenté en interne
       comme une boîte de volume zéro
      </entry>
     </row>
     <row>
      <entry>'(x1,x2,x3,...,xn)'</entry>
      <entry>Identique à ci-dessus</entry>
     </row>
     <row>
      <entry>'(x),(y)'</entry>
      <entry>Élément cube à une dimension commençant à x et se terminant à
       y ou vice-versa&nbsp;; l'ordre n'importe pas
      </entry>
     </row>
     <row>
      <entry>'(x1,...,xn),(y1,...,yn)'</entry>
      <entry>boîte à n dimensions représentée par une paire pour ses coins
       opposés, peu importe lesquels. Les fonctions s'occupent de la bascule
       pour réaliser une représentation en bas à gauche, en haut à droite
       avant de calculer toute valeur
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
   </sect2>
  
   <sect2>
    <title>Grammaire</title>
    <table>
     <title>Règles de grammaire du cube</title>
     <tgroup cols="2">
      <tbody>
       <row>
        <entry>règle 1</entry>
        <entry>box -> O_BRACKET paren_list COMMA paren_list C_BRACKET</entry>
       </row>
       <row>
        <entry>règle 2</entry>
        <entry>box -> paren_list COMMA paren_list</entry>
       </row>
       <row>
        <entry>règle 3</entry>
        <entry>box -> paren_list</entry>
       </row>
       <row>
        <entry>règle 4</entry>
        <entry>box -> list</entry>
       </row>
       <row>
        <entry>règle 5</entry>
        <entry>paren_list -> O_PAREN list C_PAREN</entry>
       </row>
       <row>
        <entry>règle 6</entry>
        <entry>list -> FLOAT</entry>
       </row>
       <row>
        <entry>règle 7</entry>
        <entry>list -> list COMMA FLOAT</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2>
    <title>Jetons</title>
    <table>
     <title>Règles de grammaire du cube</title>
     <tgroup cols="2">
      <tbody>
       <row>
        <entry>n</entry>
        <entry>[0-9]+</entry>
       </row>
       <row>
        <entry>i</entry>
        <entry>nteger                [+-]?{n}</entry>
       </row>
       <row>
        <entry>real</entry>
        <entry>[+-]?({n}\.{n}?|\.{n})</entry>
       </row>
       <row>
        <entry>FLOAT</entry>
        <entry>({integer}|{real})([eE]{integer})?</entry>
       </row>
       <row>
        <entry>O_BRACKET</entry>        
        <entry>\[</entry>
       </row>
       <row>
        <entry>C_BRACKET</entry>
        <entry>\]</entry>
       </row>
       <row>
        <entry>O_PAREN</entry>
        <entry>\(</entry>
       </row>
       <row>
        <entry>C_PAREN</entry>
        <entry>\)</entry>
       </row>
       <row>
        <entry>COMMA</entry>
        <entry>\,</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

 <sect2>
  <title>Exemples</title>
  <table>
   <title>Exemples</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>'x'</entry>
      <entry>Une valeur en virgule flottante représentant un point sur une
       dimension (ou un interval nul sur une dimension)
      </entry>
     </row>
     <row>
      <entry>'(x)'</entry>
      <entry>Identique à ci-dessus</entry>
     </row>
     <row>
      <entry>'x1,x2,x3,...,xn'</entry>
      <entry>Un point dans un espace à n dimensions représenté par un cube
       de volume nul
      </entry>
     </row>
     <row>
      <entry>'(x1,x2,x3,...,xn)'</entry>
      <entry>Identique à ci-dessus</entry>
     </row>
     <row>
      <entry>'(x),(y)'</entry>
      <entry>Un intervalle sur une dimension commençant à x et se terminant à
       y ou vice-versa&nbsp;; l'ordre n'importe pas
      </entry>
     </row>
     <row>
      <entry>'[(x),(y)]'</entry>
      <entry>Identique à ci-dessus</entry>
     </row>
     <row>
      <entry>'(x1,...,xn),(y1,...,yn)'</entry>
      <entry>Une boîte à n dimensions par une paire de ces coins opposés,
       quelque soit l'ordre. La bascule est fournie par toutes les routines
       de comparaison pour assurer la représentation en bas à gauche, en
       haut à droite avec la réalisation de comparaisons.
      </entry>
     </row>
     <row>
      <entry>'[(x1,...,xn),(y1,...,yn)]'</entry>
      <entry>Identique à ci-dessus</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   Les espaces blancs sont ignorés, donc '[(x),(y)]' peut être
   '[ ( x ), ( y ) ]'.
  </para>
 </sect2>
 <sect2>
  <title>Par défaut</title>
  <para>
   Je crois que cette union&nbsp;:
  </para>
<programlisting>
select cube_union('(0,5,2),(2,3,1)','0'); 
cube_union        
-------------------
(0, 0, 0),(2, 5, 2)
(1 row)
</programlisting>

   <para>
    n'est pas en contradiction avec le bon sens et ne fait pas l'intersection
   </para>

<programlisting>
select cube_inter('(0,-1),(1,1)','(-2),(2)');
cube_inter  
-------------
(0, 0),(1, 0)
(1 row)
</programlisting>

   <para>
    Dans toutes les opérations binaires sur des boîtes de différentes tailles,
    je suppose que la plus petite est une projection cartésienne, c'est-à-dire
    avoir des zéros à la place des coordonnées omises dans la représentation
    sous forme de chaîne. Les exemples ci-dessous sont équivalents à&nbsp;:
   </para>

<programlisting>
cube_union('(0,5,2),(2,3,1)','(0,0,0),(0,0,0)'); 
cube_inter('(0,-1),(1,1)','(-2,0),(2,0)');
</programlisting>

   <para>
    Le prédicat de contenance suivant utilise la syntaxe point alors qu'en
    fait, le second argument est représenté en interne par une boîte. Cette
    syntaxe rend inutile la définition du type spécial Point et les fonctions
    pour le prédicat (boîte,point).
   </para>

<programlisting>
select cube_contains('(0,0),(1,1)', '0.5,0.5');
cube_contains
--------------
t             
(1 row)
</programlisting>
 </sect2>
 <sect2>
  <title>Précision</title>
  <para>
   Les valeurs sont enregistrées en interne sous la forme de nombres en
   virgule flottante. Cela signifie que les nombres avec plus de 16 chiffres
   significatifs seront tronqués.
  </para>
 </sect2>

 <sect2>
  <title>Utilisation</title>
  <para>
   La méthode d'accès pour CUBE est un index GiST (gist_cube_ops), qui est une
   généralisation de R-tree. GiST permet l'implémentation postgres de
   R-tree, développé à l'origine pour supporter les types géométriques à
   deux dimensions comme les boîtes et les polygones et pour être utilisé
   avec tout type de données dont le domaine peut être partitionné en utilisant
   les concepts de contenance, d'intersection et d'égalité. En d'autres mots,
   tout ce qui peut contenir une partie ou tout de son propre type peut être
   indexé dans un index GiST. Ceci inclut, parmi d'autres, tous les types
   de données géométriques, quelque soit le nombre de dimensions (voir aussi
   le module contrib/seg).
  </para>

  <para>
   Les opérateurs supportés par la méthode d'accès GiST incluent&nbsp;:
  </para>

  <programlisting>
a = b                Identique à
  </programlisting>
  <para>
   Les éléments cube a et b sont identiques.
  </para>

  <programlisting><![CDATA[
a && b                Couvre une partie
  ]]></programlisting>
  <para>
   Les éléments cube a et b se couvrent en partie.
  </para>

  <programlisting><![CDATA[
a @> b                Contient
  ]]></programlisting>
  <para>
   L'élément cube a contient l'élément cube b.
  </para>

  <programlisting><![CDATA[
a <@ b                Contenu dans
  ]]></programlisting>
  <para>
   L'élément cube est contenu dans l'élément cube b.
  </para>

  <para>
   (Avant PostgreSQL 8.2, les opérateurs de contenance @&gt; et &lt;@ étaient
   appelés respectivement @ et ~. Ces noms sont toujours disponibles mais sont
   déclarés obsolètes et seront supprimés un jour. Notez que les anciens noms
   sont inversés par rapport à la convention suivie par les types de données
   géométriques&nbsp;!)
  </para>

  <para>
   Bien que les mnémoniques des opérateurs suivants sont questionnables, je
   les ai préservé pour maintenir une cohérence visuelle avec les autres
   types de données géométriques dans Postgres.
  </para>

  <para>
   D'autres opérateurs&nbsp;:
  </para>

  <programlisting><![CDATA[
[a, b] < [c, d]                Plus petit que
[a, b] > [c, d]                Plus grand que
  ]]></programlisting>
 
  <para>
   Ces opérateurs n'ont pas vraiment de sens sauf en ce qui concerne le tri.
   Ces opérateurs comparent en premier (a) à (c) et, s'ils sont égaux,
   comparent (b) à (d). Cela fait un bon tri dans la plupart des cas, ce qui
   est utile si vous voulez utiliser ORDER BY avec ce type.
  </para>

  <para>
   Les fonctions suivantes sont disponibles&nbsp;:
  </para>

  <table>
   <title>Fonctions disponibles</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry><literal>cube_distance(cube, cube) returns double</literal></entry>
      <entry>cube_distance renvoie la distance entre deux cubes. Si les deux
       cubes sont des points, ceci est la fonction de distance normale.
      </entry>
     </row>
     <row>
      <entry><literal>cube(float8) returns cube</literal></entry>
      <entry>Ceci crée un cube à une dimension avec les mêmes coordonnées.
       Si le type de l'argument est un type numérique autre que float8, une
       conversion explicite vers float8 pourrait être nécessaire.
       <literal>cube(1) == '(1)'</literal>
      </entry>
     </row>

     <row>
      <entry><literal>cube(float8, float8) returns cube</literal></entry>
      <entry>
       Ceci crée un cube à une dimension.
       <literal>cube(1,2) == '(1),(2)'</literal>
      </entry>
     </row>

     <row>
      <entry><literal>cube(float8[]) returns cube</literal></entry>
      <entry>Ceci crée un cube de volume nul en utilisant les coordonnées
       définies par le tableau.<literal>cube(ARRAY[1,2]) == '(1,2)'</literal>
      </entry>
     </row>

     <row>
      <entry><literal>cube(float8[], float8[]) returns cube</literal></entry>
      <entry>Ceci crée un cube avec les coordonnées en haut à droite et en
       bas à gauche définies par deux tableaux de flottants. Tous les
       tableaux doivent être de la même longueur.
       <literal>cube('{1,2}'::float[], '{3,4}'::float[]) == '(1,2),(3,4)'
       </literal>
      </entry>
     </row>

     <row>
      <entry><literal>cube(cube, float8) returns cube</literal></entry>
      <entry>Ceci construit un nouveau cube en ajoutant une dimension à un
       cube existant avec les mêmes valeurs pour les deux parties de la
       nouvelle coordonnée. Ceci est utile pour construire des cubes pièce
       par pièce à partir des valeurs calculées.
       <literal>cube('(1)',2) == '(1,2),(1,2)'</literal>
      </entry>
     </row>

     <row>
      <entry><literal>cube(cube, float8, float8) returns cube</literal></entry>
      <entry>Ceci crée un nouveau cube en ajoutant une dimension sur un cube
       existant. C'est utile pour construire des cubes pièce par pièce à partir
       de valeurs calculées.
       <literal>cube('(1,2)',3,4) == '(1,3),(2,4)'</literal>
      </entry>
     </row>

     <row>
      <entry><literal>cube_dim(cube) returns int</literal></entry>
      <entry>cube_dim renvoie le nombre de dimensions enregistrées dans la
       de données pour un cube. Ceci est utile pour les contraintes sur les
       dimensions d'un cube.
      </entry>
     </row>

     <row>
      <entry><literal>cube_ll_coord(cube, int) returns double </literal></entry>
      <entry>
       cube_ll_coord renvoie la n-ième coordonnée pour le coin en bas à
       gauche d'un cube. Ceci est utile pour réaliser des transformations de
       coordonnées.
      </entry>
     </row>

    <row>
      <entry><literal>cube_ur_coord(cube, int) returns double
      </literal></entry>
      <entry>cube_ur_coord renvoie la n-ième coordonnée pour le coin en haut à
       droite d'un cube. Ceci est utile pour réaliser des transformations de
       coordonnées.
      </entry>
     </row>

     <row>
      <entry><literal>cube_subset(cube, int[]) returns cube
      </literal></entry>
      <entry>Crée un nouveau cube à partir d'un cube existant en utilisant une
       liste d'index de dimension pour un tableau. Peut être utilisé pour
       trouver les coordonnées en bas à gauche et en haut à droite d'une
       dimension, par exemple&nbsp;:
       cube_subset(cube('(1,3,5),(6,7,8)'), ARRAY[2]) = '(3),(7)'
       Ou peut être utilisé pour supprimer des dimensions, ou pour les
       réordonner comme voulu, par exemple&nbsp;:
       cube_subset(cube('(1,3,5),(6,7,8)'), ARRAY[3,2,1,1]) = 
       '(5, 3, 1, 1),(8, 7, 6, 6)'
      </entry>
     </row>

     <row>
      <entry><literal>cube_is_point(cube) returns bool</literal></entry>
      <entry>cube_is_point renvoie true si un cube est aussi un point.
       Ceci se vérifie quand deux coins de définition sont identiques.</entry>
     </row>
 
     <row>
      <entry><literal>cube_enlarge(cube, double, int) returns cube</literal></entry>
      <entry>
       cube_enlarge augmente la taille d'un cube suivant un radius précisé
       dans au moins n dimensions. Si le radius est négatif, la boîte est
       diminuée. C'est utile pour créer des boîtes limitantes autour d'un
       point dans le but de rechercher les points voisins. Toutes les
       dimensions définies sont modifiées par le radius. Si n est plus grand
       que le nombre de dimensions définies et que le cube est augmenté
       (r >= 0), alors 0 est utilisé comme base des coordonnées
       supplémentaires. Les coordonnées en bas à gauche sont diminuées de r
       et les coordonnées en haut à droite sont augmentées de r. Si une
       coordonnée en bas à gauche est augmentée à une valeur plus importante
       que la coordonnée correspondante en haut à droite (ceci peut seulement
       survenir quand r est négatif), alors les deux coordonnées sont
       initialisées à leur valeur moyenne. Malgré tout, pour solidifier
       ce module, il existe un maximum aux dimensions des cubes. Il est de
       100. Ceci est configuré dans cubedata.h si vous souhaitez augmenter
       cette valeur.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 
  <para>
   Il existe quelques fonctions potentiellement utiles définies dans seg.c
   qui ont disparu du schéma car j'ai arrêté de les utiliser. Certaines
   avaient pour but de supporter la conversion de type. Prévenez-moi si
   j'ai eu tort, je les rajouterais dans le schéma. J'apprécierais aussi
   d'autres idées pour améliorer le type et le rendre plus utile.
  </para>

  <para>
   Pour des exemples d'utilisation, voir sql/cube.sql
  </para>
 </sect2>

 <sect2>
  <title>Crédits</title>
  <para>
   Ce code est essentiellement basé sur l'exemple écrit pour
   Illustra, <ulink url="http://garcia.me.berkeley.edu/~adong/rtree"></ulink>
  </para>
  <para>
   Mes remerciements vont tout particulièrement au professeur Joe Hellerstein
   (<ulink url="http://db.cs.berkeley.edu/~jmh/"></ulink>) pour avoir élucier
   l'idée centrale de GiST (<ulink
   url="http://gist.cs.berkeley.edu/"></ulink>), et à son ancien étudiant,
   Andy Dong 
   (<ulink url="http://best.me.berkeley.edu/~adong/"></ulink>), pour son
   exemple. Mes remerciements aussi aux
   développeurs de PostgreSQL pour m'avoir permis de créer mon propre monde
   et de pouvoir y vivre sans pertubation. Argonne Lab et le département
   américain de l'énergie ont aussi toute ma gratitude pour les années de
   support dans ma recherche sur les bases de données.
  </para>

  <para>
   Gene Selkov, Jr.
   Computational Scientist
   Mathematics and Computer Science Division
   Argonne National Laboratory
   9700 S Cass Ave.
   Building 221
   Argonne, IL 60439-4844
   <email>selkovjr@mcs.anl.gov</email>
  </para>

  <para>
   Des modifications mineures ont été effectuées sur ce modul par Bruno Wolff
   III  <email>bruno@wolff.to</email> en août/septembre 2002. Elles incluent
   la modification de la précision (de simple à double) et l'ajout de
   quelques nouvelles fonctions.
  </para>

  <para>
   Des mises à jour supplémentaires ont été réalisées par Joshua Reich
   <email>josh@root.net</email> en juillet 2006. Elles concernent
   <literal>cube(float8[], float8[])</literal> et le nettoyage du code pour
   utiliser le protocole d'appel V à la place de la forme V0 maintenant
   obsolète.
  </para>
 </sect2>
</sect1>

