<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/datatype.sgml,v 1.13 2005/09/22 18:34:40 guillaume Exp $
-->

 <chapter id="datatype">
  <title id="datatype-title">Types de données</title>

  <indexterm zone="datatype">
   <primary>Types de données</primary>
  </indexterm>

  <indexterm>
   <primary>type</primary>
   <see>type de données</see>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> a un large choix de types de 
   données disponibles nativement.
   Les utilisateurs peuvent ajouter de nouveaux types à 
   <productname>PostgreSQL</productname> en utilisant la commande <xref
   linkend="sql-createtype" endterm="sql-createtype-title">.
  </para>

  <para>
   Le <xref linkend="datatype-table"> montre tous les types de données
   généraux disponibles nativement.
   La plupart des types de données alternatifs listés dans la colonne
   <quote>Alias</quote> sont les noms utilisés en interne par
   <productname>PostgreSQL</productname> pour des raisons historiques.
   De plus, certains types de données internes ou obsolètes sont 
   disponibles, mais ils ne sont pas listés ici.
 
  </para>

   <table id="datatype-table">
    <title>Types de données</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Alias</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
       <entry>Entier signé sur 8 octets</entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
       <entry>Entier sur 8 octets à incrémentation automatique</entry>
      </row>

      <row>
       <entry><type>bit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>Suite de bits de longueur fixe</entry>
      </row>

      <row>
       <entry><type>bit varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varbit</type></entry>
       <entry>Suite de bits de longueur variable</entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
       <entry>Booléen (Vrai/Faux)</entry>
      </row>

      <row>
       <entry><type>box</type></entry>
       <entry></entry>
       <entry>Boîte rectangulaire dans le plan</entry>
      </row>

      <row>
       <entry><type>bytea</type></entry>
       <entry></entry>
       <entry>Donnée binaire (<quote>tableau d'octets</>)</entry>
      </row>

      <row>
       <entry><type>character varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varchar [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>Suite de caractères de longueur variable</entry>
      </row>

      <row>
       <entry><type>character [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>char [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>Suite de caractères de longueur fixe</entry>
      </row>

      <row>
       <entry><type>cidr</type></entry>
       <entry></entry>
       <entry>Adresse réseau IPv4 ou IPv6 </entry>
      </row>

      <row>
       <entry><type>circle</type></entry>
       <entry></entry>
       <entry>Cercle dans le plan</entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry></entry>
       <entry>Date du calendrier (année, mois, jour)</entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
       <entry>Nombre à virgule flottante de double précision</entry>
      </row>

      <row>
       <entry><type>inet</type></entry>
       <entry></entry>
       <entry>Adresse d'ordinateur IPv4 ou IPv6</entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
       <entry>Entier signé sur 4 octets</entry>
      </row>

      <row>
       <entry><type>interval [ (<replaceable>p</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>Intervalle de temps</entry>
      </row>

      <row>
       <entry><type>line</type></entry>
       <entry></entry>
       <entry>Ligne infinie dans le plan</entry>
      </row>

      <row>
       <entry><type>lseg</type></entry>
       <entry></entry>
       <entry>Segment de droite dans le plan</entry>
      </row>

      <row>
       <entry><type>macaddr</type></entry>
       <entry></entry>
       <entry>adresse MAC</entry>
      </row>

      <row>
       <entry><type>money</type></entry>
       <entry></entry>
       <entry>montant d'une devise</entry>
      </row>

      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry>Nombre exact de la précision indiquée</entry>
      </row>

      <row>
       <entry><type>path</type></entry>
       <entry></entry>
       <entry>Chemin géométrique dans le plan</entry>
      </row>

      <row>
       <entry><type>point</type></entry>
       <entry></entry>
       <entry>Point géométrique dans le plan</entry>
      </row>

      <row>
       <entry><type>polygon</type></entry>
       <entry></entry>
       <entry>Chemin géométrique fermé dans le plan</entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
       <entry>Nombre à virgule flottante de simple précision</entry>
      </row>

      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
       <entry>Entier signé sur 2 octets</entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
       <entry>Entier sur 4 octets à incrémentation automatique</entry>
      </row>

      <row>
       <entry><type>text</type></entry>
       <entry></entry>
       <entry>Chaîne de caractères de longueur variable</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>Heure du jour</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
       <entry>Heure du jour, avec fuseau horaire</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>Date et heure</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) with time zone</type></entry>
       <entry><type>timestamptz</type></entry>
       <entry>Date et heure, avec fuseau horaire</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <title>Compatibilité</title>
   <para>
    Les types suivants sont conformes à la norme <acronym>SQL</acronym>:
    <type>bit</type>, <type>bit varying</type>, <type>boolean</type>, 
    <type>char</type>,
    <type>character varying</type>, <type>character</type>,
    <type>varchar</type>, <type>date</type>, <type>double
    precision</type>, <type>integer</type>, <type>interval</type>,
    <type>numeric</type>, <type>decimal</type>, <type>real</type>,
    <type>smallint</type>, <type>time</type> (avec et sans fuseau horaire),
    <type>timestamp</type> (avec et sans fuseau horaire).
   </para>
  </note>

  <para>
   Chaque type de données a une représentation externe déterminée par
   ses fonctions d'entrée et de sortie. De nombreux types de données
   internes ont un format externe évident. Cependant, certains types
   soit sont spécifiques à <productname>PostgreSQL</productname>,
   comme les chemins géométriques, soit ont différents formats 
   possibles, comme les types de données de date et d'heure.
   Certaines fonctions d'entrée et de sortie ne sont pas inversables:
   Le résultat de la fonction de sortie peut manquer de précision
   comparé à l'entrée initiale.
  </para>

  <sect1 id="datatype-numeric">
   <title>Types numériques</title>

   <indexterm zone="datatype-numeric">
    <primary>Type de données</primary>
    <secondary>numeric</secondary>
   </indexterm>

   <para>
    Les types numériques sont constitués d'entiers de 2, 4 ou 8 octets,
    de nombres à virgule flottante de 4 ou 8 octets, et de décimaux à
    précision sélectionnable. Le <xref linkend="datatype-numeric-table">
    précise les types disponibles.
   </para>

    <table id="datatype-numeric-table">
     <title>Types numériques</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
        <entry>Étendue</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>smallint</></entry>
        <entry>2 octets</entry>
        <entry>entier de faible étendue</entry>
        <entry>de -32768 à +32767</entry>
       </row>
       <row>
       <entry><type>integer</></entry>
        <entry>4 octets</entry>
        <entry>entiers les plus courants</entry>
        <entry>de -2147483648 à +2147483647</entry>
       </row>
       <row>
        <entry><type>bigint</></entry>
        <entry>8 octets</entry>
        <entry>grands entiers</entry>
        <entry>de -9223372036854775808 à 9223372036854775807</entry>
       </row>

       <row>
        <entry><type>decimal</></entry>
        <entry>variable</entry>
        <entry>précision indiquée par l'utilisateur, valeurs exactes</entry>
        <entry>pas de limite</entry>
       </row>
       <row>
        <entry><type>numeric</></entry>
        <entry>variable</entry>
        <entry>précision indiquée par l'utilisateur, valeurs exactes</entry>
        <entry>pas de limite</entry>
       </row>

       <row>
        <entry><type>real</></entry>
        <entry>4 octets</entry>
        <entry>précision variable, valeurs inexactes</entry>
        <entry>précision de 6 décimales</entry>
       </row>
       <row>
        <entry><type>double precision</></entry>
        <entry>8 octets</entry>
        <entry>précision variable, valeurs inexactes</entry>
        <entry>précision de 15 décimales</entry>
       </row>

       <row>
        <entry><type>serial</></entry>
        <entry>4 octets</entry>
        <entry>entier à incrémentation automatique</entry>
        <entry>de 1 à 2147483647</entry>
       </row>

       <row>
        <entry><type>bigserial</type></entry>
        <entry>8 octets</entry>
        <entry>entier de grande taille à incrémentation automatique</entry>
        <entry>de 1 à 9223372036854775807</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    La syntaxe des constantes pour les types numériques est décrite
    dans la <xref linkend="sql-syntax-constants">. Les types numériques
    ont un ensemble complet d'opérateurs arithmétiques et de fonctions.
    Référez-vous au <xref linkend="functions"> pour plus d'informations.
    Les sections suivantes décrivent ces types en détail.
   </para>

   <sect2 id="datatype-int">
    <title>Types entiers</title>

    <indexterm zone="datatype-int">
     <primary>integer</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>smallint</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>bigint</primary>
    </indexterm>

    <indexterm>
     <primary>int4</primary>
     <see>integer</see>
    </indexterm>

    <indexterm>
     <primary>int2</primary>
     <see>smallint</see>
    </indexterm>

    <indexterm>
     <primary>int8</primary>
     <see>bigint</see>
    </indexterm>

    <para>
     Les types <type>smallint</type>, <type>integer</type> et
     <type>bigint</type> stockent des nombres entiers, c'est-à-dire
     sans décimale, de différentes étendues.
     Toute tentative d'y stocker une valeur en dehors de l'échelle
     produit une erreur.
    </para>

    <para>
     Le type <type>integer</type> est le plus courant. Il offre un
     bon compromis entre capacité, espace utilisé et performance.
     Le type <type>smallint</type> n'est utilisé que si l'économie
     d'espace disque est le premier critère de choix.
     Le type <type>bigint</type> ne doit être utilisé que si le 
     type <type>integer</type> n'offre pas une étendue suffisante
     car le type <type>integer</type> est nettement plus rapide.
    </para>

    <para>
     Le type <type>bigint</type> peut ne pas fonctionner correctement
     sur toutes les plates-formes, car il repose sur la capacité du
     compilateur à supporter les entiers de 8 octets.
     Sur une machine qui ne les supporte pas, <type>bigint</type> se
     comporte comme <type>integer</type> (mais prend bien huit octets
     d'espace de stockage). Ceci dit, nous ne connaissons pas de
     plate-forme raisonnable sur laquelle il en va ainsi.
    </para>

    <para>
     <acronym>SQL</acronym> ne spécifie que les types de données
     <type>integer</type> (ou <type>int</type>) et
     <type>smallint</type>.  Le type <type>bigint</type> et les noms
     de types <type>int2</type>, <type>int4</type>, et
     <type>int8</type> sont des extensions, qui sont partagées avec
     d'autres systèmes de bases de données <acronym>SQL</acronym>.
    </para>

   </sect2>

   <sect2 id="datatype-numeric-decimal">
    <title>Nombres à précision arbitraire</title>

    <indexterm zone="datatype-numeric-decimal">
     <primary>numeric (data type)</primary>
    </indexterm>

    <indexterm>
     <primary>decimal</primary>
     <see>numeric</see>
    </indexterm>

    <para>
     Le type <type>numeric</type> peut stocker des nombres avec 
     jusqu'à 1000 chiffres significatifs et effectuer des calculs
     exacts. Il est spécialement recommandé pour stocker les montants
     financiers et autres quantités pour lesquelles l'exactitude est 
     indispensable. Néanmoins, l'arithmétique sur les valeurs
     <type>numeric</type> est très lent comparé aux types entiers ou aux
     types à virgule flottante décrits dans la section suivante.
    </para>

    <para>
     Dans ce qui suit, on utilise les termes suivants&nbsp;:
     l'<firstterm>échelle</firstterm> d'un <type>numeric</type> est le
     nombre de chiffres décimaux de la partie fractionnaire. La 
     <firstterm>précision</firstterm> d'un <type>numeric</type> est le
     nombre total de chiffres significatifs dans le nombre entier, 
     c'est-à-dire avant et après la virgule. Donc, le nombre 23,5141
     a une précision de 6 et une échelle de 4. On peut considérer que 
     les entiers ont une échelle de 0.
   </para>

    <para>
     La précision maximum et l'échelle maximum d'une colonne <type>numeric</type>
     peuvent être réglés.
     Pour déclarer une colonne de type numérique, il faut utiliser la
     syntaxe&nbsp;:
<programlisting>
NUMERIC(<replaceable>précision</replaceable>, <replaceable>échelle</replaceable>)
</programlisting>
     La précision pour être strictement positive, l'échelle positive
     ou NULL.
     Alternativement, 
<programlisting>
NUMERIC(<replaceable>précision</replaceable>)
</programlisting>
     indique une échelle de 0.  Préciser
<programlisting>
NUMERIC
</programlisting>
     sans précision ni échelle crée une colonne dans laquelle on
     peut stocker des valeurs de n'importe quelle précision ou
     échelle, jusqu'à la limite de précision. Une colonne de ce type
     ne forcera aucune valeur entrée à une précision particulière,
     alors que les colonnes <type>numeric</type> avec une échelle 
     forcent les valeurs entrées à cette échelle. (Le standard 
     <acronym>SQL</acronym> demande une précision par défaut de 0, 
     c'est-à-dire de forcer la transformation en entiers. Nous
     trouvons ça inutile. Si vous êtes soucieux de portabilité, 
     précisez toujours la précision et l'échelle explicitement.)
    </para>

    <para>
     Si l'échelle d'une valeur est supérieure à l'échelle d'une colonne, le
     système tentera d'arrondir la valeur au nombre de chiffres après la
     virgule spécifiée.  Ensuite, si le nombre de chiffres à gauche du point
     décimal dépasse la précision déclarée moins l'échelle déclarée, une
     erreur est levée.
    </para>

    <para>
     Les valeurs numériques sont stockées physiquement sans zéro avant ou
     après. Du coup, la précision déclarée et l'échelle de la colonne sont
     des valeurs maximums, pas des allocations fixes (en ce sens, le type
     numérique est plus proche de <type>varchar(<replaceable>n</>)</type> que
     de <type>char(<replaceable>n</>)</type>). Le besoin pour le stockage actuel
     est de deux octets pour chaque groupe de quatre chiffres décimaux, plus
     huit octets d'en-tête.
    </para>

    <para>
	 En plus des valeurs numériques ordinaires, le type <type>numeric</type>
	 autorise la valeur spéciale <literal>NaN</>, signifiant   
	 <quote>not-a-number</quote> (NdT&nbsp;: pas un nombre). Toute opération
	 sur <literal>NaN</> renvoie un autre <literal>NaN</>. En écrivant cette
	 valeur comme une constante dans une requête SQL, vous devez placer des
	 guillemets autour. Par exemple, <literal>UPDATE table SET x =  
	 'NaN'</>. En saisie, la chaîne <literal>NaN</> est reconnue quelque soit
	 la casse utilisée.
    </para>

    <para>
     Les types <type>decimal</type> et <type>numeric</type> sont 
     équivalents. Les deux types sont dans le standard 
     <acronym>SQL</acronym>.
    </para>
   </sect2>


   <sect2 id="datatype-float">
    <title>Types à virgule flottante</title>

    <indexterm zone="datatype-float">
     <primary>real</primary>
    </indexterm>

    <indexterm zone="datatype-float">
     <primary>double precision</primary>
    </indexterm>

    <indexterm>
     <primary>float4</primary>
     <see>real</see>
    </indexterm>

    <indexterm>
     <primary>float8</primary>
     <see>double precision</see>
    </indexterm>

    <indexterm zone="datatype-float">
     <primary>floating point</primary>
    </indexterm>

    <para>
     Les types de données <type>real</type> et <type>double
     precision</type> sont des types numériques à précision variable
     inexacts. En pratique, ils sont généralement conformes à la norme
     <acronym>IEEE</acronym> 754 pour l'arithmétique binaire à 
     virgule flottante (respectivement simple et double précision), 
     dans la mesure où les processeurs, le système d'exploitation et
     le compilateur les supportent.
    </para>

    <para>
     Inexact signifie que certaines valeurs ne peuvent être converties
     exactement dans le format interne, et sont stockées sous forme
     d'approximations, si bien que stocker puis réafficher ces valeurs
     peut faire apparaître de légers écarts.
     Prendre en compte ces erreurs et la façon dont elles se propagent
     au cours des calculs est le sujet d'une branche entière des
     mathématiques et de l'informatique. Nous n'en dirons pas plus que 
     ce qui suit:
     <itemizedlist>
      <listitem>
       <para>
        Si vous avez besoin d'un stockage et de calculs exacts, comme
        pour les valeurs monétaires, utilisez plutôt le type
        <type>numeric</type>.
      </para>
      </listitem>

      <listitem>
       <para>
        Si vous voulez faire des calculs compliqués avec ces types 
        pour quoi que ce soit d'important, et particulièrement si
        vous comptez sur certains comportements aux limites (infinis, 
        zéro), alors vous devriez étudier le comportement de votre
        plate-forme avec soin.
       </para>
      </listitem>

      <listitem>
       <para>
        Tester l'égalité de deux valeurs à virgule flottante peux ne
        pas donner le résultat attendu.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Sur la plupart des plates-formes, le type <type>real</type> a une
     étendue d'au moins 1E-37 à 1E37 avec une précision d'au moins
     6 chiffres décimaux. Le type <type>double precision</type> a
     généralement une étendue de 1E-307 à 1E+308 avec une précision
     d'au moins 15 chiffres. Les valeurs trop grandes ou trop petites 
     produisent une erreur. Un arrondi peut avoir lieu si la précision
     d'un nombre en entrée est trop grande. Les nombres trop proches
     de zéro qui ne peuvent être représentés autrement que par zéro
     produisent une erreur (underflow).
    </para>

    <para>
	 En plus des valeurs numériques ordinaires, les types à virgule flottante
	 ont plusieurs valeurs spéciales&nbsp;:
     <literallayout>
       <literal>Infinity</literal>
       <literal>-Infinity</literal>
       <literal>NaN</literal>
     </literallayout>
	 Elles représentent les valeurs spéciales de l'IEEE 754,
	 respectivement <quote>infinity</quote> (NdT&nbsp;: infini),
	 <quote>negative infinity</quote> (NdT&nbsp;: infini négatif) et
	 <quote>not-a-number</quote> (NdT&nbsp;: pas un nombre) (sur une machine
	 dont l'arithmétique à virgule flottante ne suit pas l'IEEE 754, ces
	 valeurs ne fonctionneront probablement pas comme c'est attendu). Lors
	 de la saisie de ces valeurs en tant que constantes dans une commande SQL,
	 vous devez placer des guillemets autour. Par exemple, <literal>UPDATE
	 table SET x = 'Infinity'</>. En entrée, ces valeurs sont reconnues
	 quelque soit la casse utilisée.
    </para>

    <para>
     <productname>PostgreSQL</productname> autorise aussi la notation
     <type>float</type> du standard SQL, ainsi que 
     <type>float(<replaceable>p</replaceable>)</type> pour indiquer
     des types numériques inexacts. Ici, <replaceable>p</replaceable>
     indique la précision minimale acceptable en chiffres binaires.
     <productname>PostgreSQL</productname> accepte
     <type>float(1)</type> à <type>float(24)</type>, transformés en
     type <type>real</type>, et
     <type>float(25)</type> à <type>float(53)</type>, transformés en
     type <type>double precision</type>. Toute valeur de 
     <replaceable>p</replaceable> hors de la zone des valeurs possibles
     produit une erreur. <type>float</type> sans précision est compris
     comme <type>double precision</type>.
    </para>

    <note>
     <para>
      Avant <productname>PostgreSQL</productname> 7.4, la précision
      d'un <type>float(<replaceable>p</replaceable>)</type> était
      supposée indiquer une précision en chiffres décimaux.
      Nous l'avons corrigée pour respecter le standard SQL, qui
      indique que la précision est indiquée en chiffres binaires.
      L'affirmation que les <type>real</type> et les
      <type>double precision</type> ont exactement 24 et 53 bits
      dans la mantisse est correcte pour les implémentations des
      nombres à virgule flottante respectant le standard IEEE.
      Sur les plates-formes non-IEEE, c'est peut-être un peu sous-estimé
      mais, pour plus de simplicité, la gamme de valeurs pour
      <replaceable>p</replaceable> est utilisée sur toutes les
      plates-formes.
     </para>
    </note>

   </sect2>

   <sect2 id="datatype-serial">
    <title>Types serial</title>

    <indexterm zone="datatype-serial">
     <primary>serial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>bigserial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial4</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial8</primary>
    </indexterm>

    <indexterm>
     <primary>auto-increment</primary>
     <see>serial</see>
    </indexterm>

    <indexterm>
     <primary>séquence</primary>
     <secondary>type serial</secondary>
    </indexterm>

    <para>
     Les types de données <type>serial</type> et <type>bigserial</type>
     ne sont pas de vrais types, mais plutôt un raccourci de notation
     pour décrire des colonnes d'identifiants uniques (similaires à la
     propriété <literal>AUTO_INCREMENT</literal> utilisée par d'autres
     SGBD). Dans la version actuelle, indiquer 

<programlisting>
CREATE TABLE <replaceable class="parameter">nom_de_table</replaceable> (
    <replaceable class="parameter">nom_de_colonne</replaceable> SERIAL
);
</programlisting>

     est équivalent à écrire :

<programlisting>
CREATE SEQUENCE <replaceable class="parameter">nom_de_table</replaceable>_<replaceable class="parameter">nom_de_colonne</replaceable>_seq;
CREATE TABLE <replaceable class="parameter">nom_de_table</replaceable> (
    <replaceable class="parameter">nom_de_colonne</replaceable> integer DEFAULT nextval('<replaceable class="parameter">nom_de_table</replaceable>_<replaceable class="parameter">nom_de_colonne</replaceable>_seq') NOT NULL
);
</programlisting>

     Ainsi, nous avons créé une colonne d'entiers et fait en sorte
     que ses valeurs par défaut soient affectées par un générateur de
     séquence. Une contrainte <literal>NOT NULL</literal> est ajoutée pour
     s'assurer qu'une valeur NULL ne puisse pas être explicitement 
     insérée. Dans la plupart des cas, vous voudrez aussi ajouter une 
     contrainte <literal>UNIQUE</literal> ou <literal>PRIMARY KEY</literal> pour
     interdire que des doublons soient créés par accident, mais ce
     n'est pas automatique.
    </para>

    <note>
     <para>
      Avant <productname>PostgreSQL</productname> 7.3, 
      <type>serial</type> sous-entendait <literal>UNIQUE</literal>.
      Ce n'est plus automatique. Si vous souhaitez qu'une colonne
      serial soit unique ou soit une clé primaire, il faut le préciser,
      comme pour les autres types.
     </para>
    </note>

    <para>
     Pour insérer la valeur suivante de la séquence dans la colonne
     <type>serial</type>, il faut faire en sorte d'utiliser la valeur par
     défaut de la colonne. Cela peut se faire de deux façons&nbsp;: soit en
     excluant cette colonne de la liste des colonnes de la commande 
     <command>INSERT</command> soit en utilisant le mot clé
     <literal>DEFAULT</literal>.
    </para>

    <para>
     Les types <type>serial</type> et <type>serial4</type> sont
     identiques&nbsp;: ils créent tous les deux des colonnes 
     <type>integer</type>. Les types <type>bigserial</type> et 
     <type>serial8</type> fonctionnent de la même façon et créent des
     colonnes <type>bigint</type>. <type>bigserial</type> doit
     être utilisé si vous pensez utiliser plus de 2<superscript>31</superscript>
     identifiants dans toute la vie de la table.
    </para>

    <para>
     La séquence créée pour une colonne <type>serial</type> est 
     automatiquement supprimée quand la colonne correspondante est
     supprimée, et ne peut l'être autrement (ce n'était
     pas le cas avant la version 7.3 de 
     <productname>PostgreSQL</productname>. Notez que ce lien de
     suppression automatique de séquence ne fonctionnera pas pour
     une base restaurée d'une sauvegarde SQL (dump) antérieure à la 
     version 7.3. La sauvegarde ne contient en effet pas l'information
     nécessaire à l'établissement du lien de dépendance).
     De plus, ce lien de dépendance n'est mis que pour la colonne de
     type <type>serial</> elle-même. Si d'autres colonnes référencent
     la séquence (par exemple en appelant la fonction 
     <function>nextval</>), elles ne peuvent plus fonctionner si la 
     séquence est supprimée.
     Utiliser le type <type>serial</> de cette façon n'est pas recommandé.
     Si vous souhaitez remplir plusieurs colonnes avec le même générateur de 
     séquence, créez la séquence indépendamment.
    </para>
   </sect2>
  </sect1>

  <sect1 id="datatype-money">
   <title>Types monétaires</title>

   <note>
    <para>
     Le type <type>money</type> est obsolète. Utilisez plutôt les  
     types <type>numeric</type> ou <type>decimal</type>, en 
     combinaison avec la fonction <function>to_char</function>.
    </para>
   </note>

   <para>
    Le type <type>money</type> stocke un montant d'une devise avec
    un nombre fixe de chiffres après la virgule. Voir le <xref
    linkend="datatype-money-table">.
    De nombreux formats sont acceptés en entrée, dont les entiers et
    les nombre à virgule flottante ainsi que les formats classiques
    de devises, comme <literal>'$1,000.00'</literal>. 
    Le format de sortie est généralement ce dernier, mais dépend de la
    localisation.
   </para>

    <table id="datatype-money-table">
     <title>Types monétaires</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
        <entry>Étendue</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>money</entry>
        <entry>4 octets</entry>
        <entry>montant monétaire</entry>
        <entry>-21474836.48 à +21474836.47</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  </sect1>


  <sect1 id="datatype-character">
   <title>Types caractères</title>

   <indexterm zone="datatype-character">
    <primary>Chaîne de caractères</primary>
    <secondary>types de données</secondary>
   </indexterm>

   <indexterm>
    <primary>Chaîne</primary>
    <see>Chaîne de caractères</see>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>character</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>character varying</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>text</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>char</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>varchar</primary>
   </indexterm>

    <table id="datatype-character-table">
     <title>Types caractères</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>character varying(<replaceable>n</>)</type>, <type>varchar(<replaceable>n</>)</type></entry>
        <entry>Longueur variable avec limite</entry>
       </row>
       <row>
        <entry><type>character(<replaceable>n</>)</type>, <type>char(<replaceable>n</>)</type></entry>
        <entry>longueur fixe, comblé avec des espaces</entry>
       </row>
       <row>
        <entry><type>text</type></entry>
        <entry>longueur variable illimitée</entry>
       </row>
     </tbody>
     </tgroup>
    </table>

   <para>
    Le <xref linkend="datatype-character-table"> montre les types
    génériques disponibles dans <productname>PostgreSQL</productname>.
   </para>

   <para>
    <acronym>SQL</acronym> définit deux types de caractères principaux&nbsp;:
    <type>character varying(<replaceable>n</>)</type> et
    <type>character(<replaceable>n</>)</type> où <replaceable>n</>
    est un entier positif.
    Ces deux types peuvent stocker des chaînes de caractères de taille
    inférieure ou égale à <replaceable>n</replaceable>. Une tentative d'insérer
    une chaîne trop longue donnera une erreur, à moins que les 
    caractères en trop soient tous des espaces, auquel cas la chaîne 
    sera tronquée à la taille maximale (cette exception étrange est imposée
    par la norme <acronym>SQL</acronym>).
    Si la chaîne à stocker est plus petite que la taille déclarée,
    elle sera complétée par des espaces pour le type 
    <type>character</type>, et elle sera stockée telle quelle pour le 
    type <type>character varying</type>.
   </para>

    <para>
     Si vous convertissez explicitement une valeur en 
     <type>character varying(<replaceable>n</replaceable>)</type> ou en
     <type>character(<replaceable>n</replaceable>)</type>, alors une chaîne trop
     longue sera tronquée à <replaceable>n</replaceable> caractères sans que
     cela génère d'erreur (ce comportement est aussi imposé par
     la norme <acronym>SQL</acronym>.)
    </para>

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 7.2, les chaînes trop longues
     étaient toujours tronquées sans générer d'erreur, que ce soit
     par une transformation explicite ou implicite.
    </para>
   </note>

   <para>
    Les notations <type>varchar(<replaceable>n</replaceable>)</type> et
    <type>char(<replaceable>n</replaceable>)</type> sont des alias pour
    <type>character varying(<replaceable>n</replaceable>)</type> et
    <type>character(<replaceable>n</replaceable>)</type>, respectivement.
    <type>character</type> sans indication de taille est équivalent à
    <type>character(1)</type>. Si <type>character varying</type> est
    utilisé sans indicateur de taille, le type accepte des chaînes de
    toutes tailles. Il s'agit là d'une spécificité de 
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    De plus, <productname>PostgreSQL</productname> propose aussi le type
    <type>text</type>, qui permet de stocker des chaînes de n'importe
    quelle taille. Bien que le type <type>text</type> ne soit pas
    dans le standard <acronym>SQL</acronym>, plusieurs autres systèmes de
    gestion de bases de données SQL le proposent aussi.
   </para>

   <para>
    Les valeurs de type <type>character</type> sont physiquement alignées avec
    des espaces pour la longueur <replaceable>n</> spécifiée, et sont
    stockées et affichées de cette façon. Néanmoins, les espaces d'alignement
    sont traités sémantiquement sans signification. Les espaces en fin ne sont
    pas utilisés lors de la comparaison de deux valeurs de type
    <type>character</type>, et ils seront supprimés lors de la conversion
    d'une valeur <type>character</type> en un des types chaîne. Notez que les
    espaces en fin <emphasis>ont</> sémantiquement une signification pour
    les valeurs de type <type>character varying</type> et <type>text</type>.
   </para>

   <para>
    L'espace de stockage utilisé pour les données de ces types est
    de quatre octets en plus de la taille de la chaîne, plus le remplissage
    dans le cas du type <type>character</type>.
    Les grandes chaînes sont automatiquement compressées par le 
    système, si bien que l'espace effectivement utilisé peut être
    inférieur. Les grandes chaînes sont aussi stockées dans des tables
    d'arrière plan, afin de ne pas ralentir l'accès aux autres
    colonnes plus petites.
    Dans tous les cas, la taille maximale possible pour une chaîne de 
    caractères est de l'ordre 1 Go. La taille maximale pour 
    <replaceable>n</replaceable> dans la déclaration de type est plus petite
    que cela. Il ne serait pas très utile de le changer parce qu'avec 
    l'encodage des caractères sur plusieurs octets, les nombres de caractères
    et d'octets peuvent être très différents. Si vous voulez stocker
    de longues chaînes sans limite de taille spécifique, utilisez le type 
    <type>text</type> ou le type <type>character varying</type> sans indiquer
    de taille, plutôt que d'indiquer une limite de taille arbitraire.
   </para>

   <tip>
    <para>
     Il n'y a pas de différence de performance entre ces trois types,
     à part la place disque supplémentaire pour le type qui remplit les
     vides avec des espaces. Bien que
     <type>character(<replaceable>n</>)</type> a des avantages en terme de
     performance dans certains autres systèmes de bases de données, il ne
     dispose pas de ce type d'avantages dans 
     <productname>PostgreSQL</productname>. Dans la plupart des situations,
     les types <type>text</type> ou <type>character varying</type> devraient
     être utilisés à leur place.
    </para>
   </tip>

   <para>
    Voir la <xref linkend="sql-syntax-strings"> pour avoir plus d'informations
    sur la syntaxe des littéraux de chaînes, et le <xref linkend="functions">
    pour avoir des informations sur les opérateurs et les fonctions.
    L'ensemble de caractères de la base de données détermine l'ensemble de
    caractères utilisé pour stocker les valeurs texte&nbsp;; pour plus
    d'informations sur le support des ensembles de caractères, référez-vous à
    la <xref linkend="multibyte">.
   </para>

   <example>
    <title>Utilisation des types caractères</title>

<programlisting>
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- <co id="co.datatype-char">
<computeroutput>
  a   | char_length
------+-------------
 ok   |           2
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('bien      ');
INSERT INTO test2 VALUES ('trop long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('trop long'::varchar(5)); -- troncature explicite
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-------+-------------
 ok    |           2
 bien  |           5
 trop  |           5
</computeroutput>
</programlisting>
    <calloutlist>
     <callout arearefs="co.datatype-char">
      <para>
       La fonction <function>char_length</function> est décrite dans
       la <xref linkend="functions-string">.
      </para>
     </callout>
    </calloutlist>
   </example>

   <para>
    Il y a deux autres types caractères de taille constante dans
    <productname>PostgreSQL</productname>, décrits dans le <xref
    linkend="datatype-character-special-table">. Le type <type>name</type>
    existe <emphasis>seulement</emphasis> pour le stockage des identifiants
    dans les catalogues systèmes et n'est pas destiné à être utilisé par
    les utilisateurs normaux. Sa taille est actuellement définie à 64 octets 
    (63 utilisables plus le terminateur) mais doit être référencée en
    utilisant la constante <symbol>NAMEDATALEN</symbol>. La taille est
    définie à la compilation (et est donc ajustable pour des besoins 
    particuliers). La taille maximale par défaut pourrait changer dans une
    prochaine version. Le type <type>"char"</type> (notez les guillemets)
    est différent de <type>char(1)</type> car il n'utilise qu'un seul octet 
    de stockage. Il est utilisé dans les catalogues systèmes comme un type 
    d'énumération économique.
   </para>

    <table id="datatype-character-special-table">
     <title>Types caractères spéciaux</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>"char"</type></entry>
        <entry>1 octet</entry>
        <entry>type interne de 1 caractère</entry>
       </row>
       <row>
        <entry><type>name</type></entry>
        <entry>64 octets</entry>
        <entry>type interne pour les noms d'objets</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>

 <sect1 id="datatype-binary">
  <title>Types de données binaires</title>

  <indexterm zone="datatype-binary">
   <primary>binary data</primary>
  </indexterm>

  <indexterm zone="datatype-binary">
   <primary>bytea</primary>
  </indexterm>
   <para>
    Le type de données <type>bytea</type> permet de stocker des chaînes
    binaires&nbsp;; voir le <xref linkend="datatype-binary-table">.
   </para>

   <table id="datatype-binary-table">
    <title>Types de données binaires</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Espace de stockage</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>bytea</type></entry>
       <entry>4 octets plus la taille de la chaîne binaire à stocker</entry>
       <entry>Chaîne binaire de longueur variable</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Une chaîne binaire est une séquence d'octets. Les chaînes binaires
    se distinguent des chaînes de caractères par deux caractéristiques&nbsp;:
    tout d'abord, les chaînes binaires permettent de stocker des octets de
    valeurs zéro ainsi que les autres caractères <quote>non imprimables</quote>
    (habituellement définis comme des octets en dehors de l'échelle de 32 à
    126). Les chaînes de caractères interdisent les octets de valeur zéro et
    interdisent aussi toute valeur d'octet et séquence d'octets invalide
    suivant le codage de l'ensemble de caractères sélectionné pour la base
    de données. Ensuite, les opérations sur les chaînes binaires traitent
    réellement les octets alors que le traitement de chaînes de caractères
    dépend de la configuration de la locale. En bref, les chaînes binaires
    sont appropriées pour le stockage de données que le développeur considère
    comme des <quote>octets bruts</> alors que les chaînes de caractères sont
    appropriées pour stocker du texte.
   </para>

   <para>
    Lors de la saisie de valeurs de type <type>bytea</type>, certaines valeurs
    d'octets <emphasis>doivent</emphasis> être préparées avec des caractères 
    d'échappement (mais toutes les valeurs <emphasis>peuvent</emphasis> 
    l'être) lorsqu'elles font partie d'une chaîne littérale dans une
    commande <acronym>SQL</acronym>. En général, pour échapper un octet,
    il faut le convertir en nombre octal sur 3 caractères, précédés par deux
    antislashs. Le <xref linkend="datatype-binary-sqlesc"> affiche les
    caractères qui doivent être échappés, et donne les séquences 
    d'échappement possibles.
   </para>

   <table id="datatype-binary-sqlesc">
    <title><type>bytea</> Octets littéraux à échapper</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Valeur décimale de l'octet</entry>
       <entry>Description</entry>
       <entry>Représentation échappée en entrée</entry>
       <entry>Exemple</entry>
       <entry>Représentation en sortie</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>0</entry>
       <entry>octet zéro</entry>
       <entry><literal>'\\000'</literal></entry>
       <entry><literal>SELECT '\\000'::bytea;</literal></entry>
       <entry><literal>\000</literal></entry>
      </row>

      <row>
       <entry>39</entry>
       <entry>apostrophe</entry>
       <entry><literal>'\''</literal> ou <literal>'\\047'</literal></entry>
       <entry><literal>SELECT '\''::bytea;</literal></entry>
       <entry><literal>'</literal></entry>
      </row>

      <row>
       <entry>92</entry>
       <entry>antislash</entry>
       <entry><literal>'\\\\'</literal> ou <literal>'\\134'</literal></entry>
       <entry><literal>SELECT '\\\\'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>de 0 à 31 et de 127 à 255</entry>
       <entry>octets <quote>non affichables</quote></entry>
       <entry><literal>'\\<replaceable>xxx'</></literal> (valeur octal)</entry>
       <entry><literal>SELECT '\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    La nécessité d'échapper les octets <quote>non affichables</quote> varie en
    fait suivant les paramétrages de la locale. Quelque fois, vous pouvez
    vous en sortir sans les échapper. Notez que le résultat de chacun des
    exemples du <xref linkend="datatype-binary-sqlesc"> était d'une longueur
    exacte d'un octet, même si la représentation en sortie de l'octet zéro et
    de l'antislash font plus d'un caractère.
   </para>

   <para>
    La raison pour laquelle il faut écrire autant d'antislashs, comme
    indiqué dans le <xref linkend="datatype-binary-sqlesc">, est qu'une
    chaîne binaire doit passer à travers deux phases d'analyse dans le
    serveur <productname>PostgreSQL</productname>. Le premier antislash
    de chaque paire est vu comme un caractère d'échappement par
    l'analyseur de chaîne et est donc consommé,
    laissant le second antislash de la paire. L'antislash restant est
    compris par la fonction d'entrée de <productname>PostgreSQL</productname>
    comme le début d'une valeur octale sur trois caractères ou comme
    l'échappement d'un autre antislash.
    Par exemple, un littéral chaîne passé au serveur comme
    <literal>'\\001'</literal> devient <literal>\001</literal> après
    être passé au travers de l'analyseur de littéral chaîne.
    Le <literal>\001</literal> est envoyé à la fonction d'entrée de
    <type>bytea</type>, qui le convertit en un octet simple ayant une valeur
    décimale de 1. Notez que le caractère apostrophe n'est pas traité
    spécialement par <type>bytea</type> et suit les règles normales
    pour les littéraux de chaîne. Voir aussi la <xref linkend="sql-syntax-strings">.
   </para>

   <para>
   Les octets de <type>bytea</type> sont aussi échappés en sortie. En général,
   chaque octet <quote>non-imprimable</quote> est converti en équivalent
   octal sur trois caractères et précédé d'un antislash.
   La plupart des caractères <quote>imprimables</quote> sont représentés 
   par leur représentation standard dans le jeu de caractère du client.
   Les octets de valeur décimale 92 (antislash) ont une autre représentation
   spéciale. Les détails sont dans le
   <xref linkend="datatype-binary-resesc">.
   </para>

   <table id="datatype-binary-resesc">
    <title>Octets échappés en sortie pour <type>bytea</></title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Valeur décimale de l'octet</entry>
       <entry>Description</entry>
       <entry>Représentation en sortie échappée</entry>
       <entry>Exemple</entry>
       <entry>Résultat en sortie</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry>92</entry>
       <entry>antislash</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>SELECT '\\134'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>0 à 31 et 127 à 255</entry>
       <entry>octets<quote>non affichables</quote></entry>
       <entry><literal>\<replaceable>xxx</></literal> (valeur octale)</entry>
       <entry><literal>SELECT '\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

      <row>
       <entry>32 à 126</entry>
       <entry>octets <quote>affichables</quote></entry>
       <entry>Représentation de l'ensemble de caractères du client</entry>
       <entry><literal>SELECT '\\176'::bytea;</literal></entry>
       <entry><literal>~</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    En fonction du client que vous utilisez pour accéder à
    <productname>PostgreSQL</>, vous pouvez avoir un travail d'échappement
    supplémentaire à effectuer pour échapper et déséchapper les
    chaînes <type>bytea</type>. Par exemple, il se peut que vous deviez 
    échapper les sauts de lignes et retours à la ligne si votre programme
    client les traduit automatiquement.
   </para>

   <para>
    Le standard <acronym>SQL</acronym> définit un type binaire différent,
    appelé <type>BLOB</type> ou <type>BINARY LARGE OBJECT</type>.
    Le format d'entrée est différent de celui du <type>bytea</type> mais les
    fonctions et opérateurs fournis sont globalement les mêmes.
   </para>
 </sect1>


  <sect1 id="datatype-datetime">
   <title>Types date/heure</title>

   <indexterm zone="datatype-datetime">
    <primary>date</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time without time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time with time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp with time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp without time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>interval</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time span</primary>
   </indexterm>
   <para>
    <productname>PostgreSQL</productname> supporte l'ensemble des types date
    et heure de <acronym>SQL</acronym> montrés dans le <xref
    linkend="datatype-datetime-table">. Les opérations disponibles sur ces
    types de données sont décrit dans la <xref linkend="functions-datetime">.
   </para>

    <table id="datatype-datetime-table">
     <title>Types date et heure</title>
     <tgroup cols="6">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
        <entry>Valeur minimale</entry>
        <entry>Valeur maximale</entry>
        <entry>Résolution</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 octets</entry>
        <entry>date et heure</entry>
        <entry>4713 avant JC</entry>
        <entry>5874897 après JC</entry>
        <entry>1 microseconde / 14 chiffres</entry>
       </row>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>8 octets</entry>
        <entry>date et heure, avec fuseau horaire</entry>
        <entry>4713 avant JC</entry>
        <entry>5874897 après JC</entry>
        <entry>1 microseconde / 14 chiffres</entry>
       </row>
       <row>
        <entry><type>interval [ (<replaceable>p</replaceable>) ]</type></entry>
        <entry>12 octets</entry>
        <entry>intervalle de temps</entry>
        <entry>-178000000 années</entry>
        <entry>178000000 années</entry>
	<entry>1 microseconde / 14 chiffres</entry>
       </row>
       <row>
        <entry><type>date</type></entry>
        <entry>4 octets</entry>
        <entry>date seulement</entry>
        <entry>4713 avant JC</entry>
        <entry>32767 après JC</entry>
        <entry>1 jour</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 octets</entry>
        <entry>heure seulement</entry>
        <entry>00:00:00.00</entry>
        <entry>24:00:00</entry>
	<entry>1 microseconde / 14 chiffres</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>12 octets</entry>
        <entry>heure seulement, avec fuseau horaire</entry>
        <entry>00:00:00+1359</entry>
        <entry>24:00:00-1359</entry>
	<entry>1 microseconde / 14 chiffres</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 7.3, écrire seulement
     <type>timestamp</type> était équivalent à <type>timestamp with
     time zone</type>. Ceci a été changé pour une meilleure compatibilité avec
     le standard SQL.
    </para>
   </note>

   <para>
    <type>time</type>, <type>timestamp</type>, et
    <type>interval</type> acceptent une précision optionnelle
    <replaceable>p</replaceable>, qui indique le nombre de chiffres
    après la virgule pour les secondes. Par défaut, il n'y a pas de
    limite explicite à cette précision. Les valeurs acceptées pour
    <replaceable>p</replaceable> vont de 0 à 6 pour les types
    <type>timestamp</type> et <type>interval</type>.
   </para>

   <note>
    <para>
     Quand les valeurs <type>timestamp</> sont stockées en tant que nombre à
     virgule flottante (actuellement le défaut), la limite réelle de la
     précision pourrait être inférieure à 6. Les valeurs 
     <type>timestamp</type> sont stockées en tant que nombre de secondes avant
     ou après le 1er janvier 2000 à minuit. La précision par microseconde est
     obtenue pour les dates proches du 1er janvier 2000 mais la précision se
     dégrade pour les dates suivantes. Quand les valeurs 
     <type>timestamp</type> sont stockées en tant qu'entier sur huit octets
     (une option au moment de la compilation), la précision en microseconde
     est disponible pour toute l'étendue des valeurs. Néanmoins, les valeurs
     de type timestamp codées avec des entiers sur huit octets ont une
     échelle de date plus limitée que celle indiquée ci-dessus&nbsp;: de
     4713 avant Jésus-Christ à 294276 après Jésus-Christ. La même option
     de compilation détermine si les valeurs <type>time</type> et
     <type>interval</type> sont stockées en tant que nombre à virgule
     flottante ou en tant qu'octet sur huit chiffres. Dans le cas de la
     virgule flottante, les valeurs <type>interval</type> larges voient leur
     précision se dégrader au fur et à mesure que l'intervalle croît.
    </para>
   </note>

   <para>
    Pour les types <type>time</type>, l'intervalle accepté pour
    <replaceable>p</replaceable> est de 0 à 6 lorsque les entiers sur
    8 octets sont utilisés, ou de 0 à 10 lorsque le stockage se fait sous
    forme de nombre à virgule flottante.
   </para>

   <para>
    Le type <type>time with time zone</type> est défini dans le standard
    SQL mais sa définition lui prête des propriétés qui font douter de son
    utilité. Dans la plupart des cas, une combinaison de <type>date</type>,
    <type>time</type>, <type>timestamp without time zone</type> et
    <type>timestamp with time zone</type> devrait permettre de résoudre
    toutes les fonctionnalités de date et heure nécessaires à une application.
   </para>

   <para>
    Les types <type>abstime</type> et <type>reltime</type> sont des types de
    précision moindre, utilisés en interne. Il n'est pas recommandé de les
    utiliser dans de nouvelles applications. Au contraire, il est souhaitable
    de migrer l'existant vers un autre type approprié.
    Ces types internes pourraient disparaître dans une future version.
   </para>

   <sect2 id="datatype-datetime-input">
    <title>Entrée des dates et heures</title>

    <para>
     La saisie de dates et heures et possible dans la plupart des formats
     raisonnables, dont ISO8601, compatible <acronym>SQL</acronym>, traditionnel
     <productname>POSTGRES</productname> et d'autres.
     Pour certains formats, l'ordre des jours, mois et années en entrée est ambigu.
     Il est alors possible de préciser l'ordre attendu pour ces champs.
     Réglez le paramètre <xref linkend="guc-datestyle"> à <literal>MDY</literal> pour choisir
     une interprétation mois-jour-année, à <literal>DMY</literal> pour jour-mois-année,
     à <literal>YMD</literal> pour année-mois-jour.
    </para>

    <para>
     <productname>PostgreSQL</productname> est plus flexible que la norme 
     <acronym>SQL</acronym> ne l'exige pour la manipulation des dates et
     des heures. Voir l'<xref linkend="datetime-appendix"> pour connaître
     les règles exactes de reconnaissance des dates et heures,
     ainsi que les formats de champs texte comme les mois, les jours de la
     semaine et les fuseaux horaires.
    </para>

    <para>
     Rappelez-vous que chaque littéral date ou heure à saisir doit être mis
     entre apostrophes, comme les chaînes de caractères.
     Référez-vous à la <xref linkend="sql-syntax-constants-generic"> pour
     plus d'information. <acronym>SQL</acronym> requiert la syntaxe suivante&nbsp;:
<synopsis>
<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>valeur</replaceable>'
</synopsis>
     où <replaceable>p</replaceable>, dans la spécification optionnelle de
     précision, est un entier correspondant au nombre de chiffres après la virgule
     dans le champ secondes.
     La précision peut être précisée pour les types <type>time</type>,
     <type>timestamp</type>, et <type>interval</type>.
     Les valeurs admissibles sont mentionnées plus haut. Si aucune précision
     n'est indiquée dans une spécification de constante, elle prend la
     précision de la valeur littérale.
    </para>

    <sect3>
    <title>Dates</title>

    <indexterm>
     <primary>date</primary>
    </indexterm>
 
    <para>
     Le <xref linkend="datatype-datetime-date-table"> montre les formats
     de date possibles pour les entrées de type <type>date</type>.
    </para>

     <table id="datatype-datetime-date-table">
      <title>Saisie de date</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Exemple</entry>
         <entry>Description</entry>
        </row>
           </thead>
           <tbody>
        <row>
         <entry>January 8, 1999</entry>
         <entry>sans ambiguïté quel que soit le style de date 
         (<varname>datestyle</varname>)</entry>
        </row>
        <row>
         <entry>1999-01-08</entry>
         <entry>ISO-8601&nbsp;; 8 janvier, quel que soit le mode
         (format recommandé)</entry>
        </row>
        <row>
         <entry>1/8/1999</entry>
         <entry>8 janvier en mode <literal>MDY</>&nbsp;;
          1er août en mode <literal>DMY</></entry>
        </row>
        <row>
         <entry>1/18/1999</entry>
         <entry>18 janvier en mode <literal>MDY</>&nbsp;;
          rejeté dans les autres modes</entry>
        </row>
        <row>
         <entry>01/02/03</entry>
         <entry>2 janvier 2003 en mode <literal>MDY</>&nbsp;;
          1er février 2003 en mode <literal>DMY</>&nbsp;;
          3 février 2003 en mode <literal>YMD</>
         </entry>
        </row>
        <row>
         <entry>1999-Jan-08</entry>
         <entry>8 janvier dans tous les modes</entry>
        </row>
        <row>
         <entry>Jan-08-1999</entry>
         <entry>8 janvier dans tous les modes</entry>
        </row>
        <row>
         <entry>08-Jan-1999</entry>
         <entry>8 janvier dans tous les modes</entry>
        </row>
        <row>
         <entry>99-Jan-08</entry>
         <entry>8 janvier en mode <literal>YMD</>, erreur sinon</entry>
        </row>
        <row>
         <entry>08-Jan-99</entry>
         <entry>8 janvier, sauf en mode <literal>YMD</>&nbsp;: erreur</entry>
        </row>
        <row>
         <entry>Jan-08-99</entry>
         <entry>8 janvier, sauf en mode <literal>YMD</>&nbsp;: erreur</entry>
        </row>
        <row>
         <entry>19990108</entry>
         <entry>ISO-8601&nbsp;; 8 janvier 1999 dans tous les modes</entry>
        </row>
        <row>
         <entry>990108</entry>
         <entry>ISO-8601&nbsp;; 8 janvier 1999 dans tous les modes</entry>
        </row>
        <row>
         <entry>1999.008</entry>
         <entry>Année et jour dans l'année</entry>
        </row>
        <row>
         <entry>J2451187</entry>
         <entry>Jour du calendrier Julien</entry>
        </row>
        <row>
         <entry>January 8, 99 BC</entry>
         <entry>année 99 avant Jésus Christ</entry>
        </row>
      </tbody>
     </tgroup>
    </table>
   </sect3>

    <sect3>
     <title>Heures</title>

     <indexterm>
      <primary>heure</primary>
     </indexterm>
     <indexterm>
      <primary>heure sans fuseau horaire</primary>
     </indexterm>
     <indexterm>
      <primary>heure avec fuseau horaire</primary>
     </indexterm>

     <para>
      Les types heure-du-jour sont <type>time [
      (<replaceable>p</replaceable>) ] without time zone</type> et
      <type>time [ (<replaceable>p</replaceable>) ] with time
      zone</type>. Écrire juste <type>time</type> est équivalent à
      <type>time without time zone</type>
     </para>

     <para>
      Les valeurs d'entrée valides pour ces types sont constituées d'une heure
      du jour suivi d'un fuseau horaire optionnel (voir le <xref
      linkend="datatype-datetime-time-table"> et le <xref
      linkend="datatype-timezone-table">). Si un fuseau est précisé
      pour le type <type>time without time zone</type>, il est ignoré sans
      message d'erreur.
     </para>

      <table id="datatype-datetime-time-table">
       <title>Saisie d'heure</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>Exemple</entry>
          <entry>Description</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05 AM</literal></entry>
          <entry>Identique à 04:05&nbsp;; AM n'affecte pas la valeur</entry>
         </row>
         <row>
          <entry><literal>04:05 PM</literal></entry>
          <entry>Identique à 16:05&nbsp;; l'heure doit être &lt;= 12</entry>
         </row>
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506-08</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
          <entry>fuseau horaire précisé par son nom</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <table tocentry="1" id="datatype-timezone-table">
       <title>Saisie des zones de date</title>
       <tgroup cols="2">
        <thead>

         <row>
          <entry>Exemple</entry>
          <entry>Description</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>PST</entry>

          <entry>Heure standard du Pacifique (Pacific Standard Time)</entry>
         </row>
         <row>
          <entry>-8:00</entry>
          <entry>Décalage ISO-8601 pour la zone PST</entry>
         </row>
         <row>
          <entry>-800</entry>
          <entry>Décalage ISO-8601 pour la zone PST</entry>
         </row>
         <row>
          <entry>-8</entry>
          <entry>Décalage ISO-8601 pour la zone PST</entry>
         </row>
         <row>
          <entry><literal>zulu</literal></entry>
          <entry>Abréviation des militaires pour GMT</entry>
         </row>
         <row>
          <entry><literal>z</literal></entry>
          <entry>Version courte de <literal>zulu</literal></entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <para>
       Référez-vous à l'<xref linkend="datetime-appendix"> pour une liste de
       noms de fuseaux horaire reconnus en entrée.
      </para>
    </sect3>

    <sect3>
    <title>Horodatages (time stamps)</title>

    <indexterm>
     <primary>timestamp</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp with time zone</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp without time zone</primary>
    </indexterm>

     <para>
      Les valeurs d'entrée valides sont constituées par la concaténation
      d'une date, d'une heure, suivi d'un fuseau horaire optionnel, d'un
      qualificatif optionnel <literal>AD</literal> (avant Jésus Christ) ou
      <literal>BC</literal>  (après Jésus Christ). (Autrement,
      <literal>AD</literal>/<literal>BC</literal> peut apparaître avant le
      fuseau horaire mais ce n'est pas l'ordre préféré.)
      Ainsi&nbsp;:

<programlisting>
1999-01-08 04:05:06
</programlisting>
      et
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>

      sont des valeurs valides, qui suivent le standard 
      <acronym>ISO</acronym> 8601. De plus, le format

<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
      très courant, est supporté.
     </para>

     <para>
	     Le standard <acronym>SQL</acronym> différencie les littéraux
	     <type>timestamp without time zone</type> et
	     <type>timestamp with time zone</type> par la présence d'un
	     <quote>+</quote> ou d'un <quote>-</quote>. Du coup, suivant le
	     standard, 
	     <programlisting>TIMESTAMP '2004-10-19 10:23:54'</programlisting>
	     est du type <type>timestamp without time zone</type> alors que
	     <programlisting>TIMESTAMP '2004-10-19 10:23:54+02'</programlisting>
	     est du type <type>timestamp with time zone</type>.
	     <productname>PostgreSQL</productname> n'examine jamais le contenu
	     d'une chaîne littérale avant de déterminer son type. Du coup, il ne
	     traitera les deux ci-dessus comme des valeurs de type
	     <type>timestamp without time zone</type>. Pour s'assurer qu'un
	     littéral est traité comme une valeur de type <type>timestamp with time
         zone</type>, donnez-lui explicitement le bon type&nbsp;:
<programlisting>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</programlisting>
         Dans un littéral de type <type>timestamp without time
         zone</type>, <productname>PostgreSQL</productname> ignorera
         silencieusement toute indication de fuseau horaire. C'est-à-dire que
         la valeur résultante est dérivée des champs date/time dans la valeur
         en entrée et n'est pas ajustée pour le fuseau horaire.
     </para>

     <para>
      Pour <type>timestamp with time zone</type>, la valeur stockée en interne
      est toujours en UTC (Temps Universel Coordonné), aussi
      connu sous le nom de <acronym>GMT</acronym>.
      Les valeurs d'entrée qui ont un fuseau horaire explicite sont converties
      en UTC en utilisant le décalage approprié. Si aucun fuseau horaire
      n'est précisé, alors le système considère que la date est dans le fuseau
      horaire indiqué par le paramètre système <xref linkend="guc-timezone">,
      et la convertit en UTC en utilisant le décalage de la zone 
      <varname>timezone</varname>.
     </para>

     <para>
      Quand une valeur <type>timestamp with time zone</type> est affichée, 
      elle est toujours convertie de l'UTC vers le fuseau horaire courant
      (variable <varname>timezone</varname>), et affichée comme une heure locale de
      cette zone.
      Pour voir l'heure dans un autre fuseau horaire, il faut soit changer la
      valeur de <varname>timezone</varname> ou utiliser la construction
      <literal>AT TIME ZONE</literal> (voir la <xref
      linkend="functions-datetime-zoneconvert">).
     </para>

     <para>
      Les conversions entre <type>timestamp without time zone</type> et
      <type>timestamp with time zone</type> considèrent normalement
      que la valeur <type>timestamp without time zone</type> utilise
      le fuseau horaire <varname>timezone</varname>. Une zone différente
      peut être choisie en utilisant <literal>AT TIME ZONE</literal>.
     </para>
    </sect3>

    <sect3>
     <title>Intervalles</title>

     <indexterm>
      <primary>interval</primary>
     </indexterm>

      <para>
       Les valeurs de type <type>interval</type> utilisent la syntaxe suivante:

<programlisting>
<optional>@</> <replaceable>quantité</> <replaceable>unité</> <optional><replaceable>quantité</> <replaceable>unité</>...</> <optional><replaceable>direction</></optional>
</programlisting>

      Où: <replaceable>quantité</replaceable> est un nombre (éventuellement
      signé)&nbsp;; <replaceable>unité</replaceable> est <literal>second</literal>,
      <literal>minute</literal>, <literal>hour</literal>, <literal>day</literal>,
      <literal>week</literal>, <literal>month</literal>, <literal>year</literal>,
      <literal>decade</literal>, <literal>century</literal>, <literal>millennium</literal>,
      ou des abréviations ou des pluriels de ces unités&nbsp;;
      <replaceable>direction</replaceable> peut être <literal>ago</literal> ou
      vide. L'arobase (<literal>@</literal>) est optionnel. Les valeurs
      des différentes unités sont implicitement ajoutées en utilisant le signe
      approprié.
     </para>

     <para>
      Les quantités de jours, heures, minutes et secondes peuvent être précisées
      sans unité explicite. Par exemple <literal>'1 12:59:10'</literal> est
      compris de la même façon que
      <literal>'1 day 12 hours 59 min 10 sec'</literal> (1 jour, 12 heures,
      59 minutes, 10 secondes).
     </para>

     <para>
      La précision optionnelle doit être entre 0 et 6, et prend la précision
      du littéral comme valeur par défaut.
     </para>
    </sect3>

    <sect3>
     <title>Valeurs spéciales</title>

     <indexterm>
      <primary>heure</primary>
      <secondary>constantes</secondary>
     </indexterm>

     <indexterm>
      <primary>date</primary>
      <secondary>constantes</secondary>
     </indexterm>

     <para>
      <productname>PostgreSQL</productname> supporte aussi plusieurs
      valeurs de dates spéciales, par simplicité, comme montré dans le
      <xref linkend="datatype-datetime-special-table">.
      Les valeurs <literal>infinity</literal> et <literal>-infinity</literal>
      ont une représentation spéciale dans le système et seront affichées de 
      la même façon. Les autres sont simplement des facilités de notation
      qui seront converties en dates/heures ordinaires lorsqu'elles seront 
      lues (en particulier, <literal>now</> et les chaînes relatives sont
      converties en une valeur temps spécifique dès qu'elles sont lues).
      Toutes ces valeurs sont traitées comme des constantes normales,
      et doivent être écrites entre apostrophes.
     </para>

      <table id="datatype-datetime-special-table">
       <title>Saisie de dates/heures spéciales</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>Chaînes entrées</entry>
          <entry>Types valides</entry>
        <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
     
      <entry><literal>epoch</literal></entry>
      <entry><type>date</type>, <type>timestamp</type></entry>
      <entry>1970-01-01 00:00:00+00 (date système zéro d'Unix)</entry>
     </row>
     <row>
      <entry><literal>infinity</literal></entry>
      <entry><type>timestamp</type></entry>
      <entry>plus tard que toutes les autres dates</entry>
     </row>
     <row>
      <entry><literal>-infinity</literal></entry>
      <entry><type>timestamp</type></entry>
      <entry>plus tôt que toutes les autres dates</entry>
     </row>
     <row>
      <entry><literal>now</literal></entry>
      <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
      <entry>heure de début de la transaction courante</entry>
     </row>
     <row>
      <entry><literal>today</literal></entry>
      <entry><type>date</type>, <type>timestamp</type></entry>
      <entry>minuit aujourd'hui</entry>
     </row>
     <row>
      <entry><literal>tomorrow</literal></entry>
      <entry><type>date</type>, <type>timestamp</type></entry>
      <entry>minuit demain</entry>
     </row>
     <row>
      <entry><literal>yesterday</literal></entry>
      <entry><type>date</type>, <type>timestamp</type></entry>
      <entry>minuit hier</entry>
     </row>
     <row>
      <entry><literal>allballs</></entry>
      <entry><type>time</type></entry>
      <entry>00:00:00.00 UTC</entry>
     </row>
    </tbody>

       </tgroup>
      </table>

      <para>
       Les fonctions suivantes, compatibles avec le standard 
       <acronym>SQL</acronym>, peuvent aussi être utilisées pour obtenir
       l'heure courante pour le type de données correspondant&nbsp;:
       <literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>, 
       <literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal>, 
       <literal>LOCALTIMESTAMP</literal>. Les quatre derniers acceptent une
       spécification de la précision en option (voir la <xref
       linkend="functions-datetime-current">). Notez néanmoins que ce sont des
       fonctions SQL et qu'elles ne sont <emphasis>pas</> reconnues en tant
       que chaînes en entrée de la donnée.
      </para>

    </sect3>
   </sect2>

   <sect2 id="datatype-datetime-output">
    <title>Affichage des dates et heures</title>

    <indexterm>
     <primary>date</primary>
     <secondary>format d'affichage</secondary>
     <seealso>formatage</seealso>
    </indexterm>

    <indexterm>
     <primary>heure</primary>
     <secondary>format de sortie</secondary>
     <seealso>formatage</seealso>
    </indexterm>

    <para>
     Le format de sortie des types date/heure peut être choisi parmi un des
     quatre formats de date suivants&nbsp;: ISO 8601, <acronym>SQL</acronym> 
     (Ingres), traditionnel POSTGRES et allemand, en utilisant la commande
     <literal>SET datestyle</literal>. Le format par défaut est le format
     <acronym>ISO</acronym>, comme demandé par le standard 
     <acronym>SQL</acronym>. Le nom du format d'affichage <quote>SQL</quote>
     est un accident historique. Le
     <xref linkend="datatype-datetime-output-table">  montre des exemples de
     chaque format d'affichage. Bien sûr, le format d'un type <type>date</type> ou
     <type>time</type> est celui de la partie date ou heure, comme
     montré dans les exemples.
    </para>

     <table id="datatype-datetime-output-table">
      <title>Styles d'affichage de date/heure</title>
      <tgroup cols="3">
       <thead>
        <row>
    
        <entry>Spécification de style</entry>
       <entry>Description</entry>
       <entry>Exemple</entry>
       </row>

       </thead>
       <tbody>
        <row>

         <entry>ISO</entry>
         <entry>standard ISO 8601/SQL</entry>
         <entry>1997-12-17 07:37:16-08</entry>
        </row>
        <row>

         <entry>SQL</entry>
         <entry>style traditionnel</entry>
         <entry>12/17/1997 07:37:16.00 PST</entry>
        </row>
        <row>

     <entry>POSTGRES</entry>
     <entry>style original</entry>
     <entry>Wed Dec 17 07:37:16 1997 PST</entry>
    </row>
    <row>

     <entry>German</entry>
     <entry>style régional</entry>
     <entry>17.12.1997 07:37:16.00 PST</entry>
    </row>

       </tbody>
      </tgroup>
     </table>

    <para>
     Dans les styles <acronym>SQL</acronym> et POSTGRES, les jours
     apparaissent avant le mois si l'ordre des champs DMY a été précisé,
     sinon les mois apparaissent avant les jours
     (voir la <xref linkend="datatype-datetime-input">  pour savoir comment
     ce paramètre affecte l'interprétation des valeurs en entrée). Le
     <xref linkend="datatype-datetime-output2-table"> montre un exemple.
    </para>

     <table id="datatype-datetime-output2-table">
      <title>Convention d'ordre des dates</title>
      <tgroup cols="3">
       <thead>
    <row>
     <entry>Réglage de ><varname>datestyle</varname> (style de date)</entry>

     <entry>Ordre d'entrée</entry>
     <entry>Exemple d'affichage</entry>
    </row>

       </thead>
       <tbody>
    <row>

        <entry><literal>SQL, DMY</></entry>
         <entry><replaceable>jour</replaceable>/<replaceable>mois</replaceable>/<replaceable>année</replaceable></entry>
         <entry>17/12/1997 15:37:16.00 CET</entry>
        </row>
        <row>
         <entry><literal>SQL, MDY</></entry>
         <entry><replaceable>mois</replaceable>/<replaceable>jour</replaceable>/<replaceable>année</replaceable></entry>
         <entry>12/17/1997 07:37:16.00 PST</entry>
        </row>
        <row>
         <entry><literal>Postgres, DMY</></entry>
         <entry><replaceable>jour</replaceable>/<replaceable>mois</replaceable>/<replaceable>année</replaceable></entry>
         <entry>Wed 17 Dec 07:37:16 1997 PST</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
     L'affichage du type <type>interval</type> ressemble au format de saisie,
     sauf que les unités comme <literal>century</literal> ou
     <literal>week</literal> sont converties en années et jours, et que
     <literal>ago</literal> est converti en un signe approprié. En mode ISO,
     l'affichage ressemble à:
<programlisting>
<optional> <replaceable>quantité</> <replaceable>unité</> <optional> ... </> </> <optional> <replaceable>jours</> </> <optional> <replaceable>heures</>:<replaceable>minutes</>:<replaceable>secondes</> </optional>
</programlisting>
    </para>

    <para>
     Les styles de date/heure peuvent être sélectionnés soit en utilisant la
     commande <command>SET datestyle</command>, soit en utilisant le paramètre
     <xref linkend="guc-datestyle"> du fichier de configuration
     <filename>postgresql.conf</filename>, soit avec la variable 
     d'environnement <envar>PGDATESTYLE</envar> sur le serveur ou le client.
     La fonction de formatage <function>to_char</function> (voir <xref 
     linkend="functions-formatting">) permet aussi de formater les affichages
     de date/heure de manière plus flexible.
    </para>
   </sect2>

   <sect2 id="datatype-timezones">
    <title>Fuseaux horaires</title>

    <indexterm zone="datatype-timezones">
     <primary>fuseau horaire</primary>
    </indexterm>

    <para>
     Les fuseaux horaires et les conventions d'heures sont influencées
     par des décisions politiques, pas seulement par la géométrie de la terre.
     Les fuseaux horaires se sont un peu standardisés au cours du
     vingtième siècle mais continuent à être soumis à des changements
     arbitraires, particulièrement en respect des règles de changement
     d'heure.
     <productname>PostgreSQL</productname> supporte actuellement les règles de
     changement d'heure pour la période de 1902 à 2038 (correspondant à
     l'échelle intégrale du temps système Unix). Les périodes en dehors de
     cette échelle sont prises en tant que <quote>temps standard</> pour le
     fuseau horaire sélectionné, quelque soit la partie de l'année où elles
     tombent.
    </para>

    <para>
     <productname>PostgreSQL</productname> se veut compatible avec les
     définitions standard <acronym>SQL</acronym> pour un usage typique.
     Néanmoins, le standard <acronym>SQL</acronym> possède un mélange 
     bizarre de types de date/heure et de possibilités. Deux problèmes 
     sont évidents:

     <itemizedlist>
      <listitem>
       <para>
        Bien que le type  <type>date</type> n'ait pas de fuseau horaire
        associé, le type  <type>heure</type> peut en avoir un.
        Les fuseaux horaires, dans le monde réel, ne peuvent avoir de sens
        qu'associés à une date et à une heure, vu que l'écart peut varier
        avec l'heure d'été.
       </para>
      </listitem>

      <listitem>
       <para>
        Le fuseau horaire par défaut est précisé comme un écart numérique constant
        avec l'<acronym>UTC</>. Il n'est pas possible de s'adapter à l'heure 
        d'été ou d'hiver lorsque l'on fait des calculs arithmétiques qui passent
        les limites de l'heure d'été et de l'heure d'hiver.
       </para>
      </listitem>

     </itemizedlist>
    </para>

    <para>
     Pour ne pas avoir ces difficultés, nous recommandons d'utiliser des
     types de date/heure qui contiennent à la fois une date et une heure
     lorsque vous utilisez les fuseaux horaires. Nous recommandons de
     <emphasis>ne pas</emphasis> utiliser le type <type>time with
     time zone</type>. Ce type est néanmoins proposé par 
     <productname>PostgreSQL</productname> pour les applications
     existantes et pour assurer la compatibilité avec le standard
     <acronym>SQL</acronym>.
     <productname>PostgreSQL</productname> utilise votre fuseau horaire
     pour tous les types qui ne contiennent qu'une date ou une heure.
    </para>

    <para>
     Toutes les dates et heures, conscientes du fuseau horaire, sont stockées
     en interne en <acronym>UTC</acronym>. Ils sont convertis en heure
     locale dans le fuseau spécifié par le paramètre de configuration <xref
     linkend="guc-timezone"> avant d'être affiché au client.
    </para>

    <para>
     Le paramètre de configuration <xref linkend="guc-timezone"> peut être
     initialisé dans le fichier <filename>postgresql.conf</> ou de tous les
     autres moyens standards décrit dans le <xref linkend="runtime-config">.
     Il existe aussi quelques moyens spéciaux pour le configurer&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        Si <varname>timezone</> n'est spécifié ni dans
        <filename>postgresql.conf</> ni comme une option en ligne de commande
        pour postmaster, le serveur tente d'utiliser la valeur de la variable
        d'environnement <envar>TZ</envar> comme fuseau horaire par défaut.
        Si <envar>TZ</envar> n'est pas définie ou ne fait pas partie des noms
        de fuseau horaire connus par <productname>PostgreSQL</productname>,
        le serveur tente de déterminer le fuseau horaire par défaut du
        système d'exploitation en vérifiant le comportement de la fonction
        <literal>localtime()</> de la bibliothèque C. Le fuseau horaire par
        défaut est sélectionné comme la correspondance la plus proche parmi
        les fuseaux horaires connus par <productname>PostgreSQL</productname>.
       </para>
      </listitem>

      <listitem>
       <para>
        La commande <acronym>SQL</acronym> <command>SET TIME ZONE</command>
        configure le fuseau horaire pour cette session. C'est une autre façon
        d'indiquer <command>SET TIMEZONE TO</> avec une syntaxe plus
        compatible avec les spécifications SQL.
       </para>
      </listitem>

      <listitem>
       <para>
        La variable d'environnement <envar>PGTZ</envar>, si elle est mise à jour
        par le client, est utilisée par les applications basées sur 
        <application>libpq</application> pour envoyer une commande 
        <command>SET TIME ZONE</command> au serveur lors de la connexion.
       </para>
      </listitem>
     </itemizedlist>
    </para>

   <para>
    Voir l'<xref linkend="datetime-appendix"> pour une liste des fuseaux
    horaires disponibles.
   </para>

   </sect2>

   <sect2 id="datatype-datetime-internals">
    <title>Types internes</title>

    <para>
    <productname>PostgreSQL</productname> utilise les dates Juliennes pour tous
    les calculs de date/heure. Elles ont la propriété intéressante de permettre
    le calcul de toute date entre 4713 avant Jésus Christ et loin dans le futur,
    si on utilise le fait que l'année dure 365,2425 jours.
    </para>

    <para>
     Les conventions pour les dates antérieures au 19ème siècle sont une
     lecture intéressante mais ne sont pas assez consistantes pour être codées
     dans un gestionnaire de dates.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-boolean">
   <title>Type booléen</title>

   <indexterm zone="datatype-boolean">
    <primary>boolean</primary>
    <secondary>type de données</secondary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> dispose du type <type>boolean</type>
    du standard <acronym>SQL</acronym>.
    Le type booléen ne peut avoir que deux états&nbsp;:<quote>true</quote> (vrai) 
    et <quote>false</quote> (faux). Un troisième état, <quote>unknown</quote>
    (inconnu), est représenté par la valeur NULL de <acronym>SQL</acronym>.
   </para>

   <para>
    Les valeurs littérales valides pour l'état <quote>vrai</quote> sont&nbsp;:
    <simplelist>
     <member><literal>TRUE</literal></member>
     <member><literal>'t'</literal></member>
     <member><literal>'true'</literal></member>
     <member><literal>'y'</literal></member>
     <member><literal>'yes'</literal></member>
     <member><literal>'1'</literal></member>
    </simplelist>
    Pour l'état <quote>faux</quote>, les valeurs suivantes peuvent être
    utilisées&nbsp;:
    <simplelist>
     <member><literal>FALSE</literal></member>
     <member><literal>'f'</literal></member>
     <member><literal>'false'</literal></member>
     <member><literal>'n'</literal></member>
     <member><literal>'no'</literal></member>
     <member><literal>'0'</literal></member>
    </simplelist>
    Il est recommandé d'utiliser <literal>TRUE</literal> et
    <literal>FALSE</literal> (qui sont compatibles avec la norme 
    <acronym>SQL</acronym>).
   </para>

   <example id="datatype-boolean-example">
    <title>Utilisation du type <type>boolean</type>.</title>

<programlisting>
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
---+---------
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
---+---------
 t | sic est
</programlisting>
   </example>

   <para>
   L'<xref linkend="datatype-boolean-example"> montre que
   les valeurs booléennes sont affichées en utilisant les lettres
   <literal>t</literal> et <literal>f</literal>.
   </para>

   <tip>
    <para>
     Les valeurs de type booléen ne peuvent pas être directement converties en
     d'autres types. Par exemple, <literal>CAST(
     <replaceable>boolval</replaceable> AS integer)</literal> ne fonctionne
     pas. Pour cela, il faut utiliser la construction <literal>CASE</literal>&nbsp;:
     <literal>CASE WHEN <replaceable>val_bool</replaceable> THEN 'valeur si vrai'
     ELSE 'valeur si faux' END</literal>.
     Voir la <xref linkend="functions-conditional">.
    </para>
   </tip>

   <para>
    le type <type>boolean</type> utilise 1 octet de stockage.
   </para>
  </sect1>

  <sect1 id="datatype-geometric">
<title>Types géométriques</title>

   <para>
    Les types de données géométriques représentent des objets à deux 
    dimensions. Le <xref linkend="datatype-geo-table"> liste les types 
    disponibles dans <productname>PostgreSQL</productname>.
    Le type le plus fondamental, le point, forme la base pour tous les
    autres types.
   </para>

    <table id="datatype-geo-table">
     <title>Types géométriques</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Représentation</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>point</type></entry>
        <entry>16 octets</entry>
        <entry>Point du plan</entry>
        <entry>(x,y)</entry>
       </row>
       <row>
        <entry><type>line</type></entry>
        <entry>32 octets</entry>
        <entry>Ligne infinie (pas entièrement implémenté)</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>lseg</type></entry>
        <entry>32 octets</entry>
        <entry>Segment de droite fini</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>box</type></entry>
        <entry>32 octets</entry>
        <entry>Boite rectangulaire</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n octets</entry>
        <entry>Chemin fermé (similaire à un polygone)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n octets</entry>
        <entry>Chemin ouvert</entry>
        <entry>[(x1,y1),...]</entry>
       </row>
       <row>
        <entry><type>polygon</type></entry>
        <entry>40+16n octets</entry>
        <entry>Polygone (similaire à un chemin fermé)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>circle</type></entry>
        <entry>24 octets</entry>
        <entry>Cercle</entry>
        <entry>&lt;(x,y),r&gt; (centre et rayon)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Un large ensemble de fonctions et d'opérateurs permettent d'effectuer
    différentes opérations géométriques, comme l'agrandissement, la translation,
    la rotation, la détermination des intersections. Elles sont expliquées dans
    la <xref linkend="functions-geometry">.
   </para>

   <sect2>
    <title>Points</title>

    <indexterm>
     <primary>point</primary>
    </indexterm>

    <para>
     Les points sont les blocs fondamentaux pour construire les types géométriques.
     Les valeurs de type <type>point</type> sont spécifiées en utilisant la syntaxe
     suivante&nbsp;:
<synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis>

     où <replaceable>x</> et <replaceable>y</> sont les coordonnées respectives
     sous forme de nombre à virgule flottante.
    </para>
   </sect2>

   <sect2>
    <title>Segments de droite</title>

    <indexterm>
     <primary>lseg</primary>
    </indexterm>

    <indexterm>
     <primary>ligne</primary>
    </indexterm>

    <para>
     Les segments de droite (<type>lseg</type>) sont représentés sous forme de
     paires de points en utilisant la syntaxe suivante&nbsp;:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )  
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     où
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     et
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     sont les points aux extrémités du segment.
    </para>
   </sect2>

   <sect2>
    <title>Boîtes</title>

    <indexterm>
     <primary>boîte (type de données)</primary>
    </indexterm>

    <indexterm>
     <primary>rectangle</primary>
    </indexterm>


    <para>
     Les boites (rectangles) sont représentées par paires de points qui sont les coins
     opposés de la boîte en utilisant la syntaxe suivante&nbsp;:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )  
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     où
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     et
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     sont les coins opposés du rectangle.
    </para>

    <para>
     Les rectangles sont affichés en utilisant la première syntaxe.
     Les coins sont réordonnées lors de la saisie. Le coin en haut à gauche,
     puis le coin en bas à droite.
     Les autres coins peuvent être saisis, mais les coins en bas à gauche et 
     en haut à droite sont déterminés à partir de l'entrée et stockés.
    </para>
   </sect2>

   <sect2>
    <title>Chemins</title>

    <indexterm>
     <primary>path (type de données)</primary>
    </indexterm>

    <para>
     Les chemins ( type <type>path</type> )
     sont représentés par des listes de points connectés.
     Les chemins peuvent être <firstterm>ouverts</firstterm>, si le premier et
     le dernier point ne sont pas considérés comme connectés, ou <firstterm>fermés</firstterm>,
     si le premier et le dernier point sont considérés connectés.
    </para>

    <para>
     Les valeurs de type <type>path</type> sont entrées avec la syntaxe
     suivante&nbsp;:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )  
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )  
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>    
</synopsis>

    où les points sont les extrémités des segments de droites qui forment
    le chemin. Les crochets (<literal>[]</literal>) indiquent un chemin ouvert
    alors que les parenthèses (<literal>()</literal>) indiquent un chemin fermé.
    </para>

    <para>
     Les chemins sont affichés avec la première syntaxe.
    </para>
   </sect2>

   <sect2>
    <title>Polygones</title>

    <indexterm>
     <primary>polygon</primary>
    </indexterm>

    <para>
     Les polygones ( type <type>polygon</type>) sont représentés par des
     ensembles de points (les vertex du polygone). Ils devraient probablement
     être considérés comme des chemins fermés, mais ils sont stockés différemment
     et ont leurs propres routines de manipulation.
    </para>

    <para>
     Les valeurs de type <type>polygon</type> sont saisies avec la syntaxe suivante&nbsp;:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )  
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )  
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>    
</synopsis>

     où les points sont les extrémités des segments de droites
     qui forment les limites du polygone.
    </para>

    <para>
     Les polygones sont affichés en utilisant la première syntaxe.
    </para>
   </sect2>

   <sect2>
    <title>Cercles</title>

    <indexterm>
     <primary>circle</primary>
    </indexterm>

    <para>
     Les cercles (type <type>circle</type>) sont représentés par le point
     central et le rayon.
     Les valeurs de type <type>circle</type> sont saisies avec la syntaxe
     suivante&nbsp;:

<synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>  
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>  
</synopsis>

     où
     <literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</literal>
     est le centre et <replaceable>r</replaceable> est le rayon du cercle.
    </para>

    <para>
     Les cercles sont affichés en utilisant la première syntaxe.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-net-types">
   <title>Types d'adresses réseau</title>

   <indexterm zone="datatype-net-types">
    <primary>réseau</primary>
    <secondary>types de données</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</> offre des types de données pour stocker des
    adresses IPv4, IPv6 et MAC, décrites dans le
    <xref linkend="datatype-net-types-table">
    Il est préférable d'utiliser ces types plutôt que des types texte
    standards pour stocker des adresses réseau car ils proposent un contrôle
    de syntaxe lors de la saisie et plusieurs opérateurs et fonctions
    spécialisées (voir la <xref linkend="functions-net">).
   </para>

    <table tocentry="1" id="datatype-net-types-table">
     <title>Types d'adresses réseau</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry><type>cidr</type></entry>
        <entry>12 ou 24 octets</entry>
        <entry>réseaux IPv4 et IPv6</entry>
       </row>

       <row>
        <entry><type>inet</type></entry>
        <entry>12 ou 24 octets</entry>
        <entry> hôtes et réseaux IPv4 et IPv6</entry>
       </row>

       <row>
        <entry><type>macaddr</type></entry>
        <entry>6 bytes</entry>
        <entry>adresses MAC</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

   <para>
    Lors du tri d'un type <type>inet</type> ou <type>cidr</type>,
    les adresses IPv4 apparaîtront toujours avant les adresses IPv6,
    y compris les adresses IPv4 encapsulées, comme
    ::10.2.3.4 or ::ffff::10.4.3.2.
   </para>


   <sect2 id="datatype-inet">
    <title><type>inet</type></title>

    <indexterm>
     <primary>inet (type de données)</primary>
    </indexterm>

    <para>
     Le type <type>inet</type> contient une adresse d'hôte IPv4 ou IPv6
     et, optionnellement, l'identité de son sous-réseau, le tout dans un
     seul champ. L'identité du sous-réseau est représentée en indiquant
     combien de bits de l'adresse hôte constituent l'adresse réseau
     (le <quote>masque réseau</quote>).
     Si le masque réseau est 32 et l'adresse de type IPV4,
     alors la valeur n'indique pas un sous-réseau, juste un hôte.
     En IPv6, la longueur de l'adresse est de 128 bits, si bien que 
     128 bits définissent une adresse réseau unique. Notez que si vous ne
     voulez utiliser que des adresses de réseau, il est préférable
     d'utiliser le type <type>cidr</type> plutôt que le type <type>inet</type>.
    </para>

    <para>
      Le format de saisie pour ce type est 
      <replaceable class="parameter">adresse/y</replaceable>
      où
      <replaceable class="parameter">adresse</replaceable>
      est une adresse IPv4 ou IPv6 et
      <replaceable class="parameter">y</replaceable>
      est le nombre de bits du masque réseau.
      Si <replaceable class="parameter">y</replaceable>
      est omis, alors le masque vaut 32 pour IPv4 et
      128 pour IPv6, et la valeur représente un hôte unique.
      À l'affichage, la portion
      <replaceable class="parameter">/y</replaceable>
      est supprimée si le masque réseau indique un hôte unique.
    </para>
   </sect2>

   <sect2 id="datatype-cidr">
    <title><type>cidr</></title>

    <indexterm>
     <primary>cidr</primary>
    </indexterm>

    <para>
     Le type <type>cidr</type> contient une spécification de réseau 
     IPv4 ou IPv6. L'entrée et la sortie suivent les conventions
     Classless Internet Domain Routing.
     Le format pour indiquer un réseau est <replaceable
     class="parameter">address/y</replaceable> où <replaceable
     class="parameter">address</replaceable> est le réseau représenté sous forme
     d'une adresse IPv4 ou IPv6 et <replaceable
     class="parameter">y</replaceable> est le nombre de bits du masque réseau.
     Si <replaceable class="parameter">y</replaceable> est omis, il calculé en
     utilisant les règles de l'ancien système de classes d'adresses,
     à ceci près qu'il sera au moins assez grand pour inclure tous
     les octets saisis. C'est une erreur de spécifier une adresse réseau
     avec des bits à droite du masque spécifié.
    </para>

    <para>
     <xref linkend="datatype-net-cidr-table"> donne des exemples.
    </para>

     <table id="datatype-net-cidr-table">
      <title>Exemples de saisie de types <type>cidr</></title>
      <tgroup cols="3">
       <thead> 
        <row> 
         <entry>Saisie de <type>cidr</type></entry>
         <entry>Affichage de <type>cidr</type></entry>
         <entry><literal><function>abbrev</function>(<type>cidr</type>)</literal></entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
   </sect2>

   <sect2 id="datatype-inet-vs-cidr">
    <title>Comparaison de <type>inet</type> et <type>cidr</type></title>

    <para>
    La différence principale entre les types de données <type>inet</type>
    et <type>cidr</type> est que <type>inet</type> accepte des valeurs avec
    des bits non nuls à la droite du masque de réseau, alors que <type>cidr</type>
    ne l'accepte pas.
    </para>

      <tip>
        <para>
        Si vous n'aimez pas le format d'affichage des valeurs
	<type>inet</type> et <type>cidr</type>, essayez les fonctions
	<function>host</>, <function>text</> et <function>abbrev</>.
        </para>
      </tip>
   </sect2>

   <sect2 id="datatype-macaddr">
    <title><type>macaddr</type></title>

    <indexterm>
     <primary>macaddr (type de données)</primary>
    </indexterm>

    <indexterm>
     <primary>adresse MAC</primary>
     <see>macaddr</see>
    </indexterm>

    <para>
     Le type <type>macaddr</type> stocke des adresses MAC, c'est-à-dire
     des adresses de cartes réseau Ethernet (mais les adresses MAC sont
     aussi utilisées dans d'autres cas). Les entrées sont acceptées dans
     de nombreux formats, dont&nbsp;:

     <simplelist>
      <member><literal>'08002b:010203'</literal></member>
      <member><literal>'08002b-010203'</literal></member>
      <member><literal>'0800.2b01.0203'</literal></member>
      <member><literal>'08-00-2b-01-02-03'</literal></member>
      <member><literal>'08:00:2b:01:02:03'</literal></member>
     </simplelist>

     qui indiquent tous la même adresse. Les majuscules et les minuscules sont
     acceptées pour les chiffres de <literal>a</literal> à <literal>f</literal>.
     L'affichage se fait toujours selon le dernier format.
    </para>

    <para>
     Le répertoire <filename class="directory">contrib/mac</filename>
     de la distribution des sources de <productname>PostgreSQL</productname>
     contient des outils peuvant être utilisés pour trouver les noms
     des fabricants des matériels liés aux adresses MAC.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-bit">
   <title>Type chaîne de bits</title>

   <indexterm zone="datatype-bit">
    <primary>chaîne de bits</primary>
    <secondary>type de données</secondary>
   </indexterm>

   <para>
    Les chaînes de bits sont des chaînes de 0 et de 1. Ils peuvent être
    utilisés pour stocker ou visualiser des masques de bits.
    Il y a deux types chaînes de bits SQL&nbsp;:
    <type>bit(<replaceable>n</replaceable>)</type> et <type>bit
    varying(<replaceable>n</replaceable>)</type>, où
    <replaceable>n</replaceable> est un entier positif.
   </para>

   <para>
    Les données de type <type>bit</type> doivent avoir une longueur de 
    <replaceable>n</replaceable> bits exactement. Essayer d'y affecter une
    chaîne de bits plus longue ou plus courte déclenche une erreur.
    Les données de type <type>bit varying</type> ont une longueur variable,
    mais ne peuvent dépasser une taille de <replaceable>n</replaceable> bits.
    Les chaînes plus longues sont rejetées.
    Écrire <type>bit</type> sans longueur est équivalent à 
    <literal>bit(1)</literal>, alors que <type>bit varying</type> sans
    longueur indique une taille illimitée.
   </para>

   <note>
    <para>
     Lors d'une conversion explicite (cast) d'une chaîne de bits vers un
     champ de type <type>bit(<replaceable>n</replaceable>)</type>, la chaîne
     obtenue sera complétée avec des zéros ou bien tronquée pour obtenir une
     taille de <replaceable>n</replaceable> bits exactement, sans que cela
     produise une erreur. De la même façon, si une chaîne de bits est
     explicitement convertie vers un champ de type <type>bit
     varying(<replaceable>n</replaceable>)</type>, elle sera tronquée si elle
     fait plus de <replaceable>n</replaceable> bits.
    </para>
   </note>

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 7.2, les données de type <type>bit</type>
     étaient toujours tronquées (ou complétées avec des zéros) silencieusement,
     que la conversion soit explicite ou non. Ce comportement a été modifié
     pour se conformer au standard <acronym>SQL</acronym>.
    </para>
   </note>

   <para>
    Voir la <xref linkend="sql-syntax-bit-strings"> pour plus d'information sur
    la syntaxe des constantes de chaînes de bits.
    Les opérateurs logiques bit à bit et les manipulations de chaînes de bits
    sont décrits dans la <xref linkend="functions-bitstring">.
   </para>

   <example>
    <title>Utilisation des types de chaînes de bits</title>

<programlisting>
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  bit string length 2 does not match type bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-----+-----
 101 | 00
 100 | 101
</computeroutput>
</programlisting>
   </example>

  </sect1>

  &array;

  &rowtypes;

  <sect1 id="datatype-oid">
   <title>Types identifiants d'objets</title>

   <indexterm zone="datatype-oid">
    <primary>identifiant d'objet</primary>
    <secondary>type de données</secondary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>oid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regproc</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regprocedure</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoper</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoperator</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regclass</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regtype</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>xid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>cid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>tid</primary>
   </indexterm>

   <para>
    Les identifiants d'objets (OID) sont utilisés en interne par
    <productname>PostgreSQL</productname> comme clés primaires de
    différentes tables système. Les OID ne sont pas ajoutés aux tables
    créées par l'utilisateur sauf si <literal>WITH OIDS</literal> est spécifié
    lors de la création de la table ou si la variable de configuration
    <xref linkend="guc-default-with-oids"> est activée. Le type <type>oid</>
    représente un identifiant d'objet. Il a aussi différents types alias pour
    le type <type>oid</>&nbsp;: <type>regproc</>, <type>regprocedure</>,
    <type>regoper</>, <type>regoperator</>, <type>regclass</> et
    <type>regtype</>. Le <xref linkend="datatype-oid-table"> donne un aperçu.
   </para>

   <para>
    Le type <type>oid</type> est actuellement un entier de quatre octets.
    Il n'est pas suffisamment grand pour garantir l'unicité dans une
    grosse base de données, voire même dans une très grosse table. Du coup,
    l'utilisation d'une colonne OID comme clé primaire d'une table créée
    par un utilisateur est déconseillée. Les OID sont surtout destinés à être
    des références vers les tables système.
   </para>

   <para>
    Le type <type>oid</type> lui-même dispose de peu d'opérations à part la
    comparaison. Néanmoins, il peut être converti en entier (integer)
    et manipulé en utilisant les opérateurs habituels des entiers
    (attention aux possibles confusions entre les entiers signés et non
    signés si vous le faites).
   </para>

   <para>
	Les types alias de l'OID n'ont pas d'opérations à eux sauf pour les
	routines spécialisées en entrée et en sortie. Ces routines sont capables
	d'accepter et d'afficher des noms symboliques pour les objets systèmes,
	plutôt que la valeur numérique brute que le type <type>oid</>
	utiliserait. Les types alias permettent de simplifier la recherche des
	valeurs OID pour les objets. Par exemple, pour examiner les lignes
	<structname>pg_attribute</> en relation avec une table 
	<literal>ma_table</>, vous pourriez écrire
<programlisting>
SELECT * FROM pg_attribute WHERE attrelid = 'ma_table'::regclass;
</programlisting>
    plutôt que
<programlisting>
SELECT * FROM pg_attribute
WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'ma_table');
</programlisting>
    Bien que cela ne semble pas si difficile, c'est toujours trop simplifié.
    Une sous-sélection bien plus compliqué peut être nécessaire pour sélectionner
    le bon OID s'il existe plusieurs tables nommées <literal>ma_table</> dans
    différents schémas. Le convertisseur d'entrées <type>regclass</> gère la
    recherche de la table suivant le paramétrage du chemin des schémas et il
    fera donc la <quote>bonne recherche</> automatiquement. De façon
    similaire, convertir un OID d'une table en <type>regclass</> est facile
    pour l'affichage symbolique d'un OID numérique.
   </para>

    <table id="datatype-oid-table">
     <title>Types identifiants d'objet</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Référence</entry>
        <entry>Description</entry>
        <entry>Exemple</entry>
       </row>
      </thead>

      <tbody>

       <row>
        <entry><type>oid</></entry>
        <entry>tous</entry>
        <entry>identifiant d'objet numérique</entry>
        <entry><literal>564182</></entry>
       </row>

       <row>
        <entry><type>regproc</></entry>
        <entry><structname>pg_proc</></entry>
        <entry>nom de fonction</entry>
        <entry><literal>sum</></entry>
       </row>

       <row>
        <entry><type>regprocedure</></entry>
        <entry><structname>pg_proc</></entry>
        <entry>fonction avec les types d'arguments</entry>
        <entry><literal>sum(int4)</></entry>
       </row>

       <row>
        <entry><type>regoper</></entry>
        <entry><structname>pg_operator</></entry>
        <entry>nom d'opérateur</entry>
        <entry><literal>+</></entry>
       </row>

       <row>
        <entry><type>regoperator</></entry>
        <entry><structname>pg_operator</></entry>
        <entry>opérateur avec types d'arguments</entry>
        <entry><literal>*(integer,integer)</> ou <literal>-(NONE,integer)</></entry>
       </row>

       <row>
        <entry><type>regclass</></entry>
        <entry><structname>pg_class</></entry>
        <entry>nom de relation</entry>
        <entry><literal>pg_type</></entry>
       </row>

       <row>
        <entry><type>regtype</></entry>
        <entry><structname>pg_type</></entry>
        <entry>nom de type de données</entry>
        <entry><literal>integer</></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Tous les types alias d'OID acceptent des noms avec un préfixe de schéma,
    et affichent des noms préfixés par un schéma si l'objet ne peut être 
trouvé dans le chemin de recherche courant sans préfixe de schéma.
    Les types alias <type>regproc</type> et <type>regoper</type> n'acceptent que des
    noms uniques en entrée (sans surcharge), si bien qu'ils sont d'un usage
    limité. Dans la plupart des cas, <type>regprocedure</type> ou
    <type>regoperator</type> sont plus appropriés. Pour <type>regoperator</type>,
    les opérateurs unaires sont identifiés en écrivant <literal>NONE</literal> pour
    les opérandes non utilisés.
   </para>

   <para>
    Une propriété supplémentaire des types d'alias OID est que, si une
    constante d'un de ces types apparaît dans une expression stockée
    (comme l'expression par défaut d'une colonne ou une vue), elle crée une
    dépendance sur l'objet référencé. Par exemple, si une colonne a une
    expression par défaut <literal>nextval('ma_seq'::regclass)</>,
    <productname>PostgreSQL</productname> comprend que l'expression par
    défaut dépend de la séquence <literal>ma_seq</>&nbsp;; le système ne
    permettra pas la suppression de la séquence sans que l'expression par
    défaut ne soit elle-même supprimée.
   </para>

   <para>
    Un autre type d'identifiant utilisé par le système est <type>xid</type>, ou
    identifiant de transaction (abrégé <abbrev>xact</abbrev>).
    C'est le type de données des colonnes systèmes <structfield>xmin</structfield> et
    <structfield>xmax</structfield>. Les identifiants de transactions sont des
    quantités sur 32 bits.
   </para>

   <para>
    Un troisième type d'identifiant utilisé par le système est <type>cid</type>,
    ou identifiant de commande. C'est le type de données des colonnes systèmes
    <structfield>cmin</structfield> et <structfield>cmax</structfield>. Les identifiants de commandes
    sont aussi des quantités sur 32 bits.
   </para>

   <para>
    Un dernier type d'identifiant utilisé par le système est <type>tid</type>,
    ou identifiant de ligne (tuple). C'est le type de données
    des colonnes système <structfield>ctid</structfield>. Un tuple est une paire
    (numéro de bloc, index de tuple dans le bloc) qui identifie l'emplacement
    physique de la ligne dans sa table.
   </para>

   <para>
    Les colonnes systèmes sont expliquées plus en détail dans la <xref
    linkend="ddl-system-columns">.
   </para>
  </sect1>

  <sect1 id="datatype-pseudo">
   <title>Pseudo-Types</title>

   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyelement</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>language_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>opaque</primary>
   </indexterm>

   <para>
    Le système de types de <productname>PostgreSQL</productname>
    contient un certain nombre de types à usage spécial qui sont
    collectivement appelés des <firstterm>pseudo-types</firstterm>. Un
    pseudo-type ne peut être utilisé pour une colonne de table, mais il peut
    être utilisé pour déclarer un argument de fonction ou un type 
    de résultat. Chacun des pseudo-types disponibles est utile dans des
    situations où le comportement d'une fonction ne correspond pas simplement
    à accepter ou retourner des valeurs d'un type de données
    <acronym>SQL</acronym> spécifique. Le <xref
    linkend="datatype-pseudotypes-table"> liste les pseudo-types existants.
   </para>

    <table id="datatype-pseudotypes-table">
     <title>Pseudo-Types</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>any</type></entry>
        <entry>
         Indique qu'une fonction accepte n'importe quel type de données,
         quel qu'il soit.
        </entry>
       </row>

       <row>
        <entry><type>anyarray</type></entry>
        <entry>
         Indique qu'une fonction accepte tout type tableau (voir la
         <xref linkend="extend-types-polymorphic">).
        </entry>
       </row>

       <row>
        <entry><type>anyelement</type></entry>
        <entry>Indique qu'une fonction accepte tout type de données.
        (voir la <xref linkend="extend-types-polymorphic">).</entry>
       </row>

       <row>
        <entry><type>cstring</type></entry>
        <entry>Indique qu'une fonction accepte ou retourne une chaîne de caractères
         du langage C (terminée par un NULL).</entry>
       </row>

       <row>
        <entry><type>internal</type></entry>
        <entry>Indique qu'une fonction accepte ou retourne un type de données
         interne du serveur de bases de données.</entry>
       </row>

       <row>
        <entry><type>language_handler</type></entry>
        <entry>Une fonction d'appel de langage procédural est déclarée retourner
	 un <type>language_handler</>.</entry>
       </row>

       <row>
        <entry><type>record</type></entry>
        <entry>Identifie une fonction qui retourne un type de ligne non spécifié.</entry>
       </row>

       <row>
        <entry><type>trigger</type></entry>
        <entry>Une fonction trigger est déclarée comme retournant un type
	 <type>trigger</>.</entry>
       </row>

       <row>
        <entry><type>void</type></entry>
        <entry>Indique qu'une fonction ne retourne pas de valeur.</entry>
       </row>

       <row>
        <entry><type>opaque</type></entry>
        <entry>Un type de données obsolète qui servait précédemment à tous les
	 usages cités ci-dessus.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Les fonctions codées en C (incluses dans le produit ou chargées dynamiquement)
    peuvent déclarer, accepter ou retourner chacun de ces pseudo-types. Il est de
    la responsabilité de l'auteur de la fonction de s'assurer que la fonction se
    comporte normalement lorsqu'un pseudo-type est utilisé comme type d'argument.
   </para>

   <para>
    Les fonctions codées en langage procédural peuvent utiliser les
    pseudo-types si leur langage le permet. À ce jour, tous les langages
    interdisent l'usage d'un pseudo-type comme argument, et n'acceptent que
    <type>void</type> et <type>record</type> comme type retourné (plus <type>trigger</type>
    lorsque la fonction est utilisée comme trigger).
    Certains supportent aussi les fonctions polymorphes en utilisant les 
    types <type>anyarray</type> et <type>anyelement</type>.
   </para>

   <para>
    Le pseudo-type <type>internal</type> sert à déclarer des fonctions qui
    ne sont appelées que par la base de données en interne,
    et non pas directement par une requête <acronym>SQL</acronym>.
    Si une fonction a au moins un argument de type <type>internal</type>,
    alors elle ne peut être appelée depuis <acronym>SQL</acronym>.
    Pour préserver la sécurité de cette restriction, il est important de
    suivre cette règle de codage: ne créez pas de fonction qui retourne un
    <type>internal</type> si elle n'a pas au moins un argument de type
    <type>internal</type>.
   </para>

  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-tabs-mode:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/share/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->


