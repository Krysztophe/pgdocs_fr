<sect1 id="dblink">
 <title>dblink</title>
 
 <indexterm zone="dblink">
  <primary>dblink</primary>
 </indexterm>

 <para>
  <literal>dblink</literal> est un module qui permet la connexion à d'autres
  bases de données.
 </para>

 <refentry id="CONTRIB-DBLINK-CONNECT">
  <refnamediv>
   <refname>dblink_connect</refname>
   <refpurpose>ouvre une connexion persistante vers une base de données
    distante</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
    dblink_connect(text connstr)
    dblink_connect(text connname, text connstr)
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>connname</title>
    <para>
     Si deux arguments sont donnés, le premier est utilisé comme nom pour la
     connexion persistante.
    </para>
   </refsect2>
 
   <refsect2>
    <title>connstr</title>
    <para>
     Chaîne de connexion au format standard de la libpq, par exemple
     <literal>hostaddr=127.0.0.1 port=5432 dbname=mabase user=postgres password=monmotdepasse</literal>
    </para>
    <para>
     Si un seul argument est donné, la connexion n'a pas de nom. Attention,
     seule une connexion sans nom peut exister à un instant t.
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie le statut = "OK"</para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 select dblink_connect('dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)
 
 select dblink_connect('myconn','dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)
   </programlisting>
  </refsect1>
 </refentry> 

 <refentry id="CONTRIB-DBLINK-DISCONNECT">
  <refnamediv>
   <refname>dblink_disconnect</refname>
   <refpurpose>ferme une connexion persistante vers une base de données
    distantes</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_disconnect()
 dblink_disconnect(text connname)
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>connname</title>
    <para>
     Si un argument est donné, il est utilisé comme nom de la connexion
     persistante à fermer&nbsp;; sinon la connexion sans nom est fermée.
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie le statut = "OK"</para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 test=# select dblink_disconnect();
  dblink_disconnect
 -------------------
  OK
 (1 row)
 
 select dblink_disconnect('myconn');
  dblink_disconnect
 -------------------
  OK
 (1 row)
   </programlisting>
  </refsect1>
 </refentry> 

 <refentry id="CONTRIB-DBLINK-OPEN">
  <refnamediv>
   <refname>dblink_open</refname>
   <refpurpose>ouvre un curseur vers une base de données distante</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_open(text cursorname, text sql [, bool fail_on_error])
 dblink_open(text connname, text cursorname, text sql [, bool fail_on_error])
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Argument</title>
 
   <refsect2>
    <title>connname</title>
    <para>
     Si trois arguments sont présents, le premier est utilisé comme nom de la
     connexion&nbsp;; sinon, la connexion sans nom est utilisée.
    </para>
   </refsect2>
 
   <refsect2>
    <title>cursorname</title>
    <para>
     Un nom de référence pour le curseur.
    </para>
   </refsect2>
 
   <refsect2>
    <title>sql</title>
    <para>
     L'instruction SQL à exécuter sur l'hôte distant, par exemple
     <literal>select * from pg_class</literal>
    </para>
   </refsect2>
 
   <refsect2>
    <title>fail_on_error</title>
    <para>
     Si true (la valeur par défaut si elle n'est pas précisée), un message
     de type ERROR sur la base distante cause l'envoi d'un message de type
     ERROR en local. Dans le cas contraire, le message distant de type ERROR
     est traité localement comme un NOTICE, et la valeur renvoyée est
     'ERROR'.
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie le statut = "OK"</para>
  </refsect1>
 
  <refsect1>
   <title>Note</title>
   <itemizedlist>
    <listitem>
     <para>
      dblink_connect(text connstr) doit d'abord être exécuté.
     </para>
    </listitem>
    <listitem>
     <para>
      dblink_open lance une transaction explicite. Si, après avoir utilisé
      dblink_open, vous utilisez dblink_exec pour modifier les données et
      qu'une erreur survient ou que vous utilisez dblink_disconnect sans
      avoir utilisé précédemment dblink_close, vos modifications seront
      perdues. De plus, utiliser dblink_close explicitement termine la
      transaction et, du coup, ferme en fait tous les curseurs ouverts.
     </para>
    </listitem>
   </itemizedlist>
 
  </refsect1>
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 test=# select dblink_connect('dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)
 
 test=# select dblink_open('foo','select proname, prosrc from pg_proc');
  dblink_open
 -------------
  OK
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-FETCH">
  <refnamediv>
   <refname>dblink_fetch</refname>
   <refpurpose>renvoie un ensemble à partir d'un curseur ouvert sur une
    base de données distante</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_fetch(text cursorname, int32 howmany [, bool fail_on_error])
 dblink_fetch(text connname, text cursorname, int32 howmany [, bool fail_on_error])
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>connname</title>
    <para>
     Si trois arguments sont présents, le premier est utilisé comme nom de
     la connexion&nbsp;; sinon la connexion sans nom est utilisée.
    </para>
   </refsect2>
 
   <refsect2>
    <title>cursorname</title>
    <para>
     Le nom de référence pour le curseur
    </para>
   </refsect2>
 
   <refsect2>
    <title>howmany</title>
    <para>
     Nombre maximum de lignes à récupérer. Les howmany lignes suivantes sont
     récupérées, en commençant à la position actuelle du curseur, vers l'avant.
     Une fois le curseur positionné à la fin, aucune ligne ne sera renvoyée.
    </para>
   </refsect2>
 
   <refsect2>
    <title>fail_on_error</title>
    <para>
     Si true (la valeur par défaut si elle n'est pas précisée), un message
     de type ERROR sur la base distante cause l'envoi d'un message de type
     ERROR en local. Dans le cas contraire, le message distant de type ERROR
     est traité localement comme un NOTICE, et la valeur renvoyée est
     'ERROR'.
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie setof record</para>
  </refsect1>
 
  <refsect1>
   <title>Note</title>
   <para>
    Si le nombre de champs spécifiés dans la clause FROM et celui renvoyés
    par le curseur distant ne correspondent pas, un message de type ERROR
    est envoyé. Dans ce cas, le curseur distant est bien avancé du nombre
    de lignes demandés.
   </para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 test=# select dblink_connect('dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)
 
 test=# select dblink_open('foo','select proname, prosrc from pg_proc where proname like ''bytea%''');
  dblink_open
 -------------
  OK
 (1 row)
 
 test=# select * from dblink_fetch('foo',5) as (funcname name, source text);
  funcname |  source
 ----------+----------
  byteacat | byteacat
  byteacmp | byteacmp
  byteaeq  | byteaeq
  byteage  | byteage
  byteagt  | byteagt
 (5 rows)
 
 test=# select * from dblink_fetch('foo',5) as (funcname name, source text);
  funcname  |  source
 -----------+-----------
  byteain   | byteain
  byteale   | byteale
  bytealike | bytealike
  bytealt   | bytealt
  byteane   | byteane
 (5 rows)
 
 test=# select * from dblink_fetch('foo',5) as (funcname name, source text);
   funcname  |   source
 ------------+------------
  byteanlike | byteanlike
  byteaout   | byteaout
 (2 rows)
 
 test=# select * from dblink_fetch('foo',5) as (funcname name, source text);
  funcname | source
 ----------+--------
 (0 rows)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CLOSE">
  <refnamediv>
   <refname>dblink_close</refname>
   <refpurpose>ferme un curseur sur une base de données distante</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_close(text cursorname [, bool fail_on_error])
 dblink_close(text connname, text cursorname [, bool fail_on_error])
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>connname</title>
    <para>
     Si deux arguments sont présents, le premier est utilisé pour le nom de
     connexion&nbsp;; sinon la connexion sans nom est utilisée.
    </para>
   </refsect2>
 
   <refsect2>
    <title>cursorname</title>
    <para>
     Le nom de référence pour le curseur.
    </para>
   </refsect2>
 
   <refsect2>
    <title>fail_on_error</title>
    <para>
     Si true (la valeur par défaut si elle n'est pas précisée), un message
     de type ERROR sur la base distante cause l'envoi d'un message de type
     ERROR en local. Dans le cas contraire, le message distant de type ERROR
     est traité localement comme un NOTICE, et la valeur renvoyée est
     'ERROR'.
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie le statut = "OK"</para>
  </refsect1>
 
  <refsect1>
   <title>Note</title>
   <para>
   dblink_connect(text connstr) ou dblink_connect(text connname, text connstr)
   doivent être exécutés en premier.
   </para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 test=# select dblink_connect('dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)
 
 test=# select dblink_open('foo','select proname, prosrc from pg_proc');
  dblink_open
 -------------
  OK
 (1 row)
 
 test=# select dblink_close('foo');
  dblink_close
 --------------
  OK
 (1 row)
 
 select dblink_connect('myconn','dbname=regression');
  dblink_connect
 ----------------
  OK
 (1 row)
 
 select dblink_open('myconn','foo','select proname, prosrc from pg_proc');
  dblink_open
 -------------
  OK
 (1 row)
 
 select dblink_close('myconn','foo');
  dblink_close
 --------------
  OK
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-EXEC">
  <refnamediv>
   <refname>dblink_exec</refname>
   <refpurpose>exécute un UPDATE/INSERT/DELETE sur une base de données
    distante</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_exec(text connstr, text sql [, bool fail_on_error])
 dblink_exec(text connname, text sql [, bool fail_on_error])
 dblink_exec(text sql [, bool fail_on_error])
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>connname/connstr</title>
    <para>
     Si deux arguments sont présents, le premier est utilisé comme nom de
     connexion. Si le nom n'est pas trouvé, l'argument est pris pour une
     chaîne de connexion au format standard de libpq, par exemple
     <literal>hostaddr=127.0.0.1 dbname=mabase user=postgres password=monmotdepasse</literal>
     Si un seul argument est utilisé, alors la connexion sans nom est prise
     en compte.
    </para>
   </refsect2>
   
   <refsect2>
    <title>sql</title>
    <para>
     Une instruction SQL que vous souhaitez exécuter sur l'hôte distant, par
     exemple&nbsp;: insert into foo values(0,'a','{"a0","b0","c0"}');
    </para>
   </refsect2>
   <refsect2>
    <title>fail_on_error</title>
    <para>
     Si true (la valeur par défaut si elle n'est pas précisée), un message
     de type ERROR sur la base distante cause l'envoi d'un message de type
     ERROR en local. Dans le cas contraire, le message distant de type ERROR
     est traité localement comme un NOTICE, et la valeur renvoyée est
     'ERROR'.
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie le statut de la commande ou 'ERROR' en cas d'échec.</para>
  </refsect1>
 
  <refsect1>
   <title>Notes</title>
   <para>
    dblink_open lance une transaction explicite. Si, après avoir utilisé
    dblink_open, vous utilisez dblink_exec pour modifier vos données et qu'une
    erreur survient ou que vous utilisez dblink_disconnect sans utiliser
    dblink_close en premier, vos modifications seront perdues.
   </para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 select dblink_connect('dbname=dblink_test_slave');
  dblink_connect
 ----------------
  OK
 (1 row)
 
 select dblink_exec('insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
    dblink_exec
 -----------------
  INSERT 943366 1
 (1 row)
 
 select dblink_connect('myconn','dbname=regression');
  dblink_connect
 ----------------
  OK
 (1 row)
 
 select dblink_exec('myconn','insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
    dblink_exec
 ------------------
  INSERT 6432584 1
 (1 row)
 
 select dblink_exec('myconn','insert into pg_class values (''foo'')',false);
 NOTICE:  sql error
 DETAIL:  ERROR:  null value in column "relnamespace" violates not-null constraint
 
  dblink_exec
 -------------
  ERROR
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CURRENT-QUERY">
  <refnamediv>
   <refname>dblink_current_query</refname>
   <refpurpose>renvoie la requête en cours</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_current_query () RETURNS text
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Argument</title>
 
   <refsect2>
    <title>Aucun</title>
    <para>
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie test -- une copie de la requête en cours d'exécution</para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 test=# select dblink_current_query() from (select dblink('dbname=postgres','select oid, proname from pg_proc where proname = ''byteacat''') as f1) as t1;
                                                                 dblink_current_query
 -----------------------------------------------------------------------------------------------------------------------------------------------------
  select dblink_current_query() from (select dblink('dbname=postgres','select oid, proname from pg_proc where proname = ''byteacat''') as f1) as t1;
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-PKEY">
  <refnamediv>
   <refname>dblink_get_pkey</refname>
   <refpurpose>renvoie la position et le nom des champs de clé primaire
    d'une relation.
   </refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_get_pkey(text relname) RETURNS setof dblink_pkey_results
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>relname</title>
    <para>
     tout nom de relation&nbsp;; 
     par exemple 'foobar'
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>
    Renvoie un ensemble (setof) de dblink_pkey_results -- une ligne pour chaque
    champ de la clé primaire, dans son ordre dans la clé.
    dblink_pkey_results est défini ainsi&nbsp;:
    CREATE TYPE dblink_pkey_results AS (position int4, colname text);
   </para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 test=# select * from dblink_get_pkey('foobar');
  position | colname
 ----------+---------
         1 | f1
         2 | f2
         3 | f3
         4 | f4
         5 | f5
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-INSERT">
  <refnamediv>
   <refname>dblink_build_sql_insert</refname>
   <refpurpose>
    construit une instruction d'insertion en utilisant une ligne locale,
    remplaçant les valeurs des champs de la clé primaire pour la sélection
    avec les valeurs fournies
   </refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_build_sql_insert(text relname
                          ,int2vector primary_key_attnums
                          ,int2 num_primary_key_atts
                          ,_text src_pk_att_vals_array
                          ,_text tgt_pk_att_vals_array) RETURNS text
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>relname</title>
    <para>
     tout nom de relation&nbsp;;
     par exemple 'foobar'
    </para>
   </refsect2>
   <refsect2>
    <title>primary_key_attnums</title>
    <para>
     vecteur de la clé primaire (commençant à 1, voir pg_index.indkey)&nbsp;;
     par exemple '1 2'
    </para>
   </refsect2>
   <refsect2>
    <title>num_primary_key_atts</title>
    <para>
     nombre d'attributs de la clé primaire dans le vecteur&nbsp;; par
     exemple, 2
    </para>
   </refsect2>
   <refsect2>
    <title>src_pk_att_vals_array</title>
    <para>
     tableau des valeurs de la clé primaire, utilisé pour recherche la
     ligne locale correspondante, valeurs qui sont utilisées pour construire
     l'instruction SQL
    </para>
   </refsect2>
   <refsect2>
    <title>tgt_pk_att_vals_array</title>
    <para>
     tableau des valeurs de la clé primaire, utilisé pour remplacer les valeurs
     de la ligne locale dans l'instruction SQL
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie du texte -- l'instruction SQL demandée</para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 test=# select dblink_build_sql_insert('foo','1 2',2,'{"1", "a"}','{"1", "b''a"}');
              dblink_build_sql_insert
 --------------------------------------------------
  INSERT INTO foo(f1,f2,f3) VALUES('1','b''a','1')
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-DELETE">
  <refnamediv>
   <refname>dblink_build_sql_delete</refname>
   <refpurpose>
    construit une instruction de suppression en utilisant une ligne locale,
    remplaçant les valeurs des champs de la clé primaire pour la sélection
    avec les valeurs fournies
   </refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_build_sql_delete(text relname
                          ,int2vector primary_key_attnums
                          ,int2 num_primary_key_atts
                          ,_text tgt_pk_att_vals_array) RETURNS text
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>relname</title>
    <para>
     tout nom de relation&nbsp;;
     par exemple 'foobar'
    </para>
   </refsect2>
   <refsect2>
    <title>primary_key_attnums</title>
    <para>
     vecteur de la clé primaire (commençant à 1, voir pg_index.indkey)&nbsp;;
     par exemple '1 2'
    </para>
   </refsect2>
   <refsect2>
    <title>num_primary_key_atts</title>
    <para>
     nombre d'attributs de la clé primaire dans le vecteur&nbsp;; par
     exemple, 2
    </para>
   </refsect2>
   <refsect2>
    <title>src_pk_att_vals_array</title>
    <para>
     tableau des valeurs de la clé primaire, utilisé pour recherche la
     ligne locale correspondante, valeurs qui sont utilisées pour construire
     l'instruction SQL
    </para>
   </refsect2>
   <refsect2>
    <title>tgt_pk_att_vals_array</title>
    <para>
     tableau des valeurs de la clé primaire, utilisé pour remplacer les valeurs
     de la ligne locale dans l'instruction SQL
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie du texte -- l'instruction SQL demandée</para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 test=# select dblink_build_sql_delete('MyFoo','1 2',2,'{"1", "b"}');
            dblink_build_sql_delete
 ---------------------------------------------
  DELETE FROM "MyFoo" WHERE f1='1' AND f2='b'
 (1 row)
   </programlisting>
  </refsect1>
 </refentry> 

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-UPDATE">
  <refnamediv>
   <refname>dblink_build_sql_update</refname>
   <refpurpose>
    construit une instruction de mise à jour en utilisant une ligne locale,
    remplaçant les valeurs des champs de la clé primaire pour la sélection
    avec les valeurs fournies
   </refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_build_sql_update(text relname
                          ,int2vector primary_key_attnums
                          ,int2 num_primary_key_atts
                          ,_text src_pk_att_vals_array
                          ,_text tgt_pk_att_vals_array) RETURNS text
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>relname</title>
    <para>
     tout nom de relation&nbsp;;
     par exemple 'foobar'
    </para>
   </refsect2>
   <refsect2>
    <title>primary_key_attnums</title>
    <para>
     vecteur de la clé primaire (commençant à 1, voir pg_index.indkey)&nbsp;;
     par exemple '1 2'
    </para>
   </refsect2>
   <refsect2>
    <title>num_primary_key_atts</title>
    <para>
     nombre d'attributs de la clé primaire dans le vecteur&nbsp;; par
     exemple, 2
    </para>
   </refsect2>
   <refsect2>
    <title>src_pk_att_vals_array</title>
    <para>
     tableau des valeurs de la clé primaire, utilisé pour recherche la
     ligne locale correspondante, valeurs qui sont utilisées pour construire
     l'instruction SQL
    </para>
   </refsect2>
   <refsect2>
    <title>tgt_pk_att_vals_array</title>
    <para>
     tableau des valeurs de la clé primaire, utilisé pour remplacer les valeurs
     de la ligne locale dans l'instruction SQL
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie du texte -- l'instruction SQL demandée</para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 test=# select dblink_build_sql_update('foo','1 2',2,'{"1", "a"}','{"1", "b"}');
                    dblink_build_sql_update
 -------------------------------------------------------------
  UPDATE foo SET f1='1',f2='b',f3='1' WHERE f1='1' AND f2='b'
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-CONNECTIONS">
  <refnamediv>
   <refname>dblink_get_connections</refname>
   <refpurpose>renvoie un tableau de type texte de toutes les connexions
    nommées et actives de dblink
   </refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_get_connections() RETURNS text[]
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>Aucun</title>
    <para></para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie un tableau de texte de toutes les connexions nommées et
   actives de dblink</para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
   SELECT dblink_get_connections();
   </programlisting>
  </refsect1>
 </refentry> 

 <refentry id="CONTRIB-DBLINK-IS-BUSY">
  <refnamediv>
   <refname>dblink_is_busy</refname>
   <refpurpose>vérifie si la connexion nommée est occupée avec une requête
    asynchrone</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_is_busy(text connname) RETURNS int
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>connname</title>
    <para>
     Le nom de la connexion à utiliser.
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>
    Renvoie 1 si la connexion est occupée, 0 dans le cas contraire.
    Si cette fonction renvoie 0, il est garanti que dblink_get_result ne
    bloquera pas.
   </para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
   SELECT dblink_is_busy('dtest1');
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CANCEL-QUERY">
  <refnamediv>
   <refname>dblink_cancel_query</refname>
   <refpurpose>annule toute requête en cours d'exécution sur la connexion
    nommée</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_cancel_query(text connname) RETURNS text
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>connname</title>
    <para>
     Le nom de la connexion à utiliser.
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>
    Renvoie "OK" en cas de succès, un message d'erreur en cas d'échec.
   </para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
    SELECT dblink_cancel_query('dtest1');
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-ERROR-MESSAGE">
  <refnamediv>
   <refname>dblink_error_message</refname>
   <refpurpose>récupère le dernier message d'erreur sur la connexion
    nommée</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_error_message(text connname) RETURNS text
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>connname</title>
    <para>
     Le nom de la connexion à utiliser.
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>
    Renvoie le dernier message d'erreur.
   </para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
    SELECT dblink_error_message('dtest1');
   </programlisting>
  </refsect1>
 </refentry> 

 <refentry id="CONTRIB-DBLINK">
  <refnamediv>
   <refname>dblink</refname>
   <refpurpose>renvoie un ensemble à partir d'une base de données
    distante</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink(text connstr, text sql [, bool fail_on_error])
 dblink(text connname, text sql [, bool fail_on_error])
 dblink(text sql [, bool fail_on_error])
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>connname/connstr</title>
    <para>
     Si deux arguments sont présents, le premier est utilisé comme nom de
     connexion. Si le nom n'est pas trouvé, l'argument est pris pour une
     chaîne de connexion au format standard de libpq, par exemple
     <literal>hostaddr=127.0.0.1 dbname=mabase user=postgres password=monmotdepasse</literal>
     Si un seul argument est utilisé, alors la connexion sans nom est prise
     en compte.
    </para>
   </refsect2>
 
   <refsect2>
    <title>sql</title>
    <para>
     L'instruction SQL à exécuter sur l'hôte distant, par exemple
     <literal>select * from pg_class</literal>
    </para>
   </refsect2>
   <refsect2>
    <title>fail_on_error</title>
    <para>
     Si true (la valeur par défaut si elle n'est pas précisée), un message
     de type ERROR sur la base distante cause l'envoi d'un message de type
     ERROR en local. Dans le cas contraire, le message distant de type ERROR
     est traité localement comme un NOTICE, et aucune ligne n'est renvoyée.
    </para>
   </refsect2>
   <refsect2>
    <title></title>
    <para>
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie un ensemble d'enregistrements (setof record).</para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 select * from dblink('dbname=postgres','select proname, prosrc from pg_proc')
  as t1(proname name, prosrc text) where proname like 'bytea%';
   proname   |   prosrc
 ------------+------------
  byteacat   | byteacat
  byteaeq    | byteaeq
  bytealt    | bytealt
  byteale    | byteale
  byteagt    | byteagt
  byteage    | byteage
  byteane    | byteane
  byteacmp   | byteacmp
  bytealike  | bytealike
  byteanlike | byteanlike
  byteain    | byteain
  byteaout   | byteaout
 (12 rows)
 
 select dblink_connect('dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)
 
 select * from dblink('select proname, prosrc from pg_proc')
  as t1(proname name, prosrc text) where proname like 'bytea%';
   proname   |   prosrc
 ------------+------------
  byteacat   | byteacat
  byteaeq    | byteaeq
  bytealt    | bytealt
  byteale    | byteale
  byteagt    | byteagt
  byteage    | byteage
  byteane    | byteane
  byteacmp   | byteacmp
  bytealike  | bytealike
  byteanlike | byteanlike
  byteain    | byteain
  byteaout   | byteaout
 (12 rows)
 
 select dblink_connect('myconn','dbname=regression');
  dblink_connect
 ----------------
  OK
 (1 row)
 
 select * from dblink('myconn','select proname, prosrc from pg_proc')
  as t1(proname name, prosrc text) where proname like 'bytea%';
   proname   |   prosrc
 ------------+------------
  bytearecv  | bytearecv
  byteasend  | byteasend
  byteale    | byteale
  byteagt    | byteagt
  byteage    | byteage
  byteane    | byteane
  byteacmp   | byteacmp
  bytealike  | bytealike
  byteanlike | byteanlike
  byteacat   | byteacat
  byteaeq    | byteaeq
  bytealt    | bytealt
  byteain    | byteain
  byteaout   | byteaout
 (14 rows)
   </programlisting>
   <para>
    Une façon plus agréable d'utiliser dblink pourrait être de créer une
    vue&nbsp;:
   </para>
   <programlisting>
    create view myremote_pg_proc as
    select *
    from dblink('dbname=postgres','select proname, prosrc from pg_proc')
    as t1(proname name, prosrc text);
   </programlisting>
   <para>
    De cette façon, vous pourrez écrire plus simplement&nbsp;:
   </para>
   <programlisting>
    select * from myremote_pg_proc where proname like 'bytea%';
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-SEND-QUERY">
  <refnamediv>
   <refname>dblink_send_query</refname>
   <refpurpose>envoie une requête asynchrone à une base de données
    distante</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
   dblink_send_query(text connname, text sql)
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>connname</title>
    <para>
     Le nom de la connexion à utiliser.
    </para>
   </refsect2>
   <refsect2>
    <title>sql</title>
    <para>
     L'instruction SQL à exécuter sur l'hôte distant, par exemple
     <literal>select * from pg_class</literal>
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>
    Renvoie un entier, 1 si la requête a bien été envoyée, 0 dans le cas
    contraire. Si 1, les résultats peuvent être récupérés par
    dblink_get_result(connname).
    Une requête en cours d'exécution peut être annulée par
    dblink_cancel_query(connname).
   </para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <para>
    <literal>
     SELECT dblink_connect('dtest1', 'dbname=contrib_regression');
     SELECT * FROM 
      dblink_send_query('dtest1', 'SELECT * FROM foo WHERE f1 &lt; 3') AS t1;
    </literal>
   </para>
  </refsect1>
 </refentry> 

 <refentry id="CONTRIB-DBLINK-GET-RESULT">
  <refnamediv>
   <refname>dblink_get_result</refname>
   <refpurpose>récupère le résultat d'une requête asynchrone</refpurpose>
  </refnamediv>
 
  <refsynopsisdiv>
   <synopsis>
 dblink_get_result(text connname [, bool fail_on_error])
   </synopsis>
  </refsynopsisdiv>
 
  <refsect1>
   <title>Arguments</title>
 
   <refsect2>
    <title>connname</title>
    <para>
     Le nom de connexion à utiliser. Une requête asynchrone doit déjà
     avoir été envoyée en utilisant dblink_send_query()
    </para>
   </refsect2>
   <refsect2>
    <title>fail_on_error</title>
    <para>
     Si true (la valeur par défaut si elle n'est pas précisée), un message
     de type ERROR sur la base distante cause l'envoi d'un message de type
     ERROR en local. Dans le cas contraire, le message distant de type ERROR
     est traité localement comme un NOTICE, et aucune ligne n'est renvoyée.
    </para>
   </refsect2>
  </refsect1>
 
  <refsect1>
   <title>Valeur de retour</title>
   <para>Renvoie un ensemble d'enregistrements (setof record)</para>
  </refsect1>
 
  <refsect1>
   <title>Notes</title>
   <para>
    Cette fonction se bloque jusqu'à l'obtention d'un résultat.
 
    Cette fonction doit être appelée si dblink_send_query a renvoyé 1, y
    compris sur des requêtes annulées - sinon la connexion ne peut être
    utilisée de nouveau. Elle doit être appelée une fois pour chaque
    requête envoyée et une fois de plus pour obrenir un ensemble de résultat
    vide avant de pouvoir ré-utiliser de nouveau la connexion.
   </para>
  </refsect1>
 
  <refsect1>
   <title>Exemple</title>
   <programlisting>
 contrib_regression=#   SELECT dblink_connect('dtest1', 'dbname=contrib_regression');
  dblink_connect
 ----------------
  OK
 (1 row)
 
 contrib_regression=#   SELECT * from
 contrib_regression-#    dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3') as t1;
  t1
 ----
   1
 (1 row)
 
 contrib_regression=#   SELECT * from dblink_get_result('dtest1') as t1(f1 int, f2 text, f3 text[]);
  f1 | f2 |     f3
 ----+----+------------
   0 | a  | {a0,b0,c0}
   1 | b  | {a1,b1,c1}
   2 | c  | {a2,b2,c2}
 (3 rows)
 
 contrib_regression=#   SELECT * from dblink_get_result('dtest1') as t1(f1 int, f2 text, f3 text[]);
  f1 | f2 | f3
 ----+----+----
 (0 rows)
 
 contrib_regression=#   SELECT * from
    dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3; select * from foo where f1 &gt; 6') as t1;
  t1
 ----
   1
 (1 row)
 
 contrib_regression=#   SELECT * from dblink_get_result('dtest1') as t1(f1 int, f2 text, f3 text[]);
  f1 | f2 |     f3
 ----+----+------------
   0 | a  | {a0,b0,c0}
   1 | b  | {a1,b1,c1}
   2 | c  | {a2,b2,c2}
 (3 rows)
 
 contrib_regression=#   SELECT * from dblink_get_result('dtest1') as t1(f1 int, f2 text, f3 text[]);
  f1 | f2 |      f3
 ----+----+---------------
   7 | h  | {a7,b7,c7}
   8 | i  | {a8,b8,c8}
   9 | j  | {a9,b9,c9}
  10 | k  | {a10,b10,c10}
 (4 rows)
 
 contrib_regression=#   SELECT * from dblink_get_result('dtest1') as t1(f1 int, f2 text, f3 text[]);
  f1 | f2 | f3
 ----+----+----
 (0 rows)
   </programlisting>
  </refsect1>
 </refentry>
</sect1>
