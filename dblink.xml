<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="dblink">
 <title>dblink</title>

 <indexterm zone="dblink">
  <primary>dblink</primary>
 </indexterm>

 <para>
  <filename>dblink</filename> est un module qui permet la connexion vers
  d'autres bases de données <productname>PostgreSQL</productname> à l'intérieur
  d'une session de base de données.
 </para>

 <refentry id="CONTRIB-DBLINK-CONNECT">
  <refnamediv>
   <refname>dblink_connect</refname>
   <refpurpose>ouvre une connexion persistante vers une base de données
    distante.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_connect(text connstr) returns text
    dblink_connect(text connname, text connstr) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_connect()</function> établit une connexion à une
    base de données <productname>PostgreSQL</productname> distante. Le
    serveur et la base de données à connecter sont identifiées par
    l'intermédiaire d'une chaine de caractères de connexion standard
    de la <application>libpq</application>. Un nom peut, en outre,
    être affecté optionnellement à la connexion. Il est possible
    d'ouvrir plusieurs connexions nommées en une seule fois, ce qui
    n'est pas le cas des connexions anonymes pour lesquelles une seule
    connexion peut être ouverte à la fois. Une connexion sera
    persistante jusqu'à ce qu'elle soit close ou que la session de
    base soit terminée.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom à utiliser pour cette connexion&nbsp;; en cas d'omission,
       une connexion sans nom est ouverte, remplaçant toute autre connexion
       sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <para>
       Chaîne de connexion au format standard de la
       <application>libpq</application>, par exemple
       <literal>hostaddr=127.0.0.1 port=5432 dbname=mabase user=postgres
       password=monmotdepasse</literal>.
       Pour les détails, voir <function>PQconnectdb</function> dans
       <xref linkend="libpq-connect"/>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie le statut qui est toujours <literal>OK</literal> (car toute
    erreur fait que la fonction bascule en mode erreur plutôt que de
    renvoyer quelque-chose).
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    Seuls les super-utilisateurs peuvent utiliser
    <function>dblink_connect</function> pour créer des connexions authentifiées
    sans mot de passe. Si des utilisateurs standards ont besoin de cette
    capacité, utilisez à la place la fonction
    <function>dblink_connect_u</function>.
   </para>

   <para>
    Il est déconseillé de choisir des noms de connexion contenant
    des signes d'égalité car ils peuvent introduire des risques de confusion
    avec les chaînes de connexion dans les autres fonctions
    <filename>dblink</filename>.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
 select dblink_connect('dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)

 select dblink_connect('myconn', 'dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CONNECT-U">
  <refnamediv>
   <refname>dblink_connect_u</refname>
   <refpurpose>ouvre une connexion distante à une base de données de
    façon non sécurisée.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_connect_u(text connstr) returns text
    dblink_connect_u(text connname, text connstr) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_connect_u()</function> est identique à
    <function>dblink_connect()</function>, sauf qu'elle permettra à des
    utilisateurs standards de se connecter en utilisant toute méthode
    d'authentification.
   </para>

   <para>
    Si le serveur distant sélectionne une méthode d'authentification qui
    n'implique pas de mot de passe, une impersonnalisation et une escalade
    de droits peut survenir car la session semblera venir de l'utilisateur
    qui exécute <productname>PostgreSQL</productname>. Du coup,
    <function>dblink_connect_u()</function> est installé initialement sans
    aucun droit pour <literal>PUBLIC</literal>, le rendant utilisable que
    par les super-utilisateurs. Dans certaines situations, il peut être
    approprié de donner le droit <literal>EXECUTE</literal> sur
    <function>dblink_connect_u()</function> à certains utilisateurs
    spécifiques qui sont considérés de confiance, mais cela doit se faire
    avec une grande attention.
   </para>

   <para>
    Pour plus de détails, voir <function>dblink_connect()</function>.
   </para>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-DISCONNECT">
  <refnamediv>
   <refname>dblink_disconnect</refname>
   <refpurpose>ferme une connexion persistante vers une base de données
    distantes</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_disconnect() returns text
    dblink_disconnect(text connname) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_disconnect()</function> ferme une connexion ouverte
    par <function>dblink_connect()</function>. La forme sans argument
    ferme une connexion sans nom.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom de la connexion à fermer
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie le statut qui est toujours <literal>OK</literal> (car toute
    erreur fait que la fonction bascule en mode erreur plutôt que de
    renvoyer quelque chose).
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
 select dblink_disconnect();
  dblink_disconnect
 -------------------
  OK
 (1 row)

 select dblink_disconnect('myconn');
  dblink_disconnect
 -------------------
  OK
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK">
  <refnamediv>
   <refname>dblink</refname>
   <refpurpose>exécute une requête sur une base de données
   distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink(text connname, text sql [, bool fail_on_error]) returns setof record
    dblink(text connstr, text sql [, bool fail_on_error]) returns setof record
    dblink(text sql [, bool fail_on_error]) returns setof record
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink</function> exécute une requête (habituellement un
    <command>SELECT</command>, mais cela pourrait être toute instruction
    SQL qui renvoie des lignes) sur une base de données distante.
   </para>

   <para>
    Si deux arguments <type>text</type> sont présents, le premier est utilisé
    comme nom d'une connexion persistante. Si cette connexion est trouvée,
    la commande est exécutée sur cette connexion. Si elle n'est pas trouvée,
    le premier argument est pris pour une chaîne de connexion comme
    <function>dblink_connect</function>, et la connexion indiquée est
    conservée uniquement pendant la durée d'exécution de cette commande.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Le nom à utiliser pour cette connexion&nbsp;; omettez ce paramètre
       pour utiliser la connexion sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <para>
       Une chaîne de connexion décrite précédemment pour
       <function>dblink_connect</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
        L'instruction SQL à exécuter sur l'hôte distant, par exemple
	<literal>select * from foo</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (la valeur par défaut si elle n'est pas précisée), un message
       de type ERROR sur la base distante cause l'envoi d'un message de type
       ERROR en local. Dans le cas contraire, le message distant de type ERROR
       est traité localement comme un NOTICE, et aucune ligne n'est renvoyée.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    La fonction renvoie les lignes produites par la requête. Comme
    <function>dblink</function> peut être utilisée avec toute requête, elle
    est déclarée comme renvoyant le type <type>record</type>, et ne spécifie
    donc aucun ensemble particulier de colonnes. Ceci signifie que
    l'ensemble des colonnes attendues doit être spécifié dans la
    requête appelante &mdash; sinon
    <productname>PostgreSQL</productname> ne sait pas 
    à quoi s'attendre. Voici un exemple&nbsp;:

<programlisting>
SELECT *
    FROM dblink('dbname=mydb', 'select proname, prosrc from pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>

    La partie <quote>alias</quote> de la clause <literal>FROM</literal> doit
    spécifier les noms et types des colonnes que la fonction va renvoyer.
    (Spécifier les noms des colonnes dans un alias est en fait une syntaxe
    du standard SQL mais spécifier les types des colonnes est une extension
    <productname>PostgreSQL</productname>.) Ceci permet au système de
    savoir comment étendre <literal>*</literal>, et à quoi correspond
    <structname>proname</structname> dans la clause
    <literal>WHERE</literal> 
    avant de tenter l'exécution de la fonction. À l'exécution, une erreur
    sera renvoyée si le résultat réel de la requête à partir de la base de
    données distante n'a pas le même nombre de colonnes que celui indiqué
    dans la clause <literal>FROM</literal>. Les noms de colonnes n'ont pas
    besoin de correspondre et <function>dblink</function> n'insiste pas
    sur une correspondance exacte des types. L'opération sera une réussite
    si les chaînes de données renvoyées sont valides pour le type déclaré
    dans la clause <literal>FROM</literal>.
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    <function>dblink</function> récupère les résultats complets de la
    requête avant des les renvoyer au système local. Si la requête doit
    renvoyer un grand nombre de lignes, il est préférable d'ouvrir un
    curseur avec <function>dblink_open</function> puis de récupérer un
    nombre gérable de lignes.
   </para>

   <para>
    Une façon agréable d'utiliser <function>dblink</function> avec des
    requêtes prédéterminées est de créer une vue. Ceci permet de stocker
    l'information sur les colonnes dans la vue, au lieu d'avoir à la saisir
    pour chaque requête. Par exemple&nbsp;:

    <programlisting>
CREATE VIEW myremote_pg_proc AS
  SELECT *
    FROM dblink('dbname=postgres', 'SELECT proname, prosrc FROM pg_proc')
    AS t1(proname name, prosrc text);

SELECT * FROM myremote_pg_proc WHERE proname LIKE 'bytea%';
    </programlisting>
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
SELECT * FROM dblink('dbname=postgres', 'SELECT proname, prosrc FROM pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
   proname   |   prosrc
 ------------+------------
  byteacat   | byteacat
  byteaeq    | byteaeq
  bytealt    | bytealt
  byteale    | byteale
  byteagt    | byteagt
  byteage    | byteage
  byteane    | byteane
  byteacmp   | byteacmp
  bytealike  | bytealike
  byteanlike | byteanlike
  byteain    | byteain
  byteaout   | byteaout
 (12 rows)

SELECT dblink_connect('dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)

SELECT * FROM dblink('SELECT proname, prosrc FROM pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
   proname   |   prosrc
 ------------+------------
  byteacat   | byteacat
  byteaeq    | byteaeq
  bytealt    | bytealt
  byteale    | byteale
  byteagt    | byteagt
  byteage    | byteage
  byteane    | byteane
  byteacmp   | byteacmp
  bytealike  | bytealike
  byteanlike | byteanlike
  byteain    | byteain
  byteaout   | byteaout
 (12 rows)

 SELECT dblink_connect('myconn', 'dbname=regression');
  dblink_connect
 ----------------
  OK
 (1 row)

 SELECT * FROM dblink('myconn', 'SELECT proname, prosrc FROM pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
   proname   |   prosrc
 ------------+------------
  bytearecv  | bytearecv
  byteasend  | byteasend
  byteale    | byteale
  byteagt    | byteagt
  byteage    | byteage
  byteane    | byteane
  byteacmp   | byteacmp
  bytealike  | bytealike
  byteanlike | byteanlike
  byteacat   | byteacat
  byteaeq    | byteaeq
  bytealt    | bytealt
  byteain    | byteain
  byteaout   | byteaout
 (14 rows)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-EXEC">
  <refnamediv>
   <refname>dblink_exec</refname>
   <refpurpose>exécute une commande sur une base de données
    distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_exec(text connname, text sql [, bool fail_on_error]) returns text
    dblink_exec(text connstr, text sql [, bool fail_on_error]) returns text
    dblink_exec(text sql [, bool fail_on_error]) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_exec</function> exécute une commande (c'est-à-dire toute
    instruction SQL qui ne renvoie pas de lignes) dans une base de données
    distante.
   </para>

   <para>
    Quand deux arguments de type <type>text</type> sont fournis, le premier
    est recherché comme nom d'une connexion persistante&nbsp;; si cette
    connexion est trouvée, la commande est exécutée sur cette connexion. Dans
    le cas contraire, le premier argument est traitée comme une chaîne de
    connexion pour <function>dblink_connect</function>, et la connexion
    indiquée est maintenue uniquement pour la durée d'exécution de cette
    commande.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Nom de la connexion à utiliser&nbsp;; omettez ce paramètre pour
       utiliser la connexion sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <para>
       Une chaîne de connexion identique à celle décrite pour
       <function>dblink_connect</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
       La commande SQL à exécuter dans la base de données
       distante&nbsp;; par exemple
       <literal>INSERT INTO foo VALUES(0,'a','{"a0","b0","c0"}')</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (la valeur par défaut si elle n'est pas précisée), un message
       de type ERROR sur la base distante cause l'envoi d'un message de type
       ERROR en local. Dans le cas contraire, le message distant de type ERROR
       est traité localement comme un NOTICE, et la valeur renvoyée est
       <literal>ERROR</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie le statut de la commande ou <literal>ERROR</literal> en cas
    d'échec.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
 SELECT dblink_connect('dbname=dblink_test_slave');
  dblink_connect
 ----------------
  OK
 (1 row)

 SELECT dblink_exec('INSERT INTO foo VALUES(21,''z'',''{"a0","b0","c0"}'');');
    dblink_exec
 -----------------
  INSERT 943366 1
 (1 row)

 SELECT dblink_connect('myconn', 'dbname=regression');
  dblink_connect
 ----------------
  OK
 (1 row)

 SELECT dblink_exec('myconn', 'INSERT INTO foo VALUES(21,''z'',''{"a0","b0","c0"}'');');
    dblink_exec
 ------------------
  INSERT 6432584 1
 (1 row)

 SELECT dblink_exec('myconn', 'INSERT INTO pg_class values (''foo'')',false);
 NOTICE:  sql error
 DETAIL:  ERROR:  null value in column "relnamespace" violates not-null constraint

  dblink_exec
 -------------
  ERROR
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-OPEN">
  <refnamediv>
   <refname>dblink_open</refname>
   <refpurpose>ouvre un curseur vers une base de données distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_open(text cursorname, text sql [, bool fail_on_error]) returns text
    dblink_open(text connname, text cursorname, text sql [, bool fail_on_error]) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_open()</function> ouvre un curseur vers une base de
    données distante. Le curseur peut ensuite être manipulé avec
    <function>dblink_fetch()</function> et
    <function>dblink_close()</function>.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Nom de la connexion à utiliser&nbsp;; omettez ce paramètre pour
       utiliser la connexion sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <para>
       Nom à affecter au curseur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
       L'instruction <command>SELECT</command> à exécuter sur l'hôte distant,
       par exemple <literal>SELECT * FROM pg_class</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (la valeur par défaut si elle n'est pas précisée), un message
       de type ERROR sur la base distante cause l'envoi d'un message de type
       ERROR en local. Dans le cas contraire, le message distant de type ERROR
       est traité localement comme un NOTICE, et la valeur renvoyée est
       <literal>ERROR</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie le statut, soit <literal>OK</literal> soit
    <literal>ERROR</literal>.
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    Comme un curseur peut seulement persister dans une transaction,
    <function>dblink_open</function> lance un bloc de transaction explicite
    (<command>BEGIN</command>) du côté distant, si le côté distant n'était
    pas déjà à l'intérieur d'une transaction. Cette transaction sera de
    nouveau fermée quand l'instruction <function>dblink_close</function>
    est exécutée. Notez que si <function>dblink_exec</function> est utilisé
    pour modifier les données entre <function>dblink_open</function> et
    <function>dblink_close</function>, et qu'ensuite une erreur survient ou
    que <function>dblink_disconnect</function> est utilisé avant
    <function>dblink_close</function>, vos modifications <emphasis>seront
    perdues</emphasis> car la transaction sera annulée.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
 SELECT dblink_connect('dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)

 SELECT dblink_open('foo', 'SELECT proname, prosrc FROM pg_proc');
  dblink_open
 -------------
  OK
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-FETCH">
  <refnamediv>
   <refname>dblink_fetch</refname>
   <refpurpose>renvoie des lignes à partir d'un curseur ouvert sur une
    base de données distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_fetch(text cursorname, int howmany [, bool fail_on_error]) returns setof record
    dblink_fetch(text connname, text cursorname, int howmany [, bool fail_on_error]) returns setof record
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_fetch</function> récupère des lignes à partir d'un
    curseur déjà ouvert par <function>dblink_open</function>.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Nom de la connexion à utiliser&nbsp;; omettez ce paramètre pour
       utiliser la connexion sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <para>
       Le nom du curseur à partir duquel récupérer les lignes.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>howmany</parameter></term>
     <listitem>
      <para>
       Nombre maximum de lignes à récupérer. Les
       <parameter>howmany</parameter> lignes suivantes sont récupérées, en
       commençant à la position actuelle du curseur, vers l'avant. Une fois
       le curseur positionné à la fin, aucune ligne supplémentaire ne sera
       renvoyée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (la valeur par défaut si elle n'est pas précisée), alors une
       erreur sur la base distante cause l'envoie d'un rapport d'erreur en
       local. Si elle vaut false, l'erreur distante est rapportée localement
       comme un NOTICE et la fonction ne renvoie aucune ligne.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    La fonction renvoie les lignes récupérées à partir du curseur. Pour
    utiliser cette fonction, l'ensemble des colonnes 
    attendues doit être spécifié, comme décrit précédemment pour
    <function>dblink</function>. 
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    S'il existe une différence entre le nombre de colonnes renvoyées spécifiées dans
    la clause <literal>FROM</literal>, et le nombre réel de colonnes renvoyées
    par le curseur distant, une erreur sera remontée. Dans ce cas, le curseur
    distant sera toujours avancé du nombre de lignes spécifié comme si
    l'erreur n'avait pas eu lieu. Il en est de même pour
    toute autre erreur survenant dans la requête locale après l'exécution
    du <command>FETCH</command> distant.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
 select dblink_connect('dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)

 SELECT dblink_open('foo', 'SELECT proname, prosrc FROM pg_proc WHERE proname LIKE ''bytea%''');
  dblink_open
 -------------
  OK
 (1 row)

 SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
  funcname |  source
 ----------+----------
  byteacat | byteacat
  byteacmp | byteacmp
  byteaeq  | byteaeq
  byteage  | byteage
  byteagt  | byteagt
 (5 rows)

 SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
  funcname  |  source
 -----------+-----------
  byteain   | byteain
  byteale   | byteale
  bytealike | bytealike
  bytealt   | bytealt
  byteane   | byteane
 (5 rows)

 SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
   funcname  |   source
 ------------+------------
  byteanlike | byteanlike
  byteaout   | byteaout
 (2 rows)

 SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
  funcname | source
 ----------+--------
 (0 rows)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CLOSE">
  <refnamediv>
   <refname>dblink_close</refname>
   <refpurpose>ferme un curseur sur une base de données distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_close(text cursorname [, bool fail_on_error]) returns text
    dblink_close(text connname, text cursorname [, bool fail_on_error]) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_close</function> ferme un curseur précédemment ouvert
    avec <function>dblink_open</function>.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Nom de la connexion à utiliser&nbsp;; omettez ce paramètre pour
       utiliser la connexion sans nom.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <para>
       Nom du curseur à fermer
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (la valeur par défaut si elle n'est pas précisée), un message
       de type ERROR sur la base distante cause l'envoi d'un message de type
       ERROR en local. Dans le cas contraire, le message distant de type ERROR
       est traité localement comme un NOTICE, et la valeur renvoyée est
       <literal>ERROR</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie le statut, soit <literal>OK</literal> soit
    <literal>ERROR</literal>.
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    Si <function>dblink_open</function> a commencé un bloc de transaction
    explicite, et que c'est le dernier curseur ouvrant restant dans cette
    connexion, <function>dblink_close</function> exécutera le
    <command>COMMIT</command> correspondant.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
 select dblink_connect('dbname=postgres');
  dblink_connect
 ----------------
  OK
 (1 row)

 select dblink_open('foo', 'select proname, prosrc from pg_proc');
  dblink_open
 -------------
  OK
 (1 row)

 select dblink_close('foo');
  dblink_close
 --------------
  OK
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-CONNECTIONS">
  <refnamediv>
   <refname>dblink_get_connections</refname>
   <refpurpose>renvoie les noms de toutes les connexions nommées
   ouvertes</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_get_connections() returns text[]
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_get_connections</function> renvoie un tableau contenant
    le nom de toutes les connexions nommées et ouvertes de
    <filename>dblink</filename>.
   </para>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>Renvoie un tableau de texte des noms des connexion, ou NULL s'il n'y
   en as pas.</para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
   SELECT dblink_get_connections();
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-ERROR-MESSAGE">
  <refnamediv>
   <refname>dblink_error_message</refname>
   <refpurpose>récupère le dernier message d'erreur sur la connexion
    nommée</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_error_message(text connname) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_error_message</function> récupère le dernier message
    d'erreur sur la connexion nommée.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Nom de la connexion.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Return Value</title>

   <para>
    Renvoie le dernier message, ou une chaîne vide s'il n'y a pas eu
    d'erreur sur cette connexion.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
    SELECT dblink_error_message('dtest1');
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-SEND-QUERY">
  <refnamediv>
   <refname>dblink_send_query</refname>
   <refpurpose>envoie une requête asynchrone à une base de données
    distante</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_send_query(text connname, text sql) returns int
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_send_query</function> envoie une requête à exécuter
    de façon asynchrone, c'est-à-dire sans attendre immédiatement le résultat.
    Il ne doit pas y avoir une requête asynchrone déjà en exécution sur la
    connexion.
   </para>

   <para>
    Après l'envoi réussi d'une requête asynchrone, le statut de fin
    d'exécution de la requête se vérifie avec
    <function>dblink_is_busy</function>, et les résultats sont finalement
    récupérés avec <function>dblink_get_result</function>. Il est
    aussi possible de tenter l'annulation d'une rquête asynchrone
    active en utilisant  <function>dblink_cancel_query</function>. 
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Nom de la connexion à utiliser.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
       L'instruction SQL à exécuter dans la base de données
       distante, par exemple <literal>select * from pg_class</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie 1 si la requête a été envoyée avec succès, 0 sinon.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
    SELECT dblink_send_query('dtest1', 'SELECT * FROM foo WHERE f1 &lt; 3');
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-IS-BUSY">
  <refnamediv>
   <refname>dblink_is_busy</refname>
   <refpurpose>vérifie si la connexion est occupée par le traitement d'une requête
   asynchrone</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_is_busy(text connname) returns int
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_is_busy</function> teste si une requête asynchrone est
    en cours d'exécution.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Nom de la connexion à vérifier
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie 1 si la connexion est occupée, 0 dans le cas contraire.
    Si cette fonction renvoie 0, il est garanti que l'appel à
    <function>dblink_get_result</function> sera pas bloquant.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
    SELECT dblink_is_busy('dtest1');
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-RESULT">
  <refnamediv>
   <refname>dblink_get_result</refname>
   <refpurpose>récupère le résultat d'une requête asynchrone</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_get_result(text connname [, bool fail_on_error]) returns setof record
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_get_result</function> récupère le résultat d'une
    requête asynchrone précédemment envoyée avec
    <function>dblink_send_query</function>. Si la requête n'est pas déjà
    terminée, <function>dblink_get_result</function> attendra jusqu'à ce que
    ce soit le cas.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Nom de la connexion à utiliser
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       Si true (la valeur par défaut si elle n'est pas précisée), un message
       de type ERROR sur la base distante cause l'envoi d'un message de type
       ERROR en local. Dans le cas contraire, le message distant de type ERROR
       est traité localement comme un NOTICE, et aucune ligne n'est renvoyée.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Pour une requête asynchrone (c'est-à-dire une requête SQL renvoyant des
    lignes), la fonction renvoie les lignes produites par la requête. Pour
    utiliser cette fonction, l'ensemble des colonnes
    attendues doit être spécifié comme indiqué pour <function>dblink</function>.
   </para>

   <para>
    Pour une commande asynchrone (c'est-à-dire une requête SQL ne renvoyant aucune
    ligne), la fonction renvoie une seule ligne avec une colonne texte
    contenant la chaîne de statut de la commande. Il est nécessaire de
    d'indiquer dans la requête que le résultat aura une colonne texte dans la clause
    <literal>FROM</literal> appelante.
   </para>
  </refsect1>

  <refsect1>
   <title>Notes</title>

   <para>
    Cette fonction <emphasis>doit</emphasis> être appelée si
    <function>dblink_send_query</function> a renvoyé 1. Elle doit l'être
    une fois pour chaque requête envoyée, et une fois de plus pour obtenir
    un ensemble vide avant de pouvoir utiliser de nouveau la connexion.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
 contrib_regression=#   SELECT dblink_connect('dtest1', 'dbname=contrib_regression');
  dblink_connect
 ----------------
  OK
 (1 row)

 contrib_regression=#   SELECT * from
 contrib_regression-#    dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3') as t1;
  t1
 ----
   1
 (1 row)

 contrib_regression=#   SELECT * from dblink_get_result('dtest1') as t1(f1 int, f2 text, f3 text[]);
  f1 | f2 |     f3
 ----+----+------------
   0 | a  | {a0,b0,c0}
   1 | b  | {a1,b1,c1}
   2 | c  | {a2,b2,c2}
 (3 rows)

 contrib_regression=#   SELECT * from dblink_get_result('dtest1') as t1(f1 int, f2 text, f3 text[]);
  f1 | f2 | f3
 ----+----+----
 (0 rows)

 contrib_regression=#   SELECT * from
    dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3; select * from foo where f1 &gt; 6') as t1;
  t1
 ----
   1
 (1 row)

 contrib_regression=#   SELECT * from dblink_get_result('dtest1') as t1(f1 int, f2 text, f3 text[]);
  f1 | f2 |     f3
 ----+----+------------
   0 | a  | {a0,b0,c0}
   1 | b  | {a1,b1,c1}
   2 | c  | {a2,b2,c2}
 (3 rows)

 contrib_regression=#   SELECT * from dblink_get_result('dtest1') as t1(f1 int, f2 text, f3 text[]);
  f1 | f2 |      f3
 ----+----+---------------
   7 | h  | {a7,b7,c7}
   8 | i  | {a8,b8,c8}
   9 | j  | {a9,b9,c9}
  10 | k  | {a10,b10,c10}
 (4 rows)

 contrib_regression=#   SELECT * from dblink_get_result('dtest1') as t1(f1 int, f2 text, f3 text[]);
  f1 | f2 | f3
 ----+----+----
 (0 rows)
   </programlisting>
  </refsect1>
 </refentry>
<!-- JCA::TAG RELECTURE -->
 <refentry id="CONTRIB-DBLINK-CANCEL-QUERY">
  <refnamediv>
   <refname>dblink_cancel_query</refname>
   <refpurpose>annule toute requête en cours d'exécution sur la connexion
    nommée</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_cancel_query(text connname) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_cancel_query</function> tente d'annuler toute requête
    en cours d'exécution sur la connexion nommée. Notez que la réussite de
    la fonction n'est pas assurée (car, par exemple, la requête distante
    pourrait être déjà terminée). Une demande d'annulation améliore simplement
    les possibilités que la question échoue rapidement. Vous devez toujours
    terminer le protocole de la requête, par exemple en appelant
    <function>dblink_get_result</function>.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <para>
       Nom de la connexion à utiliser.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie <literal>OK</literal> si la demande d'annulation a bien été
    envoyée, ou le texte d'un message d'erreur en cas d'échec.
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
    SELECT dblink_cancel_query('dtest1');
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CURRENT-QUERY">
  <refnamediv>
   <refname>dblink_current_query</refname>
   <refpurpose>renvoie la requête en cours</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_current_query() returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    Renvoie la commande en cours d'exécution sur la session locale, ou
    NULL si ce n'est pas déterminable. Notez que cette fonction n'a pas
    de relation avec d'autres fonctionnalités de <filename>dblink</filename>.
    Elle est fournie car elles est parfois utile pour générer des requêtes à
    envoyer à des bases distantes.
   </para>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>Renvoie une copie de la requête en cours d'exécution.</para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
select dblink_current_query();
      dblink_current_query
--------------------------------
 select dblink_current_query();
(1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-PKEY">
  <refnamediv>
   <refname>dblink_get_pkey</refname>
   <refpurpose>renvoie la position et le nom des champs de clé primaire
    d'une relation
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_get_pkey(text relname) returns setof dblink_pkey_results
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_get_pkey</function> fournit des informations sur la clé
    primaire d'une relation dans la base de données locale. C'est parfois
    utile dans la génération de requêtes à envoyer sur des bases distantes.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       Nom d'une relation existante, par exemple <literal>foo</literal> ou
       <literal>monschema.matable</literal>. Ajoutez des guillemets doubles
       si le nom est en minuscule et en majuscule, ou contient des
       caractères spéciaux, par exemple <literal>"FooBar"</literal>&nbsp;;
       sans guillemets, la chaîne sera mise en minuscule.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

5H  <refsect1>
   <title>Valeur de retour</title>

   <para>
    Renvoie une ligne pour chaque champ de clé primaire, ou aucune ligne
    si la relation n'a pas de clé primaire. Le type de ligne résultante
    est défini ainsi&nbsp;:

    <programlisting>
CREATE TYPE dblink_pkey_results AS (position int, colname text);
    </programlisting>
   </para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
create table foobar(f1 int, f2 int, f3 int,
test(#   primary key(f1,f2,f3));
CREATE TABLE
select * from dblink_get_pkey('foobar');
 position | colname
----------+---------
        1 | f1
        2 | f2
        3 | f3
(3 rows)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-INSERT">
  <refnamediv>
   <refname>dblink_build_sql_insert</refname>
   <refpurpose>
    construit une instruction d'insertion en utilisant une ligne locale,
    remplaçant les valeurs des champs de la clé primaire pour la sélection
    avec les valeurs fournies
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_build_sql_insert(text relname,
                            int2vector primary_key_attnums,
                            int2 num_primary_key_atts,
                            text[] src_pk_att_vals_array,
                            text[] tgt_pk_att_vals_array) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_build_sql_insert</function> peut être utile pour réaliser
    une réplication sélective d'une table locale vers une base distante.
    Elle sélectionne une ligne de la table locale basée sur la clé primaire
    et construit une commande SQL <command>INSERT</command> qui dupliquera
    cette ligne, mais avec les valeurs de clé primaire remplacées par les
    valeurs du dernier argument. (Pour réaliser une copie exacte de la ligne,
    indiquez simplement les mêmes valeurs pour les deux derniers arguments.)
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       Nom d'une relation existante, par exemple <literal>foo</literal> ou
       <literal>monschema.matable</literal>. Ajoutez des guillemets doubles
       si le nom est en minuscule et en majuscule, ou contient des
       caractères spéciaux, par exemple <literal>"FooBar"</literal>&nbsp;;
       sans guillemets, la chaîne sera mise en minuscule.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <para>
       Numéros des attributs (commençant à 1) des champs de la clé primaire,
       par exemple <literal>1 2</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <para>
       Le nombre de champs de la clé primaire
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>src_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       Les valeurs des champs de la clé primaire pour rechercher la ligne
       locale. Chaque champ est représenté dans sa forme textuelle. Une
       erreur est renvoyé s'il n'y a pas de lignes locales avec ces valeurs
       de clé primaire.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       Les valeurs des champs de la clé primaire à placer dans la commande
       <command>INSERT</command> résultante. Chaque champ est représenté dans
       sa forme textuelle.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>Renvoie l'instruction SQL demandée en tant que texte.</para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
 select dblink_build_sql_insert('foo', '1 2', 2, '{"1", "a"}', '{"1", "b''a"}');
              dblink_build_sql_insert
 --------------------------------------------------
  INSERT INTO foo(f1,f2,f3) VALUES('1','b''a','1')
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-DELETE">
  <refnamediv>
   <refname>dblink_build_sql_delete</refname>
   <refpurpose>construit une instruction de suppression en utilisant une ligne
    locale, en remplaçant les valeurs des champs de la clé primaire pour la
    sélection avec les valeurs fournies
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_build_sql_delete(text relname,
                            int2vector primary_key_attnums,
                            int2 num_primary_key_atts,
                            text[] tgt_pk_att_vals_array) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_build_sql_delete</function> peut être utile pour réaliser
    une réplication sélective d'une table locale vers une base distante.
    Elle construit une commande SQL <command>DELETE</command> qui supprimera
    la ligne avec les valeurs indiquées pour la clé primaire.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       Nom d'une relation existante, par exemple <literal>foo</literal> ou
       <literal>monschema.matable</literal>. Ajoutez des guillemets doubles
       si le nom est en minuscule et en majuscule, ou contient des
       caractères spéciaux, par exemple <literal>"FooBar"</literal>&nbsp;;
       sans guillemets, la chaîne sera mise en minuscule.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <para>
       Numéros des attributs (commençant à 1) des champs de la clé primaire,
       par exemple <literal>1 2</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <para>
       Le nombre de champs de la clé primaire
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       Les valeurs de champs de la clé primaire, à utiliser dans la commande
       <command>DELETE</command> résultante. Chaque champ est représenté dans
       sa forme textuelle.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>Renvoie l'instruction SQL demandée en tant que texte.</para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
 select dblink_build_sql_delete('"MyFoo"', '1 2', 2, '{"1", "b"}');
            dblink_build_sql_delete
 ---------------------------------------------
  DELETE FROM "MyFoo" WHERE f1='1' AND f2='b'
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-UPDATE">
  <refnamediv>
   <refname>dblink_build_sql_update</refname>
   <refpurpose>construit une instruction de mise à jour en utilisant une ligne
    locale, en remplaçant les valeurs des champs de la clé primaire pour la
    sélection avec les valeurs fournies
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <synopsis>
    dblink_build_sql_update(text relname,
                            int2vector primary_key_attnums,
                            int2 num_primary_key_atts,
                            text[] src_pk_att_vals_array,
                            text[] tgt_pk_att_vals_array) returns text
   </synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <para>
    <function>dblink_build_sql_update</function> peut être utile pour réaliser
    une réplication sélective d'une table locale vers une base de donnée
    distante. Elle sélectionne une ligne à partir de la table locale en se
    basant sur la clé primaire, puis construit une commande SQL
    <command>UPDATE</command> qui dupliquera cette ligne, mais avec les valeurs
    de clé primaire remplacées par les valeurs dans le dernier argument.
    (Pour faire une copie exacte de la ligne, indiquez les mêmes valeurs
    pour les deux derniers arguments.) La commande <command>UPDATE</command>
    affecte toujours tous les champs de la ligne &mdash; la différence
    principale entre ceci et <function>dblink_build_sql_insert</function> est
    qu'il est supposé que la ligne cible existe déjà dans la table distante.
   </para>
  </refsect1>

  <refsect1>
   <title>Arguments</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       Nom d'une relation existante, par exemple <literal>foo</literal> ou
       <literal>monschema.matable</literal>. Ajoutez des guillemets doubles
       si le nom est en minuscule et en majuscule, ou contient des
       caractères spéciaux, par exemple <literal>"FooBar"</literal>&nbsp;;
       sans guillemets, la chaîne sera mise en minuscule.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <para>
       Numéros des attributs (commençant à 1) des champs de la clé primaire,
       par exemple <literal>1 2</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <para>
       Le nombre de champs de la clé primaire
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>src_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       Les valeurs des champs de la clé primaire pour rechercher la ligne
       locale. Chaque champ est représenté dans sa forme textuelle. Une
       erreur est renvoyé s'il n'y a pas de lignes locales avec ces valeurs
       de clé primaire.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       Les valeurs des champs de la clé primaire à placer dans la commande
       <command>UPDATE</command> résultante. Chaque champ est représenté dans
       sa forme textuelle.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Valeur de retour</title>

   <para>Renvoie l'instruction SQL demandée en tant que texte.</para>
  </refsect1>

  <refsect1>
   <title>Exemple</title>

   <programlisting>
 select dblink_build_sql_update('foo', '1 2', 2, '{"1", "a"}', '{"1", "b"}');
                    dblink_build_sql_update
 -------------------------------------------------------------
  UPDATE foo SET f1='1',f2='b',f3='1' WHERE f1='1' AND f2='b'
 (1 row)
   </programlisting>
  </refsect1>
 </refentry>

</sect1>
