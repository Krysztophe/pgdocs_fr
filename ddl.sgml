<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/ddl.sgml,v 1.12 2005/09/15 07:03:16 guillaume Exp $ -->

<chapter id="ddl">
 <title>Définition des données</title>

 <para>
  Ce chapitre couvre la création des structures de données qui contiendront
  les données. Dans une base relationnelle, les données brutes
  sont stockées dans des tables. Du coup, une grande partie de ce chapitre
  sera consacrée à l'explication de la création et de la modification des tables 
  et des fonctions disponibles pour contrôler les données stockées dans les tables.
  Ensuite, nous discuterons de l'organisation des tables dans les schémas, et de
  l'attribution de droits aux tables. Enfin,
  nous verrons brièvement d'autres fonctionnalités, tel que l'héritage, les vues,
  les fonctions et les déclencheurs.
 </para>

 <sect1 id="ddl-basics">
  <title>Bases sur les tables</title>

  <indexterm zone="ddl-basics">
   <primary>table</primary>
  </indexterm>

  <indexterm>
   <primary>ligne</primary>
  </indexterm>

  <indexterm>
   <primary>colonne</primary>
  </indexterm>

  <para>
   Une table d'une base relationnelle ressemble beaucoup à un tableau
   sur papier&nbsp;: elle est constituée de lignes et de colonnes. Le nombre
   et l'ordre des colonnes sont fixés et chaque colonne a un nom. Le
   nombre de lignes est variable -- il représente la quantité de données
   stockées à un moment donné. SQL n'apporte aucune garantie sur l'ordre des
   lignes dans une table. Quand une table est lue, les lignes
   apparaîtront dans un ordre aléatoire sauf si un tri est demandé
   explicitement. Ceci est couvert dans le <xref linkend="queries"/>. De plus,
   SQL n'attribue pas d'identifieur unique aux lignes. Du coup, il est possible
   d'avoir plusieurs lignes complètement identiques dans une table. Ceci
   est une conséquence du modèle mathématique sur lequel repose SQL mais
   n'est habituellement pas désiré.
   Plus tard dans ce chapitre, nous verrons comment traiter ce problème.
  </para>

  <para>
   Chaque colonne a un type de donnée. Ce type de donnée restreint la série
   de valeurs possibles pouvant être attribuées à une colonne et attribue
   une sémantique à la donnée stockée dans la colonne pour qu'elle puisse
   être utilisée pour des calculs. Par exemple, une colonne déclarée comme
   étant d'un type numérique n'acceptera pas une chaîne arbitraire de texte,
   et les données stockées dans une telle colonne peuvent être utilisées dans
   des calculs mathématiques.
   Par opposition, une colonne déclarée comme étant de type chaîne de
   caractères acceptera pratiquement n'importe quel type de donnée mais ne
   se prêtera pas à des calculs mathématiques bien que d'autres opérations
   tel que la concaténation des chaînes soient disponibles.
  </para>

  <para>
   <productname>PostgreSQL</productname> inclut une série conséquente de types
   de données intégrés qui correspondent à plusieurs applications. Les
   utilisateurs peuvent aussi définir leurs propres types de données. La
   plupart des types de données intégrés ont des noms et des sémantiques
   évidents alors nous reportons une explication détaillée au <xref
   linkend="datatype"/>. Quelques-uns des types les plus utilisés sont
   <type>integer</type> pour les entiers, <type>numeric</type> pour
   les nombres pouvant être fractionnels, <type>text</type> pour les chaînes de
   caractères, <type>date</type> pour les dates, <type>time</type> pour
   les valeurs de type heure et <type>timestamp</type> pour les valeurs
   contenant une date et une heure.
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>création</secondary>
  </indexterm>

  <para>
   Pour créer une table, il faut utiliser la commande bien nommée <command>CREATE
   TABLE</command>. Dans cette commande, vous devez spécifier au moins le nom de la
   nouvelle table, les noms des colonnes et le type de données pour chacune des
   colonnes. Par exemple&nbsp;:
<programlisting>
CREATE TABLE ma_premiere_table (
    premiere_colonne text,
    deuxieme_colonne integer
);
</programlisting>
   Ceci crée une table nommée <literal>ma_premiere_table</literal> avec
   deux colonnes. La première colonne est nommée
   <literal>premiere_colonne</literal> et a un type de données
   <type>text</type>&nbsp;; la seconde colonne porte le nom
   <literal>deuxieme_colonne</literal> et le type <type>integer</type>.
   Les noms de table et colonne suivent la syntaxe des identifieurs expliquée
   dans la <xref linkend="sql-syntax-identifiers"/>.  Les noms des types sont souvent
   aussi des identifieurs mais il existe des exceptions. Notez que la liste des
   colonnes est séparée par des virgules et entourée par des parenthèses.
  </para>

  <para>
   Bien sûr, l'exemple précédant est un peu tiré par les cheveux. Normalement,
   on donne aux tables et aux colonnes des noms indiquant quels types de données
   ils stockent. Alors, voyons un exemple plus réaliste&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric
);
</programlisting>
   Le type <type>numeric</type> peut stocker des composants fractionnels
   par exemple des montants.
  </para>

  <tip>
   <para>
    Quand vous créez des tables liées entre elles, il est prudent de choisir
    des règles de nommage pour les tables et les colonnes. Par exemple, il
    peut y avoir le choix d'utiliser des noms au pluriel ou au singulier
    pour les noms de table, chaque choix ayant les faveurs d'un théoricien
    ou d'un autre.
   </para>
  </tip>

  <para>
   Il y a une limite sur le nombre de colonnes qu'une table peut contenir.
   Suivant le type de colonne, ce nombre oscille entre 250 et 1600.
   Par contre, définir une table avec un nombre de colonnes proche de ceux-ci
   est très inhabituel et est souvent la preuve d'une conception douteuse.
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>suppression</secondary>
  </indexterm>

  <para>
   Si vous n'avez plus besoin d'une table, vous pouvez la retirer en utilisant
   la commande <command>DROP TABLE</command>. Par exemple&nbsp;:
<programlisting>
DROP TABLE ma_premiere_table;
DROP TABLE produits;
</programlisting>
   Tenter de supprimer une table qui n'existe pas est une erreur.
   Malgré cela, il est habituel dans des fichiers de scripts SQL d'essayer
   de supprimer chaque table avant de la créer, tout en ignorant les messages
   d'erreur.
  </para>

  <para>
   Si vous avez besoin de modifier une table qui existe déjà, regardez la <xref
   linkend="ddl-alter"/> plus loin dans ce chapitre.
  </para>

  <para>
   Avec les outils dont nous avons déjà discuté, vous pouvez créer des tables
   fonctionnelles. Le reste de ce chapitre est consacré à l'ajout de fonctionnalités,
   à la définition de tables pour garantir l'intégrité des données, la sécurité
   ou la facilité.  Si vous êtes impatients de remplir vos tables avec des données,
   vous pouvez sauter au <xref linkend="dml"/> et lire le reste de
   ce chapitre plus tard.
  </para>
 </sect1>

 <sect1 id="ddl-default">
  <title>Valeurs par défaut</title>

  <indexterm zone="ddl-default">
   <primary>valeur par défaut</primary>
  </indexterm>

  <para>
   Une valeur par défaut est attribuable à une colonne. Quand une nouvelle
   ligne est créée et qu'aucune valeur n'est spécifiée pour certaines de ses
   colonnes, celles-ci sont remplies avec leur valeur par défaut respective.
   Une commande de manipulation de données peut aussi demander explicitement
   qu'une colonne soit mise à sa valeur par défaut sans avoir à connaître la
   valeur en question (les détails sur les commandes de manipulation de données
   sont donnés au <xref linkend="dml"/>).
  </para>

  <para>
   <indexterm><primary>valeur NULL</primary><secondary>valeur par défaut</secondary></indexterm>
   Si aucune valeur par défaut n'est déclarée explicitement, la valeur
   par défaut est la valeur NULL. Ceci est d'habitude cohérent car on
   peut considérer que la valeur NULL représente des données inconnues.
  </para>

  <para>
   Dans une définition de table, les valeurs par défaut sont listées après
   le type de donnée de la colonne. Par exemple:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
  </para>

  <para>
   La valeur par défaut peut être une expression, qui
   sera évaluée à l'insertion de la valeur par défaut
   (<emphasis>pas</emphasis> à la création de la table.) Un exemple habituel
   est qu'une colonne de type <type>timestamp</type> pourrait avoir
   <literal>now()</literal> comme valeur par défaut de façon à ce qu'elle obtienne la
   valeur de l'heure au moment de l'insertion. Un autre exemple habituel est
   la génération d'un <quote>numéro de série</quote> pour chaque ligne.
   Dans <productname>PostgreSQL</productname>, ceci se fait habituellement par
   quelque chose comme
<programlisting>
CREATE TABLE produits (
    no_produit integer <emphasis>DEFAULT nextval('produits_no_produit_seq')</emphasis>,
    ...
);
</programlisting>
   où la fonction <literal>nextval()</literal> fournit des valeurs successives à
   partir d'un <firstterm>objet séquence</firstterm> (voir la <xref
   linkend="functions-sequence"/>). Cet arrangement est suffisamment commun
   pour qu'il ait son propre raccourci&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit <emphasis>SERIAL</emphasis>,
    ...
);
</programlisting>
   Le raccourci <literal>SERIAL</literal> est discuté plus tard dans la <xref
   linkend="datatype-serial"/>.
  </para>
 </sect1>

 <sect1 id="ddl-constraints">
  <title>Contraintes</title>

  <indexterm zone="ddl-constraints">
   <primary>contrainte</primary>
  </indexterm>

  <para>
   Les types de données sont un moyen de limiter ce qui peut être stocké
   dans une table. Pour beaucoup d'applications, par contre, la contrainte
   qu'elles appliquent est trop grossière. Par exemple, une colonne qui
   contient le prix d'un produit ne devrait accepter que des valeurs
   positives. Mais il n'y a pas de type de données standard qui n'accepte que
   des valeurs positives. Un autre problème est le fait de vouloir limiter
   les données d'une colonne par rapport à d'autres colonnes ou lignes.
   Par exemple, dans une table contenant des informations de produit, il
   ne devrait y avoir qu'une ligne pour chaque numéro de produit.
  </para>

  <para>
   Dans ce but, SQL vous permet de définir les contraintes sur les colonnes
   et les tables. Les contraintes vous donnent autant de contrôle sur les
   données de vos tables que vous désirez. Si un utilisateur tente de stocker
   des données dans une colonne qui violeraient une contrainte, une erreur est
   soulevée. Ceci s'applique même si la valeur vient de la définition de la
   valeur par défaut.
  </para>

  <sect2>
   <title>Contraintes de vérification</title>

   <indexterm>
    <primary>contrainte de vérification</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>vérification</secondary>
   </indexterm>

   <para>
    Une contrainte de vérification est le type de contrainte le plus
    générique qui soit. Elle vous permet de spécifier que l'expression
    d'une certaine colonne doit satisfaire une expression booléenne. Par
    exemple, pour obliger des prix de produits positifs, on pourrait
    utiliser&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>CHECK (prix &gt; 0)</emphasis>
);
</programlisting>
   </para>

   <para>
    Comme vous pouvez le voir, la définition de contrainte vient après
    le type de données comme les définitions de valeur par défaut. Les
    valeurs par défaut et les contraintes peuvent être données dans
    n'importe quel ordre. Une contrainte de vérification s'utilise avec
    le mot clé <literal>CHECK</literal> suivi d'une expression entre
    parenthèses. L'expression de contrainte de vérification peut
    impliquer la colonne ainsi contrainte, sinon la contrainte n'aurait
    pas beaucoup de sens.
   </para>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>nom</secondary>
   </indexterm>

   <para>
    Vous pouvez aussi donner à la contrainte un nom diffèrent. Ceci
    clarifie les messages d'erreur et vous permet de faire référence
    à la contrainte lorsque vous avez besoin de la modifier.
    La syntaxe est&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (prix &gt; 0)
);
</programlisting>
    Alors, pour spécifier une contrainte nommée, utilisez le mot-clé
    <literal>CONSTRAINT</literal> suivi d'un identifieur et de la
    définition de contrainte (si vous ne donnez pas de nom à la contrainte,
    le système choisira un nom pour vous).
   </para>

   <para>
    Une contrainte de vérification peut faire référence à plusieurs
    colonnes. Admettons que vous souhaitez stocker un prix normal et un
    prix de promotion, et être certain que le prix de promotion soit inférieur
    au prix normal.
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric CHECK (prix &gt; 0),
    prix_promotion numeric CHECK (prix_promotion &gt; 0),
    <emphasis>CHECK (prix &gt; prix_promotion)</emphasis>
);
</programlisting>
   </para>

   <para>
    Les deux premières contraintes devraient vous être familières. La troisième
    utilise une nouvelle syntaxe. Elle n'est pas attachée à une colonne
    particulière, elle apparaît comme un élément distinct dans
    la liste de colonnes séparées par des virgules. Les définitions de
    colonnes et ces définitions de contraintes peuvent être définies dans
    un ordre quelconque.
   </para>

   <para>
    On dit que les deux premières contraintes sont des contraintes de
    colonnes tandis que la troisième est une contrainte de table parce
    qu'elle est écrite séparément de toute définition de colonne tandis que
    l'inverse n'est pas forcément possible car une contrainte de colonne est
    supposé faire uniquement référence à la colonne à laquelle elle est
    attachée (<productname>PostgreSQL</productname> ne force pas cette règle
    mais vous devriez la suivre si vous voulez que les définitions de votre
    table fonctionnent avec d'autres systèmes de bases de données) 
    L'exemple ci-dessus aurait pu s'écrire&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0),
    CHECK (prix &gt; prix_promotion)
);
</programlisting>
    ou même
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0 AND prix &gt; prix_promotion)
);
</programlisting>
    C'est une question de goût.
   </para>

   <para>
    Des noms peuvent être affectés à des contraintes de table de la même
    façon que pour les contraintes de colonne&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0),
    <emphasis>CONSTRAINT valid_discount</emphasis> CHECK (prix &gt; prix_promotion)
);
</programlisting>
   </para>

   <indexterm>
    <primary>valeur NULL</primary>
    <secondary sortas="check constraints">avec contraintes de vérification</secondary>
   </indexterm>

   <para>
    Il faut noter qu'une contrainte de vérification est satisfaite si
    l'expression est évaluée à vrai ou la valeur NULL. Puisque la
    plupart des expressions seront évaluées à la valeur NULL si l'un
    des opérandes est NULL, elles n'empêchent pas les valeurs NULL
    dans les colonnes contraintes. Pour s'assurer qu'une colonne ne
    contient pas de valeurs NULL, la contrainte non-NULL décrite
    dans la section suivante peut être utilisée.
   </para>

   <para>
    Les contraintes de vérification sont utiles pour améliorer la performance
    des tables partitionées. Pour les détails, voir
    <xref linkend="ddl-partitioning"/>.
   </para>
  </sect2>

  <sect2>
   <title>Contraintes non NULL</title>

   <indexterm>
    <primary>contrainte non NULL</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>

   <para>
    Une contrainte non NULL dit simplement qu'une colonne ne peut
    pas prendre la valeur NULL. Un exemple de syntaxe&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer <emphasis>NOT NULL</emphasis>,
    nom text <emphasis>NOT NULL</emphasis>,
    prix numeric
);
</programlisting>
   </para>

   <para>
    Une contrainte non NULL est toujours écrite comme une contrainte de
    colonne. Une contrainte non NULL est l'équivalence fonctionnelle de
    la création d'contrainte <literal>CHECK (<replaceable>nom_colonne</replaceable>
    IS NOT NULL)</literal>, mais dans <productname>PostgreSQL</productname>,
    créer une contrainte explicitement non NULL est plus efficace.
    L'inconvénient est que vous ne pouvez pas donner de noms explicites
    à des contraintes non NULL créées de cette manière.
   </para>

   <para>
    Bien sûr, une colonne peut avoir plus d'une contrainte. Écrivez juste
    les contraintes les unes après les autres&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer NOT NULL,
    nom text NOT NULL,
    prix numeric NOT NULL CHECK (prix &gt; 0)
);
</programlisting>
    L'ordre n'importe pas. Il ne détermine pas dans quel ordre les contraintes
    seront vérifiées.
   </para>

   <para>
    La contrainte <literal>NOT NULL</literal> a un opposé&nbsp;; la contrainte
    <literal>NULL</literal>. Ceci ne veut pas dire que la colonne doit
    être NULL, ce qui serait inutile. À la place, ceci sélectionne le comportement
    par défaut, à savoir que la colonne peut être NULL. La contrainte <literal>NULL
    </literal> n'est pas définie dans le standard SQL et ne devrait pas
    être utilisée dans des applications portables (elle n'a été ajoutée
    dans <productname>PostgreSQL</productname> que pour assurer la
    compatibilité avec d'autres bases de données). Certains utilisateurs
    l'apprécient car elle facilite le fait d'activer une contrainte
    dans un fichier de script. Par exemple, vous pourriez commencer avec&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer NULL,
    nom text NULL,
    prix numeric NULL
);
</programlisting>
    et puis insérer le mot-clé <literal>NOT</literal> suivant vos besoins.
   </para>

   <tip>
    <para>
     Dans beaucoup de conceptions de bases de données, la majorité des
     colonnes devraient être marquées non NULL.
    </para>
   </tip>
  </sect2>

  <sect2>
   <title>Contraintes uniques</title>

   <indexterm>
    <primary>contrainte unique</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>unique</secondary>
   </indexterm>

   <para>
    Les contraintes uniques garantissent que les données contenues dans
    la colonne ou un groupe de colonnes est unique par rapport à toutes
    les lignes de la table. La syntaxe est&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer <emphasis>UNIQUE</emphasis>,
    nom text,
    prix numeric
);
</programlisting>
    quand elle est saisie comme une contrainte de colonne et
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    <emphasis>UNIQUE (no_produit)</emphasis>
);
</programlisting>
    quand elle est saisie comme une contrainte de table.
   </para>

   <para>
    Si une contrainte unique fait référence à un groupe de colonnes,
    celles-ci sont listées en les séparant par des virgules&nbsp;:
<programlisting>
CREATE TABLE exemple (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
    Ceci spécifie que la combinaison de valeurs dans les colonnes indiquées
    est unique pour toute la table bien qu'une seule des colonnes puisse ne
    pas être (et habituellement n'est pas) unique.
   </para>

   <para>
    Vous pouvez affecter votre propre nom pour une contrainte unique, de la
    façon habituelle&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer <emphasis>CONSTRAINT doit_etre_different</emphasis> UNIQUE,
    nom text,
    prix numeric
);
</programlisting>
   </para>

   <indexterm>
    <primary>valeur NULL</primary>
    <secondary sortas="unique constraints">avec contrainte unique</secondary>
   </indexterm>

   <para>
    En général, une contrainte unique est violée lorsqu'il y a au moins deux
    lignes dans une table où la valeur de toutes les colonnes inclus dans la
    contrainte sont égales. Par contre, les valeurs NULL ne sont pas assimilées
    à une égalité dans cette comparaison. Ceci veut dire qu'il est possible
    de stocker des lignes dupliquées contenant une valeur NULL
    dans au moins l'une des colonnes contraintes. Ce comportement est conforme
    au standard SQL mais nous avons été informé que d'autres bases SQL ne
    suivent pas cette règle. Alors, soyez prudents en développant des
    applications prévues pour être portables.
   </para>
  </sect2>

  <sect2>
   <title>Clés primaires</title>

   <indexterm>
    <primary>clé primaire</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>clé primaire</secondary>
   </indexterm>

   <para>
    Techniquement, une contrainte de clé primaire est tout
    simplement une combinaison d'une contrainte unique et
    d'une contrainte non NULL. Donc, les définitions de
    tables suivantes acceptent les mêmes données&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer UNIQUE NOT NULL,
    nom text,
    prix numeric
);
</programlisting>

<programlisting>
CREATE TABLE produits (
    no_produit integer <emphasis>PRIMARY KEY</emphasis>,
    nom text,
    prix numeric
);
</programlisting>
   </para>

   <para>
    Les clés primaires peuvent contraindre sur plus d'une colonne&nbsp;; la
    syntaxe est semblable aux contraintes uniques&nbsp;:
<programlisting>
CREATE TABLE exemple (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
   </para>

   <para>
    Une clé primaire indique qu'une colonne ou un groupe de colonnes peut
    être utilisé comme identifieur unique pour les lignes de la table (ceci
    est une conséquence directe de la définition d'une clé primaire. Notez
    qu'une contrainte unique ne donne pas par elle-même un identifieur unique
    car elle n'exclut pas les valeurs NULL). Ceci est pratique à la fois
    pour des raisons de documentation et pour les applications clientes. Par
    exemple, une application graphique qui permet de modifier les valeurs de
    lignes a probablement besoin de connaître la clé primaire d'une table pour
    pouvoir identifier les lignes de manière unique.
   </para>

   <para>
    Une table a au mieux une clé primaire (tandis qu'elle peut
    avoir plusieurs contraintes uniques et non NULL). La théorie des
    bases de données relationnelles dit que chaque table doit avoir
    une clé primaire. Cette règle n'est pas forcée par
    <productname>PostgreSQL</productname> mais il vaut mieux la respecter
    autant que possible.
   </para>
  </sect2>

  <sect2 id="ddl-constraints-fk">
   <title>Clés étrangères</title>

   <indexterm>
    <primary>clé étrangère</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>clé étrangère</secondary>
   </indexterm>

   <indexterm>
    <primary>intégrité référentielle</primary>
   </indexterm>

   <para>
    Une contrainte de clé étrangère stipule que les valeurs dans cette
    colonne (ou un groupe de colonnes) doit correspondre aux valeurs
    apparaissant dans des lignes d'une autre table.
    Nous disons que ceci maintient l'<firstterm>intégrité
    référentielle</firstterm> entre les deux tables.
   </para>

   <para>
    Disons que vous avez la table de produits que nous avons déjà utilisée
    plusieurs fois&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer PRIMARY KEY,
    nom text,
    prix numeric
);
</programlisting>
    Disons aussi que vous avez une table stockant les commandes de
    ces produits. Nous voulons nous assurer que la table des
    commandes ne contienne que des commandes concernant des produits
    qui existent réellement. Alors, nous définissons une contrainte
    de clé étrangère dans la table des commandes qui référence la
    table produit:
<programlisting>
CREATE TABLE commandes (
    id_commande integer PRIMARY KEY,
    no_produit integer <emphasis>REFERENCES produits (no_produit)</emphasis>,
    quantite integer
);
</programlisting>
    Maintenant, il est impossible de créer des commandes avec une entrée
    <structfield>no_produit</structfield> qui n'apparaît pas dans la table
    produits.
   </para>

   <para>
    Dans cette situation, nous disons que la table des commandes est la table
    <firstterm>référente</firstterm> et la table des produits est la table
    <firstterm>référencée</firstterm>.  De la même façon, il y a des colonnes
    référentes et des colonnes référées.
   </para>

   <para>
    On peut aussi raccourcir la commande ci-dessus en
<programlisting>
CREATE TABLE commandes (
    id_commande integer PRIMARY KEY,
    no_produit integer <emphasis>REFERENCES produits</emphasis>,
    quantite integer
);
</programlisting>
    parce qu'en l'absence d'une liste de colonne, la clé primaire de la
    table référente est utilisée comme colonne référée.
   </para>

   <para>
    Une clé étrangère peut aussi contraindre et référencer un groupe de colonnes.
    Comme d'habitude, il faut aussi l'écrire sous forme de contrainte de table.
    Voici un exemple de syntaxe&nbsp;:
<programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES autre_table (c1, c2)</emphasis>
);
</programlisting>
    Bien sûr, le nombre et le type des colonnes contraintes doivent correspondre
    au nombre et au type des colonnes référées.
   </para>

   <para>
    Vous pouvez affecter un nom qui vous est propre pour une contrainte de clé
    étrangère de la façon habituelle.
   </para>

   <para>
    Une table peut contenir plus d'une contrainte de clé étrangère. Ceci est
    utilisé pour implémenter des relations n à n entre tables. Disons
    que vous avez des tables contenant des produits et des commandes mais vous
    voulez maintenant autoriser une commande qui contient peut-être beaucoup
    de produits (ce que la structure ci-dessus ne permet pas). On pourrait
    utiliser cette structure de table&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer PRIMARY KEY,
    nom text,
    prix numeric
);

CREATE TABLE commandes (
    id_commande integer PRIMARY KEY,
    adresse_de_livraison text,
    ...
);

CREATE TABLE order_items (
    no_produit integer REFERENCES produits,
    id_commande integer REFERENCES commandes,
    quantite integer,
    PRIMARY KEY (no_produit, id_commande)
);
</programlisting>
    Notez aussi que la clé primaire chevauche les clés étrangères dans la dernière table.
   </para>

   <indexterm>
    <primary>CASCADE</primary>
    <secondary>action clé étrangère</secondary>
   </indexterm>

   <indexterm>
    <primary>RESTRICT</primary>
    <secondary>action clé étrangère</secondary>
   </indexterm>

   <para>
    Nous savons que les clés étrangères n'autorisent pas la création
    de commandes qui ne sont pas liés à un produit. Et si un produit
    est retiré après qu'une commande qui y réfère soit créée&nbsp;? SQL vous
    permet aussi de le gérer. Intuitivement, nous avons plusieurs options&nbsp;:
    <itemizedlist spacing="compact">
     <listitem><para>Interdire d'effacer un produit référé</para></listitem>
     <listitem><para>Effacer aussi les commandes</para></listitem>
     <listitem><para>Autre chose ?</para></listitem>
    </itemizedlist>
   </para>

   <para>
    Pour illustrer ce cas, implémentons la politique suivante sur
    l'exemple de relations n à n évoquée plus haut: Quand quelqu'un
    veut retirer un produit qui est encore référencé par un ordre
    (via <literal>ordre_items</literal>), on l'interdit. Si quelqu'un
    retire une commande, les éléments de l'ordre sont aussi retirés.
<programlisting>
CREATE TABLE produits (
    no_produit integer PRIMARY KEY,
    nom text,
    prix numeric
);

CREATE TABLE commandes (
    id_commande integer PRIMARY KEY,
    adresse_de_livraison text,
    ...
);

CREATE TABLE order_items (
    no_produit integer REFERENCES produits <emphasis>ON DELETE RESTRICT</emphasis>,
    id_commande integer REFERENCES commandes <emphasis>ON DELETE CASCADE</emphasis>,
    quantite integer,
    PRIMARY KEY (no_produit, id_commande)
);
</programlisting>
   </para>

   <para>
     Restreindre les suppressions et supprimer en cascade sont les deux
     options les plus communes. <literal>RESTRICT</literal> empêche la
     suppression d'une ligne référencée. <literal>NO ACTION</literal> signifie
     que si des lignes de références existent lors de la vérification de la 
     contrainte, une erreur est levée. Ceci est le comportement par
     défaut si vous n'avez rien spécifié (la différence essentielle entre
     ces deux choix est que <literal>NO ACTION</literal> autorise la
     déférence de la vérification plus tard dans la transaction alors que    
     <literal>RESTRICT</literal> ne le permet pas). <literal>CASCADE</literal>
     spécifie que, quand une ligne référencée est supprimée, les lignes la
     référençant devraient aussi être automatiquement supprimées. Il existe
     deux autres options&nbsp;: <literal>SET NULL</literal> et <literal>SET
     DEFAULT</literal>. Celles-ci font que les colonnes de références soient
     initialisées à NULL ou à leur valeur par défaut, respectivement quand la
     ligne référencée est supprimée. Notez qu'elles ne vous excusent pas
     d'observer les contraintes. Par exemple, si une action spécifie 
     <literal>SET DEFAULT</literal> mais que la valeur par défaut ne
     satisfait pas la clé étrangère, l'opération échoue.
   </para>

   <para>
    Sur le même principe que <literal>ON DELETE</literal>, il y a aussi
    <literal>ON UPDATE</literal> qui est évoqué lorsqu'une colonne référencée
    est modifiée (mise à jour). Les actions possibles sont les mêmes.
   </para>

   <para>
    Le <xref linkend="dml"/> contient plus d'informations sur la mise à jour et
    la suppression de données.
   </para>

   <para>
    Enfin, la clé étrangère peut référencer des colonnes qui sont une clé
    primaire ou forment une contrainte unique. Si la clé étrangère référence
    une contrainte unique, il y a des possibilités supplémentaires selon que
    l'on souhaite faire correspondre les valeurs NULL. Celles-ci sont expliquées
    dans la documentation de référence pour <xref linkend="sql-createtable"
    endterm="sql-createtable-title"/>.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-system-columns">
   <title>Colonnes système</title>

   <para>
     Chaque table a plusieurs <firstterm>colonnes système</firstterm> qui sont
     implicitement définies par le système. De ce fait, ces noms ne peuvent
     être utilisés comme noms de colonnes définis par l'utilisateur (notez
     que ces restrictions sont différentes si le nom est un mot-clé ou
     pas&nbsp;; mettre un nom entre guillemets ne vous permettra pas d'échapper
     à ces restrictions). Vous n'avez pas vraiment besoin de vous préoccuper de
     ces colonnes, simplement sachez qu'elles existent.
   </para>

 <indexterm>
   <primary>colonne</primary>
   <secondary>colonne système</secondary>
 </indexterm>

 <variablelist>
   <varlistentry>
     <term><structfield>oid</structfield></term>
     <listitem>
       <para>
        <indexterm>
         <primary>OID</primary>
         <secondary>colonne</secondary>
        </indexterm>
	L'identifieur objet (<foreignphrase>object ID</foreignphrase>) d'une ligne. Cette
	colonne est seulement présente si la table a été créée en utilisant
	<literal>WITH OIDS</literal> ou si la variable de configuration <xref
	linkend="guc-default-with-oids"/> était activée. Cette colonne est de
        type oid (même nom que la colonne)&nbsp;; voir la <xref
        linkend="datatype-oid"/> pour plus d'informations sur ce type.
       </para>
     </listitem>
   </varlistentry>
   
   <varlistentry>
     <term><structfield>tableoid</structfield></term>
   <listitem>
     <indexterm>
       <primary>tableoid</primary>
     </indexterm>
     
     <para>
        L' OID de la table contenant cette ligne. Cette colonne est
	particulièrement utile pour les requêtes qui font des sélections à
	partir de hiérarchies héritées (voir <xref linkend="ddl-inherit"/>)
	puisque, sans elle, il est difficile de
	dire de quelle table provient une ligne. <structfield>tableoid</structfield>
	peut être joint à la colonne <structfield>oid</structfield> de
	<structname>pg_class</structname> pour obtenir le nom de la table.
     </para>
   </listitem>
 </varlistentry>
 
 <varlistentry>
   <term><structfield>xmin</structfield></term>
 <listitem>
   <indexterm>
     <primary>xmin</primary>
   </indexterm>
   
   <para>
      L'identifieur (ID de transaction) de la transaction d'insertion de cette
      version de la ligne (une version de ligne est un état individuel
      d'une ligne&nbsp;; chaque mise à jour d'une ligne crée une nouvelle
      version de ligne pour la même ligne logique).
   </para>
 </listitem>
</varlistentry>

<varlistentry>
  <term><structfield>cmin</structfield></term>
<listitem>
  <indexterm>
    <primary>cmin</primary>
  </indexterm>
  
  <para>
     L'identifieur de commande (à partir de zéro) au sein de la transaction
     d'insertion.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>xmax</structfield></term>
<listitem>
  <indexterm>
    <primary>xmax</primary>
  </indexterm>
  
  <para>
     L'identifieur (ID de transaction) de la transaction de suppression, ou zéro
     pour une version de ligne non effacée. Il est possible pour cette
     colonne d'être non NULL dans une version de ligne visible&nbsp;: ceci
     indique normalement que la transaction de suppression n'a pas été
     effectuée, ou qu'une tentative de suppression a été annulée.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>cmax</structfield></term>
<listitem>
  <indexterm>
    <primary>cmax</primary>
  </indexterm>
  
  <para>
     L'identifieur de commande au sein d'une transaction de suppression, ou
     zéro.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>ctid</structfield></term>
<listitem>
  <indexterm>
    <primary>ctid</primary>
  </indexterm>
  
  <para>
     La localisation physique de la version de ligne au sein de sa table.
     Notez que, bien que le <structfield>ctid</structfield> peut être utilisé
     pour trouver la version de ligne très rapidement, le
     <structfield>ctid</structfield>  d'une ligne change chaque fois
     qu'il est mis à jour ou déplacé par la commande <command>VACUUM FULL</command>.
     Donc, <structfield>ctid</structfield> est inutile en tant
     qu'identifieur de ligne à long terme. L'OID, ou encore mieux un numéro
     de série défini par l'utilisateur, devrait être utilisé pour
     identifier des lignes logiques.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>
   Les OID sont des nombres de 32 bits et sont attribués d'un seul
   compteur. Dans une base de données grande ou vieille, il est possible que
   le compteur boucle sur lui-même. Donc il est peu pertinent de partir du
   principe que les OID sont uniques, sauf si vous prenez les précautions
   nécessaires. Si vous avez besoin d'identifier les lignes d'une table,
   l'utilisation d'un générateur de séquence est fortement recommandée.
   Néanmoins, les OID peuvent aussi être utilisés à condition que quelques
   précautions soient prises&nbsp;:
  
  <itemizedlist>
    <listitem>
      <para>
        Une contrainte unique doit être ajoutée sur la colonne OID de chaque
	table pour laquelle l'OID est utilisée pour identifier les lignes.
	Quand une telle contrainte unique (ou un index unique) existe, le système
	fait attention à ne pas générer un OID correspondant à celui d'une ligne
	déjà existante (bien sûr, ceci est seulement possible si la table contient
	moins de 2<superscript>32</superscript> (4 milliards) lignes et, en pratique, la
	taille de la table a tout intérêt à être bien plus petite que ça, sinon les
	performances pourraient en souffrir).
      </para>
    </listitem>
    <listitem>
      <para>
        Les OID ne doivent jamais être supposés uniques entre tables&nbsp;;
        utilisez la combinaison de <structfield>tableoid</structfield> et de l'OID de la
        ligne si vous avez besoin d'un identifieur sur la base complète.
      </para>
    </listitem>
    <listitem>
      <para>
      Les tables en question devraient être créées en utilisant <literal>WITH
      OIDS</literal>. À partir de <productname>PostgreSQL</productname> 8.1,
      <literal>WITHOUT OIDS</literal> est l'option par défaut.
      </para>
    </listitem>
  </itemizedlist>
</para>

  <para>
    Les identifieurs de transaction sont aussi des nombres de 32 bits. Dans 
    une base de données de longue vie, il est possible que les ID de
    transaction bouclent sur eux-mêmes. Ceci n'est pas un problème fatal
    avec des procédures de maintenance appropriées&nbsp;; voir le <xref
    linkend="maintenance"/> pour les détails. Par contre, il est imprudent
    de dépendre de l'aspect unique des ID de transaction à long terme (plus
    d'un milliard de transactions).
  </para>
  
  <para>
     Les identifieurs de commande sont aussi des nombres de 32 bits. Ceci
     crée une limite dure de 2<superscript>32</superscript> (4 milliards) commandes
     <acronym>SQL</acronym> au sein d'une seule transaction. En pratique,
     cette limite n'est pas un problème &mdash; notez que la limite est sur
     le nombre de commandes <acronym>SQL</acronym>, pas le nombre de lignes
     traitées.
  </para>
</sect1>

 <sect1 id="ddl-alter">
  <title>Modification des tables</title>

  <indexterm zone="ddl-alter">
   <primary>table</primary>
   <secondary>modification</secondary>
  </indexterm>

  <para>
   Quand on crée une table et qu'on se rend compte qu'on a fait une erreur
   ou que les besoins de l'application ont changés, on peut alors effacer
   la table et la recréer. Mais ceci n'est pas pratique si la table contient
   déjà des données ou si la table est référencée par d'autres objets de la base
   de données (une contrainte de clé étrangère). Par conséquent,
   <productname>PostgreSQL</productname> offre une série de commandes
   permettant de modifier une table existante. Notez que ceci est différent
   au niveau du concept avec la modification des données contenues dans la
   table&nbsp;; ici, nous sommes intéressés par la modification de la
   définition ou de la structure de la table.
  </para>

  <para>
   Vous pouvez
   <itemizedlist spacing="compact">
    <listitem>
     <para>ajouter des colonnes,</para>
    </listitem>
    <listitem>
     <para>retirer des colonnes,</para>
    </listitem>
    <listitem>
     <para>ajouter des contraintes,</para>
    </listitem>
    <listitem>
     <para>retirer des contraintes,</para>
    </listitem>
    <listitem>
     <para>modifier les valeurs par défaut,</para>
    </listitem>
    <listitem>
     <para>modifier les types de données des colonnes,</para>
    </listitem>
    <listitem>
     <para>renommer des colonnes,</para>
    </listitem>
    <listitem>
     <para>renommer des tables.</para>
    </listitem>
   </itemizedlist>

   Toutes ces actions sont réalisées en utilisant la commande <xref
   linkend="sql-altertable" endterm="sql-altertable-title"/>.
  </para>

  <sect2>
   <title>Ajouter une colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>ajouter</secondary>
   </indexterm>

   <para>
    Pour ajouter une colonne, utilisez une commande comme ceci&nbsp;:
<programlisting>
ALTER TABLE produits ADD COLUMN description text;
</programlisting>
    La nouvelle colonne est initialement remplie avec la valeur par défaut
    (NULL si vous n'avez pas spécifié de clause <literal>DEFAULT</literal>).
   </para>

   <para>
    Vous pouvez aussi définir des contraintes sur la colonne au même moment
    en utilisant la syntaxe habituelle&nbsp;:
<programlisting>
ALTER TABLE produits ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting>
    En fait, toutes les options applicables à la description d'une colonne
    dans <command>CREATE TABLE</command> peuvent être utilisées ici. Néanmoins,
    gardez en tête que la valeur par défaut doit satisfaire les contraintes
    données. Sinon, <literal>ADD</literal> échouera. Autrement, vous pouvez ajouter
    les contraintes plus tard (voir ci-dessous) après avoir rempli la nouvelle
    colonne correctement.
   </para>
  </sect2>

  <sect2>
   <title>Retirer une Colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>retirer</secondary>
   </indexterm>

   <para>
    Pour retirer une colonne, utilisez une commande comme celle-ci&nbsp;:
<programlisting>
ALTER TABLE produits DROP COLUMN description;
</programlisting>
    Les données de cette colonne disparaissent. Les contraintes de table
    impliquant la colonne sont aussi supprimées. Néanmoins, si la colonne est
    référencée par une contrainte de clé étrangère dans une autre table,
    <productname>PostgreSQL</productname> ne supprimera pas silencieusement
    cette contrainte. Vous pouvez autoriser la suppression de tout ce qui     
    dépend de la colonne en ajoutant <literal>CASCADE</literal>&nbsp;:
<programlisting>
	ALTER TABLE produits DROP COLUMN description CASCADE;
</programlisting>
    Voir la <xref linkend="ddl-depend"/> pour une description du mécanisme général
    derrière ceci.
   </para>
  </sect2>

  <sect2>
   <title>Ajouter une contrainte</title>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>ajouter</secondary>
   </indexterm>

   <para>
    Pour ajouter une contrainte, la syntaxe de contrainte de table est utilisée.
    Par exemple&nbsp;:
<programlisting>
ALTER TABLE produits ADD CHECK (nom &lt;&gt; '');
ALTER TABLE produits ADD CONSTRAINT autre_nom UNIQUE (no_produit);
ALTER TABLE produits ADD FOREIGN KEY (id_groupe_produit) REFERENCES groupes_produits;
</programlisting>
    Pour ajouter une contrainte non NULL, qui ne peut pas être écrite
    sous forme d'une contrainte de table, utilisez cette syntaxe&nbsp;:
<programlisting>
ALTER TABLE produits ALTER COLUMN no_produit SET NOT NULL;
</programlisting>
   </para>

   <para>
    La contrainte sera vérifiée immédiatement, donc les données de la
    table doivent satisfaire la contrainte avant qu'elle soit ajoutée.
   </para>
  </sect2>

  <sect2>
   <title>Retirer une contrainte</title>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>retirer</secondary>
   </indexterm>

   <para>
    Pour retirer la contrainte, il faut connaître son nom. Si vous lui avez donné
    un nom, alors c'est facile. Sinon, le système a attribué un nom généré que vous
    devez découvrir. La commande <literal>\d <replaceable>table</replaceable></literal>
    de <application>psql</application> peut être utile ici&nbsp;; d'autres interfaces peuvent
    aussi donner le moyen d'examiner les détails de table. La commande est&nbsp;:
<programlisting>
ALTER TABLE produits DROP CONSTRAINT autre_nom;
</programlisting>
    (si vous traitez avec un nom de contrainte généré comme <literal>$2</literal>,
    n'oubliez pas qu'il faudra l'entourer de guillemets double pour en faire
    un identifieur valable)
   </para>

   <para>
	Comme avec la suppression d'une colonne, vous avez besoin d'ajouter
	<literal>CASCADE</literal> si vous voulez supprimer une contrainte qui dépend
	d'autre chose. Un exemple concerne la contrainte de clé étrangère qui
	dépend d'une contrainte de clé unique ou primaire sur le(s) colonne(s)
    référencée(s).
   </para>

   <para>
    Ça fonctionne de la même manière pour toutes les types de contrainte
    sauf les contraintes non NULL. Pour retirer une contrainte non NULL,
    utilisez
<programlisting>
ALTER TABLE produits ALTER COLUMN no_produit DROP NOT NULL;
</programlisting>
    (Rappelez vous que les contraintes non NULL n'ont pas de noms.)
   </para>
  </sect2>

  <sect2>
   <title>Modifier la valeur par défaut d'une colonne</title>

   <indexterm>
    <primary>valeur par défaut</primary>
    <secondary>modifier</secondary>
   </indexterm>

   <para>
    Pour mettre une nouvelle valeur par défaut sur une colonne, utilisez une
    commande comme celle-ci&nbsp;:
<programlisting>
ALTER TABLE produits ALTER COLUMN prix SET DEFAULT 7.77;
</programlisting>
    Notez que ceci n'affecte pas les lignes existantes dans la table, cela ne
    modifie que la valeur par défaut pour les futures commandes
    <command>INSERT</command>.
   </para>

   <para>
    Pour retirer toute valeur par défaut, utilisez
<programlisting>
ALTER TABLE produits ALTER COLUMN prix DROP DEFAULT;
</programlisting>
    Ceci est équivalent à mettre la valeur par défaut à NULL. En conséquence,
    ce n'est pas une erreur de
    retirer une valeur par défaut qui n'a pas été définie car la valeur NULL
    est la valeur par défaut implicite.
   </para>
  </sect2>

  <sect2>
   <title>Modifier le type de données d'une colonne</title>

   <indexterm>
    <primary>type de données d'une colonne</primary>
    <secondary>modification</secondary>
   </indexterm>

   <para>
    Pour convertir une colonne en un autre type de données, utilisez une
    commande comme ceci&nbsp;:
    <programlisting>
ALTER TABLE produits ALTER COLUMN prix TYPE numeric(10,2);
    </programlisting>
    Elle ne réussira que si chaque valeur dans la colonne peut être
    convertie dans le nouveau type par une conversion implicite. Si une
    conversion plus complexe est nécessaire, vous pouvez ajouter une clause
    <literal>USING</literal> qui spécifie comment calculer les nouveaux valeurs à
    partir des anciennes.
   </para>
  
   <para>
    <productname>PostgreSQL</productname> tentera de convertir la valeur par défaut de la
    colonne, si elle en a une. Mais ces conversions pourraient échouer ou
    pourraient produire des résultats surprenants. Il est souvent mieux de
    supprimer les contraintes sur une colonne avant de modifier son type, puis
    d'ajouter les contraintes modifiées convenablement.
   </para>
  </sect2>

  <sect2>
   <title>Renommer une colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>renommer</secondary>
   </indexterm>

   <para>
    Pour renommer une colonne&nbsp;:
<programlisting>
ALTER TABLE produits RENAME COLUMN no_produit TO numero_produit;
</programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Renommer une table</title>

   <indexterm>
    <primary>table</primary>
    <secondary>renommer</secondary>
   </indexterm>

   <para>
    Pour renommer une table&nbsp;:
<programlisting>
ALTER TABLE produits RENAME TO elements;
</programlisting>
   </para>
  </sect2>
 </sect1>
 
 <sect1 id="ddl-priv">
  <title>Droits</title>

  <indexterm zone="ddl-priv">
   <primary>droit</primary>
  </indexterm>

  <indexterm>
   <primary>permission</primary>
   <see>droit</see>
  </indexterm>

  <para>
   Quand vous créez un objet dans la base de données, vous en devenez le
   propriétaire. Avec les paramètres par défaut, seul le propriétaire
   d'un objet peut faire quelque chose avec. Pour que d'autres utilisateurs
   puissent s'en servir, des <firstterm>droits</firstterm> doivent être
   accordés (néanmoins, les superutilisateurs ont toujours accès à n'importe
   quel objet).
  </para>

  <para>
   Il existe plusieurs droits&nbsp;: <literal>SELECT</literal>,
   <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   <literal>RULE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>,
   <literal>CREATE</literal>, <literal>TEMPORARY</literal>, <literal>EXECUTE</literal>
   et <literal>USAGE</literal>. Les droits applicables à un objet particulier varient
   suivant le type d'objet (table, fonction, etc.) Pour une
   information complète sur les différents types de droits gérés par
   <productname>PostgreSQL</productname>, lisez la page de référence
   <xref linkend="sql-grant" endterm="sql-grant-title"/>.  La section et
   les chapitres suivants vous montreront aussi comment ces droits
   sont utilisés.
  </para>

  <para>
   Le droit de modifier ou de détruire est le droit du propriétaire seul.
  </para>

  <note>
    <para>
      Pour modifier le propriétaire d'une table, d'un index, d'une séquence ou
      d'une vue, utilisez la commande <xref linkend="sql-altertable"
      endterm="sql-altertable-title"/>. Il
      existe des commandes <literal>ALTER</literal> correspondant aux autres types 
      d'objets.
    </para>
  </note>
  
  <para>
   Pour accorder des droits, la commande <command>GRANT</command> est
   utilisée. Par exemple, si <literal>joe</literal> est un utilisateur
   existant et <literal>comptes</literal> une table existante, le
   droit de mettre la table à jour peut être accordé avec
<programlisting>
GRANT UPDATE ON comptes TO joe;
</programlisting>
   Pour accorder un droit à un groupe, utilisez
<programlisting>
GRANT SELECT ON comptes TO GROUP equipe;
</programlisting>
   Le nom d'<quote>utilisateur</quote> spéciale <literal>PUBLIC</literal> peut
   être utilisé pour accorder un droit à tous les utilisateurs du système.
   Écrire <literal>ALL</literal> au lieu d'un droit spécifique accorde tous
   les droits adéquats pour ce type d'objet.
  </para>

  <para>
   Pour révoquer un droit, utilisez la commande appropriée
   <command>REVOKE</command> ci-dessous&nbsp;:
<programlisting>
REVOKE ALL ON comptes FROM PUBLIC;
</programlisting>
   Les droits spéciaux du propriétaire de l'objet (c'est-à-dire, le droit de faire des
   <command>DROP</command>, <command>GRANT</command>, <command>REVOKE</command>, etc.)
   sont toujours implicitement ceux du propriétaire et ne peuvent être ni
   accordés ni révoqués. Mais le propriétaire de l'objet peut choisir
   de révoquer ses propres droits ordinaires pour, par exemple, mettre
   une table en lecture seule pour soi-même ainsi que pour les autres.
  </para>

  <para>
   Habituellement, seul le propriétaire de l'objet (ou un superutilisateur)
   peut donner ou révoquer les droits sur un objet. Néanmoins, il est possible
   de donner un droit <quote>avec une option de don de droits</quote>, qui donne
   à celui qui le reçoit de le donner à d'autres. Si cette option est ensuite
   révoquée, alors tous ceux qui ont reçu le droit de cet utilisateur
   (directement ou indirectement via la chaîne des dons)  perdront leur
   droit. Pour des détails, voir les pages de références <xref
   linkend="sql-grant" endterm="sql-grant-title"/> et <xref linkend="sql-revoke"
   endterm="sql-revoke-title"/>.
  </para>
 </sect1>

 <sect1 id="ddl-schemas">
  <title>Schémas</title>

  <indexterm zone="ddl-schemas">
   <primary>schéma</primary>
  </indexterm>

  <para>
   Un groupe de bases de données <productname>PostgreSQL</productname>
   contient une ou plusieurs bases nommées. Les utilisateurs et groupes
   d'utilisateurs sont partagés sur le groupe tout entier mais aucune
   autre donnée n'est partagée parmi les bases. Une connexion cliente
   donnée sur le serveur peut accéder aux données d'une seule base, celle
   spécifiée dans la connexion de requête.
  </para>

  <note>
   <para>
    Les utilisateurs d'un groupe n'ont pas forcément le droit d'accéder à
    toutes les bases du groupe. Le partage des noms d'utilisateur veut dire
    qu'il ne peut pas y avoir plusieurs utilisateurs nommés <literal>joe</literal>,
    par exemple, dans deux bases du même groupe&nbsp;; mais le système peut être
    configuré pour autoriser <literal>joe</literal> à accéder qu'à certaines bases.
   </para>
  </note>

  <para>
   Une base de données contient un ou plusieurs <firstterm>schémas</firstterm>
   nommés qui, eux, contiennent des tables. Les schémas contiennent aussi d'autres
   types d'objets nommés, y compris des types de données, fonctions et opérateurs.
   Seul le nom d'objet peut être utilisé sans conflit&nbsp;; par exemple,
   <literal>schema1</literal> et <literal>mon_schema</literal> peuvent tous les deux
   contenir une table nommée <literal>ma_table</literal>. Contrairement aux
   bases de données, les schémas ne sont pas séparés de manière rigide&nbsp;:
   un utilisateur peut accéder aux objets de n'importe lequel des schémas de la
   base de données auxquels il se connecte s'il a les droits pour le faire.
  </para>

  <para>
   Il existe plusieurs raisons pour lesquelles quelqu'un voudrait utiliser les
   schémas&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Pour autoriser beaucoup d'utilisateurs à utiliser une base de données sans se gêner
      les uns les autres.
     </para>
    </listitem>

    <listitem>
     <para>
      Pour organiser des objets de bases de données en groupes logiques afin de faciliter
      leur gestion.
     </para>
    </listitem>

    <listitem>
     <para>
      Les applications tierces peuvent être mises dans des schémas séparés pour qu'il n'y
      ait pas de collision avec les noms d'autres objets.
     </para>
    </listitem>
   </itemizedlist>

   Les schémas sont comparables aux répertoires au niveau du système d'exploitation
   sauf que les schémas ne peuvent pas être imbriqués.
  </para>

  <sect2 id="ddl-schemas-create">
   <title>Créer un schéma</title>

   <indexterm zone="ddl-schemas-create">
    <primary>schéma</primary>
    <secondary>créer</secondary>
   </indexterm>

   <para>
    Pour créer un schéma, utilisez la commande <command>CREATE
    SCHEMA</command>. Donnez au schéma un nom de votre choix. Par
    exemple&nbsp;:
<programlisting>
CREATE SCHEMA mon_schema;
</programlisting>
   </para>

   <indexterm>
    <primary>nom qualifié</primary>
   </indexterm>

   <indexterm>
    <primary>nom</primary>
    <secondary>qualifié</secondary>
   </indexterm>

   <para>
    Pour créer ou accéder aux objets dans un schéma, écrivez un
    <firstterm>nom qualifié</firstterm> qui consiste en le nom du schéma et
    le nom de la table séparés par un point&nbsp;:
<synopsis>
<replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    Ceci fonctionne partout où un nom de table est attendu, donc en incluant les
    commandes de modification de la table et les commandes d'accès aux données
    discutées dans les chapitres suivants (nous parlons uniquement
    des tables mais les mêmes idées s'appliquent aux autres genres d'objets
    nommés, comme les types et les fonctions).
   </para>
   
   <para>
    En fait, la syntaxe encore plus générale
<synopsis>
<replaceable>basededonnees</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    peut être utilisé aussi mais, pour le moment, ceci n'existe que pour
    être conforme au standard SQL. Si vous écrivez un nom de base de
    données, il devrait être celui de la base auquel vous êtes connecté.
   </para>

   <para>
    Donc, pour créer une table dans le nouveau schéma, utilisez
<programlisting>
CREATE TABLE mon_schema.ma_table (
 ...
);
</programlisting>
   </para>

   <indexterm>
    <primary>schéma</primary>
    <secondary>suppression</secondary>
   </indexterm>

   <para>
    Pour effacer un schéma vide (tous les objets qu'il contient ont été
    supprimés), utilisez
<programlisting>
DROP SCHEMA mon_schema;
</programlisting>
    Pour effacer un schéma avec les objets qu'il contient, utilisez
<programlisting>
DROP SCHEMA mon_schema CASCADE;
</programlisting>
    Lisez la <xref linkend="ddl-depend"/> pour une description du mécanisme
    général derrière tout ceci.
   </para>

   <para>
    Souvent, vous voudrez modifier le schéma utilisé par quelqu'un
    d'autre (puisque c'est l'une des méthodes par lesquelles on peut
    restreindre l'activité de vos utilisateurs à des espaces de nom
    définis). La syntaxe pour ceci est&nbsp;:
<programlisting>
CREATE SCHEMA <replaceable>nom_schema</replaceable> AUTHORIZATION <replaceable>nom_utilisateur</replaceable>;
</programlisting>
    Vous pouvez même omettre le nom du schéma auquel cas, le nom du schéma
    sera le même que le nom d'utilisateur. Voir la <xref
    linkend="ddl-schemas-patterns"/> pour voir comment cela peut être utilisé.
   </para>

   <para>
    Les noms de schéma commençant par <literal>pg_</literal> sont réservés pour
    les besoins du système et les schémas commençant ainsi ne peuvent pas être
    créés par les utilisateurs.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-public">
   <title>Le schéma public</title>

   <indexterm zone="ddl-schemas-public">
    <primary>schéma</primary>
    <secondary>public</secondary>
   </indexterm>

   <para>
    Dans les sections précédentes, on créait des tables sans spécifier un
    nom de schéma. Par défaut, ces tables (et autres objets) sont
    automatiquement placées dans un schéma nommé <quote>public</quote>. Toute
    nouvelle base de données contient un tel schéma. Donc, ces instructions
    sont équivalentes&nbsp;:
<programlisting>
CREATE TABLE produits ( ... );
</programlisting>
    et
<programlisting>
CREATE TABLE public.produits ( ... );
</programlisting>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-path">
   <title>Chemin de recherche de schéma</title>

   <indexterm>
    <primary>chemin de recherche</primary>
   </indexterm>

   <indexterm>
    <primary>nom non qualifié</primary>
   </indexterm>

   <indexterm>
    <primary>nom</primary>
    <secondary>non qualifié</secondary>
   </indexterm>

   <para>
    Les noms qualifiés sont pénibles à écrire et il est, de toute façon,
    préférable de ne pas coder un nom de schéma dans une application. Donc, les
    tables sont souvent appelées par des noms non <firstterm>qualifiés</firstterm>
    qui s'apparentent souvent au nom de la table lui-même. Le système détermine
    la table appelée en suivant un <firstterm>chemin de recherche</firstterm>
    qui est une liste de schémas à vérifier. La première table correspondante
    est considérée comme la table voulue. S'il n'y a pas de correspondance, une
    erreur est remontée, même si des noms de table correspondants existent dans
    d'autres schémas de la base.
   </para>

   <indexterm>
    <primary>schéma</primary>
    <secondary>courant</secondary>
   </indexterm>

   <para>
    Le premier schéma dans le chemin de recherche est appelé le schéma courant.
    En plus d'être le premier schéma parcouru, il est aussi le schéma dans lequel
    de nouvelles tables seront créées si la commande <command>CREATE TABLE</command>
    ne précise pas de nom de schéma.
   </para>

   <indexterm>
    <primary>search_path</primary>
   </indexterm>

   <para>
    Pour voir le chemin de recherche courant, utilisez la commande
    suivante&nbsp;:
<programlisting>
SHOW search_path;
</programlisting>
    Dans la configuration par défaut, ceci renvoie&nbsp;:
<screen> search_path
--------------
 $user,public</screen>
    Le premier élément précise qu'un schéma avec le même nom que l'utilisateur
    en cours doit être parcouru. Le deuxième élément renvoie au schéma public
    que nous avons déjà vu.
   </para>

   <para>
    Le premier schéma existant dans le chemin de recherche est l'endroit
    par défaut pour la création de nouveaux objets. Ceci est la raison
    pour laquelle les objets sont créés dans le schéma public. Quand les
    objets sont liés dans tout autre contexte sans une qualification de
    schéma (modification de table, modification de données ou requête de
    commande), le chemin de recherche est traversé jusqu'à ce qu'un objet
    correspondant soit trouvé. Donc, dans la configuration par défaut,
    tout accès non qualifié ne peut que se référer au schéma public.
   </para>

   <para>
    Pour mettre notre nouveau schéma dans le chemin, nous utilisons
<programlisting>
SET search_path TO mon_schema,public;
</programlisting>
    (nous ne mettons pas le <literal>$user</literal> ici car nous n'en avons
    pas besoin pour l'instant). Et nous pouvons pas accéder à la table sans
    qualification de schéma&nbsp;:
<programlisting>
DROP TABLE ma_table;
</programlisting>
    Aussi, puisque <literal>mon_schema</literal> est le premier élément dans
    le chemin, les nouveaux objets seront créés dans ce schéma.
   </para>

   <para>
    On pourrait aussi écrire
<programlisting>
SET search_path TO mon_schema;
</programlisting>
    Dans ce cas, nous n'avons pas accès au schéma public sans qualification explicite.
    Il n'y a rien de spécial à propos du schéma public hormis le fait qu'il
    existe par défaut. Il peut aussi être effacé.
   </para>

   <para>
    Voir aussi la <xref linkend="functions-info"/> qui détaille les autres façons
    de manipuler le chemin de recherche des schémas.
   </para>

   <para>
    Le chemin de recherche fonctionne de la même façon pour les noms de type de
    données, les noms de fonction et les noms d'opérateur que pour les noms de
    tables. Les types de données et de fonctions peuvent être qualifiés de la
    même façon que les noms de table. Si vous avez besoin d'écrire un nom
    d'opérateur qualifié dans une expression, il y a une condition
    spéciale&nbsp;: vous devez écrire
<synopsis>
<literal>OPERATOR(</literal><replaceable>schéma</replaceable><literal>.</literal><replaceable>opérateur</replaceable><literal>)</literal>
</synopsis>
    Ceci est nécessaire afin d'éviter une ambiguïté syntaxique. En voici un
    exemple
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    En pratique, on dépend souvent du chemin de recherche pour les opérateurs,
    afin de ne pas avoir à écrire quelque chose d'aussi peu présentable.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-priv">
   <title>Schémas et droits</title>

   <indexterm zone="ddl-schemas-priv">
    <primary>droit</primary>
    <secondary sortas="schemas">pour les schémas</secondary>
   </indexterm>

   <para>
    Par défaut, les utilisateurs ne peuvent pas accéder aux objets présents
    dans les schémas qui ne leur appartiennent pas. Pour leur permettre, le
    propriétaire du schéma doit donner le droit <literal>USAGE</literal> sur
    le schéma. Pour autoriser les utilisateurs à manipuler les objets d'un
    schéma, des droits supplémentaires devront peut-être être accordés, suivant
    l'objet.
   </para>

   <para>
    Un utilisateur peut aussi être autorisé à créer des objets dans le
    schéma de quelqu'un d'autre. Pour permettre ceci, le droit
    <literal>CREATE</literal> doit être accordé. Notez que, par défaut,
    tout le monde a les droits <literal>CREATE</literal> et
    <literal>USAGE</literal> sur le schéma <literal>public</literal>.
    Ceci permet à tous les utilisateurs qui sont capables de se connecter
    à une base de données de créer des objets dans son schéma
    <literal>public</literal>. Si vous ne souhaitez pas ce comportement,
    vous pouvez révoquer ce droit&nbsp;:
<programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
    Le premier <quote>public</quote> est le schéma, le second
    <quote>public</quote> veut dire <quote>chaque utilisateur</quote>. Dans le
    premier cas, c'est un identifieur. Dans le second, c'est un mot clé,
    d'où la casse différente. Souvenez-vous des règles de la
    <xref linkend="sql-syntax-identifiers"/>.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-catalog">
   <title>Catalogue du système de schémas</title>

   <indexterm zone="ddl-schemas-catalog">
    <primary>système de catalogue</primary>
    <secondary>schéma</secondary>
   </indexterm>

   <para>
    En plus du schéma <literal>public</literal> et de ceux créés par les
    utilisateurs, chaque
    base de données contient un schéma <literal>pg_catalog</literal>, qui contient
    les tables systèmes et tous les types de données, fonctions et opérateurs
    intégrés. <literal>pg_catalog</literal> fait toujours partie du chemin
    de recherche. S'il n'est pas nommé explicitement dans le chemin, il est
    parcouru implicitement <emphasis>avant</emphasis> la recherche dans les schémas
    du chemin. Ceci garantie qui les noms internes seront toujours trouvables .
    Par contre, vous pouvez explicitement placer <literal>pg_catalog</literal> à la
    fin si vous préférez que les noms définis par les utilisateurs surchargent
    les noms internes.
   </para>

   <para>
    Dans les versions de <productname>PostgreSQL</productname> antérieures à la 7.3,
    les noms de table commençant par <literal>pg_</literal> étaient réservés. Ceci
    n'est plus vrai&nbsp;: vous pouvez créer une telle table si vous le voulez
    dans n'importe quel schéma non système. Par contre, il vaut mieux
    continuer d'éviter de tels noms pour garantir que vous n'aurez pas
    de conflit si une prochaine version définit une table système qui
    porte le même nom que votre table (avec le chemin de recherche par
    défaut, une référence non qualifiée à votre table pointera au lieu
    vers la table système).
    Les tables systèmes continueront de suivre la convention de porter
    des noms commençant par <literal>pg_</literal> pour qu'ils n'aient pas de
    conflit avec des noms de table non qualifiés tant que les utilisateurs
    éviteront le préfixe <literal>pg_</literal>.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-patterns">
   <title>Méthodes d'utilisation</title>

   <para>
    Les schémas peuvent être utilisés pour organiser vos données de plusieurs
    manières. Plusieurs sont recommandés et sont facilement supportés par la
    configuration par défaut&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Si vous ne créez aucun schéma, alors tout les utilisateurs
       auront accès au schéma public implicitement. Ceci simule la
       situation dans laquelle les schémas ne sont pas disponibles.
       Cette situation est recommandée lorsque il n'y a qu'un seul
       utilisateur ou quelques utilisateurs coopérants dans une base
       de données. Cette configuration permet aussi une transition
       en douceur d'une situation où on ne connaît pas le schéma.
      </para>
     </listitem>

     <listitem>
      <para>
       Vous pouvez créer un schéma pour chaque utilisateur avec un
       nom identique à celui de l'utilisateur. Souvenez-vous que le
       chemin de recherche par défaut commence par
       <literal>$user</literal>, ce qui correspond au nom d'utilisateur.
       Donc si chaque utilisateur a un schéma distinct, ils accèdent
       à leurs propres schémas par défaut.
      </para>

      <para>
       Si vous utilisez cette configuration, alors vous devriez peut-être
       aussi révoquer l'accès au schéma public (ou l'effacer complètement)
       pour que les utilisateurs soient réellement limités à leur propre
       schéma.
      </para>
     </listitem>

     <listitem>
      <para>
       Pour installer des applications partagées (tables utilisables
       par tout le monde, fonctionnalités supplémentaires fournies par
       des applications tiers, etc), insérez-les dans des schéma séparés.
       Rappelez-vous que vous devez donner les permissions appropriées
       pour permettre aux utilisateurs d'y accéder. Les utilisateurs
       peuvent alors se référer à ces objets additionnels en qualifiant
       les noms avec un nom de schéma ou ils peuvent mettre les schémas
       supplémentaires dans leur chemin de recherche, s'ils le souhaitent.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-portability">
   <title>Portabilité</title>

   <para>
    Dans le standard SQL, la notion d'objets du même schéma
    appartenant à des utilisateurs différents n'existe pas. De plus,
    certaines implémentations ne vous permettent pas de créer des
    schémas qui ont un nom différent de celui de leur propriétaire.
    En fait, les concepts de schéma et d'utilisateur sont presque
    équivalents dans un système de base de données qui n'implémente
    que le support basique des schémas spécifiés dans le standard.
    À partir de ce constat, beaucoup d'utilisateurs considèrent les noms
    qualifiés comme correspondant réellement à
    <literal><replaceable>utilisateur</replaceable>.<replaceable>table</replaceable></literal>.
    C'est comme cela que <productname>PostgreSQL</productname> se comporte
    si vous créez un schéma par utilisateur pour chaque utilisateur.
   </para>

   <para>
    De plus, il n'y a aucun concept d'un schéma <literal>public</literal> dans le
    standard SQL. Pour plus de conformité au standard, vous ne devriez pas
    utiliser (et sans doute effacer) le schéma <literal>public</literal>.
   </para>

   <para>
    Bien sûr, certains systèmes de bases de données n'implémentent pas du
    tout les schémas. ou donnent le support d'espace de nommage en
    autorisant (peut-être de façon limité) des accès sur plusieurs bases
    de données. Dans ce cas, la portabilité maximale sera obtenue en n'utilisant
    pas du tout les schémas.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-inherit">
  <title>Héritage</title>

  <indexterm>
   <primary>héritage</primary>
  </indexterm>

  <indexterm>
   <primary>table</primary>
   <secondary>héritage</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> implémente l'héritage des tables,
   un outil bien utile pour les concepteurs de bases de données (SQL:1999 et
   les versions ultérieures définissent une fonctionnalité d'héritage de
   type qui diffère par de nombreux aspects des fonctionnalités décrites ici).
  </para>

  <para>
   Commençons avec un exemple&nbsp;: supposons que nous essayons de construire
   un modèle de données pour les villes. Chaque état a plusieurs villes mais
   ne dispose que d'une capitale. Nous voulons être capable de retrouver
   rapidement la ville de la capitale pour tout état. Ceci peut se faire en
   créant deux tables, une pour les capitales et une pour les villes qui ne
   sont pas des capitales. Néanmoins, que se passe-t'il quand nous voulons
   récupérer les données de toutes les villes, capitales ou non&nbsp;?
   l'héritage nous permet de résoudre ce problème. Nous définissons une
   table <structname>capitales</structname> comme héritant de
   <structname>villes</structname>&nbsp;:

<programlisting>
CREATE TABLE villes (
    nom             text,
    population      float,
    altitude        int     -- (en pied)
);

CREATE TABLE capitales (
    etat           char(2)
) INHERITS (villes);
</programlisting>

   Dans ce cas, la table <structname>capitales</structname> <firstterm>hérite</firstterm> de
   toutes les colonnes de sa table parent, <structname>villes</structname>. Les capitales
   ont aussi une colonne supplémentaire, <structfield>état</structfield>, indiquant leur
   état.
  </para>

  <para>
   Dans <productname>PostgreSQL</productname>, une table peut hériter d'aucune,
   de une ou de plusieurs autres tables. Une requête peut référencer soit toutes
   les lignes d'une table soit toutes les lignes d'une table ainsi que celles
   des tables descendantes. Ce dernier comportement est celui par défaut. Par
   exemple, la requête suivante trouve les noms de toutes les villes, y compris
   les capitales, situées à une altitude supérieure à 500 pieds&nbsp;:

<programlisting>
SELECT nom, altitude
    FROM villes
    WHERE altitude &gt; 500;
</programlisting>

   Étant donné les données provenant du tutoriel de <productname>PostgreSQL</productname>
   (voir <xref linkend="tutorial-sql-intro"/>), ceci renvoit&nbsp;:

<programlisting>
   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
</programlisting>
  </para>

  <para>
   D'un autre côté, la requête suivante trouve toutes les villes qui ne sont
   pas des capitales et qui sont situées à une altitude de plus de 500
   pieds&nbsp;:

<programlisting>
SELECT nom, altitude
    FROM ONLY villes
    WHERE altitude &gt; 500;

   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
</programlisting>
  </para>

  <para>
   Le mot clé <literal>ONLY</literal> indique que la requête s'applique seulement
   aux <structname>villes</structname>, et non pas à toutes les tables en-dessous
   de <structname>cities</structname> suivant la hiérarchie de l'héritage. Un
   grand nombre des colonnes dont nous avons déjà discutées &mdash;
   <command>SELECT</command>, <command>UPDATE</command> et
   <command>DELETE</command> &mdash; supportent le mot clé
   <literal>ONLY</literal>.
  </para>

  <para>
  Dans certain cas, vous souhaitez savoir de quelle table provient une ligne
  donnée. Une colonne système appelée <structfield>TABLEOID</structfield>
  présente dans chaque table vous donne la table d'origine&nbsp;:

<programlisting>
SELECT c.tableoid, c.nom, c.altitude
FROM villes c
WHERE c.altitude &gt; 500;
</programlisting>

   qui renvoie&nbsp;:

<programlisting>
 tableoid |   nom    | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845
</programlisting>

   (Si vous essayez de reproduire cet exemple, vous obtiendrez probablement des
   OID numériques différents). En faisant une jointure avec
   <structname>pg_class</structname>, vous pourrez voir les noms de tables
   actuelles&nbsp;:

<programlisting>
SELECT p.relname, v.nom, v.altitude
FROM villes v, pg_class p
WHERE v.altitude &gt; 500 and v.tableoid = p.oid;
</programlisting>

   ce qui retourne&nbsp;:

<programlisting>
 relname   |   nom     | altitude
-----------+-----------+----------
 villes    | Las Vegas |     2174
 villes    | Mariposa  |     1953
 capitales | Madison   |      845
</programlisting>
   
  </para>

  <para>
   L'héritage ne propage pas automatiquement les données des commandes
   <command>INSERT</command> ou <command>COPY</command> aux autres tables de
   la hiérarchie de l'héritage. Dans notre exemple, l'instruction
   <command>INSERT</command> suivante échouera&nbsp;:
<programlisting>
INSERT INTO villes (nom, population, altitude, etat)
VALUES ('New York', NULL, NULL, 'NY');
</programlisting>
   Nous pouvions espérer que les données seraient renvoyées dans la table
   <structname>capitales</structname> mais ceci n'arrivera pas&nbsp;:
   <command>INSERT</command> insère toujours dans la table indiquée. Dans
   certains cas, il est possible de rediriger l'insertion en utilisant une
   règle (voir <xref linkend="rules"/>). Néanmoins, cela n'aide pas pour le
   cas ci-dessus car la table <structname>villes</structname> ne contient pas la
   colonne <structfield>etat</structfield>, donc la commande sera rejetée avant que la
   règle ne soit appliquée.
  </para>

  <para>
   Les contraintes de vérification peuvent être définies sur les tables de la
   hiérarchie d'héritage. Toutes les contraintes de vérification d'une table
   parent. Toutes les contraintes de vérification d'une table parent sont
   automatiquement héritées par tous ses enfants. Néanmoins, les autres types
   de contraintes ne sont pas hérités.
  </para>

  <para>
   Une table peut hériter de plus d'une table parent, auquel cas elle comprend
   l'union des colonnes définies par les tables parents. Toute colonne déclarée
   dans la définition de la table enfant est ajoutée à celles-ci. Si le même nom
   de colonne apparaît dans plusieurs tables parent, alors ces colonnes sont
   <quote>assemblées</quote> pour qu'il n'existe qu'une seule colonne dans la table
   enfant. Pour être assemblées, les colonnes doivent avoir le même type de
   données, sinon une erreur survient. La colonne assemblée copiera toutes les
   contraintes de vérification provenant de toutes les définitions de colonnes
   dont elle provient.
  </para>

  <para>
   Actuellement, l'héritage de table peut seulement être définie en utilisant
   en utilisant l'instruction <xref linkend="sql-createtable"
   endterm="sql-createtable-title"/>. L'instruction relative <command>CREATE
   TABLE AS</command> ne permet pas la spécification d'un héritage. Il n'existe
   aucune façon d'ajouter un lien d'héritage pour transformer une table existante
   en table enfant. De façon similaire, il n'existe aucun moyen de supprimer un
   lien d'héritage d'une table enfant une fois qu'elle a été définie, autrement
   qu'en supprimant la table complètement. Une table parent ne peut pas être
   supprimée alors qu'un de ces enfants reste. Si vous souhaitez supprimer une
   table et tous ces descendants, une façon simple est de supprimer la table
   parent avec l'option <literal>CASCADE</literal>.
  </para>

  <para>
   <xref linkend="sql-altertable" endterm="sql-altertable-title"/>
   propagera toute modification dans les définitions des colonnes et dans les
   contraintes de vérification aux héritages. De nouveau, supprimer des colonnes
   ou des contraintes sur les tables parents n'est possible qu'en utilisant
   l'option <literal>CASCADE</literal>. <command>ALTER TABLE</command> suit les
   mêmes règles pour l'assemblage des colonnes dupliquées et le rejet qui
   s'appliquent lors de l'instruction <command>CREATE TABLE</command>.
  </para>

 <sect2 id="ddl-inherit-caveats">
  <title>Astuces</title>

  <para>
   Les droits d'accès des tables ne sont pas automatiquement hérités. Du coup,
   un utilisateur tentant d'accéder à une table parent doit soit avoir aussi les
   droits pour réaliser l'opération sur toutes les tables enfants soit utiliser
   le mot clé <literal>ONLY</literal>. Lors de l'ajout d'une nouvelle table
   enfant à un héritage existant, faites attention de donner tous les droits
   nécessaires dessus.
  </para>

  <para>
    Une limitation sérieuse de la fonctionnalité d'héritage est que les index
    (incluant les contraintes uniques) et les contraintes de clés étrangères
    s'appliquent seulement à des tables seules, pas à leurs héritiers. Ceci
    est vrai pour le côté de référence et le côté référencé d'une contrainte
    de clé étrangère. Du coup, dans les termes de l'exemple ci-dessus&nbsp;:

    <itemizedlist>
      <listitem>
        <para>
          Si nous déclarons <structname>villes</structname>.<structfield>nom</structfield> comme
           <literal>UNIQUE</literal> ou comme une clé primaire (<literal>PRIMARY
	   KEY</literal>), ceci
           n'empêchera pas la table <structname>capitales</structname> d'avoir des lignes
           avec des noms dupliqués dans <structname>villes</structname>. Et ces lignes
           dupliquées pourraient par défaut s'afficher dans les requêtes sur
           <structname>villes</structname>. En fait, par défaut,
           <structname>capitales</structname> n'aurait pas du tout de contrainte
           unique et, du coup, pourrait contenir plusieurs lignes avec le
           même nom. Vous pouvez ajouter une contrainte unique à
           <structname>capitales</structname> mais ceci n'empêcherait pas la duplication
           comparée à <structname>villes</structname>.
        </para>
      </listitem>

      <listitem>
        <para>
          De façon similaire, si nous devions spécifier que
          <structname>villes</structname>.<structfield>nom</structfield> fait référence
          (<literal>REFERENCES</literal>) une autre table, cette contrainte ne serait
          pas automatiquement propager à <structname>capitales</structname>. Dans ce cas,
          vous pourriez contourner ceci en ajoutant manuellement la même
          contrainte <literal>REFERENCES</literal> à <structname>capitales</structname>.
        </para>
      </listitem>

      <listitem>
        <para>
          Spécifier que la colonne d'une autre table <literal>REFERENCES
          villes(nom)</literal> autoriserait l'autre table à contenir les noms des
          villes mais pas les noms des capitales. Il n'existe pas de bons
          contournements pour ce cas.
        </para>
      </listitem>
    </itemizedlist>

    Ces déficiences seront probablement corrigées dans une version future mais
    en attendant, un soucis considérable est nécessaire dans la décision de
    l'utilité de l'héritage pour votre problème.
  </para>

  <note>
   <title>Obsolète</title>
   <para>
     Dans les précédentes versions de <productname>PostgreSQL</productname>, le
     comportement par défaut n'était pas d'inclure les tables enfants dans les
     requêtes. Ceci facilitait les erreurs et est en plus une violation du
     standard SQL. Avec l'ancienne syntaxe, pour inclure les tables enfants,
     vous deviez ajouter <literal>*</literal> au nom de la table. Par
     exemple&nbsp;:
<programlisting>
SELECT * from villes*;
</programlisting>
     Vous pouvez toujours spécifier explicitement le parcours des tables enfants
     en ajoutant <literal>*</literal> et spécifier explicitement de ne pas
     parcourir les tables enfants en précisant <literal>ONLY</literal>. Mais à
     partir de la version 7.1, le comportement par défaut pour un nom de table
     sans ajout est de parcourir aussi les tables enfants. Pour obtenir l'ancien
     comportement par défaut, désactivez l'option <xref linkend="guc-sql-inheritance"/>.
   </para>
  </note>

   </sect2>
  </sect1>

  <sect1 id="ddl-partitioning">
   <title>Partitionnement</title>

   <indexterm>
    <primary>partitionnement</primary>
   </indexterm>

   <indexterm>
    <primary>table</primary>
    <secondary>partitionnement</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> offre un support basique du
    partitionnement de table. Cette section décrit pourquoi et comment vous
    pouvez implémenter le partitionnement dans la conception de votre base
    de données.
   </para>

   <sect2 id="ddl-partitioning-overview">
     <title>Aperçu</title>

   <para>
    Le partitionnement fait référence à la division logique d'une grosse table
    en plusieurs parties physiques. Le partitionnement apporte plusieurs
    bénéfices&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      Les performances des requêtes peuvent être dramatiquement améliorées pour
      certains types de requêtes.
     </para>
    </listitem>

    <listitem>
     <para>
      Les performances de mise à jour peuvent aussi être améliorées car chaque
      pièce de la table a des index plus petits que ne le serait l'index de
      l'ensemble complet des données. Quand un index n'est plus facilement
      contenu en mémoire, les opérations de lecture et d'écriture sur
      l'index demandent progressivement plus d'accès au disque.
     </para>
    </listitem>

    <listitem>
     <para>
      Les suppressions en masse peuvent être accomplies en supprimant simplement
      une des partitions, si ce besoin est pris en compte dans la conception du
      partitionnement. <command>DROP TABLE</command> est bien plus rapide qu'un groupe
      de <command>DELETE</command>, sans parler de la surcharge occasionnée par le
      <command>VACUUM</command> qui suit.
     </para>
    </listitem>

    <listitem>
     <para>
      Les données peu utilisées peuvent être déplacées sur un média peu cher et
      lent.
     </para>
    </listitem>
   </itemizedlist>

    Les bénéfices seront normalement intéressants quand une table sera
    suffisamment importante. Le point exact où une table bénéficierait d'un
    partitionnement dépend de l'application bien qu'une règle de base est que
    la taille de la table ne doit pas dépasser la mémoire physique du serveur.
   </para>

   <para>
    Actuellement, <productname>PostgreSQL</productname> supporte le
    partitionnement via l'héritage des tables. Chaque partition doit être
    créée comme une table enfant d'une seule table parent. La table parent
    elle-même est habituellement vide&nbsp;; elle existe seulement pour
    représenter l'ensemble complet des données. Vous devez être familier
    avec l'héritage (voir <xref linkend="ddl-inherit"/>) avant de tenter
    d'implanter le partitionnement.
   </para>

   <para>
    Les formes suivantes de partitionnement peuvent être implantées dans
    <productname>PostgreSQL</productname>&nbsp;:

    <variablelist>
     <varlistentry>
      <term>Partitionnement de groupe</term>

      <listitem>
       <para>
        La table est partitionnée en <quote>groupes</quote> définis par une
	colonne clé ou par un ensemble de colonnes, sans intersection dans
	les ensembles de valeurs affectées aux différentes partition. Par
	exemple, il est possible de partitionner par date ou par ensemble
	d'identifieurs pour des objets métier particuliers.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Partitionnement de liste</term>

      <listitem>
       <para>
        La table est partitionnée en listant explicitement les valeurs clés
	apparaissant dans chaque partition.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Le partitionnement par hachage n'est pas encore supporté.
   </para>
   </sect2>

   <sect2 id="ddl-partitioning-implementation">
     <title>Implanter le partitionnement</title>

    <para>
     Pour configurer une table partitionnée, faites ce qui suit&nbsp;:
     <orderedlist spacing="compact">
      <listitem>
       <para>
        Créez la table <quote>maître</quote> à partir de laquelle toutes les
	partitions vont hériter.
       </para>
       <para>
        Cette table ne contiendra pas de données. Ne définissez pas de contraintes
	de vérification sur cette table sauf si vous avez l'intention de les
	appliquer sur toutes les partitions. Il n'y a non plus aucune raison de
	définir des index ou des contraintes uniques sur elle.
       </para>
      </listitem>

      <listitem>
       <para>
        Créez plusieurs tables <quote>filles</quote> qui héritent chacune de la
	table maître. Normalement, ces tables n'ajouteront pas de colonnes
	à l'ensemble hérité du maître.
       </para>

       <para>
        Nous ferons référence aux tables enfants par le mot partition bien
	qu'elles se comportent comme de vraies tables <productname>PostgreSQL</productname>.
       </para>
      </listitem>

      <listitem>
       <para>
        Ajoutez les contraintes de tables aux tables partition pour définir
	les valeurs des clés autorisées dans chaque partition.
       </para>

       <para>
        Voici quelques exemples typiques&nbsp;:
<programlisting>
CHECK ( x = 1 )
CHECK ( comté IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( ID &gt;= 100 AND ID &lt; 200 )
</programlisting>
        Assurez-vous que les contraintes garantissent qu'il n'y aura pas
	d'intersection entre les valeurs clés permises dans les différentes
	partitions. Une erreur commune est de configurer des contraintes
	d'échelle de cette façon&nbsp;:
<programlisting>
CHECK ( comté BETWEEN 100 AND 200 )
CHECK ( comté BETWEEN 200 AND 300 )
</programlisting>
        Ceci est mauvais car il n'est pas aisé de savoir à quelle partition
	appartient la clé 200.
       </para>

       <para>
        Notez qu'il n'y a aucune différence dans la syntaxe BETWEEN et le
	partitionnement de listes&nbsp;; ces termes sont seulement descriptifs.
       </para>
      </listitem>

      <listitem>
       <para>
        Pour chaque partition, créez un index sur la (ou les) colonne(s) clé(s),
        ainsi que tout autre index nécessaire (l'index clé n'est pas vraiment
	nécessaire mais, dans la plupart des scénarios, il est utile. Si vous
	avez l'intention que les valeurs clés soient uniques, alors vous devez
	toujours créer une contrainte unique ou une clé primaire pour chaque
	partition.)
       </para>
      </listitem>

      <listitem>
       <para>
        En option, définissez une règle ou un déclencheur pour rediriger les
	modifications de la table maître vers la partition appropriée.
       </para>
      </listitem>

      <listitem>
       <para>
        Assurez-vous que le paramètre de configuration <xref
	linkend="guc-constraint-exclusion"/> est activé dans
	<filename>postgresql.conf</filename>. Sans ce dernier, les requêtes ne sont
	pas optimisées.
       </para>
      </listitem>

     </orderedlist>
    </para>

    <para>
     Par exemple, supposons que nous construisons une base de données pour une
     grande société de glaces. La compagnie mesure les piques de températures
     chaque jour ainsi que les ventes de glaces dans chaque région. À la base,
     nous voulons une table comme ceci&nbsp;:

<programlisting>
CREATE TABLE mesure (
    id_ville        int not null,
    date_trace      date not null,
    temperature     int,
    ventes          int
);
</programlisting>

     Nous savons que la plupart des requêtes accèdent seulement à la dernière
     semaine, au dernier mois ou au dernier trimestre des données car l'utilisation
     principale de cette table sera de préparer des rapports en ligne pour la
     gestion. Pour réduire le nombre de données anciennes devant être restaurées,
     nous décidons de conserver seulement les trois dernières années. Au début
     de chaque mois, nous supprimerons les données de l'ancien mois.
    </para>

    <para>
     Dans cette situation, nous pouvons utiliser le partitionnement pour nous
     aider dans nos différents besoins pour la table mesure. En suivant les
     étapes indiquées ci-dessus, le partitionnement peut être configuré de la
     façon suivante&nbsp;:
    </para>

    <para>
     <orderedlist spacing="compact">
      <listitem>
       <para>
        La table maître est la table <structname>mesure</structname>, déclarée exactement
	comme ci-dessous.
       </para>
      </listitem>

      <listitem>
       <para>
        Ensuite, nous créons une partition pour chaque mois actif&nbsp;:

<programlisting>
CREATE TABLE mesure_aa04mm02 ( ) INHERITS (mesure);
CREATE TABLE mesure_aa04mm03 ( ) INHERITS (mesure);
...
CREATE TABLE mesure_aa05mm11 ( ) INHERITS (mesure);
CREATE TABLE mesure_aa05mm12 ( ) INHERITS (mesure);
CREATE TABLE mesure_aa06mm01 ( ) INHERITS (mesure);
</programlisting>

        Chaque partition est une table complète avec leur propre droits mais
	leur définition est héritée de la table <structname>mesure</structname>.
       </para>

       <para>
	Ceci résoud un de nos problèmes&nbsp;: supprimer les anciennes données.
	Chaque mois, tout ce que nous aurons à faire est un <command>DROP
	TABLE</command> sur l'ancienne table enfant et créez une nouvelle table
	enfant pour les données du nouveau mois.
       </para>
      </listitem>

      <listitem>
       <para>
	Nous devons ajouter des contraintes de table qui ne permettent pas
	l'intersection des ensembles de données, donc notre script de création
	de table devient&nbsp;:

 <programlisting>
CREATE TABLE mesure_aa04mm02 (
    CHECK ( date_trace &gt;= DATE '2004-02-01' AND date_trace &lt; DATE '2004-03-01' )
) INHERITS (mesure);
CREATE TABLE mesure_aa04mm03 (
    CHECK ( date_trace &gt;= DATE '2004-03-01' AND date_trace &lt; DATE '2004-04-01' )
) INHERITS (mesure);
...
CREATE TABLE mesure_aa05mm11 (
    CHECK ( date_trace &gt;= DATE '2005-11-01' AND date_trace &lt; DATE '2005-12-01' )
) INHERITS (mesure);
CREATE TABLE mesure_aa05mm12 (
    CHECK ( date_trace &gt;= DATE '2005-12-01' AND date_trace &lt; DATE '2006-01-01' )
) INHERITS (mesure);
CREATE TABLE mesure_aa06mm01 (
    CHECK ( date_trace &gt;= DATE '2006-01-01' AND date_trace &lt; DATE '2006-02-01' )
) INHERITS (mesure);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Nous avons probablement besoin d'index sur les colonnes clés&nbsp;:

 <programlisting>
CREATE INDEX mesure_yy04mm02_date_trace ON mesure_yy04mm02 (date_trace);
CREATE INDEX mesure_yy04mm03_date_trace ON mesure_yy04mm03 (date_trace);
...
CREATE INDEX mesure_yy05mm11_date_trace ON mesure_yy05mm11 (date_trace);
CREATE INDEX mesure_yy05mm12_date_trace ON mesure_yy05mm12 (date_trace);
CREATE INDEX mesure_yy06mm01_date_trace ON mesure_yy06mm01 (date_trace);
</programlisting>

        Nous choisissons de ne pas en ajouter d'autres pour l'instant.
       </para>
      </listitem>

      <listitem>
       <para>
        Si les données seront seulement ajoutées dans la dernière partition,
	nous pouvons configurer une règle très simple pour insérer des données.
	Nous devons la redéfinir chaque mois pour qu'elle pointe toujours vers
	la partition en cours.

<programlisting>
CREATE OR REPLACE RULE partition_actuelle_mesure AS
ON INSERT TO mesure
DO INSTEAD
    INSERT INTO mesure_yy06mm01 VALUES ( NEW.id_ville,
                                              NEW.date_trace,
                                              NEW.temperature,
                                              NEW.ventes );
</programlisting>

        Nous pourrions vouloir insérer des données et que le serveur situe
	automatiquement la partition où cette ligne doit être ajoutée. Nous
	pouvons le faire avec un ensemble de règles plus complexes.

<programlisting>
CREATE RULE mesure_insert_yy04mm02 AS
ON INSERT TO mesure WHERE
    ( date_trace &gt;= DATE '2004-02-01' AND date_trace &lt; DATE '2004-03-01' )
DO INSTEAD
    INSERT INTO mesure_yy04mm02 VALUES ( NEW.id_ville,
                                              NEW.date_trace,
                                              NEW.temperature,
                                              NEW.ventes );
...
CREATE RULE mesure_insert_yy05mm12 AS
ON INSERT TO mesure WHERE
    ( date_trace &gt;= DATE '2005-12-01' AND date_trace &lt; DATE '2006-01-01' )
DO INSTEAD
    INSERT INTO mesure_yy05mm12 VALUES ( NEW.id_ville,
                                              NEW.date_trace,
                                              NEW.temperature,
                                              NEW.ventes );
CREATE RULE mesure_insert_yy06mm01 AS
ON INSERT TO mesure WHERE
    ( date_trace &gt;= DATE '2006-01-01' AND date_trace &lt; DATE '2006-02-01' )
DO INSTEAD
    INSERT INTO mesure_yy06mm01 VALUES ( NEW.id_ville,
                                              NEW.date_trace,
                                              NEW.temperature,
                                              NEW.ventes );
</programlisting>

        Notez que la clause <literal>WHERE</literal> de chaque règle correspond
	exactement à la contrainte de vérification pour cette partition.
       </para>
      </listitem>
     </orderedlist>
    </para>

    <para>
     Comme nous pouvons le voir, un schéma complexe de partitionnement demanderait
     un ajout substentiel de DDL. Dans l'exemple ci-dessus, nous pouvons créer une
     nouvelle partition chaque mois, donc il est conseillé d'écrire un script qui
     génère automatiquement la DDL requise.
    </para>

   <para>
    Voici quelques conseils&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      Actuellement, il n'existe pas de moyen de vérifier que toutes les
      contraintes de vérification (<literal>CHECK</literal>) sont mutuellement
      exclusives. Le concepteur de la base de données doit faire attention.
     </para>
    </listitem>

    <listitem>
     <para>
      Il n'existe pas de façon simple de spécifier les lignes ne devant pas être
      insérées dans la table maître. Une contrainte <literal>CHECK (false)</literal>
      sur la table maître sera héritée par toutes les tables filles et ne peut donc
      pas être utilisée dans ce but. Une possibilité revient à configurer un
      déclencheur <literal>ON INSERT</literal> sur la table maître qui renvoie toujours
      une erreur (sinon, un déclencheur peut être utilisé pour rediriger les
      données dans la bonne table fille au lieu d'utiliser un ensemble de règles
      comme suggéré ci-dessus).
     </para>
    </listitem>
   </itemizedlist>
   </para>

   <para>
    Le partitionnement peut aussi être arrangé en utilisant une vue
    <literal>UNION ALL</literal>&nbsp;:

<programlisting>
CREATE VIEW mesure AS
          SELECT * FROM mesure_aa04mm02
UNION ALL SELECT * FROM mesure_aa04mm03
...
UNION ALL SELECT * FROM mesure_aa05mm11
UNION ALL SELECT * FROM mesure_aa05mm12
UNION ALL SELECT * FROM mesure_aa06mm01;
</programlisting>

    Néanmoins, l'exclusion des contraintes n'est pas supportée pour les tables
    partitionnées définies de cette façon. De plus, le besoin de recréer la vue
    ajoute une étape à l'ajout et à la suppression des partitions individuelles
    de l'ensemble des données.
   </para>
   </sect2>

   <sect2 id="ddl-partitioning-constraint-exclusion">
   <title>Partitionnement et exclusion de contrainte</title>

   <indexterm>
    <primary>exclusion de contrainte</primary>
   </indexterm>

   <para>
    L'<firstterm>exclusion de contrainte</firstterm> est une technique d'optimisation des
    requêtes pour améliorer les performances pour les tables partitionnées de la
    façon décrite ci-dessus. En exemple&nbsp;:

<programlisting>
SET constraint_exclusion = on;
SELECT count(*) FROM mesure WHERE date_trace &gt;= DATE '2006-01-01';
</programlisting>

    Sans exclusion de contrainte, la requête ci-dessus devrait parcourir chacune
    des partitions de la table <structname>mesure</structname>. Avec l'exclusion de
    contrainte activée, le plannificateur examinera les contraintes de chaque
    partition et tentera de prouver que la partition n'a pas besoin d'être
    parcourue parce qu'elle ne pourrait pas contenir de lignes correspondant à
    la clause <literal>WHERE</literal> de la requête. Quand le plannificateur peut le
    prouver, il exclut la partition du plan de requête.
   </para>

   <para>
    Vous pouvez utiliser la commande <command>EXPLAIN</command> pour afficher la
    différence avec entre un plan avec <varname>constraint_exclusion</varname> à on et
    un plan avec ce paramètre à off. Un plan typique par défaut pour ce type de
    table est&nbsp;:

<programlisting>
SET constraint_exclusion = off;
EXPLAIN SELECT count(*) FROM mesure WHERE date_trace &gt;= DATE '2006-01-01';

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=158.66..158.68 rows=1 width=0)
   ->  Append  (cost=0.00..151.88 rows=2715 width=0)
         ->  Seq Scan on mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
         ->  Seq Scan on mesure_yy04mm02 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
         ->  Seq Scan on mesure_yy04mm03 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
...
         ->  Seq Scan on mesure_yy05mm12 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
         ->  Seq Scan on mesure_yy06mm01 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
</programlisting>

    Certaines ou toutes les partitions pourraient utiliser des parcours d'index
    à la place de parcours séquentiels de la table complète mais le fait est
    qu'il n'est pas besoin de parcourir les anciennes partitions pour répondre
    à cette requête. Quand nous activons l'exclusion de contrainte, nous
    obtenons un plan réduit significativement et qui nous renvoit la même
    réponse&nbsp;:

<programlisting>
SET constraint_exclusion = on;
EXPLAIN SELECT count(*) FROM mesure WHERE date_trace &gt;= DATE '2006-01-01';
                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=63.47..63.48 rows=1 width=0)
   ->  Append  (cost=0.00..60.75 rows=1086 width=0)
         ->  Seq Scan on mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
         ->  Seq Scan on mesure_yy06mm01 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
</programlisting>
   </para>

   <para>
    Notez que l'exclusion de contraintes est seulement piloté par les contraintes
    <literal>CHECK</literal>, pas par la présence d'index. Du coup, il n'est pas
    nécessaire de définir des index sur les colonnes clés. Le fait qu'un index
    ait besoin d'être créé pour une partition donnée  dépend si vous vous
    attendez à ce que les requêtes qui parcourent la partition parcoureront
    aussi généralement une grande partie de la partition ou seulement une petite
    partie. Un index sera utile dans le dernier cas, pas dans le premier.
   </para>

   <para>
    Quelques conseils&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      L'exclusion de contrainte fonctionne seulement quand la clause
      <literal>WHERE</literal> de la requête contient des constantes. Une requête avec
      paramètre ne sera pas optimisée car le plannificateur ne sait pas quelles
      partitions la valeur du paramètre pourrait sélectionner à son exécution.
      Pour la même raison, les fonctions <quote>stables</quote> comme
      <function>CURRENT_DATE</function> doivent être évitées. Joindre la clé de
      la partition à une colonne d'une autre table ne sera pas non plus
      optimisé.
     </para>
    </listitem>

    <listitem>
     <para>
      Évitez les comparaisons inter-type dans les contraintes <literal>CHECK</literal>
      car le plannificateur échouera à prouver que de telles conditions sont
      fausses. Par exemple, la contrainte suivante fonctionnera si
      <varname>x</varname> est une colonne de type <type>integer</type>, mais
      pas si <varname>x</varname> est un <type>bigint</type>&nbsp;:
<programlisting>
CHECK ( x = 1 )
</programlisting>
      Pour une colonne <type>bigint</type>, nous devons utiliser une contrainte
      comme celle-ci&nbsp;:
<programlisting>
CHECK ( x = 1::bigint )
</programlisting>
      Le problème n'est pas limité au type <type>bigint</type> &mdash; il peut
      survenir quand le type de données par défaut de la constante ne correspond
      pas au type de données de la colonne avec laquelle elle est comparée. Les
      comparaisons inter-type dans les requêtes fournies sont habituellement
      gérées, mais pas dans les conditions <literal>CHECK</literal>.
     </para>
    </listitem>

    <listitem>
     <para>
      Les commandes <command>UPDATE</command> et <command>DELETE</command> sur
      la table maître ne traitent pas actuellement l'exclusion de contrainte.
     </para>
    </listitem>

    <listitem>
     <para>
      Toutes les constraintes de toutes les partitions de la table maître sont
      considérées pour l'exclusion de contraintes, donc un grand nombre de
      partitions a tendance à augmenter considérablement le temps de
      plannification de la requête.
     </para>
    </listitem>

    <listitem>
     <para>
      N'oubliez pas que vous avez toujours besoin d'exécuter <command>ANALYZE</command>
      individuellement sur chaque partition. Une commande comme
<programlisting>
ANALYZE mesure;
</programlisting>
      traitera seulement la table maître.
     </para>
    </listitem>

   </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-others">
  <title>D'autres objets de la base de données</title>

  <para>
   Les tables sont les objets centraux dans une structure de base de
   données relationnelles. Mais ce ne sont pas les seuls objets qui
   existent dans une base de données. Plusieurs autres types d'objets
   peuvent être créés afin de rendre l'utilisation et la gestion
   des données plus efficace ou pratique. Ils ne seront pas abordés
   dans ce chapitre mais nous vous en faisons une liste ici pour que
   vous soyez informés de ce qui est possible.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Vues
    </para>
   </listitem>

   <listitem>
    <para>
     Fonctions et opérateurs
    </para>
   </listitem>

   <listitem>
    <para>
     Types de données et domaines
    </para>
   </listitem>

   <listitem>
    <para>
     Déclencheurs et règles de réécriture
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Des informations détaillées sur ces sujets apparaissent dans la <xref
   linkend="server-programming"/>.
  </para>
 </sect1>

 <sect1 id="ddl-depend">
  <title>Gestion des dépendances</title>

  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <para>
   Lorsque vous créez des structures de base complexes impliquant
   beaucoup de tables avec des contraintes de clés étrangères, des
   vues, des déclencheurs, des fonctions, etc, vous créez implicitement
   un filet de dépendances entre les objets.
   Par exemple, une table avec une contrainte de clé étrangère dépend
   de la table à laquelle elle fait référence.
  </para>

  <para>
   Pour garantir l'intégrité de la structure entière de la base,
   <productname>PostgreSQL</productname> vérifie que vous ne pouvez
   pas effacer des objets dont d'autres objets dépendent. Par
   exemple, la tentative d'effacer la table des produits que nous
   avons utilisé dans la <xref linkend="ddl-constraints-fk"/>, avec la
   table des commandes qui en dépend, donnera un message d'erreur
   comme celui-ci&nbsp;:
<screen>DROP TABLE produits;

NOTICE:  constraint commandes_no_produit_fkey on table commandes depends on table produits
ERROR:  cannot drop table produits because other objects depend on it
HINT:  Use DROP ... CASCADE to drop the dependent objects too.</screen>
   Le message d'erreur contient un indice utile&nbsp;: si vous ne souhaitez
   pas effacer les objets dépendants individuellement, vous pouvez
   lancer
<screen>DROP TABLE produits CASCADE;</screen>
   et tous les objets seront effacés. Dans ce cas, cela n'effacera pas
   la table des commandes mais seulement la contrainte de clé étrangère
   (si vous voulez vérifier ce que <command>DROP ... CASCADE</command> fera,
   lancez <command>DROP</command> sans <literal>CASCADE</literal> et lisez les messages
   <literal>NOTICE</literal>).
  </para>

  <para>
   Toutes les commandes de suppression dans
   <productname>PostgreSQL</productname> supportent l'utilisation de
   <literal>CASCADE</literal>. Bien sûr, la nature des dépendances
   varie avec la nature des objets. Vous pouvez aussi écrire
   <literal>RESTRICT</literal> au lieu de <literal>CASCADE</literal>
   pour obtenir le comportement par défaut qui est d'empêcher les
   suppressions d'objets sur lesquelles dépendent d'autres objets.
  </para>

  <note>
   <para>
    D'après le standard SQL, spécifier
    <literal>RESTRICT</literal> ou <literal>CASCADE</literal> est
    requis. Aucun système de base de donnée ne force cette règle de cette
    manière actuellement mais le choix du comportement par défaut,
    <literal>RESTRICT</literal> ou <literal>CASCADE</literal>,
    varie suivant le système.
   </para>
  </note>

  <note>
   <para>
    Les dépendances de contraintes de clés étrangères et de colonnes
    en série des versions de <productname>PostgreSQL</productname>
    antérieures à 7.3 ne seront <emphasis>pas</emphasis> maintenues ou
    créées pendant le processus de mise à jour. Tout autre type de
    dépendance sera proprement créé pendant une mise à jour à partir d'une
    base de données antérieure à la 7.3.
   </para>
  </note>
 </sect1>

</chapter>
