<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/ddl.sgml,v 1.12 2005/09/15 07:03:16 guillaume Exp $ -->

<chapter id="ddl">
 <title>Définition des données</title>

 <para>
  Ce chapitre couvre la création des structures de données qui contiendront
  les données. Dans une base relationnelle, les données brutes
  sont stockées dans des tables. Du coup, une grande partie de ce chapitre
  sera consacrée à l'explication de la création et de la modification des tables 
  et des fonctions disponibles pour contrôler les données stockées dans les tables.
  Ensuite, nous discuterons de l'organisation des tables dans les schémas, et de
  l'attribution de droits aux tables. Enfin,
  nous verrons brièvement d'autres fonctionnalités, tel que l'héritage, les vues,
  les fonctions et les déclencheurs.
 </para>

 <sect1 id="ddl-basics">
  <title>Bases sur les tables</title>

  <indexterm zone="ddl-basics">
   <primary>table</primary>
  </indexterm>

  <indexterm>
   <primary>ligne</primary>
  </indexterm>

  <indexterm>
   <primary>colonne</primary>
  </indexterm>

  <para>
   Une table d'une base relationnelle ressemble beaucoup à un tableau
   sur papier&nbsp;: elle est constituée de lignes et de colonnes. Le nombre
   et l'ordre des colonnes sont fixés et chaque colonne a un nom. Le
   nombre de lignes est variable -- il représente la quantité de données
   stockées à un moment donné. SQL n'apporte aucune garantie sur l'ordre des
   lignes dans une table. Quand une table est lue, les lignes
   apparaîtront dans un ordre aléatoire sauf si un tri est demandé
   explicitement. Ceci est couvert dans le <xref linkend="queries">. De plus,
   SQL n'attribue pas d'identifieur unique aux lignes. Du coup, il est possible
   d'avoir plusieurs lignes complètement identiques dans une table. Ceci
   est une conséquence du modèle mathématique sur lequel repose SQL mais
   n'est habituellement pas désiré.
   Plus tard dans ce chapitre, nous verrons comment traiter ce problème.
  </para>

  <para>
   Chaque colonne a un type de donnée. Ce type de donnée restreint la série
   de valeurs possibles pouvant être attribuées à une colonne et attribue
   une sémantique à la donnée stockée dans la colonne pour qu'elle puisse
   être utilisée pour des calculs. Par exemple, une colonne déclarée comme
   étant d'un type numérique n'acceptera pas une chaîne arbitraire de texte,
   et les données stockées dans une telle colonne peuvent être utilisées dans
   des calculs mathématiques.
   Par opposition, une colonne déclarée comme étant de type chaîne de
   caractères acceptera pratiquement n'importe quel type de donnée mais ne
   se prêtera pas à des calculs mathématiques bien que d'autres opérations
   tel que la concaténation des chaînes soient disponibles.
  </para>

  <para>
   <productname>PostgreSQL</productname> inclut une série conséquente de types
   de données intégrés qui correspondent à plusieurs applications. Les
   utilisateurs peuvent aussi définir leurs propres types de données. La
   plupart des types de données intégrés ont des noms et des sémantiques
   évidents alors nous reportons une explication détaillée au <xref
   linkend="datatype">. Quelques-uns des types les plus utilisés sont
   <type>integer</type> pour les entiers, <type>numeric</type> pour
   les nombres pouvant être fractionnels, <type>text</type> pour les chaînes de
   caractères, <type>date</type> pour les dates, <type>time</type> pour
   les valeurs de type heure et <type>timestamp</type> pour les valeurs
   contenant une date et une heure.
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>création</secondary>
  </indexterm>

  <para>
   Pour créer une table, il faut utiliser la commande bien nommée <command>CREATE
   TABLE</command>. Dans cette commande, vous devez spécifier au moins le nom de la
   nouvelle table, les noms des colonnes et le type de données pour chacune des
   colonnes. Par exemple&nbsp;:
<programlisting>
CREATE TABLE ma_premiere_table (
    premiere_colonne text,
    deuxieme_colonne integer
);
</programlisting>
   Ceci crée une table nommée <literal>ma_premiere_table</literal> avec
   deux colonnes. La première colonne est nommée
   <literal>premiere_colonne</literal> et a un type de données
   <type>text</type>&nbsp;; la seconde colonne porte le nom
   <literal>deuxieme_colonne</literal> et le type <type>integer</type>.
   Les noms de table et colonne suivent la syntaxe des identifieurs expliquée
   dans la <xref linkend="sql-syntax-identifiers">.  Les noms des types sont souvent
   aussi des identifieurs mais il existe des exceptions. Notez que la liste des
   colonnes est séparée par des virgules et entourée par des parenthèses.
  </para>

  <para>
   Bien sûr, l'exemple précédant est un peu tiré par les cheveux. Normalement,
   on donne aux tables et aux colonnes des noms indiquant quels types de données
   ils stockent. Alors, voyons un exemple plus réaliste&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric
);
</programlisting>
   Le type <type>numeric</type> peut stocker des composants fractionnels
   par exemple des montants.
  </para>

  <tip>
   <para>
    Quand vous créez des tables liées entre elles, il est prudent de choisir
    des règles de nommage pour les tables et les colonnes. Par exemple, il
    peut y avoir le choix d'utiliser des noms au pluriel ou au singulier
    pour les noms de table, chaque choix ayant les faveurs d'un théoricien
    ou d'un autre.
   </para>
  </tip>

  <para>
   Il y a une limite sur le nombre de colonnes qu'une table peut contenir.
   Suivant le type de colonne, ce nombre oscille entre 250 et 1600.
   Par contre, définir une table avec un nombre de colonnes proche de ceux-ci
   est très inhabituel et est souvent la preuve d'une conception douteuse.
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>suppression</secondary>
  </indexterm>

  <para>
   Si vous n'avez plus besoin d'une table, vous pouvez la retirer en utilisant
   la commande <command>DROP TABLE</command>. Par exemple&nbsp;:
<programlisting>
DROP TABLE ma_premiere_table;
DROP TABLE produits;
</programlisting>
   Tenter de supprimer une table qui n'existe pas est une erreur.
   Malgré cela, il est habituel dans des fichiers de scripts SQL d'essayer
   de supprimer chaque table avant de la créer, tout en ignorant les messages
   d'erreur.
  </para>

  <para>
   Si vous avez besoin de modifier une table qui existe déjà, regardez la <xref
   linkend="ddl-alter"> plus loin dans ce chapitre.
  </para>

  <para>
   Avec les outils dont nous avons déjà discuté, vous pouvez créer des tables
   fonctionnelles. Le reste de ce chapitre est consacré à l'ajout de fonctionnalités,
   à la définition de tables pour garantir l'intégrité des données, la sécurité
   ou la facilité.  Si vous êtes impatients de remplir vos tables avec des données,
   vous pouvez sauter au <xref linkend="dml"> et lire le reste de
   ce chapitre plus tard.
  </para>
 </sect1>

 <sect1 id="ddl-default">
  <title>Valeurs par défaut</title>

  <indexterm zone="ddl-default">
   <primary>valeur par défaut</primary>
  </indexterm>

  <para>
   Une valeur par défaut est attribuable à une colonne. Quand une nouvelle
   ligne est créée et qu'aucune valeur n'est spécifiée pour certaines de ses
   colonnes, celles-ci sont remplies avec leur valeur par défaut respective.
   Une commande de manipulation de données peut aussi demander explicitement
   qu'une colonne soit mise à sa valeur par défaut sans avoir à connaître la
   valeur en question (les détails sur les commandes de manipulation de données
   sont donnés au <xref linkend="dml">).
  </para>

  <para>
   <indexterm><primary>valeur NULL</primary><secondary>valeur par défaut</secondary></indexterm>
   Si aucune valeur par défaut n'est déclarée explicitement, la valeur
   par défaut est la valeur NULL. Ceci est d'habitude cohérent car on
   peut considérer que la valeur NULL représente des données inconnues.
  </para>

  <para>
   Dans une définition de table, les valeurs par défaut sont listées après
   le type de donnée de la colonne. Par exemple:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
  </para>

  <para>
   La valeur par défaut peut être une expression, qui
   sera évaluée à l'insertion de la valeur par défaut
   (<emphasis>pas</emphasis> à la création de la table.) Un exemple habituel
   est qu'une colonne de type <type>timestamp</type> pourrait avoir
   <literal>now()</> comme valeur par défaut de façon à ce qu'elle obtienne la
   valeur de l'heure au moment de l'insertion. Un autre exemple habituel est
   la génération d'un <quote>numéro de série</> pour chaque ligne.
   Dans <productname>PostgreSQL</productname>, ceci se fait habituellement par
   quelque chose comme
<programlisting>
CREATE TABLE produits (
    no_produit integer <emphasis>DEFAULT nextval('produits_no_produit_seq')</emphasis>,
    ...
);
</programlisting>
   où la fonction <literal>nextval()</> fournit des valeurs successives à
   partir d'un <firstterm>objet séquence</> (voir la <xref
   linkend="functions-sequence">). Cet arrangement est suffisamment commun
   pour qu'il ait son propre raccourci&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit <emphasis>SERIAL</emphasis>,
    ...
);
</programlisting>
   Le raccourci <literal>SERIAL</> est discuté plus tard dans la <xref
   linkend="datatype-serial">.
  </para>
 </sect1>

 <sect1 id="ddl-constraints">
  <title>Contraintes</title>

  <indexterm zone="ddl-constraints">
   <primary>contrainte</primary>
  </indexterm>

  <para>
   Les types de données sont un moyen de limiter ce qui peut être stocké
   dans une table. Pour beaucoup d'applications, par contre, la contrainte
   qu'elles appliquent est trop grossière. Par exemple, une colonne qui
   contient le prix d'un produit ne devrait accepter que des valeurs
   positives. Mais il n'y a pas de type de données standard qui n'accepte que
   des valeurs positives. Un autre problème est le fait de vouloir limiter
   les données d'une colonne par rapport à d'autres colonnes ou lignes.
   Par exemple, dans une table contenant des informations de produit, il
   ne devrait y avoir qu'une ligne pour chaque numéro de produit.
  </para>

  <para>
   Dans ce but, SQL vous permet de définir les contraintes sur les colonnes
   et les tables. Les contraintes vous donnent autant de contrôle sur les
   données de vos tables que vous désirez. Si un utilisateur tente de stocker
   des données dans une colonne qui violeraient une contrainte, une erreur est
   soulevée. Ceci s'applique même si la valeur vient de la définition de la
   valeur par défaut.
  </para>

  <sect2>
   <title>Contraintes de vérification</title>

   <indexterm>
    <primary>contrainte de vérification</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>vérification</secondary>
   </indexterm>

   <para>
    Une contrainte de vérification est le type de contrainte le plus
    générique qui soit. Elle vous permet de spécifier que l'expression
    d'une certaine colonne doit satisfaire une expression booléenne. Par
    exemple, pour obliger des prix de produits positifs, on pourrait
    utiliser&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>CHECK (prix &gt; 0)</emphasis>
);
</programlisting>
   </para>

   <para>
    Comme vous pouvez le voir, la définition de contrainte vient après
    le type de données comme les définitions de valeur par défaut. Les
    valeurs par défaut et les contraintes peuvent être données dans
    n'importe quel ordre. Une contrainte de vérification s'utilise avec
    le mot clé <literal>CHECK</literal> suivi d'une expression entre
    parenthèses. L'expression de contrainte de vérification peut
    impliquer la colonne ainsi contrainte, sinon la contrainte n'aurait
    pas beaucoup de sens.
   </para>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>nom</secondary>
   </indexterm>

   <para>
    Vous pouvez aussi donner à la contrainte un nom diffèrent. Ceci
    clarifie les messages d'erreur et vous permet de faire référence
    à la contrainte lorsque vous avez besoin de la modifier.
    La syntaxe est&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (prix &gt; 0)
);
</programlisting>
    Alors, pour spécifier une contrainte nommée, utilisez le mot-clé
    <literal>CONSTRAINT</literal> suivi d'un identifieur et de la
    définition de contrainte (si vous ne donnez pas de nom à la contrainte,
    le système choisira un nom pour vous).
   </para>

   <para>
    Une contrainte de vérification peut faire référence à plusieurs
    colonnes. Admettons que vous souhaitez stocker un prix normal et un
    prix de promotion, et être certain que le prix de promotion soit inférieur
    au prix normal.
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric CHECK (prix &gt; 0),
    prix_promotion numeric CHECK (prix_promotion &gt; 0),
    <emphasis>CHECK (prix &gt; prix_promotion)</emphasis>
);
</programlisting>
   </para>

   <para>
    Les deux premières contraintes devraient vous être familières. La troisième
    utilise une nouvelle syntaxe. Elle n'est pas attachée à une colonne
    particulière, elle apparaît comme un élément distinct dans
    la liste de colonnes séparées par des virgules. Les définitions de
    colonnes et ces définitions de contraintes peuvent être définies dans
    un ordre quelconque.
   </para>

   <para>
    On dit que les deux premières contraintes sont des contraintes de
    colonnes tandis que la troisième est une contrainte de table parce
    qu'elle est écrite séparément de toute définition de colonne tandis que
    l'inverse n'est pas forcément possible car une contrainte de colonne est
    supposé faire uniquement référence à la colonne à laquelle elle est
    attachée (<productname>PostgreSQL</productname> ne force pas cette règle
    mais vous devriez la suivre si vous voulez que les définitions de votre
    table fonctionnent avec d'autres systèmes de bases de données) 
    L'exemple ci-dessus aurait pu s'écrire&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0),
    CHECK (prix &gt; prix_promotion)
);
</programlisting>
    ou même
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0 AND prix &gt; prix_promotion)
);
</programlisting>
    C'est une question de goût.
   </para>

   <para>
    Des noms peuvent être affectés à des contraintes de table de la même
    façon que pour les contraintes de colonne&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0),
    <emphasis>CONSTRAINT valid_discount</> CHECK (prix &gt; prix_promotion)
);
</programlisting>
   </para>

   <indexterm>
    <primary>valeur NULL</primary>
    <secondary sortas="check constraints">avec contraintes de vérification</secondary>
   </indexterm>

   <para>
    Il faut noter qu'une contrainte de vérification est satisfaite si
    l'expression est évaluée à vrai ou la valeur NULL. Puisque la
    plupart des expressions seront évaluées à la valeur NULL si l'un
    des opérandes est NULL, elles n'empêchent pas les valeurs NULL
    dans les colonnes contraintes. Pour s'assurer qu'une colonne ne
    contient pas de valeurs NULL, la contrainte non-NULL décrite
    dans la section suivante peut être utilisée.
   </para>

   <para>
    Les contraintes de vérification sont utiles pour améliorer la performance
    des tables partitionées. Pour les détails, voir
    <xref linkend="ddl-partitioning">.
   </para>
  </sect2>

  <sect2>
   <title>Contraintes non NULL</title>

   <indexterm>
    <primary>contrainte non NULL</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>

   <para>
    Une contrainte non NULL dit simplement qu'une colonne ne peut
    pas prendre la valeur NULL. Un exemple de syntaxe&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer <emphasis>NOT NULL</emphasis>,
    nom text <emphasis>NOT NULL</emphasis>,
    prix numeric
);
</programlisting>
   </para>

   <para>
    Une contrainte non NULL est toujours écrite comme une contrainte de
    colonne. Une contrainte non NULL est l'équivalence fonctionnelle de
    la création d'contrainte <literal>CHECK (<replaceable>nom_colonne</replaceable>
    IS NOT NULL)</literal>, mais dans <productname>PostgreSQL</productname>,
    créer une contrainte explicitement non NULL est plus efficace.
    L'inconvénient est que vous ne pouvez pas donner de noms explicites
    à des contraintes non NULL créées de cette manière.
   </para>

   <para>
    Bien sûr, une colonne peut avoir plus d'une contrainte. Écrivez juste
    les contraintes les unes après les autres&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer NOT NULL,
    nom text NOT NULL,
    prix numeric NOT NULL CHECK (prix &gt; 0)
);
</programlisting>
    L'ordre n'importe pas. Il ne détermine pas dans quel ordre les contraintes
    seront vérifiées.
   </para>

   <para>
    La contrainte <literal>NOT NULL</literal> a un opposé&nbsp;; la contrainte
    <literal>NULL</literal>. Ceci ne veut pas dire que la colonne doit
    être NULL, ce qui serait inutile. À la place, ceci sélectionne le comportement
    par défaut, à savoir que la colonne peut être NULL. La contrainte <literal>NULL
    </literal> n'est pas définie dans le standard SQL et ne devrait pas
    être utilisée dans des applications portables (elle n'a été ajoutée
    dans <productname>PostgreSQL</productname> que pour assurer la
    compatibilité avec d'autres bases de données). Certains utilisateurs
    l'apprécient car elle facilite le fait d'activer une contrainte
    dans un fichier de script. Par exemple, vous pourriez commencer avec&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer NULL,
    nom text NULL,
    prix numeric NULL
);
</programlisting>
    et puis insérer le mot-clé <literal>NOT</literal> suivant vos besoins.
   </para>

   <tip>
    <para>
     Dans beaucoup de conceptions de bases de données, la majorité des
     colonnes devraient être marquées non NULL.
    </para>
   </tip>
  </sect2>

  <sect2>
   <title>Contraintes uniques</title>

   <indexterm>
    <primary>contrainte unique</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>unique</secondary>
   </indexterm>

   <para>
    Les contraintes uniques garantissent que les données contenues dans
    la colonne ou un groupe de colonnes est unique par rapport à toutes
    les lignes de la table. La syntaxe est&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer <emphasis>UNIQUE</emphasis>,
    nom text,
    prix numeric
);
</programlisting>
    quand elle est saisie comme une contrainte de colonne et
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    <emphasis>UNIQUE (no_produit)</emphasis>
);
</programlisting>
    quand elle est saisie comme une contrainte de table.
   </para>

   <para>
    Si une contrainte unique fait référence à un groupe de colonnes,
    celles-ci sont listées en les séparant par des virgules&nbsp;:
<programlisting>
CREATE TABLE exemple (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
    Ceci spécifie que la combinaison de valeurs dans les colonnes indiquées
    est unique pour toute la table bien qu'une seule des colonnes puisse ne
    pas être (et habituellement n'est pas) unique.
   </para>

   <para>
    Vous pouvez affecter votre propre nom pour une contrainte unique, de la
    façon habituelle&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer <emphasis>CONSTRAINT doit_etre_different</emphasis> UNIQUE,
    nom text,
    prix numeric
);
</programlisting>
   </para>

   <indexterm>
    <primary>valeur NULL</primary>
    <secondary sortas="unique constraints">avec contrainte unique</secondary>
   </indexterm>

   <para>
    En général, une contrainte unique est violée lorsqu'il y a au moins deux
    lignes dans une table où la valeur de toutes les colonnes inclus dans la
    contrainte sont égales. Par contre, les valeurs NULL ne sont pas assimilées
    à une égalité dans cette comparaison. Ceci veut dire qu'il est possible
    de stocker des lignes dupliquées contenant une valeur NULL
    dans au moins l'une des colonnes contraintes. Ce comportement est conforme
    au standard SQL mais nous avons été informé que d'autres bases SQL ne
    suivent pas cette règle. Alors, soyez prudents en développant des
    applications prévues pour être portables.
   </para>
  </sect2>

  <sect2>
   <title>Clés primaires</title>

   <indexterm>
    <primary>clé primaire</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>clé primaire</secondary>
   </indexterm>

   <para>
    Techniquement, une contrainte de clé primaire est tout
    simplement une combinaison d'une contrainte unique et
    d'une contrainte non NULL. Donc, les définitions de
    tables suivantes acceptent les mêmes données&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer UNIQUE NOT NULL,
    nom text,
    prix numeric
);
</programlisting>

<programlisting>
CREATE TABLE produits (
    no_produit integer <emphasis>PRIMARY KEY</emphasis>,
    nom text,
    prix numeric
);
</programlisting>
   </para>

   <para>
    Les clés primaires peuvent contraindre sur plus d'une colonne&nbsp;; la
    syntaxe est semblable aux contraintes uniques&nbsp;:
<programlisting>
CREATE TABLE exemple (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
   </para>

   <para>
    Une clé primaire indique qu'une colonne ou groupe de colonnes peut
    être utilisé comme identifieur unique pour les lignes de la table (ceci
    est une conséquence directe de la définition d'une clé primaire. Notez
    qu'une contrainte unique ne donne pas par elle-même un identifieur unique
    car elle n'exclut pas les valeurs NULL). Ceci est pratique à la fois
    pour des raisons de documentation et pour les applications clientes. Par
    exemple, une application graphique qui permet de modifier les valeurs de
    lignes a probablement besoin de connaître la clé primaire d'une table pour
    pouvoir identifier les lignes de manière unique.
   </para>

   <para>
    Une table a au mieux une clé primaire (tandis qu'elle peut
    avoir plusieurs contraintes uniques et non NULL). La théorie des
    bases de données relationnelles dit que chaque table doit avoir
    une clé primaire. Cette règle n'est pas forcée par
    <productname>PostgreSQL</productname> mais il vaut mieux la respecter
    autant que possible.
   </para>
  </sect2>

  <sect2 id="ddl-constraints-fk">
   <title>Clés étrangères</title>

   <indexterm>
    <primary>clé étrangère</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>clé étrangère</secondary>
   </indexterm>

   <indexterm>
    <primary>intégrité référentielle</primary>
   </indexterm>

   <para>
    Une contrainte de clé étrangère stipule que les valeurs dans cette
    colonne (ou un groupe de colonnes) doit correspondre aux valeurs
    apparaissant dans des lignes d'une autre table.
    Nous disons que ceci maintient l'<firstterm>intégrité
    référentielle</firstterm> entre les deux tables.
   </para>

   <para>
    Disons que vous avez la table de produits que nous avons déjà utilisée
    plusieurs fois&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer PRIMARY KEY,
    nom text,
    prix numeric
);
</programlisting>
    Disons aussi que vous avez une table stockant les commandes de
    ces produits. Nous voulons nous assurer que la table des
    commandes ne contienne que des commandes concernant des produits
    qui existent réellement. Alors, nous définissons une contrainte
    de clé étrangère dans la table des commandes qui référence la
    table produit:
<programlisting>
CREATE TABLE commandes (
    id_commande integer PRIMARY KEY,
    no_produit integer <emphasis>REFERENCES produits (no_produit)</emphasis>,
    quantite integer
);
</programlisting>
    Maintenant, il est impossible de créer des commandes avec une entrée
    <structfield>no_produit</structfield> qui n'apparaît pas dans la table
    produits.
   </para>

   <para>
    Dans cette situation, nous disons que la table des commandes est la table
    <firstterm>référente</firstterm> et la table des produits est la table
    <firstterm>référencée</firstterm>.  De la même façon, il y a des colonnes
    référentes et des colonnes référées.
   </para>

   <para>
    On peut aussi raccourcir la commande ci-dessus en
<programlisting>
CREATE TABLE commandes (
    id_commande integer PRIMARY KEY,
    no_produit integer <emphasis>REFERENCES produits</emphasis>,
    quantite integer
);
</programlisting>
    parce qu'en l'absence d'une liste de colonne, la clé primaire de la
    table référente est utilisée comme colonne référée.
   </para>

   <para>
    Une clé étrangère peut aussi contraindre et référencer un groupe de colonnes.
    Comme d'habitude, il faut aussi l'écrire sous forme de contrainte de table.
    Voici un exemple de syntaxe&nbsp;:
<programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES autre_table (c1, c2)</emphasis>
);
</programlisting>
    Bien sûr, le nombre et le type des colonnes contraintes doit correspondre
    aux nombres et types des colonnes référées.
   </para>

   <para>
    Vous pouvez affecter un nom qui vous est propre pour une contrainte de clé
    étrangère de la façon habituelle.
   </para>

   <para>
    Une table peut contenir plus d'une contrainte de clé étrangère. Ceci est
    utilisé pour implémenter des relations n à n entre tables. Disons
    que vous avez des tables contenant des produits et des commandes mais vous
    voulez maintenant autoriser une commande qui contient peut-être beaucoup
    de produits (ce que la structure ci-dessus ne permet pas). On pourrait
    utiliser cette structure de table&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer PRIMARY KEY,
    nom text,
    prix numeric
);

CREATE TABLE commandes (
    id_commande integer PRIMARY KEY,
    adresse_de_livraison text,
    ...
);

CREATE TABLE order_items (
    no_produit integer REFERENCES produits,
    id_commande integer REFERENCES commandes,
    quantite integer,
    PRIMARY KEY (no_produit, id_commande)
);
</programlisting>
    Notez aussi que la clé primaire chevauche les clés étrangères dans la dernière table.
   </para>

   <indexterm>
    <primary>CASCADE</primary>
    <secondary>action clé étrangère</secondary>
   </indexterm>

   <indexterm>
    <primary>RESTRICT</primary>
    <secondary>action clé étrangère</secondary>
   </indexterm>

   <para>
    Nous savons que les clés étrangères n'autorisent pas la création
    de commandes qui ne sont pas liés à un produit. Et si un produit
    est retiré après qu'une commande qui y réfère soit créée&nbsp;? SQL vous
    permet aussi de le gérer. Intuitivement, nous avons plusieurs options&nbsp;:
    <itemizedlist spacing="compact">
     <listitem><para>Interdire d'effacer un produit référé</para></listitem>
     <listitem><para>Effacer aussi les commandes</para></listitem>
     <listitem><para>Autre chose ?</para></listitem>
    </itemizedlist>
   </para>

   <para>
    Pour illustrer ce cas, implémentons la politique suivante sur
    l'exemple de relations n à n évoquée plus haut: Quand quelqu'un
    veut retirer un produit qui est encore référencé par un ordre
    (via <literal>ordre_items</literal>), on l'interdit. Si quelqu'un
    retire une commande, les éléments de l'ordre sont aussi retirés.
<programlisting>
CREATE TABLE produits (
    no_produit integer PRIMARY KEY,
    nom text,
    prix numeric
);

CREATE TABLE commandes (
    id_commande integer PRIMARY KEY,
    adresse_de_livraison text,
    ...
);

CREATE TABLE order_items (
    no_produit integer REFERENCES produits <emphasis>ON DELETE RESTRICT</emphasis>,
    id_commande integer REFERENCES commandes <emphasis>ON DELETE CASCADE</emphasis>,
    quantite integer,
    PRIMARY KEY (no_produit, id_commande)
);
</programlisting>
   </para>

   <para>
     Restreindre les suppressions et supprimer en cascade sont les deux
     options les plus communes. <literal>RESTRICT</literal> empêche la
     suppression d'une ligne référencée. <literal>NO ACTION</literal> signifie
     que si des lignes de références existent lors de la vérification de la 
     contrainte, une erreur est levée. Ceci est le comportement par
     défaut si vous n'avez rien spécifié (la différence essentielle entre
     ces deux choix est que <literal>NO ACTION</literal> autorise la
     déférence de la vérification plus tard dans la transaction alors que    
     <literal>RESTRICT</literal> ne le permet pas). <literal>CASCADE</>
     spécifie que, quand une ligne référencée est supprimée, les lignes la
     référençant devraient aussi être automatiquement supprimées. Il existe
     deux autres options&nbsp;: <literal>SET NULL</literal> et <literal>SET
     DEFAULT</literal>. Celles-ci font que les colonnes de références soient
     initialisées à NULL ou à leur valeur par défaut, respectivement quand la
     ligne référencée est supprimée. Notez qu'elles ne vous excusent pas
     d'observer les contraintes. Par exemple, si une action spécifie 
     <literal>SET DEFAULT</literal> mais que la valeur par défaut ne
     satisfait pas la clé étrangère, l'opération échoue.
   </para>

   <para>
    Sur le même principe que <literal>ON DELETE</literal>, il y a aussi
    <literal>ON UPDATE</literal> qui est évoqué lorsqu'une colonne référencée
    est modifiée (mise à jour). Les actions possibles sont les mêmes.
   </para>

   <para>
    Le <xref linkend="dml"> contient plus d'informations sur la mise à jour et
    la suppression de données.
   </para>

   <para>
    Enfin, la clé étrangère peut référencer des colonnes qui sont une clé
    primaire ou forment une contrainte unique. Si la clé étrangère référence
    une contrainte unique, il y a des possibilités supplémentaires selon que
    l'on souhaite faire correspondre les valeurs NULL. Celles-ci sont expliquées
    dans la documentation de référence pour <xref linkend="sql-createtable"
    endterm="sql-createtable-title">.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-system-columns">
   <title>Colonnes système</title>

   <para>
     Chaque table a plusieurs <firstterm>colonnes système</> qui sont
     implicitement définies par le système. De ce fait, ces noms ne peuvent
     être utilisés comme noms de colonnes définis par l'utilisateur (notez
     que ces restrictions sont différentes si le nom est un mot-clé ou
     pas&nbsp;; mettre un nom entre guillemets ne vous permettra pas d'échapper
     à ces restrictions). Vous n'avez pas vraiment besoin de vous préoccuper de
     ces colonnes, simplement sachez qu'elles existent.
   </para>

 <indexterm>
   <primary>colonne</primary>
   <secondary>colonne système</secondary>
 </indexterm>

 <variablelist>
   <varlistentry>
     <term><structfield>oid</></term>
     <listitem>
       <para>
        <indexterm>
         <primary>OID</primary>
         <secondary>colonne</secondary>
        </indexterm>
	L'identifieur objet (<foreignphrase>object ID</>) d'une ligne. Cette
	colonne est seulement présente si la table a été créée en utilisant
	<literal>WITH OIDS</literal> ou si la variable de configuration <xref
	linkend="guc-default-with-oids"> était activée. Cette colonne est de
        type oid (même nom que la colonne)&nbsp;; voir la <xref
        linkend="datatype-oid"> pour plus d'informations sur ce type.
       </para>
     </listitem>
   </varlistentry>
   
   <varlistentry>
     <term><structfield>tableoid</></term>
   <listitem>
     <indexterm>
       <primary>tableoid</primary>
     </indexterm>
     
     <para>
        L' OID de la table contenant cette ligne. Cette colonne est
	particulièrement utile pour les requêtes qui font des sélections à
	partir de hiérarchies héritées (voir <xref linkend="ddl-inherit">)
	puisque, sans elle, il est difficile de
	dire de quelle table provient une ligne. <structfield>tableoid</structfield>
	peut être joint à la colonne <structfield>oid</structfield> de
	<structname>pg_class</structname> pour obtenir le nom de la table.
     </para>
   </listitem>
 </varlistentry>
 
 <varlistentry>
   <term><structfield>xmin</></term>
 <listitem>
   <indexterm>
     <primary>xmin</primary>
   </indexterm>
   
   <para>
      L'identifieur (ID de transaction) de la transaction d'insertion de cette
      version de la ligne (une version de ligne est un état individuel
      d'une ligne&nbsp;; chaque mise à jour d'une ligne crée une nouvelle
      version de ligne pour la même ligne logique).
   </para>
 </listitem>
</varlistentry>

<varlistentry>
  <term><structfield>cmin</></term>
<listitem>
  <indexterm>
    <primary>cmin</primary>
  </indexterm>
  
  <para>
     L'identifieur de commande (à partir de zéro) au sein de la transaction
     d'insertion.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>xmax</></term>
<listitem>
  <indexterm>
    <primary>xmax</primary>
  </indexterm>
  
  <para>
     L'identifieur (ID de transaction) de la transaction de suppression, ou zéro
     pour une version de ligne non effacée. Il est possible pour cette
     colonne d'être non NULL dans une version de ligne visible&nbsp;: ceci
     indique normalement que la transaction de suppression n'a pas été
     effectuée, ou qu'une tentative de suppression a été annulée.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>cmax</></term>
<listitem>
  <indexterm>
    <primary>cmax</primary>
  </indexterm>
  
  <para>
     L'identifieur de commande au sein d'une transaction de suppression, ou
     zéro.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>ctid</></term>
<listitem>
  <indexterm>
    <primary>ctid</primary>
  </indexterm>
  
  <para>
     La localisation physique de la version de ligne au sein de sa table.
     Notez que, bien que le <structfield>ctid</structfield> peut être utilisé
     pour trouver la version de ligne très rapidement, le
     <structfield>ctid</structfield>  d'une ligne change chaque fois
     qu'il est mis à jour ou déplacé par la commande <command>VACUUM FULL</>.
     Donc, <structfield>ctid</structfield> est inutile en tant
     qu'identifieur de ligne à long terme. L'OID, ou encore mieux un numéro
     de série défini par l'utilisateur, devrait être utilisé pour
     identifier des lignes logiques.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>
   Les OID sont des nombres de 32 bits et sont attribués d'un seul
   compteur. Dans une base de données grande ou vieille, il est possible que
   le compteur boucle sur lui-même. Donc il est peu pertinent de partir du
   principe que les OID sont uniques, sauf si vous prenez les précautions
   nécessaires. Si vous avez besoin d'identifier les lignes d'une table,
   l'utilisation d'un générateur de séquence est fortement recommandée.
   Néanmoins, les OID peuvent aussi être utilisés à condition que quelques
   précautions soient prises&nbsp;:
  
  <itemizedlist>
    <listitem>
      <para>
        Une contrainte unique doit être ajoutée sur la colonne OID de chaque
	table pour laquelle l'OID est utilisée pour identifier les lignes.
	Quand une telle contrainte unique (ou un index unique) existe, le système
	fait attention à ne pas générer un OID correspondant à celui d'une ligne
	déjà existante (bien sûr, ceci est seulement possible si la table contient
	moins de 2<superscript>32</> (4 milliards) lignes et, en pratique, la
	taille de la table a tout intérêt à être bien plus petite que ça, sinon les
	performances pourraient en souffrir).
      </para>
    </listitem>
    <listitem>
      <para>
        Les OID ne doivent jamais être supposés uniques entre tables&nbsp;;
        utilisez la combinaison de <structfield>tableoid</> et de l'OID de la
        ligne si vous avez besoin d'un identifieur sur la base complète.
      </para>
    </listitem>
    <listitem>
      <para>
      Les tables en question devraient être créées en utilisant <literal>WITH
      OIDS</literal>. À partir de <productname>PostgreSQL</productname> 8.1,
      <literal>WITHOUT OIDS</> est l'option par défaut.
      </para>
    </listitem>
  </itemizedlist>
</para>

  <para>
    Les identifieurs de transaction sont aussi des nombres de 32 bits. Dans 
    une base de données de longue vie, il est possible que les ID de
    transaction bouclent sur eux-mêmes. Ceci n'est pas un problème fatal
    avec des procédures de maintenance appropriées&nbsp;; voir le <xref
    linkend="maintenance"> pour les détails. Par contre, il est imprudent
    de dépendre de l'aspect unique des ID de transaction à long terme (plus
    d'un milliard de transactions).
  </para>
  
  <para>
     Les identifieurs de commande sont aussi des nombres de 32 bits. Ceci
     crée une limite dure de 2<superscript>32</> (4 milliards) commandes
     <acronym>SQL</acronym> au sein d'une seule transaction. En pratique,
     cette limite n'est pas un problème &mdash; notez que la limite est sur
     le nombre de commandes <acronym>SQL</acronym>, pas le nombre de lignes
     traitées.
  </para>
</sect1>

 <sect1 id="ddl-alter">
  <title>Modification des tables</title>

  <indexterm zone="ddl-alter">
   <primary>table</primary>
   <secondary>modification</secondary>
  </indexterm>

  <para>
   Quand on crée une table et qu'on se rend compte qu'on a fait une erreur
   ou que les besoins de l'application ont changés, on peut alors effacer
   la table et la recréer. Mais ceci n'est pas pratique si la table contient
   déjà des données ou si la table est référencée par d'autres objets de la base
   de données (une contrainte de clé étrangère). Par conséquent, 
   <productname>PostgreSQL</productname> offre une série de commandes
   permettant de modifier une table existante. Notez que ceci est différent
   au niveau du concept avec la modification des données contenues dans la
   table&nbsp;; ici, nous sommes intéressés par la modification de la
   définition ou de la structure de la table.
  </para>

  <para>
   Vous pouvez
   <itemizedlist spacing="compact">
    <listitem>
     <para>ajouter des colonnes,</para>
    </listitem>
    <listitem>
     <para>retirer des colonnes,</para>
    </listitem>
    <listitem>
     <para>ajouter des contraintes,</para>
    </listitem>
    <listitem>
     <para>retirer des contraintes,</para>
    </listitem>
    <listitem>
     <para>modifier les valeurs par défaut,</para>
    </listitem>
    <listitem>
     <para>modifier les types de données des colonnes,</para>
    </listitem>
    <listitem>
     <para>renommer des colonnes,</para>
    </listitem>
    <listitem>
     <para>renommer des tables.</para>
    </listitem>
   </itemizedlist>

   Toutes ces actions sont réalisées en utilisant la commande <xref
   linkend="sql-altertable" endterm="sql-altertable-title">.
  </para>

  <sect2>
   <title>Ajouter une colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>ajouter</secondary>
   </indexterm>

   <para>
    Pour ajouter une colonne, utilisez une commande comme ceci&nbsp;:
<programlisting>
ALTER TABLE produits ADD COLUMN description text;
</programlisting>
    La nouvelle colonne est initialement remplie avec la valeur par défaut
    (NULL si vous n'avez pas spécifié de clause <literal>DEFAULT</>).
   </para>

   <para>
    Vous pouvez aussi définir des contraintes sur la colonne au même moment
    en utilisant la syntaxe habituelle&nbsp;:
<programlisting>
ALTER TABLE produits ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting>
    En fait, toutes les options applicables à la description d'une colonne
    dans <command>CREATE TABLE</> peuvent être utilisées ici. Néanmoins,
    gardez en tête que la valeur par défaut doit satisfaire les contraintes
    données. Sinon, <literal>ADD</> échouera. Autrement, vous pouvez ajouter
    les contraintes plus tard (voir ci-dessous) après avoir rempli la nouvelle
    colonne correctement.
   </para>
  </sect2>

  <sect2>
   <title>Retirer une Colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>retirer</secondary>
   </indexterm>

   <para>
    Pour retirer une colonne, utilisez une commande comme celle-ci&nbsp;:
<programlisting>
ALTER TABLE produits DROP COLUMN description;
</programlisting>
    Les données de cette colonne disparaissent. Les contraintes de table
    impliquant la colonne sont aussi supprimées. Néanmoins, si la colonne est
    référencée par une contrainte de clé étrangère dans une autre table,
    <productname>PostgreSQL</productname> ne supprimera pas silencieusement
    cette contrainte. Vous pouvez autoriser la suppression de tout ce qui     
    dépend de la colonne en ajoutant <literal>CASCADE</>&nbsp;:
<programlisting>
	ALTER TABLE produits DROP COLUMN description CASCADE;
</programlisting>
    Voir la <xref linkend="ddl-depend"> pour une description du mécanisme général
    derrière ceci.
   </para>
  </sect2>

  <sect2>
   <title>Ajouter une contrainte</title>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>ajouter</secondary>
   </indexterm>

   <para>
    Pour ajouter une contrainte, la syntaxe de contrainte de table est utilisée.
    Par exemple&nbsp;:
<programlisting>
ALTER TABLE produits ADD CHECK (nom &lt;&gt; '');
ALTER TABLE produits ADD CONSTRAINT autre_nom UNIQUE (no_produit);
ALTER TABLE produits ADD FOREIGN KEY (id_groupe_produit) REFERENCES groupes_produits;
</programlisting>
    Pour ajouter une contrainte non NULL, qui ne peut pas être écrite
    sous forme d'une contrainte de table, utilisez cette syntaxe&nbsp;:
<programlisting>
ALTER TABLE produits ALTER COLUMN no_produit SET NOT NULL;
</programlisting>
   </para>

   <para>
    La contrainte sera vérifiée immédiatement, donc les données de la
    table doivent satisfaire la contrainte avant qu'elle soit ajoutée.
   </para>
  </sect2>

  <sect2>
   <title>Retirer une contrainte</title>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>retirer</secondary>
   </indexterm>

   <para>
    Pour retirer la contrainte, il faut connaître son nom. Si vous lui avez donné
    un nom, alors c'est facile. Sinon, le système a attribué un nom généré que vous
    devez découvrir. La commande <literal>\d <replaceable>table</replaceable></literal>
    de <application>psql</application> peut être utile ici&nbsp;; d'autres interfaces peuvent
    aussi donner le moyen d'examiner les détails de table. La commande est&nbsp;:
<programlisting>
ALTER TABLE produits DROP CONSTRAINT autre_nom;
</programlisting>
    (si vous traitez avec un nom de contrainte généré comme <literal>$2</literal>,
    n'oubliez pas qu'il faudra l'entourer de guillemets double pour en faire
    un identifieur valable)
   </para>

   <para>
	Comme avec la suppression d'une colonne, vous avez besoin d'ajouter
	<literal>CASCADE</> si vous voulez supprimer une contrainte qui dépend
	d'autre chose. Un exemple concerne la contrainte de clé étrangère qui
	dépend d'une contrainte de clé unique ou primaire sur le(s) colonne(s)
    référencée(s).
   </para>

   <para>
    Ça fonctionne de la même manière pour toutes les types de contrainte
    sauf les contraintes non NULL. Pour retirer une contrainte non NULL,
    utilisez
<programlisting>
ALTER TABLE produits ALTER COLUMN no_produit DROP NOT NULL;
</programlisting>
    (Rappelez vous que les contraintes non NULL n'ont pas de noms.)
   </para>
  </sect2>

  <sect2>
   <title>Modifier la valeur par défaut d'une colonne</title>

   <indexterm>
    <primary>valeur par défaut</primary>
    <secondary>modifier</secondary>
   </indexterm>

   <para>
    Pour mettre une nouvelle valeur par défaut sur une colonne, utilisez une
    commande comme celle-ci&nbsp;:
<programlisting>
ALTER TABLE produits ALTER COLUMN prix SET DEFAULT 7.77;
</programlisting>
    Notez que ceci n'affecte pas les lignes existantes dans la table, cela ne
    modifie que la valeur par défaut pour les futures commandes
    <command>INSERT</>.
   </para>

   <para>
    Pour retirer toute valeur par défaut, utilisez
<programlisting>
ALTER TABLE produits ALTER COLUMN prix DROP DEFAULT;
</programlisting>
    Ceci est équivalent à mettre la valeur par défaut à NULL. En conséquence,
    ce n'est pas une erreur de
    retirer une valeur par défaut qui n'a pas été définie car la valeur NULL
    est la valeur par défaut implicite.
   </para>
  </sect2>

  <sect2>
   <title>Modifier le type de données d'une colonne</title>

   <indexterm>
    <primary>type de données d'une colonne</primary>
    <secondary>modification</secondary>
   </indexterm>

   <para>
    Pour convertir une colonne en un autre type de données, utilisez une
    commande comme ceci&nbsp;:
    <programlisting>
ALTER TABLE produits ALTER COLUMN prix TYPE numeric(10,2);
    </programlisting>
    Elle ne réussira que si chaque valeur dans la colonne peut être
    convertie dans le nouveau type par une conversion implicite. Si une
    conversion plus complexe est nécessaire, vous pouvez ajouter une clause
    <literal>USING</> qui spécifie comment calculer les nouveaux valeurs à
    partir des anciennes.
   </para>
  
   <para>
    <productname>PostgreSQL</> tentera de convertir la valeur par défaut de la
    colonne, si elle en a une. Mais ces conversions pourraient échouer ou
    pourraient produire des résultats surprenants. Il est souvent mieux de
    supprimer les contraintes sur une colonne avant de modifier son type, puis
    d'ajouter les contraintes modifiées convenablement.
   </para>
  </sect2>

  <sect2>
   <title>Renommer une colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>renommer</secondary>
   </indexterm>

   <para>
    Pour renommer une colonne&nbsp;:
<programlisting>
ALTER TABLE produits RENAME COLUMN no_produit TO numero_produit;
</programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Renommer une table</title>

   <indexterm>
    <primary>table</primary>
    <secondary>renommer</secondary>
   </indexterm>

   <para>
    Pour renommer une table&nbsp;:
<programlisting>
ALTER TABLE produits RENAME TO elements;
</programlisting>
   </para>
  </sect2>
 </sect1>
 
 <sect1 id="ddl-priv">
  <title>Droits</title>

  <indexterm zone="ddl-priv">
   <primary>droit</primary>
  </indexterm>

  <indexterm>
   <primary>permission</primary>
   <see>droit</see>
  </indexterm>

  <para>
   Quand vous créez un objet dans la base de données, vous en devenez le
   propriétaire. Avec les paramètres par défaut, seul le propriétaire
   d'un objet peut faire quelque chose avec. Pour que d'autres utilisateurs
   puissent s'en servir, des <firstterm>droits</firstterm> doivent être
   accordés (néanmoins, les superutilisateurs ont toujours accès à n'importe
   quel objet).
  </para>

  <para>
   Il existe plusieurs droits&nbsp;: <literal>SELECT</literal>,
   <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   <literal>RULE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>,
   <literal>CREATE</literal>, <literal>TEMPORARY</literal>, <literal>EXECUTE</literal>
   et <literal>USAGE</>. Les droits applicables à un objet particulier varient
   suivant le type d'objet (table, fonction, etc.) Pour une
   information complète sur les différents types de droits gérés par
   <productname>PostgreSQL</productname>, lisez la page de référence
   <xref linkend="sql-grant" endterm="sql-grant-title">.  La section et
   les chapitres suivants vous montreront aussi comment ces droits
   sont utilisés.
  </para>

  <para>
   Le droit de modifier ou de détruire est le droit du propriétaire seul.
  </para>

  <note>
    <para>
      Pour modifier le propriétaire d'une table, d'un index, d'une séquence ou
      d'une vue, utilisez la commande <xref linkend="sql-altertable"
      endterm="sql-altertable-title">. Il
      existe des commandes <literal>ALTER</> correspondant aux autres types 
      d'objets.
    </para>
  </note>
  
  <para>
   Pour accorder des droits, la commande <command>GRANT</command> est
   utilisée. Par exemple, si <literal>joe</literal> est un utilisateur
   existant et <literal>comptes</literal> une table existante, le
   droit de mettre la table à jour peut être accordé avec
<programlisting>
GRANT UPDATE ON comptes TO joe;
</programlisting>
   Pour accorder un droit à un groupe, utilisez
<programlisting>
GRANT SELECT ON comptes TO GROUP equipe;
</programlisting>
   Le nom d'<quote>utilisateur</quote> spéciale <literal>PUBLIC</literal> peut
   être utilisé pour accorder un droit à tous les utilisateurs du système.
   Écrire <literal>ALL</literal> au lieu d'un droit spécifique accorde tous
   les droits adéquats pour ce type d'objet.
  </para>

  <para>
   Pour révoquer un droit, utilisez la commande appropriée
   <command>REVOKE</command> ci-dessous&nbsp;:
<programlisting>
REVOKE ALL ON comptes FROM PUBLIC;
</programlisting>
   Les droits spéciaux du propriétaire de l'objet (c'est-à-dire, le droit de faire des
   <command>DROP</command>, <command>GRANT</command>, <command>REVOKE</command>, etc.)
   sont toujours implicitement ceux du propriétaire et ne peuvent être ni
   accordés ni révoqués. Mais le propriétaire de l'objet peut choisir
   de révoquer ses propres droits ordinaires pour, par exemple, mettre
   une table en lecture seule pour soi-même ainsi que pour les autres.
  </para>

  <para>
   Habituellement, seul le propriétaire de l'objet (ou un superutilisateur)
   peut donner ou révoquer les droits sur un objet. Néanmoins, il est possible
   de donner un droit <quote>avec une option de don de droits</>, qui donne
   à celui qui le reçoit de le donner à d'autres. Si cette option est ensuite
   révoquée, alors tous ceux qui ont reçu le droit de cet utilisateur
   (directement ou indirectement via la chaîne des dons)  perdront leur
   droit. Pour des détails, voir les pages de références <xref
   linkend="sql-grant" endterm="sql-grant-title"> et <xref linkend="sql-revoke"
   endterm="sql-revoke-title">.
  </para>
 </sect1>

 <sect1 id="ddl-schemas">
  <title>Schémas</title>

  <indexterm zone="ddl-schemas">
   <primary>schéma</primary>
  </indexterm>

  <para>
   Un groupe de bases de données <productname>PostgreSQL</productname>
   contient une ou plusieurs bases nommées. Les utilisateurs et groupes
   d'utilisateurs sont partagés sur le groupe tout entier mais aucune
   autre donnée n'est partagée parmi les bases. Une connexion cliente
   donnée sur le serveur peut accéder aux données d'une seule base, celle
   spécifiée dans la connexion de requête.
  </para>

  <note>
   <para>
    Les utilisateurs d'un groupe n'ont pas forcément le droit d'accéder à
    toutes les bases du groupe. Le partage des noms d'utilisateur veut dire
    qu'il ne peut pas y avoir plusieurs utilisateurs nommés <literal>joe</literal>,
    par exemple, dans deux bases du même groupe&nbsp;; mais le système peut être
    configuré pour autoriser <literal>joe</literal> à accéder qu'à certaines bases.
   </para>
  </note>

  <para>
   Une base de données contient un ou plusieurs <firstterm>schémas</firstterm>
   nommés qui, eux, contiennent des tables. Les schémas contiennent aussi d'autres
   types d'objets nommés, y compris des types de données, fonctions et opérateurs.
   Seul le nom d'objet peut être utilisé sans conflit&nbsp;; par exemple,
   <literal>schema1</literal> et <literal>mon_schema</literal> peuvent tous les deux
   contenir une table nommée <literal>ma_table</literal>. Contrairement aux
   bases de données, les schémas ne sont pas séparés de manière rigide&nbsp;:
   un utilisateur peut accéder aux objets de n'importe lequel des schémas de la
   base de données auxquels il se connecte s'il a les droits pour le faire.
  </para>

  <para>
   Il existe plusieurs raisons pour lesquelles quelqu'un voudrait utiliser les
   schémas&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Pour autoriser beaucoup d'utilisateurs à utiliser une base de données sans se gêner
      les uns les autres.
     </para>
    </listitem>

    <listitem>
     <para>
      Pour organiser des objets de bases de données en groupes logiques afin de faciliter
      leur gestion.
     </para>
    </listitem>

    <listitem>
     <para>
      Les applications tierces peuvent être mises dans des schémas séparés pour qu'il n'y
      ait pas de collision avec les noms d'autres objets.
     </para>
    </listitem>
   </itemizedlist>

   Les schémas sont comparables aux répertoires au niveau du système d'exploitation
   sauf que les schémas ne peuvent pas être imbriqués.
  </para>

  <sect2 id="ddl-schemas-create">
   <title>Créer un schéma</title>

   <indexterm zone="ddl-schemas-create">
    <primary>schéma</primary>
    <secondary>créer</secondary>
   </indexterm>

   <para>
    Pour créer un schéma, utilisez la commande <command>CREATE
    SCHEMA</command>. Donnez au schéma un nom de votre choix. Par
    exemple&nbsp;:
<programlisting>
CREATE SCHEMA mon_schema;
</programlisting>
   </para>

   <indexterm>
    <primary>nom qualifié</primary>
   </indexterm>

   <indexterm>
    <primary>nom</primary>
    <secondary>qualifié</secondary>
   </indexterm>

   <para>
    Pour créer ou accéder aux objets dans un schéma, écrivez un
    <firstterm>nom qualifié</firstterm> qui consiste en le nom du schéma et
    le nom de la table séparés par un point&nbsp;:
<synopsis>
<replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    Ceci fonctionne partout où un nom de table est attendu, donc en incluant les
    commandes de modification de la table et les commandes d'accès aux données
    discutées dans les chapitres suivants (nous parlons uniquement
    des tables mais les mêmes idées s'appliquent aux autres genres d'objets
    nommés, comme les types et les fonctions).
   </para>
   
   <para>
    En fait, la syntaxe encore plus générale
<synopsis>
<replaceable>basededonnees</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    peut être utilisé aussi mais, pour le moment, ceci n'existe que pour
    être conforme au standard SQL. Si vous écrivez un nom de base de
    données, il devrait être celui de la base auquel vous êtes connecté.
   </para>

   <para>
    Donc, pour créer une table dans le nouveau schéma, utilisez
<programlisting>
CREATE TABLE mon_schema.ma_table (
 ...
);
</programlisting>
   </para>

   <indexterm>
    <primary>schéma</primary>
    <secondary>suppression</secondary>
   </indexterm>

   <para>
    Pour effacer un schéma vide (tous les objets qu'il contient ont été
    supprimés), utilisez
<programlisting>
DROP SCHEMA mon_schema;
</programlisting>
    Pour effacer un schéma avec les objets qu'il contient, utilisez
<programlisting>
DROP SCHEMA mon_schema CASCADE;
</programlisting>
    Lisez la <xref linkend="ddl-depend"> pour une description du mécanisme
    général derrière tout ceci.
   </para>

   <para>
    Souvent, vous voudrez modifier le schéma utilisé par quelqu'un
    d'autre (puisque c'est l'une des méthodes par lesquelles on peut
    restreindre l'activité de vos utilisateurs à des espaces de nom
    définis). La syntaxe pour ceci est&nbsp;:
<programlisting>
CREATE SCHEMA <replaceable>nom_schema</replaceable> AUTHORIZATION <replaceable>nom_utilisateur</replaceable>;
</programlisting>
    Vous pouvez même omettre le nom du schéma auquel cas, le nom du schéma
    sera le même que le nom d'utilisateur. Voir la <xref
    linkend="ddl-schemas-patterns"> pour voir comment cela peut être utilisé.
   </para>

   <para>
    Les noms de schéma commençant par <literal>pg_</literal> sont réservés pour
    les besoins du système et les schémas commençant ainsi ne peuvent pas être
    créés par les utilisateurs.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-public">
   <title>Le schéma public</title>

   <indexterm zone="ddl-schemas-public">
    <primary>schéma</primary>
    <secondary>public</secondary>
   </indexterm>

   <para>
    Dans les sections précédentes, on créait des tables sans spécifier un
    nom de schéma. Par défaut, ces tables (et autres objets) sont
    automatiquement placées dans un schéma nommé <quote>public</quote>. Toute
    nouvelle base de données contient un tel schéma. Donc, ces instructions
    sont équivalentes&nbsp;:
<programlisting>
CREATE TABLE produits ( ... );
</programlisting>
    et
<programlisting>
CREATE TABLE public.produits ( ... );
</programlisting>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-path">
   <title>Chemin de recherche de schéma</title>

   <indexterm>
    <primary>chemin de recherche</primary>
   </indexterm>

   <indexterm>
    <primary>nom non qualifié</primary>
   </indexterm>

   <indexterm>
    <primary>nom</primary>
    <secondary>non qualifié</secondary>
   </indexterm>

   <para>
    Les noms qualifiés sont pénibles à écrire et il est, de toute façon,
    préférable de ne pas coder un nom de schéma dans une application. Donc, les
    tables sont souvent appelées par des noms non <firstterm>qualifiés</firstterm>
    qui s'apparentent souvent au nom de la table lui-même. Le système détermine
    la table appelée en suivant un <firstterm>chemin de recherche</firstterm>
    qui est une liste de schémas à vérifier. La première table correspondante
    est considérée comme la table voulue. S'il n'y a pas de correspondance, une
    erreur est remontée, même si des noms de table correspondants existent dans
    d'autres schémas de la base.
   </para>

   <indexterm>
    <primary>schéma</primary>
    <secondary>courant</secondary>
   </indexterm>

   <para>
    Le premier schéma dans le chemin de recherche est appelé le schéma courant.
    En plus d'être le premier schéma parcouru, il est aussi le schéma dans lequel
    de nouvelles tables seront créées si la commande <command>CREATE TABLE</command>
    ne précise pas de nom de schéma.
   </para>

   <indexterm>
    <primary>search_path</primary>
   </indexterm>

   <para>
    Pour voir le chemin de recherche courant, utilisez la commande
    suivante&nbsp;:
<programlisting>
SHOW search_path;
</programlisting>
    Dans la configuration par défaut, ceci renvoie&nbsp;:
<screen>
 search_path
--------------
 $user,public
</screen>
    Le premier élément précise qu'un schéma avec le même nom que l'utilisateur
    en cours doit être parcouru. Le deuxième élément renvoie au schéma public
    que nous avons déjà vu.
   </para>

   <para>
    Le premier schéma existant dans le chemin de recherche est l'endroit
    par défaut pour la création de nouveaux objets. Ceci est la raison
    pour laquelle les objets sont créés dans le schéma public. Quand les
    objets sont liés dans tout autre contexte sans une qualification de
    schéma (modification de table, modification de données ou requête de
    commande), le chemin de recherche est traversé jusqu'à ce qu'un objet
    correspondant soit trouvé. Donc, dans la configuration par défaut,
    tout accès non qualifié ne peut que se référer au schéma public.
   </para>

   <para>
    Pour mettre notre nouveau schéma dans le chemin, nous utilisons
<programlisting>
SET search_path TO mon_schema,public;
</programlisting>
    (nous ne mettons pas le <literal>$user</literal> ici car nous n'en avons
    pas besoin pour l'instant). Et nous pouvons pas accéder à la table sans
    qualification de schéma&nbsp;:
<programlisting>
DROP TABLE ma_table;
</programlisting>
    Aussi, puisque <literal>mon_schema</literal> est le premier élément dans
    le chemin, les nouveaux objets seront créés dans ce schéma.
   </para>

   <para>
    On pourrait aussi écrire
<programlisting>
SET search_path TO mon_schema;
</programlisting>
    Dans ce cas, nous n'avons pas accès au schéma public sans qualification explicite.
    Il n'y a rien de spécial à propos du schéma public hormis le fait qu'il
    existe par défaut. Il peut aussi être effacé.
   </para>

   <para>
    Voir aussi la <xref linkend="functions-info"> qui détaille les autres façons
    de manipuler le chemin de recherche des schémas.
   </para>

   <para>
    Le chemin de recherche fonctionne de la même façon pour les noms de type de
    données, les noms de fonction et les noms d'opérateur que pour les noms de
    tables. Les types de données et de fonctions peuvent être qualifiés de la
    même façon que les noms de table. Si vous avez besoin d'écrire un nom
    d'opérateur qualifié dans une expression, il y a une condition
    spéciale&nbsp;: vous devez écrire
<synopsis>
<literal>OPERATOR(</literal><replaceable>schéma</replaceable><literal>.</literal><replaceable>opérateur</replaceable><literal>)</literal>
</synopsis>
    Ceci est nécessaire afin d'éviter une ambiguïté syntaxique. En voici un
    exemple
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    En pratique, on dépend souvent du chemin de recherche pour les opérateurs,
    afin de ne pas avoir à écrire quelque chose d'aussi peu présentable.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-priv">
   <title>Schémas et droits</title>

   <indexterm zone="ddl-schemas-priv">
    <primary>droit</primary>
    <secondary sortas="schemas">pour les schémas</secondary>
   </indexterm>

   <para>
    Par défaut, les utilisateurs ne peuvent pas accéder aux objets présents
    dans les schémas qui ne leur appartiennent pas. Pour leur permettre, le
    propriétaire du schéma doit donner le droit <literal>USAGE</literal> sur
    le schéma. Pour autoriser les utilisateurs à manipuler les objets d'un
    schéma, des droits supplémentaires devront peut-être être accordés, suivant
    l'objet.
   </para>

   <para>
    Un utilisateur peut aussi être autorisé à créer des objets dans le
    schéma de quelqu'un d'autre. Pour permettre ceci, le droit
    <literal>CREATE</literal> doit être accordé. Notez que, par défaut,
    tout le monde a les droits <literal>CREATE</literal> et
    <literal>USAGE</literal> sur le schéma <literal>public</literal>.
    Ceci permet à tous les utilisateurs qui sont capables de se connecter
    à une base de données de créer des objets dans son schéma
    <literal>public</literal>. Si vous ne souhaitez pas ce comportement,
    vous pouvez révoquer ce droit&nbsp;:
<programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
    Le premier <quote>public</quote> est le schéma, le second
    <quote>public</quote> veut dire <quote>chaque utilisateur</quote>. Dans le
    premier cas, c'est un identifieur. Dans le second, c'est un mot clé,
    d'où la casse différente. Souvenez-vous des règles de la
    <xref linkend="sql-syntax-identifiers">.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-catalog">
   <title>Catalogue du système de schémas</title>

   <indexterm zone="ddl-schemas-catalog">
    <primary>système de catalogue</primary>
    <secondary>schéma</secondary>
   </indexterm>

   <para>
    En plus du schéma <literal>public</literal> et de ceux créés par les
    utilisateurs, chaque
    base de données contient un schéma <literal>pg_catalog</literal>, qui contient
    les tables systèmes et tous les types de données, fonctions et opérateurs
    intégrés. <literal>pg_catalog</literal> fait toujours partie du chemin
    de recherche. S'il n'est pas nommé explicitement dans le chemin, il est
    parcouru implicitement <emphasis>avant</emphasis> la recherche dans les schémas
    du chemin. Ceci garantie qui les noms internes seront toujours trouvables .
    Par contre, vous pouvez explicitement placer <literal>pg_catalog</literal> à la
    fin si vous préférez que les noms définis par les utilisateurs surchargent
    les noms internes.
   </para>

   <para>
    Dans les versions de <productname>PostgreSQL</productname> avant la 7.3,
    les noms de table commençant par <literal>pg_</literal> sont réservés. Ceci
    n'est plus vrai&nbsp;: vous pouvez créer une telle table si vous le voulez
    dans n'importe quel schéma non système. Par contre, il vaut mieux
    continuer d'éviter de tels noms pour garantir que vous n'aurez pas
    de conflit si une prochaine version définit une table système qui
    porte le même nom que votre table (avec le chemin de recherche par
    défaut, une référence non qualifiée à votre table pointera au lieu
    vers la table système).
    Les tables systèmes continueront de suivre la convention de porter
    des noms commençant par <literal>pg_</literal> pour qu'ils n'aient pas de
    conflit avec des noms de table non qualifiés tant que les utilisateurs
    éviteront le préfixe <literal>pg_</literal>.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-patterns">
   <title>Méthodes d'utilisation</title>

   <para>
    Les schémas peuvent être utilisés pour organiser vos données de plusieurs
    manières. Plusieurs sont recommandés et sont facilement supportés par la
    configuration par défaut&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Si vous ne créez aucun schéma, alors tout les utilisateurs
       auront accès au schéma public implicitement. Ceci simule la
       situation dans laquelle les schémas ne sont pas disponibles.
       Cette situation est recommandée lorsque il n'y a qu'un seul
       utilisateur ou quelques utilisateurs coopérants dans une base
       de données. Cette configuration permet aussi une transition
       en douceur d'une situation où on ne connaît pas le schéma.
      </para>
     </listitem>

     <listitem>
      <para>
       Vous pouvez créer un schéma pour chaque utilisateur avec un
       nom identique à celui de l'utilisateur. Souvenez-vous que le
       chemin de recherche par défaut commence par
       <literal>$user</literal>, ce qui correspond au nom d'utilisateur.
       Donc si chaque utilisateur a un schéma distinct, ils accèdent
       à leurs propres schémas par défaut.
      </para>

      <para>
       Si vous utilisez cette configuration, alors vous devriez peut-être
       aussi révoquer l'accès au schéma public (ou l'effacer complètement)
       pour que les utilisateurs soient réellement limités à leur propre
       schéma.
      </para>
     </listitem>

     <listitem>
      <para>
       Pour installer des applications partagées (tables utilisables
       par tout le monde, fonctionnalités supplémentaires fournies par
       des applications tiers, etc), insérez-les dans des schéma séparés.
       Rappelez-vous que vous devez donner les permissions appropriées
       pour permettre aux utilisateurs d'y accéder. Les utilisateurs
       peuvent alors se référer à ces objets additionnels en qualifiant
       les noms avec un nom de schéma ou ils peuvent mettre les schémas
       supplémentaires dans leur chemin de recherche, s'ils le souhaitent.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-portability">
   <title>Portabilité</title>

   <para>
    Dans le standard SQL, la notion d'objets du même schéma
    appartenant à des utilisateurs différents n'existe pas. De plus,
    certaines implémentations ne vous permettent pas de créer des
    schémas qui ont un nom différent de celui de leur propriétaire.
    En fait, les concepts de schéma et d'utilisateur sont presque
    équivalents dans un système de base de données qui n'implémente
    que le support basique des schémas spécifiés dans le standard.
    À partir de ce constat, beaucoup d'utilisateurs considèrent les noms
    qualifiés comme correspondant réellement à
    <literal><replaceable>utilisateur</replaceable>.<replaceable>table</replaceable></literal>.
    C'est comme cela que <productname>PostgreSQL</productname> se comporte
    si vous créez un schéma par utilisateur pour chaque utilisateur.
   </para>

   <para>
    De plus, il n'y a aucun concept d'un schéma <literal>public</literal> dans le
    standard SQL. Pour plus de conformité au standard, vous ne devriez pas
    utiliser (et sans doute effacer) le schéma <literal>public</literal>.
   </para>

   <para>
    Bien sûr, certains systèmes de bases de données n'implémentent pas du
    tout les schémas. ou donnent le support d'espace de nommage en
    autorisant (peut-être de façon limité) des accès sur plusieurs bases
    de données. Dans ce cas, la portabilité maximale sera obtenue en n'utilisant
    pas du tout les schémas.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-inherit">
  <title>Héritage</title>

  <indexterm>
   <primary>inheritance</primary>
  </indexterm>

  <indexterm>
   <primary>table</primary>
   <secondary>inheritance</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> implements table inheritance
   which can be a useful tool for database designers.  (SQL:1999 and
   later define a type inheritance feature, which differs in many
   respects from the features described here.)
  </para>

  <para>
   Let's start with an example: suppose we are trying to build a data
   model for cities.  Each state has many cities, but only one
   capital. We want to be able to quickly retrieve the capital city
   for any particular state. This can be done by creating two tables,
   one for state capitals and one for cities that are not
   capitals. However, what happens when we want to ask for data about
   a city, regardless of whether it is a capital or not? The
   inheritance feature can help to resolve this problem. We define the
   <structname>capitals</structname> table so that it inherits from
   <structname>cities</structname>:

<programlisting>
CREATE TABLE villes (
    nom             text,
    population      float,
    altitude        int     -- (en pied)
);

CREATE TABLE capitales (
    etat           char(2)
) INHERITS (villes);
</programlisting>

   In this case, the <structname>capitals</> table <firstterm>inherits</>
   all the columns of its parent table, <structname>cities</>. State
   capitals also have an extra column, <structfield>state</>, that shows
   their state.
  </para>

  <para>
   In <productname>PostgreSQL</productname>, a table can inherit from
   zero or more other tables, and a query can reference either all
   rows of a table or all rows of a table plus all of its descendant tables.
   The latter behavior is the default.
   For example, the following query finds the names of all cities,
   including state capitals, that are located at an altitude over
   500ft:

<programlisting>
SELECT nom, altitude
    FROM villes
    WHERE altitude &gt; 500;
</programlisting>

   Given the sample data from the <productname>PostgreSQL</productname>
   tutorial (see <xref linkend="tutorial-sql-intro">), this returns:

<programlisting>
   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
</programlisting>
  </para>

  <para>
   On the other hand, the following query finds all the cities that
   are not state capitals and are situated at an altitude over 500ft:

<programlisting>
SELECT nom, altitude
    FROM ONLY villes
    WHERE altitude &gt; 500;

   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
</programlisting>
  </para>

  <para>
   Here the <literal>ONLY</literal> keyword indicates that the query
   should apply only to <structname>cities</structname>, and not any tables
   below <structname>cities</structname> in the inheritance hierarchy.  Many
   of the commands that we have already discussed &mdash;
   <command>SELECT</command>, <command>UPDATE</command> and
   <command>DELETE</command> &mdash; support the
   <literal>ONLY</literal> keyword.
  </para>

  <para>
  Dans certain cas, vous souhaitez savoir de quelle table provient une ligne
  donnée. Une colonne système appelée <structfield>TABLEOID</structfield>
  présente dans chaque table vous donne la table d'origine&nbsp;:

<programlisting>
SELECT c.tableoid, c.nom, c.altitude
FROM villes c
WHERE c.altitude &gt; 500;
</programlisting>

   qui renvoie&nbsp;:

<programlisting>
 tableoid |   nom    | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845
</programlisting>

   (Si vous essayez de reproduire cet exemple, vous obtiendrez probablement des
   OID numériques différents). En faisant une jointure avec
   <structname>pg_class</structname>, vous pourrez voir les noms de tables
   actuelles&nbsp;:

<programlisting>
SELECT p.relname, v.nom, v.altitude
FROM villes v, pg_class p
WHERE v.altitude &gt; 500 and v.tableoid = p.oid;
</programlisting>

   ce qui retourne&nbsp;:

<programlisting>
 relname   |   nom     | altitude
-----------+-----------+----------
 villes    | Las Vegas |     2174
 villes    | Mariposa  |     1953
 capitales | Madison   |      845
</programlisting>
   
  </para>

  <para>
   Inheritance does not automatically propagate data from
   <command>INSERT</command> or <command>COPY</command> commands to
   other tables in the inheritance hierarchy. In our example, the
   following <command>INSERT</command> statement will fail:
<programlisting>
INSERT INTO cities (name, population, altitude, state)
VALUES ('New York', NULL, NULL, 'NY');
</programlisting>
   We might hope that the data would somehow be routed to the
   <structname>capitals</structname> table, but this does not happen:
   <command>INSERT</command> always inserts into exactly the table
   specified.  In some cases it is possible to redirect the insertion
   using a rule (see <xref linkend="rules">).  However that does not
   help for the above case because the <structname>cities</> table
   does not contain the column <structfield>state</>, and so the
   command will be rejected before the rule can be applied.
  </para>

  <para>
   Check constraints can be defined on tables within an inheritance
   hierarchy. All check constraints on a parent table are
   automatically inherited by all of its children.  Other types of
   constraints are not inherited, however.
  </para>

  <para>
   A table can inherit from more than one parent table, in which case it has
   the union of the columns defined by the parent tables.  Any columns
   declared in the child table's definition are added to these.  If the
   same column name appears in multiple parent tables, or in both a parent
   table and the child's definition, then these columns are <quote>merged</>
   so that there is only one such column in the child table.  To be merged,
   columns must have the same data types, else an error is raised.  The
   merged column will have copies of all the check constraints coming from
   any one of the column definitions it came from.
  </para>

  <para>
   Table inheritance can currently only be defined using the <xref
   linkend="sql-createtable" endterm="sql-createtable-title">
   statement.  The related statement <command>CREATE TABLE AS</command> does
   not allow inheritance to be specified. There
   is no way to add an inheritance link to make an existing table into
   a child table. Similarly, there is no way to remove an inheritance
   link from a child table once it has been defined, other than by dropping
   the table completely.  A parent table cannot be dropped
   while any of its children remain. If you wish to remove a table and
   all of its descendants, one easy way is to drop the parent table with
   the <literal>CASCADE</literal> option.
  </para>

  <para>
   <xref linkend="sql-altertable" endterm="sql-altertable-title"> will
   propagate any changes in column data definitions and check
   constraints down the inheritance hierarchy.  Again, dropping
   columns or constraints on parent tables is only possible when using
   the <literal>CASCADE</literal> option. <command>ALTER
   TABLE</command> follows the same rules for duplicate column merging
   and rejection that apply during <command>CREATE TABLE</command>.
  </para>

 <sect2 id="ddl-inherit-caveats">
  <title>Caveats</title>

  <para>
   Table access permissions are not automatically inherited.  Therefore,
   a user attempting to access a parent table must either have permissions
   to do the operation on all its child tables as well, or must use the
   <literal>ONLY</literal> notation.  When adding a new child table to
   an existing inheritance hierarchy, be careful to grant all the needed
   permissions on it.
  </para>

  <para>
    Une limitation sérieuse de la fonctionnalité d'héritage est que les index
    (incluant les contraintes uniques) et les contraintes de clés étrangères
    s'appliquent seulement à des tables seules, pas à leurs héritiers. Ceci
    est vrai pour le côté de référence et le côté référencé d'une contrainte
    de clé étrangère. Du coup, dans les termes de l'exemple ci-dessus&nbsp;:

    <itemizedlist>
      <listitem>
        <para>
          Si nous déclarons <structname>villes</>.<structfield>nom</> comme
           <literal>UNIQUE</> ou comme une clé primaire (<literal>PRIMARY
	   KEY</>), ceci
           n'empêchera pas la table <structname>capitales</> d'avoir des lignes
           avec des noms dupliqués dans <structname>villes</>. Et ces lignes
           dupliquées pourraient par défaut s'afficher dans les requêtes sur
           <structname>villes</>. En fait, par défaut,
           <structname>capitales</> n'aurait pas du tout de contrainte
           unique et, du coup, pourrait contenir plusieurs lignes avec le
           même nom. Vous pouvez ajouter une contrainte unique à
           <structname>capitales</> mais ceci n'empêcherait pas la duplication
           comparée à <structname>villes</>.
        </para>
      </listitem>

      <listitem>
        <para>
          De façon similaire, si nous devions spécifier que
          <structname>villes</>.<structfield>nom</> fait référence
          (<literal>REFERENCES</>) une autre table, cette contrainte ne serait
          pas automatiquement propager à <structname>capitales</>. Dans ce cas,
          vous pourriez contourner ceci en ajoutant manuellement la même
          contrainte <literal>REFERENCES</> à <structname>capitales</>.
        </para>
      </listitem>

      <listitem>
        <para>
          Spécifier que la colonne d'une autre table <literal>REFERENCES
          villes(nom)</> autoriserait l'autre table à contenir les noms des
          villes mais pas les noms des capitales. Il n'existe pas de bons
          contournements pour ce cas.
        </para>
      </listitem>
    </itemizedlist>

    Ces déficiences seront probablement corrigées dans une version future mais
    en attendant, un soucis considérable est nécessaire dans la décision de
    l'utilité de l'héritage pour votre problème.
  </para>

  <note>
   <title>Deprecated</title>
   <para>
     In previous versions of <productname>PostgreSQL</productname>, the
     default behavior was not to include child tables in queries. This was
     found to be error prone and is also in violation of the SQL
     standard. Under the old syntax, to include the child tables you append
     <literal>*</literal> to the table name. For example:
<programlisting>
SELECT * from cities*;
</programlisting>
     You can still explicitly specify scanning child tables by
     appending <literal>*</literal>, as well as explicitly specify not
     scanning child tables by writing <literal>ONLY</literal>.  But
     beginning in version 7.1, the default behavior for an undecorated
     table name is to scan its child tables too, whereas before the
     default was not to do so.  To get the old default behavior,
     disable the <xref linkend="guc-sql-inheritance"> configuration
     option.
   </para>
  </note>

   </sect2>
  </sect1>

  <sect1 id="ddl-partitioning">
   <title>Partitioning</title>

   <indexterm>
    <primary>partitioning</primary>
   </indexterm>

   <indexterm>
    <primary>table</primary>
    <secondary>partitioning</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> supports basic table
    partitioning. This section describes why and how you can implement
    partitioning as part of your database design.
   </para>

   <sect2 id="ddl-partitioning-overview">
     <title>Overview</title>

   <para>
    Partitioning refers to splitting what is logically one large table
    into smaller physical pieces.
    Partitioning can provide several benefits:
   <itemizedlist>
    <listitem>
     <para>
      Query performance can be improved dramatically for certain kinds
      of queries.
     </para>
    </listitem>

    <listitem>
     <para>
      Update performance can be improved too, since each piece of the table
      has indexes smaller than an index on the entire data set would be.
      When an index no longer fits easily
      in memory, both read and write operations on the index take
      progressively more disk accesses.
     </para>
    </listitem>

    <listitem>
     <para>
      Bulk deletes may be accomplished by simply removing one of the
      partitions, if that requirement is planned into the partitioning design.
      <command>DROP TABLE</> is far faster than a bulk <command>DELETE</>,
      to say nothing of the ensuing <command>VACUUM</> overhead.
     </para>
    </listitem>

    <listitem>
     <para>
      Seldom-used data can be migrated to cheaper and slower storage media.
     </para>
    </listitem>
   </itemizedlist>

    The benefits will normally be worthwhile only when a table would
    otherwise be very large. The exact point at which a table will
    benefit from partitioning depends on the application, although a
    rule of thumb is that the size of the table should exceed the physical
    memory of the database server.
   </para>

   <para>
    Currently, <productname>PostgreSQL</productname> supports partitioning
    via table inheritance.  Each partition must be created as a child
    table of a single parent table.  The parent table itself is normally
    empty; it exists just to represent the entire data set.  You should be
    familiar with inheritance (see <xref linkend="ddl-inherit">) before
    attempting to implement partitioning.
   </para>

   <para>
    The following forms of partitioning can be implemented in
    <productname>PostgreSQL</productname>:

    <variablelist>
     <varlistentry>
      <term>Range Partitioning</term>

      <listitem>
       <para>
        The table is partitioned into <quote>ranges</quote> defined
        by a key column or set of columns, with no overlap between
        the ranges of values assigned to different partitions.  For
        example one might partition by date ranges, or by ranges of
        identifiers for particular business objects.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>List Partitioning</term>

      <listitem>
       <para>
        The table is partitioned by explicitly listing which key values
        appear in each partition.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Hash partitioning is not currently supported.
   </para>
   </sect2>

   <sect2 id="ddl-partitioning-implementation">
     <title>Implementing Partitioning</title>

    <para>
     To set up a partitioned table, do the following:
     <orderedlist spacing=compact>
      <listitem>
       <para>
        Create the <quote>master</quote> table, from which all of the
        partitions will inherit.
       </para>
       <para>
        This table will contain no data.  Do not define any check
        constraints on this table, unless you intend them to
        be applied equally to all partitions.  There is no point
        in defining any indexes or unique constraints on it, either.
       </para>
      </listitem>

      <listitem>
       <para>
        Create several <quote>child</quote> tables that each inherit from
        the master table.  Normally, these tables will not add any columns
        to the set inherited from the master.
       </para>

       <para>
        We will refer to the child tables as partitions, though they
        are in every way normal <productname>PostgreSQL</> tables.
       </para>
      </listitem>

      <listitem>
       <para>
        Add table constraints to the partition tables to define the
        allowed key values in each partition.
       </para>

       <para>
        Typical examples would be:
<programlisting>
CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID >= 100 AND outletID < 200 )
</programlisting>
        Ensure that the constraints guarantee that there is no overlap
        between the key values permitted in different partitions.  A common
        mistake is to set up range constraints like this:
<programlisting>
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
</programlisting>
        This is wrong since it is not clear which partition the key value
        200 belongs in.
       </para>

       <para>
        Note that there is no difference in
        syntax between range and list partitioning; those terms are
        descriptive only.
       </para>
      </listitem>

      <listitem>
       <para>
        For each partition, create an index on the key column(s),
        as well as any other indexes you might want.  (The key index is
        not strictly necessary, but in most scenarios it is helpful.
        If you intend the key values to be unique then you should
        always create a unique or primary-key constraint for each
        partition.)
       </para>
      </listitem>

      <listitem>
       <para>
        Optionally, define a rule or trigger to redirect modifications
        of the master table to the appropriate partition.
       </para>
      </listitem>

      <listitem>
       <para>
        Ensure that the <xref linkend="guc-constraint-exclusion">
        configuration
        parameter is enabled in <filename>postgresql.conf</>.  Without
        this, queries will not be optimized as desired.
       </para>
      </listitem>

     </orderedlist>
    </para>

    <para>
     For example, suppose we are constructing a database for a large
     ice cream company. The company measures peak temperatures every
     day as well as ice cream sales in each region. Conceptually,
     we want a table like this:

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting>

     We know that most queries will access just the last week's, month's or
     quarter's data, since the main use of this table will be to prepare
     online reports for management.
     To reduce the amount of old data that needs to be stored, we
     decide to only keep the most recent 3 years worth of data. At the
     beginning of each month we will remove the oldest month's data.
    </para>

    <para>
     In this situation we can use partitioning to help us meet all of our
     different requirements for the measurements table. Following the
     steps outlined above, partitioning can be set up as follows:
    </para>

    <para>
     <orderedlist spacing=compact>
      <listitem>
       <para>
        The master table is the <structname>measurement</> table, declared
        exactly as above.
       </para>
      </listitem>

      <listitem>
       <para>
        Next we create one partition for each active month:

<programlisting>
CREATE TABLE measurement_yy04mm02 ( ) INHERITS (measurement);
CREATE TABLE measurement_yy04mm03 ( ) INHERITS (measurement);
...
CREATE TABLE measurement_yy05mm11 ( ) INHERITS (measurement);
CREATE TABLE measurement_yy05mm12 ( ) INHERITS (measurement);
CREATE TABLE measurement_yy06mm01 ( ) INHERITS (measurement);
</programlisting>

        Each of the partitions are complete tables in their own right,
        but they inherit their definition from the
        <structname>measurement</> table.
       </para>

       <para>
        This solves one of our problems: deleting old data. Each
        month, all we will need to do is perform a <command>DROP
        TABLE</command> on the oldest child table and create a new
        child table for the new month's data.
       </para>
      </listitem>

      <listitem>
       <para>
        We must add non-overlapping table constraints, so that our
        table creation script becomes:

 <programlisting>
CREATE TABLE measurement_yy04mm02 (
    CHECK ( logdate >= DATE '2004-02-01' AND logdate < DATE '2004-03-01' )
) INHERITS (measurement);
CREATE TABLE measurement_yy04mm03 (
    CHECK ( logdate >= DATE '2004-03-01' AND logdate < DATE '2004-04-01' )
) INHERITS (measurement);
...
CREATE TABLE measurement_yy05mm11 (
    CHECK ( logdate >= DATE '2005-11-01' AND logdate < DATE '2005-12-01' )
) INHERITS (measurement);
CREATE TABLE measurement_yy05mm12 (
    CHECK ( logdate >= DATE '2005-12-01' AND logdate < DATE '2006-01-01' )
) INHERITS (measurement);
CREATE TABLE measurement_yy06mm01 (
    CHECK ( logdate >= DATE '2006-01-01' AND logdate < DATE '2006-02-01' )
) INHERITS (measurement);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        We probably need indexes on the key columns too:

 <programlisting>
CREATE INDEX measurement_yy04mm02_logdate ON measurement_yy04mm02 (logdate);
CREATE INDEX measurement_yy04mm03_logdate ON measurement_yy04mm03 (logdate);
...
CREATE INDEX measurement_yy05mm11_logdate ON measurement_yy05mm11 (logdate);
CREATE INDEX measurement_yy05mm12_logdate ON measurement_yy05mm12 (logdate);
CREATE INDEX measurement_yy06mm01_logdate ON measurement_yy06mm01 (logdate);
</programlisting>

        We choose not to add further indexes at this time.
       </para>
      </listitem>

      <listitem>
       <para>
        If data will be added only to the latest partition, we can
        set up a very simple rule to insert data. We must
        redefine this each month so that it always points to the
        current partition.

<programlisting>
CREATE OR REPLACE RULE measurement_current_partition AS
ON INSERT TO measurement
DO INSTEAD
    INSERT INTO measurement_yy06mm01 VALUES ( NEW.city_id,
                                              NEW.logdate,
                                              NEW.peaktemp,
                                              NEW.unitsales );
</programlisting>

        We might want to insert data and have the server automatically
        locate the partition into which the row should be added. We
        could do this with a more complex set of rules as shown below.

<programlisting>
CREATE RULE measurement_insert_yy04mm02 AS
ON INSERT TO measurement WHERE
    ( logdate >= DATE '2004-02-01' AND logdate < DATE '2004-03-01' )
DO INSTEAD
    INSERT INTO measurement_yy04mm02 VALUES ( NEW.city_id,
                                              NEW.logdate,
                                              NEW.peaktemp,
                                              NEW.unitsales );
...
CREATE RULE measurement_insert_yy05mm12 AS
ON INSERT TO measurement WHERE
    ( logdate >= DATE '2005-12-01' AND logdate < DATE '2006-01-01' )
DO INSTEAD
    INSERT INTO measurement_yy05mm12 VALUES ( NEW.city_id,
                                              NEW.logdate,
                                              NEW.peaktemp,
                                              NEW.unitsales );
CREATE RULE measurement_insert_yy06mm01 AS
ON INSERT TO measurement WHERE
    ( logdate >= DATE '2006-01-01' AND logdate < DATE '2006-02-01' )
DO INSTEAD
    INSERT INTO measurement_yy06mm01 VALUES ( NEW.city_id,
                                              NEW.logdate,
                                              NEW.peaktemp,
                                              NEW.unitsales );
</programlisting>

        Note that the <literal>WHERE</literal> clause in each rule
        exactly matches the the <literal>CHECK</literal>
        constraint for its partition.
       </para>
      </listitem>
     </orderedlist>
    </para>

    <para>
     As we can see, a complex partitioning scheme could require a
     substantial amount of DDL. In the above example we would be
     creating a new partition each month, so it may be wise to write a
     script that generates the required DDL automatically.
    </para>

   <para>
    The following caveats apply:
   <itemizedlist>
    <listitem>
     <para>
      There is currently no way to verify that all of the
      <literal>CHECK</literal> constraints are mutually
      exclusive. Care is required by the database designer.
     </para>
    </listitem>

    <listitem>
     <para>
      There is currently no simple way to specify that rows must not be
      inserted into the master table. A <literal>CHECK (false)</literal>
      constraint on the master table would be inherited by all child
      tables, so that cannot be used for this purpose.  One possibility is
      to set up an <literal>ON INSERT</> trigger on the master table that
      always raises an error.  (Alternatively, such a trigger could be
      used to redirect the data into the proper child table, instead of
      using a set of rules as suggested above.)
     </para>
    </listitem>
   </itemizedlist>
   </para>

   <para>
    Partitioning can also be arranged using a <literal>UNION ALL</literal>
    view:

<programlisting>
CREATE VIEW measurement AS
          SELECT * FROM measurement_yy04mm02
UNION ALL SELECT * FROM measurement_yy04mm03
...
UNION ALL SELECT * FROM measurement_yy05mm11
UNION ALL SELECT * FROM measurement_yy05mm12
UNION ALL SELECT * FROM measurement_yy06mm01;
</programlisting>

    However, constraint exclusion is currently not supported for
    partitioned tables defined in this manner.  Also, the need to
    recreate the view adds an extra step to adding and dropping
    individual partitions of the dataset.
   </para>
   </sect2>

   <sect2 id="ddl-partitioning-constraint-exclusion">
   <title>Partitioning and Constraint Exclusion</title>

   <indexterm>
    <primary>constraint exclusion</primary>
   </indexterm>

   <para>
    <firstterm>Constraint exclusion</> is a query optimization technique
    that improves performance for partitioned tables defined in the
    fashion described above.  As an example:

<programlisting>
SET constraint_exclusion = on;
SELECT count(*) FROM measurement WHERE logdate >= DATE '2006-01-01';
</programlisting>

    Without constraint exclusion, the above query would scan each of
    the partitions of the <structname>measurement</> table. With constraint
    exclusion enabled, the planner will examine the constraints of each
    partition and try to prove that the partition need not
    be scanned because it could not contain any rows meeting the query's
    <literal>WHERE</> clause.  When the planner can prove this, it
    excludes the partition from the query plan.
   </para>

   <para>
    You can use the <command>EXPLAIN</> command to show the difference
    between a plan with <varname>constraint_exclusion</> on and a plan
    with it off.  A typical default plan for this type of table setup is:

<programlisting>
SET constraint_exclusion = off;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate >= DATE '2006-01-01';

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=158.66..158.68 rows=1 width=0)
   ->  Append  (cost=0.00..151.88 rows=2715 width=0)
         ->  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate >= '2006-01-01'::date)
         ->  Seq Scan on measurement_yy04mm02 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate >= '2006-01-01'::date)
         ->  Seq Scan on measurement_yy04mm03 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate >= '2006-01-01'::date)
...
         ->  Seq Scan on measurement_yy05mm12 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate >= '2006-01-01'::date)
         ->  Seq Scan on measurement_yy06mm01 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate >= '2006-01-01'::date)
</programlisting>

    Some or all of the partitions might use index scans instead of
    full-table sequential scans, but the point here is that there
    is no need to scan the older partitions at all to answer this query.
    When we enable constraint exclusion, we get a significantly
    reduced plan that will deliver the same answer:

<programlisting>
SET constraint_exclusion = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate >= DATE '2006-01-01';
                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=63.47..63.48 rows=1 width=0)
   ->  Append  (cost=0.00..60.75 rows=1086 width=0)
         ->  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate >= '2006-01-01'::date)
         ->  Seq Scan on measurement_yy06mm01 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate >= '2006-01-01'::date)
</programlisting>
   </para>

   <para>
    Note that constraint exclusion is driven only by <literal>CHECK</>
    constraints, not by the presence of indexes.  Therefore it isn't
    necessary to define indexes on the key columns.  Whether an index
    needs to be created for a given partition depends on whether you
    expect that queries that scan the partition will generally scan
    a large part of the partition or just a small part.  An index will
    be helpful in the latter case but not the former.
   </para>

   <para>
    The following caveats apply:

   <itemizedlist>
    <listitem>
     <para>
      Constraint exclusion only works when the query's <literal>WHERE</>
      clause contains constants.  A parameterized query will not be
      optimized, since the planner cannot know what partitions the
      parameter value might select at runtime.  For the same reason,
      <quote>stable</> functions such as <function>CURRENT_DATE</function>
      must be avoided.  Joining the partition key to a column of another
      table will not be optimized, either.
     </para>
    </listitem>

    <listitem>
     <para>
      Avoid cross-datatype comparisons in the <literal>CHECK</>
      constraints, as the planner will currently fail to prove such
      conditions false.  For example, the following constraint
      will work if <varname>x</varname> is an <type>integer</type>
      column, but not if <varname>x</varname> is a
      <type>bigint</type>:
<programlisting>
CHECK ( x = 1 )
</programlisting>
      For a <type>bigint</type> column we must use a constraint like:
<programlisting>
CHECK ( x = 1::bigint )
</programlisting>
      The problem is not limited to the <type>bigint</type> data type
      &mdash; it can occur whenever the default data type of the
      constant does not match the data type of the column to which it
      is being compared.  Cross-datatype comparisons in the supplied
      queries are usually OK, just not in the <literal>CHECK</> conditions.
     </para>
    </listitem>

    <listitem>
     <para>
      <command>UPDATE</command> and <command>DELETE</command> commands
      against the master table do not currently perform constraint exclusion.
     </para>
    </listitem>

    <listitem>
     <para>
      All constraints on all partitions of the master table are considered for
      constraint exclusion, so large numbers of partitions are likely to
      increase query planning time considerably.
     </para>
    </listitem>

    <listitem>
     <para>
      Don't forget that you still need to run <command>ANALYZE</command>
      on each partition individually. A command like
<programlisting>
ANALYZE measurement;
</programlisting>
      will only process the master table.
     </para>
    </listitem>

   </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-others">
  <title>D'autres objets de la base de données</title>

  <para>
   Les tables sont les objets centraux dans une structure de base de
   données relationnelles. Mais ce ne sont pas les seuls objets qui
   existent dans une base de données. Plusieurs autres types d'objets
   peuvent être créés afin de rendre l'utilisation et la gestion
   des données plus efficace ou pratique. Ils ne seront pas abordés
   dans ce chapitre mais nous vous en faisons une liste ici pour que
   vous soyez informés de ce qui est possible.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Vues
    </para>
   </listitem>

   <listitem>
    <para>
     Fonctions et opérateurs
    </para>
   </listitem>

   <listitem>
    <para>
     Types de données et domaines
    </para>
   </listitem>

   <listitem>
    <para>
     Déclencheurs et règles de réécriture
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Des informations détaillées sur ces sujets apparaissent dans la <xref
   linkend="server-programming">.
  </para>
 </sect1>

 <sect1 id="ddl-depend">
  <title>Gestion des dépendances</title>

  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <para>
   Lorsque vous créez des structures de base complexes impliquant
   beaucoup de tables avec des contraintes de clés étrangères, des
   vues, des déclencheurs, des fonctions, etc, vous créez implicitement
   un filet de dépendances entre les objets.
   Par exemple, une table avec une contrainte de clé étrangère dépend
   de la table à laquelle elle fait référence.
  </para>

  <para>
   Pour garantir l'intégrité de la structure entière de la base,
   <productname>PostgreSQL</productname> vérifie que vous ne pouvez
   pas effacer des objets dont d'autres objets dépendent. Par
   exemple, la tentative d'effacer la table des produits que nous
   avons utilisé dans la <xref linkend="ddl-constraints-fk">, avec la
   table des commandes qui en dépend, donnera un message d'erreur
   comme celui-ci&nbsp;:
<screen>
DROP TABLE produits;

NOTICE:  constraint commandes_no_produit_fkey on table commandes depends on table produits
ERROR:  cannot drop table produits because other objects depend on it
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</screen>
   Le message d'erreur contient un indice utile&nbsp;: si vous ne souhaitez
   pas effacer les objets dépendants individuellement, vous pouvez
   lancer
<screen>
DROP TABLE produits CASCADE;
</screen>
   et tous les objets seront effacés. Dans ce cas, cela n'effacera pas
   la table des commandes mais seulement la contrainte de clé étrangère
   (si vous voulez vérifier ce que <command>DROP ... CASCADE</command> fera,
   lancez <command>DROP</command> sans <literal>CASCADE</literal> et lisez les messages
   <literal>NOTICE</literal>).
  </para>

  <para>
   Toutes les commandes de suppression dans
   <productname>PostgreSQL</productname> supportent l'utilisation de
   <literal>CASCADE</literal>. Bien sûr, la nature des dépendances
   varie avec la nature des objets. Vous pouvez aussi écrire
   <literal>RESTRICT</literal> au lieu de <literal>CASCADE</literal>
   pour obtenir le comportement par défaut qui est d'empêcher les
   suppressions d'objets sur lesquelles dépendent d'autres objets.
  </para>

  <note>
   <para>
    D'après le standard SQL, spécifier
    <literal>RESTRICT</literal> ou <literal>CASCADE</literal> est
    requis. Aucun système de base de donnée ne force cette règle de cette
    manière actuellement mais le choix du comportement par défaut,
    <literal>RESTRICT</literal> ou <literal>CASCADE</literal>,
    varie suivant le système.
   </para>
  </note>

  <note>
   <para>
    Les dépendances de contraintes de clés étrangères et de colonnes
    en série des versions de <productname>PostgreSQL</productname>
    antérieures à 7.3 ne seront <emphasis>pas</emphasis> maintenues ou
    créées pendant le processus de mise à jour. Tout autre type de
    dépendance sera proprement créé pendant une mise à jour à partir d'une
    base de données antérieure à la 7.3.
   </para>
  </note>
 </sect1>

</chapter>