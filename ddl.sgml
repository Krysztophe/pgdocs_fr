<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/ddl.sgml,v 1.12 2005/09/15 07:03:16 guillaume Exp $ -->

<chapter id="ddl">
 <title>Définition des données</title>

 <para>
  Ce chapitre couvre la création de structures de données qui contiendront
  les données de quelqu'un. Dans une base relationnelle, les données brutes
  sont stockées dans des tables. Du coup, la plus grande partie de ce chapitre
  sera consacrée à l'explication de la création et de la modification des tables 
  et des fonctions disponibles pour contrôler les données stockées dans les tables.
  Ensuite, nous discuterons de l'organisation de tables en schémas, et comment
  des droits peuvent être attribués aux tables. Enfin,
  nous verrons brièvement d'autres fonctionnalités, tel que les vues, les fonctions
  et les déclencheurs.
 </para>

 <sect1 id="ddl-basics">
  <title>Bases sur les tables</title>

  <indexterm zone="ddl-basics">
   <primary>table</primary>
  </indexterm>

  <indexterm>
   <primary>rangée</primary>
  </indexterm>

  <indexterm>
   <primary>colonne</primary>
  </indexterm>

  <para>
   Une table dans une base relationnelle ressemble beaucoup à un tableau
   sur papier&nbsp;: elle est constituée de rangées et de colonnes. Le nombre
   et l'ordre des colonnes sont fixés et chaque colonne a un nom. Le
   nombre de rangées est variable -- il représente la quantité de données
   stockées à un moment donné. SQL n'apporte aucune garantie sur l'ordre des
   rangées dans une table. Quand une table est lue, les rangées
   apparaîtront dans un ordre aléatoire sauf si un tri est demandé
   explicitement. Ceci est couvert dans <xref linkend="queries">. De plus,
   SQL n'attribue pas d'identifiant unique aux rangées. Du coup, il est possible
   d'avoir plusieurs rangées complètement identiques dans une table. Ceci
   est une conséquence du modèle mathématique sur lequel repose SQL mais
   n'est habituellement pas désiré.
   Plus tard dans ce chapitre, nous verrons comment traiter ce problème.
  </para>

  <para>
   Chaque colonne a un type de donnée. Ce type de donnée restreint la série
   de valeurs possibles qui peuvent être attribuées à une colonne et attribue
   des sémantiques à la donnée stockée dans la colonne pour qu'elles puissent
   être utilisées pour des calculs. Par exemple, une colonne déclarée comme
   étant d'un type numérique n'acceptera pas une chaîne arbitraire de texte,
   et les données stockées dans une telle table peuvent être utilisées dans
   des calculs mathématiques.
   Par opposition, une colonne déclarée comme étant de type chaîne de
   caractères acceptera pratiquement n'importe quel type de donnée mais ne
   se prêtera pas à des calculs mathématiques bien que d'autres opérations
   tel que la concaténation des chaînes sont disponibles.
  </para>

  <para>
   <productname>PostgreSQL</productname> inclut une série conséquente de types
   de données intégrés qui correspondent à plusieurs applications. Les
   utilisateurs peuvent aussi définir leurs propres types de données. La
   plupart des types de données intégrés ont des noms et des sémantiques
   évidents alors nous reportons une explication détaillée à <xref
   linkend="datatype">. Quelques-uns des types les plus utilisés sont
   <type>integer</type> pour les entiers, <type>numeric</type> pour
   les nombres pouvant être fractionnels, <type>text</type> pour les chaînes de
   caractères, <type>date</type> pour les dates, <type>time</type> pour
   les valeurs de type heure et <type>timestamp</type> pour les valeurs
   contenant et une date et une heure.
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>création</secondary>
  </indexterm>

  <para>
   Pour créer une table, il faut utiliser la commande bien nommée <command>CREATE
   TABLE</command>. Dans cette commande, vous devez spécifier au moins le nom de la
   nouvelle table, les noms des colonnes et le type de données pour chacune des
   colonnes. Par exemple&nbsp;:
<programlisting>
CREATE TABLE ma_premiere_table (
    premiere_colonne text,
    deuxieme_colonne integer
);
</programlisting>
   Ceci crée une table nommée <literal>ma_premiere_table</literal> avec
   deux colonnes. La première colonne est nommée
   <literal>premiere_colonne</literal> et a un type de données
   <type>text</type>&nbsp;; la seconde colonne porte le nom
   <literal>deuxieme_colonne</literal> et le type <type>integer</type>.
   Les noms de table et colonnes suivent la syntaxe d'identification expliquée
   dans <xref linkend="sql-syntax-identifiers">.  Les noms des types sont souvent
   aussi des identifiants mais il y a des exceptions. Notez que la liste des
   colonnes est séparée par des virgules et entourée par des parenthèses.
  </para>

  <para>
   Bien sur, l'exemple précédant est un peu tiré par les cheveux. Normalement,
   on donne aux tables et aux colonnes des noms indiquant quels types de données
   ils stockent. Alors voyons un exemple plus réaliste&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric
);
</programlisting>
   (Le type <type>numeric</type> peut stocker des composants fractionnels
   comme on pourrait s'y attendre de montants monétaires.)
  </para>

  <tip>
   <para>
    Quand vous créez des tables liées entre elles, il est prudent de choisir
    des règles de nommage pour les tables et les colonnes. Par exemple, il
    peut y avoir le choix d'utiliser des noms au pluriel ou au singulier
    pour les noms de table, chaque choix ayant les faveurs d'un théoricien
    ou d'un autre.
   </para>
  </tip>

  <para>
   Il y a une limite sur le nombre de colonnes qu'une table peut contenir.
   Suivant le type de colonne, elle peut être entre 250 et 1600.
   Par contre, définir une table avec un nombre de colonnes proche de ceux-ci
   est très inhabituel et est souvent la preuve d'une conception douteuse.
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>suppression</secondary>
  </indexterm>

  <para>
   Si vous n'avez plus besoin d'une table, vous pouvez la retirer en utilisant
   la commande <command>DROP TABLE</command>. Par exemple&nbsp;:
<programlisting>
DROP TABLE ma_premiere_table;
DROP TABLE produits;
</programlisting>
   Tenter de supprimer une table qui n'existe pas est une erreur.
   Malgré cela, il est habituel dans des fichiers de scripts SQL d'essayer
   de supprimer chaque table avant de la créer, tout en ignorant les messages
   d'erreur.
  </para>

  <para>
   Si vous avez besoin de modifier une table qui existe déjà, regardez <xref
   linkend="ddl-alter"> plus loin dans ce chapitre.
  </para>

  <para>
   Avec les outils dont nous avons déjà discuté, vous pouvez créer des tables
   fonctionnelles. Le reste de ce chapitre est consacré à l'ajout de fonctionnalités,
   à la définition de tables pour garantir l'intégrité des données, la sécurité
   ou la facilité.  Si vous êtes impatients de remplir vos tables avec des données
   tout de suite, vous pouvez sauter au <xref linkend="dml"> et lire le reste de
   ce chapitre plus tard.
  </para>
 </sect1>

 <sect1 id="ddl-default">
  <title>Valeurs par défaut</title>

  <indexterm zone="ddl-default">
   <primary>valeur par défaut</primary>
  </indexterm>

  <para>
   On peut attribuer une valeur par défaut à une colonne. Quant une nouvelle
   rangée est créée et aucune valeur n'est spécifié pour certaines de ses
   colonnes, celles-ci sont remplies avec leur valeur par défaut respective.
   Une commande de manipulation de données peut aussi demander explicitement
   qu'une colonne soit mise à sa valeur par défaut sans avoir à connaître la
   valeur en question. (Les détails sur les commandes de manipulation de données
   sont dans <xref linkend="dml">.)
  </para>

  <para>
   <indexterm><primary>valeur NULL</primary><secondary>valeur par défaut</secondary></indexterm>
   Si aucune valeur par défaut n'est déclarée explicitement, la valeur
   par défaut est la valeur NULL. Ceci est d'habitude cohérent car on
   peut considérer que la valeur NULL représente des données inconnues.
  </para>

  <para>
   Dans une définition de table, les valeurs par défaut sont listées après
   le type de donnée de la colonne. Par exemple:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
  </para>

  <para>
   La valeur par défaut peut être une expression, qui
   sera évaluée à l'insertion de la valeur par défaut
   (<emphasis>pas</emphasis> à la création de la table.) Un exemple habituel
   est qu'une colonne de type timestamp pourrait avoir une valeur par défaut
   <literal>now()</>, de façon à ce qu'il obtienne la valeur de l'heure au
   moment de l'insertion. Un autre exemple habituel est la génération d'un
   <quote>numéro de série</> pour chaque ligne.
   Dans <productname>PostgreSQL</productname>, ceci se fait habituellement par
   quelque chose comme
<programlisting>
	CREATE TABLE products (
	product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,
	...
	);
</programlisting>
   où la fonction <literal>nextval()</> fournit des valeurs successives à
   partir d'une <firstterm>objet séquence</> (voir <xref
   linkend="functions-sequence">). Cet arrangement est suffisamment commun
   pour qu'il y ait un raccourci pour lui&nbsp;:
<programlisting>
	CREATE TABLE products (
	product_no <emphasis>SERIAL</emphasis>,
	...
	);
</programlisting>
   Le raccourci <literal>SERIAL</> est discuté plus tard dans <xref
   linkend="datatype-serial">.
  </para>
 </sect1>

 <sect1 id="ddl-constraints">
  <title>Contraintes</title>

  <indexterm zone="ddl-constraints">
   <primary>contrainte</primary>
  </indexterm>

  <para>
   Les types de données sont un moyen de limiter ce qui peut être stocké
   dans une table. Pour beaucoup d'applications, par contre, la contrainte
   qu'elles appliquent sont trop fortes. Par exemple, une colonne qui
   contient le prix d'un produit ne devrait accepter que des valeurs
   positives. Mais il n'y a pas de type de données qui n'acceptent que
   des valeurs positives. Un autre problème est le fait de vouloir limiter
   les données d'une colonne par rapport à d'autres colonnes ou rangées.
   Par exemple, dans une table contenant des informations de produit, il
   ne devrait y avoir qu'une rangée pour chaque numéro de produit.
  </para>

  <para>
   Dans ce but, SQL vous permet de définir les contraintes sur les colonnes
   et les tables. Les contraintes vous donnent autant de contrôle sur les
   données de vos tables que vous désirez. Si un utilisateur tente de stocker
   des données dans une colonne qui violerait un contrainte, une erreur est
   soulevée. Ceci s'applique même si la valeur vient de la définition de la
   valeur par défaut.
  </para>

  <sect2>
   <title>Contraintes de Vérification</title>

   <indexterm>
    <primary>contrainte de vérification</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>vérification</secondary>
   </indexterm>

   <para>
    Une contrainte de vérification est le type de contrainte le plus
    générique qui soit. Elle vous permet de spécifier l'expression
    d'une certaine colonne doit satisfaire une expression booléenne. Par
    exemple, pour obliger des prix de produits positifs, on pourrait
    utiliser&nbsp;:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>
);
</programlisting>
   </para>

   <para>
    Comme vous pouvez le voir, la définition de contrainte vient après
    le type de données comme les définitions de valeur par défaut. Les
    valeurs par défaut et les contraintes peuvent être données dans
    n'importe quel ordre. Une contrainte de vérification s'utilise avec
    le mot clé <literal>CHECK</literal> suivi d'une expression entre
    parenthèses. L'expression de contrainte de vérification peut
    impliquer la colonne ainsi contrainte, sinon la contrainte n'aurait
    pas beaucoup de sens.
   </para>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>nom</secondary>
   </indexterm>

   <para>
    Vous pouvez aussi donner à la contrainte un nom diffèrent. Ceci
    clarifie les messages d'erreur et vous permet de faire référence
    à la contrainte lorsque vous avez besoin de la modifier.
    La syntaxe est:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)
);
</programlisting>
    Alors, pour spécifier une contrainte nommée, utilisez le mot-clé
    <literal>CONSTRAINT</literal> suivi d'un identifiant et de la
    définition de contrainte. (Si vous ne donnez pas de nom à la contrainte,
    le système choisira un nom pour vous.)
   </para>

   <para>
    Une contrainte de vérification peut faire référence à plusieurs
    colonnes. Admettons que vous souhaitez stocker un prix normal et un
    prix de promotion et, être sur que le prix de
    promotion soit inférieur au prix normal.
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    <emphasis>CHECK (price &gt; discounted_price)</emphasis>
);
</programlisting>
   </para>

   <para>
    Les deux premières contraintes devrait vous être familières. La troisième
    utilise une nouvelle syntaxe. Elle n'est pas attachée à une colonne
    particulière, elle apparaît comme un élément distinct dans
    la liste de colonnes séparées par des virgules. Les définitions de
    colonnes et ces définitions de contraintes peut être définies dans
    un ordre quelconque.
   </para>

   <para>
    On dit que les deux premières contraintes sont des contraintes de
    colonnes tandis que la troisième est une contrainte de table parce
    qu'elle est écrite séparément de toute définition de colonne tandis que
    l'inverse n'est pas forcément possible car une contrainte de colonne est
    supposé faire uniquement référence à la colonne à laquelle elle est
    attachée. (<productname>PostgreSQL</productname> ne force pas cette règle
    mais vous devriez la suivre si vous voulez que les définitions de votre
    table fonctionnent avec d'autres systèmes de bases de données.) 
    L'exemple ci-dessus aurait pu s'écrire&nbsp;:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);
</programlisting>
    ou même
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);
</programlisting>
    C'est une question de goût.
   </para>

   <para>
    Des noms peuvent être affectés à des contraintes de table de la même
    façon que les contraintes de colonne&nbsp;:
     <programlisting>
       CREATE TABLE products (
       product_no integer,
       name text,
       price numeric,
       CHECK (price &gt; 0),
       discounted_price numeric,
       CHECK (discounted_price &gt; 0),
       <emphasis>CONSTRAINT valid_discount</> CHECK (price &gt; discounted_price)
     );
     </programlisting>
   </para>

   <indexterm>
    <primary>valeur NULL</primary>
    <secondary sortas="check constraints">avec contraintes de vérification</secondary>
   </indexterm>

   <para>
    Il faut noter qu'une contrainte de vérification est satisfaite si
    l'expression est évaluée à vrai ou la valeur NULL. Puisque la
    plupart des expressions seront évaluées à la valeur NULL si l'un
    des opérandes est NULL, elles n'empêchent pas les valeurs NULL
    dans les colonnes contraintes. Pour s'assurer qu'une colonne ne
    contient pas de valeurs NULL, la contrainte non-NULL décrite
    dans la section suivante peut être utilisée.
   </para>
  </sect2>

  <sect2>
   <title>Contraintes Non NULL</title>

   <indexterm>
    <primary>contrainte non NULL</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>

   <para>
    Une contrainte non NULL dit simplement qu'une colonne ne peut
    pas prendre la valeur NULL. Un exemple de syntaxe:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>NOT NULL</emphasis>,
    name text <emphasis>NOT NULL</emphasis>,
    price numeric
);
</programlisting>
   </para>

   <para>
    Une contrainte non NULL est toujours écrite comme une contrainte de
    colonne. Une contrainte non NULL est l'équivalente fonctionnelle de
    créer une contrainte <literal>CHECK (<replaceable>nom_colonne</replaceable>
    IS NOT NULL)</literal>, mais dans <productname>PostgreSQL</productname>,
    créer une contrainte explicitement non NULL est plus efficace.
    L'inconvénient est que vous ne pouvez pas donner de noms explicites
    à des contraintes non NULL créées de cette manière.
   </para>

   <para>
    Bien sur, une colonne peut avoir plus d'une contrainte. Écrivez juste
    les contraintes les unes après les autres:
<programlisting>
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);
</programlisting>
    L'ordre n'importe pas. Il ne détermine pas dans quel ordre les contraintes
    seront vérifiées.
   </para>

   <para>
    La contrainte <literal>NOT NULL</literal> a un opposé; la contrainte
    <literal>NULL</literal> . Ceci ne veut pas dire que la colonne doit
    être NULL, ce qui serait inutile. À la place, ceci sélectionne le comportement
    par défaut que la colonne doit être NULL. La contrainte <literal>NULL
    </literal> n'est pas définie dans le standard SQL et ne devrait pas
    être utilisé dans des applications portables. (Elle n'a été ajoutée
    dans <productname>PostgreSQL</productname> que pour assurer la
    compatibilité avec d'autres bases de données.) Certains utilisateurs
    l'apprécient car elle facilite le fait d'activer une contrainte
    dans un fichier de script. Par exemple, vous pourriez commencer avec:
<programlisting>
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
</programlisting>
    et puis insérer le mot-clé <literal>NOT</literal> suivant vos besoins.
   </para>

   <tip>
    <para>
     Dans beaucoup de conceptions de bases de données, la majorité des
     colonnes devraient être marquées non NULL.
    </para>
   </tip>
  </sect2>

  <sect2>
   <title>Contraintes Uniques</title>

   <indexterm>
    <primary>contrainte unique</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>unique</secondary>
   </indexterm>

   <para>
    Les contraintes uniques garantissent que les données contenues dans
    la colonne ou un groupe de colonnes est unique par rapport à toutes
    les rangées dans la table. La syntaxe est:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>UNIQUE</emphasis>,
    name text,
    price numeric
);
</programlisting>
    est écrit comme contrainte de colonne et
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>UNIQUE (product_no)</emphasis>
);
</programlisting>
    est écrit comme contrainte de table.
   </para>

   <para>
    Si une contrainte unique fait référence à un groupe de colonnes,
    celles-ci sont listées séparées par des virgules:
<programlisting>
CREATE TABLE exemple (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
    Ceci spécifie que la combinaison de valeurs dans les colonnes indiquées
    est unique pour toute la table bien qu'une seule des colonnes puisse ne
    pas être (et habituellement n'est pas) unique.
   </para>

   <para>
    Vous pouvez affecter votre propre nom pour une contrainte unique, de la
    façon habituelle&nbsp;:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,
    name text,
    price numeric
);
</programlisting>
   </para>

   <indexterm>
    <primary>valeur NULL</primary>
    <secondary sortas="unique constraints">avec contrainte unique</secondary>
   </indexterm>

   <para>
    En général, une contrainte unique est violée lorsqu'il y a au
    moins deux rangées dans une table ou la valeur de toutes les
    colonnes inclus dans la contrainte sont
    égales. Par contre, les valeurs NULL ne sont pas assimilées
    à une égalités dans cette comparaison. Ceci veut dire qu'il est possible
    de stocker un nombre illimité de rangées qui contiennent une
    valeur NULL dans au moins l'une des colonnes contraintes. Ce
    comportement est conforme au standard SQL mais nous avons
    été informé que d'autres bases SQL ne suivent pas cette règle. Alors,
    soyez prudents en développant des applications qui sont prévues
    pour être portable.
   </para>
  </sect2>

  <sect2>
   <title>Clés Primaires</title>

   <indexterm>
    <primary>clé primaire</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>clé primaire</secondary>
   </indexterm>

   <para>
    Techniquement, une contrainte de clé primaire est tout
    simplement une combinaison d'une contrainte unique et
    d'une contrainte non NULL. Donc, les définitions de
    tables suivantes accepteront les mêmes données:
<programlisting>
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
</programlisting>

<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>PRIMARY KEY</emphasis>,
    name text,
    price numeric
);
</programlisting>
   </para>

   <para>
    Les clés primaires peuvent contraindre sur plus d'une colonne; la
    syntaxe est semblable aux contraintes uniques:
<programlisting>
CREATE TABLE exemple (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
   </para>

   <para>
    Une clé primaire indique qu'une colonne ou groupe de colonnes peuvent
    être utilisé comme identifiant unique pour les rangées de la table. (Ceci
    est une conséquence directe de la définition d'une clé primaire. Notez
    qu'une contrainte unique ne donne pas par elle-même, un identifiant unique
    car elle n'exclut pas les valeurs NULL.) Ceci est pratique à la fois
    pour des raisons de documentation et pour les applications clientes. Par
    exemple, une application graphique qui permet de modifier les valeurs de
    rangées a probablement besoin de connaître la clé primaire d'une table pour
    pouvoir identifier les rangées de manière unique correctement.
   </para>

   <para>
    Une table peut avoir au mieux une clé primaire (tandis qu'elle peut
    avoir plusieurs contraintes uniques et non NULL). La théorie des
    bases de données relationnelles dit que chaque table doit avoir
    une clé primaire. Cette règle n'est pas appliquée par
    <productname>PostgreSQL</productname>, mais il vaut mieux la respecter
    autant que possible.
   </para>
  </sect2>

  <sect2 id="ddl-constraints-fk">
   <title>Clés Étrangères</title>

   <indexterm>
    <primary>clé étrangère</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>clé étrangère</secondary>
   </indexterm>

   <indexterm>
    <primary>intégrité référentielle</primary>
   </indexterm>

   <para>
    Une contrainte de clé étrangère stipule que les valeurs dans cette
    colonne (ou un groupe de colonnes) doit correspondre aux valeurs
    apparaissant dans des rangées d'une autre table.
    Nous disons que ceci maintient l'<firstterm>intégrité
    référentielle</firstterm> entre deux tables liées.
   </para>

   <para>
    Disons que vous avez la table de produits que nous avons déjà utilisé plusieurs fois:
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
</programlisting>
    Disons aussi que vous avez une table stockant les commandes de
    ces produits. Nous voulons aussi nous assurer que la table des
    commandes ne contienne que des commandes concernant des produits
    qui existent réellement. Alors, nous définissons une contrainte
    de clé étrangère dans la table des commandes qui référence la
    table produit:
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,
    quantity integer
);
</programlisting>
    Maintenant, il est impossible de créer des commandes avec une entrée
    <structfield>product_no</structfield> qui n'apparaît pas dans la table products.
   </para>

   <para>
    Nous disons que, dans cette situation, la table de commandes est la table
    <firstterm>référente</firstterm> et la table products est la table
    <firstterm>référée</firstterm>.  De la même façon, il y a des colonnes
    référentes et des colonnes référées.
   </para>

   <para>
    On peut aussi raccourcir la commande ci-dessus en
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products</emphasis>,
    quantity integer
);
</programlisting>
    parce qu'en l'absence d'une liste de colonne, la clé primaire de la
    table référente est utilisé comme colonne référée.
   </para>

   <para>
    Une clé étrangère peut aussi contraindre et référencer un groupe de colonnes.
    Comme d'habitude, il faut aussi l'écrire sous forme de contrainte de table.
    Voici un exemple de syntaxe:
<programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>
);
</programlisting>
    Bien sûr, le nombre et le type des colonnes contraintes doit correspondre
    aux nombres et types des colonnes référées.
   </para>

   <para>
	Vous pouvez affecter votre propre nom pour une contrainte de clé
	étrangère de la façon habituelle.
   </para>

   <para>
    Une table peut contenir plus d'une contrainte de clé étrangère. Ceci peut
    être utilisé pour implémenter des relations n à n entre tables. Disons
    que vous avez des tables contenant des produits et des commandes mais vous
    voulez maintenant autoriser une commande qui contient peut-être beaucoup
    de produits (ce que la structure ci-dessus ne permet pas). On pourrait
    utiliser cette structure de table:
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
    Notez aussi que la clé primaire chevauche les clés étrangères dans la dernière table.
   </para>

   <indexterm>
    <primary>CASCADE</primary>
    <secondary>action clé étrangère</secondary>
   </indexterm>

   <indexterm>
    <primary>RESTRICT</primary>
    <secondary>action clé étrangère</secondary>
   </indexterm>

   <para>
    Nous savons que les clés étrangères n'autorisent pas la création
    de commandes qui ne sont pas liés à un produit. Et si un produit
    est retiré après qu'une commande qui y réfère soit créée&nbsp;? SQL vous
    permet aussi de le gérer. Intuitivement, nous avons plusieurs options&nbsp;:
    <itemizedlist spacing="compact">
     <listitem><para>Interdire d'effacer un produit référé</para></listitem>
     <listitem><para>Effacer aussi les commandes</para></listitem>
     <listitem><para>Autre chose ?</para></listitem>
    </itemizedlist>
   </para>

   <para>
    Pour illustrer ce cas, implémentons la politique suivante sur
    l'exemple de relations n à n évoquée plus haut: Quand quelqu'un
    veut retirer un produit qui est encore référencé par un ordre
    (via <literal>ordre_items</literal>), on l'interdit. Si quelqu'un
    retire une commande, les éléments de l'ordre sont aussi retirés.
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,
    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
   </para>

   <para>
     Restreindre les suppressions et supprimer en cascade sont les deux
     options les plus communes. <literal>RESTRICT</literal> empêche la
     suppression d'une ligne référencée. <literal>NO ACTION</literal> signifie
     que si des lignes de références existent lors de la vérification de la 
     contrainte, une erreur est levée&nbsp; ceci est le comportement par
     défaut si vous n'avez rien spécifié. (La différence essentielle entre
     ces deux choix est que <literal>NO ACTION</literal> autorise la
     déférence de la vérification plus tard dans la transaction alors que    
     <literal>RESTRICT</literal> ne le permet pas.) <literal>CASCADE</>
     spécifie que, quand une ligne référencée est supprimée, les lignes la
     référençant devraient aussi être automatiquement supprimées. Il existe
     deux autres options&nbsp;: <literal>SET NULL</literal> et <literal>SET
     DEFAULT</literal>. Celles-ci font que les colonnes de références soient
     initialisées à NULL ou à leur valeur par défaut, respectivement quand la
     ligne référencée est supprimée. Notez qu'elles ne vous excusent pas
     d'observer les contraintes. Par exemple, si une action spécifie 
     <literal>SET DEFAULT</literal> mais que la valeur par défaut ne
     satisferait pas la clé étrangère, l'opération échouera.
   </para>

   <para>
    Sur le même principe que <literal>ON DELETE</literal>, il y a aussi
    <literal>ON UPDATE</literal> qui est évoqué lorsqu'une colonne référencée
    est modifiée (mise à jour). Les actions possibles sont les mêmes.
   </para>

   <para>
    Il y a plus d'informations sur la mise à jour et la suppression de données dans <xref
    linkend="dml">.
   </para>

   <para>
    Enfin, nous devrions dire que la clé étrangère peut référencer
    des colonnes qui sont une clé primaire ou forment une contrainte unique.
    Si la clé étrangère référence une contrainte unique, il y a des
    possibilités supplémentaires selon que l'on souhaite faire correspondre
    les valeurs NULL.
    Ceux-ci sont expliqués dans la documentation de référence pour
    <xref linkend="sql-createtable" endterm="sql-createtable-title">.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-system-columns">
   <title>Colonnes Systèmes</title>
   
   <para>
     Chaque table a plusieurs <firstterm>colonnes systèmes</> qui sont 
     implicitement définis par le système. De ce fait, ces noms ne peuvent
     être utilisés comme noms de colonnes définis par l'utilisateur. (Notez
     que ces restrictions sont différentes si le nom est un mot-clé ou
     pas&nbsp;; citez un nom ne vous permettra pas d'échapper à ces
     restrictions.) Vous n'avez pas vraiment besoin de vous préoccuper de
     ces colonnes, simplement savoir qu'elles existent.
   </para>
 
 <indexterm>
   <primary>colonne</primary>
   <secondary>colonne système</secondary>
 </indexterm>
 
 <variablelist>
   <varlistentry>
     <term><structfield>oid</></term>
     <listitem>
       <para>
        <indexterm>
         <primary>OID</primary>
         <secondary>colonne</secondary>
        </indexterm>
	L'identifiant objet (<foreignphrase>object ID</>) d'une rangée. Cette
	colonne est seulement présente si la table a été créée en utilisant
	<literal>WITH OIDS</literal> ou si la variable de configuration <xref
	linkend="guc-default-with-oids"> était configurée. Cette colonne est de
        type oid (même nom que la colonne)&nbsp;; voir la <xref
        linkend="datatype-oid"> pour plus d'informations sur ce type.
       </para>
     </listitem>
   </varlistentry>
   
   <varlistentry>
     <term><structfield>tableoid</></term>
   <listitem>
     <indexterm>
       <primary>tableoid</primary>
     </indexterm>
     
     <para>
        L' OID de la table contenant cette rangée. Cette colonne est
        particulièrement utile pour les requêtes qui sélectionnent de
        hiérarchies héritées, puisque sans elle, il est difficile de dire de
        quelle table vient une rangée. <structfield>tableoid</structfield>
        peut être joint à la colonne <structfield>oid</structfield> de
        <structname>pg_class</structname> pour obtenir le nom de la table.
     </para>
   </listitem>
 </varlistentry>
 
 <varlistentry>
   <term><structfield>xmin</></term>
 <listitem>
   <indexterm>
     <primary>xmin</primary>
   </indexterm>
   
   <para>
      L'identité (transaction ID) de la transaction d'insertion de cette 
      version de la rangée. (Une version de rangée est un état individuel
      d'une rangée; chaque mise à jour d'une rangée crée une nouvelle
      version de rangée pour la même rangée logique.)
   </para>
 </listitem>
</varlistentry>

<varlistentry>
  <term><structfield>cmin</></term>
<listitem>
  <indexterm>
    <primary>cmin</primary>
  </indexterm>
  
  <para>
     L'identifiant de commande (à partir de zéro) au sein de la transaction
     d'insertion.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>xmax</></term>
<listitem>
  <indexterm>
    <primary>xmax</primary>
  </indexterm>
  
  <para>
     L'identité (transaction ID) de la transaction de suppression, ou zéro 
     pour une version de rangée non effacée. Il est possible pour cette
     colonne d'être non NULL dans une version de rangée visible: Ceci
     indique normalement que la transaction de suppression n'a pas été
     effectuée, ou qu'une tentative de suppression a été annulée.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>cmax</></term>
<listitem>
  <indexterm>
    <primary>cmax</primary>
  </indexterm>
  
  <para>
     L'identifiant de commande au sein d'une transaction de suppression, ou
     zéro.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>ctid</></term>
<listitem>
  <indexterm>
    <primary>ctid</primary>
  </indexterm>
  
  <para>
     La localisation physique de la version de rangée au sein de sa table.
     Notez que bien que le <structfield>ctid</structfield> peut être utilisé
     pour trouver la version de rangée très rapidement, le
     <structfield>ctid</structfield>  d'une rangée changera chaque fois
     qu'il est mis à jour ou déplacé par <structfield>ctid</structfield>
     changera à chaque lancement de la commande <command>VACUUM FULL</>. 
     Donc, <structfield>ctid</structfield> est inutile en tant
     qu'identifiant de rangée à long terme. L'OID, ou encore mieux un numéro
     de série définie par l'utilisateur, devrait être utilisé pour
     identifier des rangées logiques.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>
   Les OID sont des nombres de 32 bits et sont attribués d'un seul
   compteur. Dans une base de données grande ou vieille, il est possible que
   le compteur boucle sur lui-même. Donc il est peu pertinent de partir du
   principe que les OID sont uniques, sauf si vous prenez les précautions
   nécessaires. Si vous avez besoin d'identifier les lignes dans une table,
   l'utilisation d'un générateur de séquence est fortement recommandée.
   Néanmoins, les OID peuvent aussi être utilisés à condition que quelques
   précautions soient prises&nbsp;:
  
  <itemizedlist>
    <listitem>
      <para>
        Une contrainte unique devrait être créée sur la colonne OID de chaque
	table pour laquelle l'OID sera utilisée pour identifier les lignes.
	Quand une telle contrainte unique (ou un index unique) existe, le système
	fait attention à ne pas générer un OID correspondant à celui d'une ligne
	déjà existante. (Bien sûr, ceci est seulement possible si la table contient
	moins de 2<superscript>32</> (4 milliards) lignes et, en pratique, la
	taille de la table a tout intérêt à être bien plus petite que ça, sinon les
	performances pourraient en souffrir.)
      </para>
    </listitem>
    <listitem>
      <para>
        Les OID ne devraient jamais être supposés uniques entre tables&nbsp;;
        utilisez la combinaison de <structfield>tableoid</> et de l'OID de la
        ligne si vous avez besoin d'un identifiant sur la base complète.
      </para>
    </listitem>
    <listitem>
      <para>
      Les tables en question devraient être créées en utilisant <literal>WITH
      OIDS</literal>. À partir de <productname>PostgreSQL</productname> 8.1,
      <literal>WITHOUT OIDS</> est l'option par défaut.
      </para>
    </listitem>
  </itemizedlist>
</para>

  <para>
    Les identifiants de transaction sont aussi des nombres de 32 bits. Dans 
    une base de données de longue vie, il est possible pour les ID de
    transaction de boucler sur eux-mêmes. Ceci n'est pas un problème fatal
    avec des procédures de maintenance appropriées; voir le <xref
    linkend="maintenance"> pour les détails. Il est, par contre, imprudent
    de dépendre de l'aspect unique des ID de transaction à long terme (plus
    d'un milliard de transactions).
  </para>
  
  <para>
     Les identifiants de commande sont aussi des nombres de 32 bits. Ceci
     crée une limite dure de 2<superscript>32</> (4 milliards) commandes
     <acronym>SQL</acronym> au sein d'une seule transaction. En pratique,
     cette limite n'est pas un problème &mdash; notez que la limite est sur
     le nombre de commandes <acronym>SQL</acronym>, pas le nombre de rangées
     traitées.
  </para>
</sect1>

 <sect1 id="ddl-inherit">
  <title>Héritage</title>

  <remark>Cette section doit être repensée. Une partie de cette
  information doit aller dans les chapitres suivants.</remark>

  <para>
   Créons deux tables. La table capitales contient les capitales
   d'état qui sont aussi des villes. Naturellement, la table
   capitales doit hériter de villes.

<programlisting>
CREATE TABLE villes (
    nom             text,
    population      float,
    altitude        int     -- (in ft)
);

CREATE TABLE capitales (
    etat           char(2)
) INHERITS (villes);
</programlisting>

   Dans ce cas, une rangée de capitales <firstterm>hérite</firstterm> de tous
   les attributs  (nom,  population, et altitude) de son parent
   villes. Les capitales d'état ont un attribut supplémentaire state qui
   donne leur état. Dans <productname>PostgreSQL</productname>,
   une table peut hériter de zéro tables ou plus et une requête peut référencer
   toutes les rangées d'une table ou toutes les rangées d'une table plus celles de
   ses descendants.

   <note>
    <para>
     La hiérarchie d'héritage est en fait un graphe acyclique dirigé.
    </para>
   </note>
  </para>

  <para>
    Par exemple, la requête suivante cherche les noms de toutes les villes,
    y compris les capitales d'état, qui se situent à une altitude de plus
    de 500 pieds:

<programlisting>
SELECT nom, altitude
    FROM villes
    WHERE altitude &gt; 500;
</programlisting>

   qui retourne:

<programlisting>
   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
</programlisting>
  </para>

  <para>
    D'un autre côté, la requête suivante cherche toutes
    les villes qui ne sont pas des capitales d'état et
    qui sont situés à une altitude de plus de 500 pieds:

<programlisting>
SELECT nom, altitude
    FROM ONLY villes
    WHERE altitude &gt; 500;

   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
</programlisting>         
  </para>

  <para>
   Ici, le <quote>ONLY</quote> avant villes indique que la requête ne devrait
   être lancée que sur villes et non les tables en dessous de villes dans la
   hiérarchie d'héritage.  Beaucoup des commandes donc nous avons déjà discuté
   -- <command>SELECT</command>, <command>UPDATE</command> et <command>DELETE</command> --
   gèrent cette syntaxe <quote>ONLY</quote>.
  </para>

  <note>
    <title>Héritages et droits</title>
    <para>
     Comme les droits ne sont pas hérités automatiquement, un utilisateur
     tentant d'accéder à une table parent doit soit avoir au moins les mêmes
     droits que sur la table fille soit avoir utiliser la notation
     <quote>ONLY</quote>. Si vous devez créé une nouvelle relation d'héritage
     dans un système existant, faites bien attention à ce que cela ne vous pose
     pas de problème.
    </para>
  </note>

  <note>
    <title>Obsolète</title> 
    <para>
     Dans les précédentes versions de <productname>PostgreSQL</productname>,
     le comportement par défaut était de ne pas inclure les tables enfants
     dans les requêtes. Il a été prouvé que cela amenait facilement des
     erreurs et est aussi en violation du standard SQL:2003. Avec l'ancienne
     syntaxe, pour obtenir les sous-tables, vous ajoutez
      <literal>*</literal> au nom de la table. Par exemple
      <programlisting>
        SELECT * from villes*;
      </programlisting>
      Vous pouvez toujours spécifié explicitement le parcours des tables
      enfants en ajoutant <literal>*</literal>, ainsi qu'en spécifiant
      explicitement les tables enfants en écrivant <quote>ONLY</quote>. Mais,
      depuis la version 7.1, le comportement par défaut pour un nom de table
      non décoré est de parcourir aussi ses tables enfants alors qu'avant ce
      n'était pas le comportement par défaut. Pour obtenir l'ancien
      comportement par défaut, initialisez l'option de configuration
      <literal>SQL_Inheritance</literal> à off, ainsi
      <programlisting>
        SET SQL_Inheritance TO OFF;
      </programlisting>
      ou ajoutez une ligne dans votre fichier
      <filename>postgresql.conf</filename>.
    </para>
  </note>

  <para>
  Dans certain cas, vous souhaiterez savoir dans quel table
  provient une rangée donnée. Il y a une colonne système appelée
  <structfield>TABLEOID</structfield> dans chaque table qui peut vous
  donner la table d'origine:

<programlisting>
SELECT c.tableoid, c.nom, c.altitude
FROM villes c
WHERE c.altitude &gt; 500;
</programlisting>

   qui renvoie :

<programlisting>
 tableoid |   name    | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845
</programlisting>

   (Si vous essayez de reproduire cet exemple, vous obtiendrez probablement des OID numériques différents.)
   En faisant une jointure avec <structname>pg_class</structname>, vous pourrez voir les noms de tables actuelles:

<programlisting>
SELECT p.relname, v.nom, v.altitude
FROM villes v, pg_class p
WHERE v.altitude &gt; 500 and v.tableoid = p.oid;
</programlisting>

   ce qui retourne:

<programlisting>
 relname   |   nom     | altitude
-----------+-----------+----------
 villes    | Las Vegas |     2174
 villes    | Mariposa  |     1953
 capitales | Madison   |      845
</programlisting>
   
  </para>

  <para>
   Une table peut très bien hériter de plusieurs tables. Dans ce cas-là,
   les colonnes de la table fille correspondent à l'union des colonnes provenant
   des tables parentes et des colonnes définies dans la table fille.
  </para>

  <para>
    Une limitation sérieuse de la fonctionnalité d'héritage est que les index
    (incluant les contraintes uniques) et les contraintes de clés étrangères
    s'appliquent seulement à des tables seules, pas à leurs héritiers. Ceci
    est vrai pour le côté de référence et le côté référencé d'une contrainte
    de clé étrangère. Du coup, dans les termes de l'exemple ci-dessus&nbsp;:

    <itemizedlist>
      <listitem>
        <para>
          Si nous déclarons <structname>villes</>.<structfield>nom</> comme
           <literal>UNIQUE</> ou comme une <literal>PRIMARY KEY</>, ceci
           n'empêchera pas la table <structname>capitales</> d'avoir des lignes
           avec des noms dupliqués dans <structname>villes</>. Et ces lignes
           dupliquées pourraient par défaut s'afficher dans les requêtes sur
           <structname>villes</>. En fait, par défaut,
           <structname>capitales</> n'aurait pas du tout de contrainte
           unique et, du coup, pourrait contenir plusieurs lignes avec le
           même nom. Vous pouvez ajouter une contrainte unique à
           <structname>capitales</> mais ceci n'empêcherait pas la duplication
           comparée à <structname>villes</>.
        </para>
      </listitem>

      <listitem>
        <para>
          De façon similaire, si nous devions spécifier que
          <structname>villes</>.<structfield>nom</> <literal>REFERENCES</>
          une autre table, cette contrainte ne serait pas automatiquement
          propager à <structname>capitales</>. Dans ce cas, vous pourriez
          contourner ceci en ajoutant manuellement la même contrainte
          <literal>REFERENCES</> à <structname>capitales</>.
        </para>
      </listitem>

      <listitem>
        <para>
          Spécifier que la colonne d'une autre table <literal>REFERENCES
          villes(nom)</> autoriserait l'autre table à contenir les noms des
          villes mais pas les noms des capitales. Il n'existe pas de bons
          contournements pour ce cas.
        </para>
      </listitem>
    </itemizedlist>

    Ces déficiences seront probablement corrigées dans une future version mais
    en attendant, un soucis considérable est nécessaire dans la décision de
    l'utilité de l'héritage pour votre problème.
  </para>
 </sect1>

 <sect1 id="ddl-alter">
  <title>Modification des tables</title>

  <indexterm zone="ddl-alter">
   <primary>table</primary>
   <secondary>modification</secondary>
  </indexterm>

  <para>
   Quand on crée une table et qu'on se rend compte qu'on a fait une erreur
   ou que les besoins de l'application ont changés, on peut alors effacer
   la table et la recréer. Mais ceci n'est pas pratique si la table contient
   déjà des données ou si la table est référencée par d'autres objets base
   de données (une contrainte de clé étrangère). Par conséquent, 
   <productname>PostgreSQL</productname> offre une série de commandes
   permettant de modifier une table existante. Notez que ceci est distinct
   au niveau du concept avec la modification des données contenues dans la
   table&nbsp;; ici, nous sommes intéressés par la modification de la
   définition ou de la structure de la table.
  </para>

  <para>
   Vous pouvez
   <itemizedlist spacing="compact">
    <listitem>
     <para>ajouter des colonnes,</para>
    </listitem>
    <listitem>
     <para>retirer des colonnes,</para>
    </listitem>
    <listitem>
     <para>ajouter des contraintes,</para>
    </listitem>
    <listitem>
     <para>retirer des contraintes,</para>
    </listitem>
    <listitem>
     <para>modifier les valeurs par défaut,</para>
    </listitem>
    <listitem>
     <para>modifier le type de données des colonnes,</para>
    </listitem>
    <listitem>
     <para>renommer des colonnes,</para>
    </listitem>
    <listitem>
     <para>renommer des tables.</para>
    </listitem>
   </itemizedlist>

   Toutes ces actions sont réalisées en utilisant la commande <xref
   linkend="sql-altertable" endterm="sql-altertable-title">.
  </para>

  <sect2>
   <title>Ajouter une colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>ajouter</secondary>
   </indexterm>

   <para>
    Pour ajouter une colonne, utilisez une commande comme ceci&nbsp;:
<programlisting>
ALTER TABLE products ADD COLUMN description text;
</programlisting>
    La nouvelle colonne est initialement remplie avec la valeur par défaut
    (NULL si vous n'avez pas spécifié de clause <literal>DEFAULT</>).
   </para>

   <para>
    Vous pouvez aussi définir des contraintes sur la colonne au même moment
    en utilisant la syntaxe habituelle:
<programlisting>
ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting>
    En fait, toutes les options applicables à la description d'une colonne
    dans <command>CREATE TABLE</> peuvent être utilisées ici. Néanmoins,
    gardez en tête que la valeur par défaut doit satisfaire les contraintes
    données. Sinon, <literal>ADD</> échouera. Autrement, vous pouvez ajouter
    les contraintes plus tard (voir ci-dessous) après avoir rempli la nouvelle
    colonne correctement.
   </para>
  </sect2>

  <sect2>
   <title>Retirer une Colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>retirer</secondary>
   </indexterm>

   <para>
    Pour retirer une colonne, utilisez une commande comme celle-ci&nbsp;:
<programlisting>
ALTER TABLE products DROP COLUMN description;
</programlisting>
    Les données de cette colonne disparaissent. Les contraintes de table
    impliquant la colonne sont aussi supprimées. Néanmoins, si la colonne est
    référencée par une contrainte de clé étrangère dans une autre table,
    <productname>PostgreSQL</productname> ne supprimera pas silencieusement
    cette contrainte. Vous pouvez autoriser la suppression de tout ce qui     
    dépend de la colonne en ajoutant <literal>CASCADE</>&nbsp;:
<programlisting>
	ALTER TABLE products DROP COLUMN description CASCADE;
</programlisting>
    Voir <xref linkend="ddl-depend"> pour une description du mécanisme général
    derrière ceci.
   </para>
  </sect2>

  <sect2>
   <title>Ajouter une Contrainte</title>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>ajouter</secondary>
   </indexterm>

   <para>
    Pour ajouter une contrainte, la syntaxe de contrainte de table est utilisée. Par exemple:
<programlisting>
ALTER TABLE products ADD CHECK (name &lt;&gt; '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
</programlisting>
    Pour ajouter une contrainte non NULL, qui ne peut pas être écrite
    sous forme d'une contrainte de table, utilisez cette syntaxe:
<programlisting>
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
</programlisting>
   </para>

   <para>
    La contrainte sera vérifiée immédiatement, donc les données de la
    table doivent remplir la contrainte avant qu'elle soit ajoutée.
   </para>
  </sect2>

  <sect2>
   <title>Retirer une Contrainte</title>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>retirer</secondary>
   </indexterm>

   <para>
    Pour retirer la contrainte, il faut connaître son nom. Si vous lui avez donné
    un nom, alors c'est facile. Sinon, le système a attribué un nom généré que vous
    devez découvrir. La commande <literal>\d <replaceable>tablename</replaceable></literal>
    de <application>psql</application> peut être utile ici; d'autres interfaces peuvent
    aussi donner le moyen d'examiner les détails de table. Alors, la commande est:
<programlisting>
ALTER TABLE products DROP CONSTRAINT some_name;
</programlisting>
    (Si vous traitez avec un nom de contrainte généré comme <literal>$2</literal>,
    n'oubliez pas qu'il faudra l'entourer de guillemets double pour en faire
    un identifiant valable.)
   </para>

   <para>
	Comme avec la suppression d'une colonne, vous avez besoin d'ajouter
	<literal>CASCADE</> si vous voulez supprimer une contrainte qui dépend
	d'autre chose. Un exemple concerne la contrainte de clé étrangère qui
	dépend d'une contrainte de clé unique ou primaire sur le(s) colonne(s)
    référencée(s).
   </para>

   <para>
    Ça fonctionne de la même manière pour toutes les types de contrainte
    sauf les contraintes non NULL. Pour retirer une contrainte non NULL,
    utilisez
<programlisting>
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
</programlisting>
    (Rappelez vous que les contraintes non NULL n'ont pas de noms.)
   </para>
  </sect2>

  <sect2>
   <title>Modifier la valeur par défaut d'une colonne</title>

   <indexterm>
    <primary>valeur par défaut</primary>
    <secondary>modifier</secondary>
   </indexterm>

   <para>
    Pour mettre une nouvelle valeur par défaut sur une colonne, utilisez une commande comme celle-ci:
<programlisting>
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
</programlisting>
    Notez que ceci n'affecte pas les lignes existantes dans la table, cela ne
    modifie que la valeur par défaut pour les futures commandes
    <command>INSERT</>.
   </para>

   <para>
    Pour retirer toute valeur par défaut, utilisez
<programlisting>
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
</programlisting>
    Ceci est équivalent à mettre la valeur par défaut à NULL. En conséquence,
    ce n'est pas une erreur de
    retirer une valeur par défaut qui n'a pas été définie car la valeur NULL
    est la valeur par défaut implicite.
   </para>
  </sect2>

  <sect2>
   <title>Modifier le type de données d'une colonne</title>
    
   <indexterm>
    <primary>type de données d'une colonne</primary>
    <secondary>modification</secondary>
   </indexterm>
    
   <para>
    Pour convertir une colonne en un autre type de données, utilisez une
    commande comme ceci&nbsp;:
    <programlisting>
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
    </programlisting>
    Elle ne réussira seulement si chaque entrée dans la colonne peut être
    convertie dans le nouveau type par une conversion implicite. Si une
    conversion plus complexe est nécessaire, vous pouvez ajouter une clause
    <literal>USING</> qui spécifie comment calculer les nouveaux valeurs à
    partir des anciennes.
   </para>
  
   <para>
    <productname>PostgreSQL</> tentera de convertir la valeur par défaut de la
    colonne, si elle en a une. Mais ces conversions pourraient échouer ou
    pourraient produire des résultats surprenants. Il est souvent mieux de
    supprimer les contraintes sur une colonne avant de modifier son type, puis
    d'ajouter les contraintes modifiées convenablement.
   </para>
  </sect2>

  <sect2>
   <title>Renommer une Colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>renommer</secondary>
   </indexterm>

   <para>
    Pour renommer une colonne:
<programlisting>
ALTER TABLE products RENAME COLUMN product_no TO product_number;
</programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Renommer une Table</title>

   <indexterm>
    <primary>table</primary>
    <secondary>renommer</secondary>
   </indexterm>

   <para>
    Pour renommer une table:
<programlisting>
ALTER TABLE products RENAME TO items;
</programlisting>
   </para>
  </sect2>
 </sect1>
 
 <sect1 id="ddl-priv">
  <title>Privilèges</title>

  <indexterm zone="ddl-priv">
   <primary>privilège</primary>
  </indexterm>

  <indexterm>
   <primary>permission</primary>
   <see>privilège</see>
  </indexterm>

  <para>
   Quand vous créez un objet base de données, vous en devenez le
   propriétaire. Avec les paramètres par défaut, seul le propriétaire
   d'un objet peut faire quelque chose avec. Pour que d'autres utilisateurs
   puissent s'en servir, des <firstterm>privilèges</firstterm> doivent être
   accordés. (Néanmoins, les utilisateurs qui sont superutilisateurs ont
   toujours accès à n'importe quel objet.)
  </para>

  <para>
   Il y a plusieurs privilèges différents : <literal>SELECT</literal>,
   <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   <literal>RULE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>,
   <literal>CREATE</literal>, <literal>TEMPORARY</literal>, <literal>EXECUTE</literal>,
   et <literal>USAGE</>. Les droits applicables à un objet particulier varient
   suivant le type d'objet (table, fonction, etc.) Pour une
   information complète sur les différents types de privilèges gérés par
   <productname>PostgreSQL</productname>, lisez la page de référence
   <xref linkend="sql-grant" endterm="sql-grant-title">.  La section et
   les chapitres suivants vous montreront aussi comment ces privilèges
   sont utilisés.
  </para>

  <para>
   Le droit de modifier ou de détruire est le privilège du propriétaire seul.
  </para>

  <note>
    <para>
      Pour modifier le propriétaire d'une table, d'un index, d'une séquence ou
      d'une vue, utilisez la commande <xref linkend="sql-altertable"
      endterm="sql-altertable-title">. Il
      existe des commandes <literal>ALTER</> correspondant aux autres types 
      d'objets.
    </para>
  </note>
  
  <para>
   Pour accorder des privilèges, la commande <command>GRANT</command> est
   utilisé. Par exemple, si <literal>joe</literal> est un utilisateur
   existant et <literal>accounts</literal> une table existante, le
   privilège de mettre la table à jour peut être accordé avec
<programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
   Pour accorder un privilège à un groupe, utilisez
<programlisting>
GRANT SELECT ON accounts TO GROUP staff;
</programlisting>
   Le nom d'<quote>utilisateur</quote> spéciale <literal>PUBLIC</literal> peut
   être utilisé pour accorder un privilège à tout les utilisateurs du système.
   Écrire <literal>ALL</literal> au lieu d'un privilège spécifique accorde tous
   les privilèges adéquats pour ce type d'objet.
  </para>

  <para>
   Pour révoquer un privilège, utilisez la commande approprié ci dessous;
   <command>REVOKE</command> :
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
   Les privilèges spéciaux du propriétaire de l'objet (c'est-à-dire, le droit de faire des
   <command>DROP</command>, <command>GRANT</command>, <command>REVOKE</command>, etc.)
   sont toujours implicitement ceux du propriétaire et ne peuvent être ni
   accordés ni révoqués. Mais le propriétaire de l'objet peut choisir
   de révoquer ses propres privilèges ordinaires pour, par exemple, mettre
   une table en lecture seule pour soi-même en plus que pour les autres.
  </para>
  
  <para>
   Habituellement, seul le propriétaire de l'objet (ou un superutilisateur)
   peut donner ou révoquer les droits sur un objet. Néanmoins, il est possible
   de donner un droit <quote>avec une option de don de droits</>, qui donne
   à celui qui le reçoit de le donner à d'autres. Si cette option est ensuite
   révoquée, alors tous ceux qui ont reçu le droit de cet utilisateur
   (directement ou indirectement via la chaîne des dons)  perdront leur
   droit. Pour des détails, voir les pages de références <xref
   linkend="sql-grant" endterm="sql-grant-title"> et <xref linkend="sql-revoke"
   endterm="sql-revoke-title">.
  </para>
 </sect1>

 <sect1 id="ddl-schemas">
  <title>Schémas</title>

  <indexterm zone="ddl-schemas">
   <primary>schéma</primary>
  </indexterm>

  <para>
   Un cluster de bases de données <productname>PostgreSQL</productname>
   contient une ou plusieurs bases nommées. Les utilisateurs et groupes
   d'utilisateurs sont partagés sur le cluster tout entier mais aucune
   autres données n'est partagées parmi les bases. Une connexion cliente
   donnée sur le serveur peut accéder aux données d'une seule base, celle
   spécifiée dans la connexion de requête.
  </para>

  <note>
   <para>
    Les utilisateurs d'un cluster n'ont pas forcément le privilège d'accéder
    toutes les bases du cluster. Le partage des noms d'utilisateur veut dire
    qu'il ne peut pas y avoir plusieurs utilisateurs nommés <literal>joe</literal>,
    par exemple, dans deux bases du même cluster; mais le système peut être
    configuré pour autoriser <literal>joe</literal> à accéder qu'à certaines bases.
   </para>
  </note>

  <para>
   Une base de données contient un ou plusieurs <firstterm>schémas</firstterm> nommés,
   qui, eux, contiennent des tables. Les schémas contiennent aussi d'autres
   types d'objets nommés, y compris des types de données, fonctions et opérateurs.
   Seul le nom d'objet peut être utilisé sans conflit; par exemple,
   <literal>schema1</literal> et <literal>mon_schema</literal> peuvent tout les deux contenir
   des tables nommées <literal>ma_table</literal>. Contrairement aux bases de données;
   les schémas ne sont pas séparés de manière rigide: un utilisateur
   peut accéder aux objets de n'importe lequel des schémas de la base
   de données auxquels il se connecte s'il a les privilèges pour le faire.
  </para>

  <para>
   Il y a plusieurs raisons pour lesquelles quelqu'un voudrait utiliser les schémas:

   <itemizedlist>
    <listitem>
     <para>
      Pour autoriser beaucoup d'utilisateurs d'utiliser une base de données sans se gêner
      les uns les autres.
     </para>
    </listitem>

    <listitem>
     <para>
      Pour organiser des objets de bases de données en groupes logiques afin de faciliter
      leur gestion.
     </para>
    </listitem>

    <listitem>
     <para>
      Les applications tierces peuvent être mises dans des schémas séparés pour qu'il n'y
      ait pas de collision avec les noms d'autres objets.
     </para>
    </listitem>
   </itemizedlist>

   Les schémas sont comparables aux répertoires au niveau du système d'exploitation.
   sauf que les schémas ne peuvent pas être imbriqués.
  </para>

  <sect2 id="ddl-schemas-create">
   <title>Créer un Schéma</title>

   <indexterm zone="ddl-schemas-create">
    <primary>schéma</primary>
    <secondary>créer</secondary>
   </indexterm>

   <para>
    Pour créer un schéma, utilisez la commande <literal>CREATE
    SCHEMA</literal>.  Donnez au schéma un nom de votre choix. Par
    exemple:
<programlisting>
CREATE SCHEMA mon_schema;
</programlisting>
   </para>

   <indexterm>
    <primary>nom qualifié</primary>
   </indexterm>

   <indexterm>
    <primary>nom</primary>
    <secondary>qualifié</secondary>
   </indexterm>

   <para>
    Pour créer ou accéder aux objets dans un schéma, écrivez un
    <firstterm>nom qualifié</firstterm> qui consiste en le nom du schéma et
    le nom de la table séparés par un point:
<synopsis>
<replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    Ceci fonctionne partout où un nom de table est attendu, ceci incluant les
    commandes de modification de la table et les commandes d'accès aux données
    discutées dans les chapitres suivants. (En bref, nous parlerons uniquement
    des tables mais les mêmes idées s'appliquent aux autres genres d'objets
    nommés, comme les types et les fonctions.)
   </para>
   
   <para>
    En fait, la syntaxe encore plus générale
<synopsis>
<replaceable>database</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    peut être utilisé aussi mais, pour le moment, ceci n'existe que pour
    être conforme au standard SQL. Si vous écrivez un nom de base de
    données, il devrait être celui de la base auquel vous êtes connecté.
   </para>

   <para>
    Donc, pour créer une table dans le nouveau schéma, utilisez
<programlisting>
CREATE TABLE mon_schema.ma_table (
 ...
);
</programlisting>
   </para>

   <indexterm>
    <primary>schéma</primary>
    <secondary>suppression</secondary>
   </indexterm>

   <para>
    Pour effacer un schéma vide (tout les objets a l'intérieur ont été
    effacés), utilisez
<programlisting>
DROP SCHEMA mon_schema;
</programlisting>
    Pour effacer un schéma, y compris les objets qu'il contient, utilisez
<programlisting>
DROP SCHEMA mon_schema CASCADE;
</programlisting>
    Lisez <xref linkend="ddl-depend"> pour une description du mécanisme
    général derrière tout ceci.
   </para>

   <para>
    Cependant, vous voudriez modifier le schéma utilisé par quelqu'un
    d'autre (puisque c'est l'une des méthodes par lesquelles on peut
    restreindre l'activité de vos utilisateurs à des espaces de nom
    définis). La syntaxe pour ceci est:
<programlisting>
CREATE SCHEMA <replaceable>nom_schema</replaceable> AUTHORIZATION <replaceable>nom_utilisateur</replaceable>;
</programlisting>
    Vous pouvez même omettre le nom du schéma auquel cas, le nom du schéma
    sera le même que le nom d'utilisateur. Voir <xref linkend="ddl-schemas-patterns">
    pour voir comment cela peut être utile.
   </para>

   <para>
    Les noms de schéma commençant par <literal>pg_</literal> sont réservés pour les
    besoins du système et ne peuvent pas être crées par les utilisateurs.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-public">
   <title>Le Schéma Public</title>

   <indexterm zone="ddl-schemas-public">
    <primary>schéma</primary>
    <secondary>public</secondary>
   </indexterm>

   <para>
    Dans les sections précédentes, on créait des tables sans spécifier un
    nom de schéma. Par défaut, ces tables (et autres objets) sont
    automatiquement mis dans un schéma nommé <quote>public</quote>. Toute
    nouvelle base de données contient un tel schéma. Donc, ces instructions
    sont équivalents:
<programlisting>
CREATE TABLE products ( ... );
</programlisting>
    and
<programlisting>
CREATE TABLE public.products ( ... );
</programlisting>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-path">
   <title>Le Chemin de Recherche de Schéma</title>

   <indexterm>
    <primary>chemin de recherche</primary>
   </indexterm>

   <indexterm>
    <primary>nom non qualifié</primary>
   </indexterm>

   <indexterm>
    <primary>nom</primary>
    <secondary>non qualifié</secondary>
   </indexterm>

   <para>
    Les noms qualifiés sont pénibles à écrire et il est, de toutes façons, préférable
    de ne pas coder un nom de schéma dans une application. Donc, les tables
    sont souvent appelées par des noms non <firstterm>qualifiés</firstterm> qui s'apparente
    souvent au nom de la table lui même. Le système détermine quel table est appelée
    en suivant un <firstterm>chemin de recherche</firstterm> qui est une liste de schémas
    a regarder. La première table correspondante est considérée comme la table
    voulue. S'il n'y a pas de correspondance, une erreur est soulevée, même si
    des noms de table correspondants existent dans d'autres schémas dans la base.
   </para>

   <indexterm>
    <primary>schéma</primary>
    <secondary>courant</secondary>
   </indexterm>

   <para>
    Le premier schéma dans le chemin de recherche est appelé le schéma courant.
    En plus d'être le premier schéma parcouru, il est aussi le schéma dans lequel
    de nouvelles tables seront créées si la commande <command>CREATE TABLE</command>
    ne précise pas de nom de schéma.
   </para>

   <indexterm>
    <primary>search_path</primary>
   </indexterm>

   <para>
    Pour voir le chemin de recherche courant, utilisez la commande suivante:
<programlisting>
SHOW search_path;
</programlisting>
    Dans la configuration par défaut, ceci renvoie:
<screen>
 search_path
--------------
 $user,public
</screen>
    Le premier élément précise qu'un schéma avec le même nom que l'utilisateur
    en cours doit être parcouru. Le deuxième élément renvoie au schéma public
    que nous avons déjà vu.
   </para>

   <para>
    Le premier schéma existant dans le chemin de recherche est l'endroit
    par défaut pour la création de nouveaux objets. Ceci est la raison
    pour laquelle les objets sont créés dans le schéma public. Quand les
    objets sont liés dans tout autre contexte sans une qualification de
    schéma (modification de table, modification de données ou requête de
    commande), le chemin de recherche est traversé jusqu'à ce qu'un objet
    correspondant soit trouvé. Donc, dans la configuration par défaut,
    tout accès non qualifié ne peut que se référer au schéma public.
   </para>

   <para>
    Pour mettre notre nouveau schéma dans le chemin, nous utilisons
<programlisting>
SET search_path TO mon_schema,public;
</programlisting>
    (Nous ne mettons pas le <literal>$user</literal> ici car nous n'en avons
    pas besoin pour l'instant.) Et nous pouvons pas accéder à la table sans
    qualification de schéma:
<programlisting>
DROP TABLE ma_table;
</programlisting>
    Aussi, puisque <literal>mon_schema</literal> est le premier élément dans
    le chemin, les nouveaux objets seront crées à l'intérieur.
   </para>

   <para>
    On pourrait aussi écrire
<programlisting>
SET search_path TO mon_schema;
</programlisting>
    Alors nous n'avons pas accès au schéma public sans qualification explicite.
    Il n'y a rien de spécial à propos du schéma public hormis le fait qu'il
    existe par défaut. Il peut aussi être effacé.
   </para>

   <para>
    Voir aussi <xref linkend="functions-info"> qui détaille les autres façons
    de manipuler le chemin de recherche de schéma.
   </para>

   <para>
    Le chemin de recherche fonctionne de la même façon pour les noms de type de données,
    noms de fonction, et noms d'opérateur que pour le noms de tables. Les types de données
    et de fonction peuvent être qualifiés de la même façon que les noms de table.
    Si vous avez besoin d'écrire un nom d'opérateur qualifié dans une expression, il
    y'a une condition spéciale: vous devez écrire
<synopsis>
<literal>OPERATOR(</literal><replaceable>schéma</replaceable><literal>.</literal><replaceable>opérateur</replaceable><literal>)</literal>
</synopsis>
    Ceci est nécessaire afin d'éviter une ambiguïté syntaxique. Un exemple est
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    En pratique, on dépend souvent du chemin de recherche pour les opérateurs,
    afin de ne pas avoir à écrire quelque chose d'aussi peu présentable.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-priv">
   <title>Schémas et Privilèges</title>

   <indexterm zone="ddl-schemas-priv">
    <primary>privilège</primary>
    <secondary sortas="schemas">pour les schémas</secondary>
   </indexterm>

   <para>
    Par défaut, les utilisateurs ne peuvent pas accéder aux objets dans
    les schémas qui ne leurs appartiennent pas. Pour autoriser cela, le
    propriétaire du schéma doit donner le privilège 
    <literal>USAGE</literal> sur le schéma.  Pour autoriser les
    utilisateurs à manipuler les objets d'un schéma, des privilèges
    supplémentaires devront peut-être être accordés, suivant l'objet.
   </para>

   <para>
    Un utilisateur peut aussi être autorisé à créer des objets dans le
    schéma de quelqu'un d'autre. Pour permettre ceci, le privilège
    <literal>CREATE</literal> doit être accordé. Notez que, par défaut,
    tout le monde à les privilèges <literal>CREATE</literal> et
    <literal>USAGE</literal> sur le schéma <literal>public</literal>.
    Ceci permet à tout les utilisateurs qui sont capables de se connecter
    à une base de données de créer des objets dans son schéma
    <literal>public</literal>. Si vous ne souhaitez pas ce comportement,
    vous pouvez révoquer ce privilège:
<programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
    (Le premier <quote>public</quote> est le schéma, le second
    <quote>public</quote> veut dire <quote>chaque utilisateur</quote>. Dans le
    premier cas, c'est un identifiant. Dans le second, c'est un mot clé,
    d'où la casse différente. Souvenez-vous des règles de 
    <xref linkend="sql-syntax-identifiers">.)
   </para>
  </sect2>

  <sect2 id="ddl-schemas-catalog">
   <title>Le Catalogue de Système de Schéma</title>

   <indexterm zone="ddl-schemas-catalog">
    <primary>système de catalog</primary>
    <secondary>schema</secondary>
   </indexterm>

   <para>
    En plus des schémas <literal>publics</literal> crées par les utilisateurs, chaque
    base de données contient un schéma <literal>pg_catalog</literal>, qui contient
    les tables systèmes et tous les types de données, fonctions et opérateurs
    intégrés. <literal>pg_catalog</literal> fait toujours, de fait, partie du chemin
    de recherche. S'il n'est pas nommé explicitement dans le chemin, il est
    parcouru implicitement <emphasis>avant</emphasis> la recherche dans les schémas
    du chemin. Ceci garantit qui les noms internes seront toujours trouvables .
    Par contre, vous pouvez explicitement placer <literal>pg_catalog</literal> à la
    fin si vous préférez que les noms définis par les utilisateurs surchargent
    les noms internes.
   </para>

   <para>
    Dans les versions de <productname>PostgreSQL</productname> avant 7.3,
    les noms de table commençant par <literal>pg_</literal> sont réservés. Ceci
    n'est plus vrai: vous pouvez créer une telle table si vous le voulez
    dans n'importe quel schéma non système. Par contre, il vaut mieux
    continuer d'éviter de tels noms pour garantir que vous n'aurez pas
    de conflit si une prochaine version définit une table système qui
    porte le même nom que votre table. (Avec le chemin de recherche par
    défaut, une référence non qualifiée à votre table pointera au lieu
    vers la table système.)
    Les tables systèmes continueront de suivre la convention de porter
    des noms commençant par <literal>pg_</literal> pour qu'ils n'aient pas de
    conflit avec des noms de table non qualifiés tant que les utilisateurs
    éviteront le préfixe <literal>pg_</literal>.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-patterns">
   <title>Méthodes d'utilisation</title>

   <para>
    Les schémas peuvent être utilisés pour organiser vos données
    de plusieurs manières. Il y en a plusieurs qui sont recommandés
    et sont facilement supportés par la configuration par défaut:
    <itemizedlist>
     <listitem>
      <para>
       Si vous ne créez aucun schéma, alors tout les utilisateurs
       auront accès au schéma public implicitement. Ceci simule la
       situation dans laquelle les schémas ne sont pas disponibles.
       Cette situation est recommandé lorsque il n'y a qu'un seul
       utilisateur ou quelques utilisateurs coopérants dans une base
       de données. Cette configuration permet aussi une transition
       en douceur d'une situation ou on ne connaît pas le schéma.
      </para>
     </listitem>

     <listitem>
      <para>
       Vous pouvez créer un schéma pour chaque utilisateur avec un
       nom identique à celui de l'utilisateur. Souvenez vous que le
       chemin de recherche par défaut commence par
       <literal>$user</literal> qui correspond au nom d'utilisateur.
       Donc si chaque utilisateur a un schéma distinct, ils accèdent
       à leurs propres schémas par défaut.
      </para>

      <para>
       Si vous utilisez cette configuration alors vous devriez peut-être
       aussi révoquer l'accès au schéma public (ou l'effacer complètement)
       pour que les utilisateurs soient réellement limités à leur propre
       schéma.
      </para>
     </listitem>

     <listitem>
      <para>
       Pour installer des applications partagées (tables utilisables
       par tout le monde, fonctionnalités supplémentaires fournies par
       des applications tiers, etc), insérez les dans des schéma séparés.
       Rappelez vous que vous devez donner les permissions appropriées
       pour permettre aux utilisateurs d'y accéder. Les utilisateurs
       peuvent alors se référer à ces objets additionnels en qualifiant
       les noms avec un nom de schéma ou ils peuvent mettre les schémas
       supplémentaires dans leur chemin de recherche, s'ils le souhaitent.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-portability">
   <title>Portabilité</title>

   <para>
    Dans le standard SQL, la notion d'objets dans le même schéma
    appartenant à des utilisateurs différents n'existe pas. De plus,
    certaines implémentations ne vous permettent pas de créer des
    schémas qui ont un nom différent de celui de leur propriétaire.
    En fait, les concepts de schéma et d'utilisateur sont presque
    équivalents dans un système de base de données qui n'implémente
    que le support basique des schémas spécifiés dans le standard.
    A partir de ce constat, beaucoup d'utilisateurs considèrent les noms
    qualifiés qui correspondre réellement à
    <literal><replaceable>utilisateur</replaceable>.<replaceable>table</replaceable></literal>.
    C'est comme cela que <productname>PostgreSQL</productname> se comporte
    si vous créez un schéma par utilisateur pour chaque utilisateur.
   </para>

   <para>
    De plus, il n'y a aucun concept d'un schéma <literal>public</literal> dans le
    standard SQL. Pour plus de conformité au standard, vous ne devriez pas
    utilisez (et sans doute effacer) le schéma <literal>public</literal>.
   </para>

   <para>
    Bien sur, certains systèmes de bases de données n'implémentent pas du
    tout les schémas. ou donnent le support d'espace de nommage en
    autorisant (peut-être de façon limité) des accès sur plusieurs bases
    de données alors la portabilité maximale sera obtenue en n'utilisant
    pas du tout les schémas.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-others">
  <title>D'autres Objets Base de Données</title>

  <para>
   Les tables sont les objets centraux dans une structure de base de
   données relationnelles. Mais ce ne sont pas les seuls objets qui
   existent dans une base de données. Plusieurs autres types d'objets
   peuvent être crées afin de pour rendre l'utilisation et la gestion
   des données plus efficace ou pratique. Ils ne seront pas abordés
   dans ce chapitre mais nous vous en faisons une liste ici pour que
   vous soyez informés de ce qui est possible.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Vues
    </para>
   </listitem>

   <listitem>
    <para>
     Fonctions et opérateurs
    </para>
   </listitem>

   <listitem>
    <para>
     Types de données et domaines
    </para>
   </listitem>

   <listitem>
    <para>
     Triggers et règles de réécriture
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Des informations détaillées sur
   ces sujets apparaissent dans <xref linkend="server-programming">.
  </para>
 </sect1>

 <sect1 id="ddl-depend">
  <title>Gestion des Dépendances</title>

  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <para>
   Lorsque vous créez des structures de base complexes impliquant
   beaucoup de tables avec des contraintes de clés étrangères, des
   vues, des triggers, des fonctions, etc, vous créez implicitement
   un filet de dépendances entre les objets.
   Par exemple, une table avec une contrainte de clé étrangère dépend
   de la base à laquelle elle fait référence.
  </para>

  <para>
   Pour garantir l'intégrité de la structure entière de la base,
   <productname>PostgreSQL</productname> vérifie que vous ne pouvez
   pas effacer des objets dont d'autres objets dont dépendants. Par
   exemple, la tentative d'effacer la table des produits que nous
   avons utilisé dans <xref linkend="ddl-constraints-fk">, avec la
   tables des commandes qui en dépend, donnera un message d'erreur
   comme celui-ci:
<screen>
DROP TABLE products;

NOTICE:  constraint orders_product_no_fkey on table orders depends on table products
ERROR:  cannot drop table products because other objects depend on it
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</screen>
   Le message d'erreur contient un indice utile: Si vous ne souhaitez
   pas effacer les objets dépendants individuellement, vous pouvez
   lancer
<screen>
DROP TABLE products CASCADE;
</screen>
   et tout les objets seront effacés. Dans ce cas, cela n'effacera pas
   la table des commandes mais seulement la contrainte de clé étrangère.
   (Si vous voulez vérifier ce que <literal>DROP ... CASCADE</literal> fera,
   lancez <command>DROP</command> sans <literal>CASCADE</literal> et lisez les messages
   <literal>NOTICE</literal>.)
  </para>

  <para>
   Toutes les commandes de suppression dans
   <productname>PostgreSQL</productname> supportent l'utilisation de
   <literal>CASCADE</literal>. Bien sur, la nature des dépendances
   varie avec la nature des objets. Vous pouvez aussi écrire
   <literal>RESTRICT</literal> au lieu de <literal>CASCADE</literal>
   pour obtenir le comportement par défaut qui est d'empêcher les
   suppressions d'objets sur lesquelles dépendent d'autres objets.
  </para>

  <note>
   <para>
    D'après le standard SQL, spécifier l'un de
    <literal>RESTRICT</literal> ou <literal>CASCADE</literal> est
    requis. Aucun système de base de donnée ne force cette règle de cette
    manière actuellement mais le choix du comportement par défaut,
    <literal>RESTRICT</literal> ou <literal>CASCADE</literal>,
    varie suivant le système.
   </para>
  </note>

  <note>
   <para>
    Les dépendances de contraintes de clés étrangères et de colonnes
    en série des versions de <productname>PostgreSQL</productname>
    antérieures à 7.3 ne seront <emphasis>pas</emphasis> maintenus ou
    crées pendant le processus de mise à jour. Tout autre type de
    dépendance sera proprement crée pendant une mise à jour à partir d'une
    base de données antérieure à la 7.3.
   </para>
  </note>
 </sect1>

</chapter>