<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/ddl.sgml,v 1.12 2005/09/15 07:03:16 guillaume Exp $ -->
<!-- SAS : 20070410, PG 8.2.3 -->

<chapter id="ddl">
 <title>Définition des données</title>

 <para>
  Ce chapitre couvre la création des structures de données amenées à contenir
  les données. Dans une base relationnelle, les données brutes
  sont stockées dans des tables. De ce fait, une grande partie de ce chapitre
  est consacrée à l'explication de la création et de la modification des tables 
  et aux fonctionnalités disponibles pour contrôler les données stockées dans les tables.
  L'organisation des tables dans des schémas et l'attribution de privilèges
  sur les tables sont ensuite décrits. Pour finir, d'autres fonctionnalités,
  telles que l'héritage, les vues, les fonctions et les déclencheurs sont
  passées en revue.
 </para>

 <sect1 id="ddl-basics">
  <title>Notions fondamentales sur les tables</title>

  <indexterm zone="ddl-basics">
   <primary>table</primary>
  </indexterm>

  <indexterm>
   <primary>ligne</primary>
  </indexterm>

  <indexterm>
   <primary>colonne</primary>
  </indexterm>

  <para>
   Une table dans une base relationnelle ressemble beaucoup à un tableau
   sur papier&nbsp;: elle est constituée de lignes et de colonnes. Le nombre
   et l'ordre des colonnes sont fixes et chaque colonne a un nom. Le
   nombre de lignes est variable &mdash; il représente le nombre de données
   stockées à un instant donné.
  </para>
  <para>
   Le SQL n'apporte aucune garantie sur l'ordre des
   lignes dans une table. Quand une table est lue, les lignes
   apparaissent dans un ordre aléatoire, sauf si un tri est demandé
   explicitement. Tout cela est expliqué dans le <xref linkend="queries"/>.
  </para>
  <para>
   De plus, le SQL n'attribue pas d'identifiant unique aux lignes. Il est
   donc possible
   d'avoir plusieurs lignes identiques au sein d'une table. C'est une
   conséquence du modèle mathématique sur lequel repose le SQL, même si
   cela n'est habituellement pas souhaitable.
   Il est expliqué plus bas dans ce chapitre comment traiter ce problème.
  </para>

  <para>
   Chaque colonne a un type de donnée. Ce type de donnée limite l'ensemble
   de valeurs qu'il est possible d'attribuer à une colonne. Il attribue
   également une sémantique aux données stockées dans la colonne pour
   permettre les calculs sur celles-ci. Par exemple, une colonne déclarée dans un
   type numérique n'accepte pas les chaînes textuelles&nbsp;; les données
   stockées dans une telle colonne peuvent être utilisées dans des
   calculs mathématiques.
   Par opposition, une colonne déclarée de type chaîne de
   caractères accepte pratiquement n'importe quel type de donnée mais ne
   se prête pas aux calculs mathématiques. D'autres types d'opérations,
   telle la concaténation de chaînes, sont cependant disponibles.
  </para>

  <para>
   <productname>PostgreSQL</productname> inclut un ensemble conséquent de types
   de données intégrés pour s'adapter à diverses applications. Les
   utilisateurs peuvent aussi définir leurs propres types de données.
  </para>
  <para>
   La plupart des types de données intégrés ont des noms et des sémantiques
   évidents. C'est pourquoi leur explication détaillée est reportée au
   <xref linkend="datatype"/>.
  </para>
<!-- fractional : fraction -->
  <para>
   Parmi les types les plus utilisés, on trouve
   <type>integer</type> pour les entiers, <type>numeric</type> pour
   les éventuelles fractions, <type>text</type> pour les chaînes de
   caractères, <type>date</type> pour les dates, <type>time</type> pour
   les heures et <type>timestamp</type> pour les valeurs
   qui contiennent à la fois une date et une heure.
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>création</secondary>
  </indexterm>

<!-- identifier : identifiant ou indicateur. Voire identificateur -->
  <para>
   Pour créer une table, on utilise la commande bien nommée
   <xref linkend="sql-createtable" endterm="sql-createtable-title"/>. Dans cette
   commande, il est nécessaire d'indiquer, au minimum, le nom de la
   table, les noms des colonnes et le type de données de chacune d'elles.
   Par exemple&nbsp;:
<programlisting>CREATE TABLE ma_premiere_table (
    premiere_colonne text,
    deuxieme_colonne integer
);</programlisting>
   Cela crée une table nommée <literal>ma_premiere_table</literal> avec
   deux colonnes. La première colonne, nommée
   <literal>premiere_colonne</literal>, est de type <type>text</type>&nbsp;;
   la seconde colonne, nommée <literal>deuxieme_colonne</literal>, est de type
   <type>integer</type>.
   Les noms des table et colonnes se conforment à la syntaxe des identifiants expliquée
   dans la <xref linkend="sql-syntax-identifiers"/>. Les noms des types sont souvent
   aussi des identifiants mais il existe des exceptions. Le séparateur de la
   liste des colonnes est la virgule. La liste doit être entre parenthèses.
  </para>

<!-- capillo-tracté s'il s'agit donc de cheveux de traie ou simplifié à l'extrême -->
  <para>
   L'exemple qui précède est à l'évidence extrêmement simpliste. On donne
   habituellement aux tables et aux colonnes des noms qui indiquent les
   données stockées. L'exemple ci-dessous est un peu plus réaliste&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric
);</programlisting>
   (Le type <type>numeric</type> peut stocker des fractions 
   telles que les montants.)
  </para>

  <tip>
   <para>
    Quand de nombreuses tables liées sont créées, il est préférable de définir
    un motif cohérent pour le nommage des tables et des colonnes. On a ainsi
    la possibilité d'utiliser le pluriel ou le singulier des noms, chacune
    ayant ses fidèles et ses détracteurs.
   </para>
  </tip>

<!-- Par contre, utilisé par Céline dans un souci de provocation, n'est à
l'évidence pas une construction grammaticale préconisée par l'Académie
Française. On lui préférera "En revanche", "Cependant", "Au contraire"... -->
  <para>
   Le nombre de colonnes d'un table est limité. En fonction du type de
   colonnes, il oscille entre 250 et 1600.
   Définir une table avec un nombre de colonnes proche de cette limite est,
   cependant, très inhabituel et doit conduire à se poser des questions quant
   à la conception du modèle.
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>suppression</secondary>
  </indexterm>

  <para>
   Lorsqu'une table n'est plus utile, elle peut être supprimée à l'aide de la
   commande <xref linkend="sql-droptable" endterm="sql-droptable-title"/>. Par exemple&nbsp;:
<programlisting>DROP TABLE ma_premiere_table;
DROP TABLE produits;</programlisting>
   Tenter de supprimer une table qui n'existe pas lève une erreur.
   Il est, néanmoins, habituel dans les fichiers de scripts SQL d'essayer
   de supprimer chaque table avant de la créer. Les messages
   d'erreur sont alors ignorés afin que le script fonctionne que la table
   existe ou non. (La variante <literal>DROP TABLE IF EXISTS</literal> peut
   aussi être utilisée pour
   éviter les messages d'erreur mais elle ne fait pas partie du
   standard SQL.)
  </para>

  <para>
   Pour la procéduure de modification d'une table qui existe déjà, voir la 
   <xref linkend="ddl-alter"/> plus loin dans ce chapitre.
  </para>

  <para>
   Les outils précédemment décrits permettent de créer des tables
   fonctionnelles. Le reste de ce chapitre est consacré à l'ajout de fonctionnalités
   à la définition de tables pour garantir l'intégrité des données, la sécurité
   ou l'ergonomie.  Le lecteur impatient d'insérer des données dans ses tables
   peut sauter au <xref linkend="dml"/> et lire le reste de
   ce chapitre plus tard.
  </para>
 </sect1>

 <sect1 id="ddl-default">
  <title>Valeurs par défaut</title>

  <indexterm zone="ddl-default">
   <primary>valeur par défaut</primary>
  </indexterm>

  <para>
   Une valeur par défaut peut être attribuée à une colonne. Quand une nouvelle
   ligne est créée et qu'aucune valeur n'est indiquée pour certaines de ses
   colonnes, celles-ci sont remplies avec leurs valeurs par défaut respectives.
   Une commande de manipulation de données peut aussi demander explicitement
   que la valeur d'une colonne soit positionnée à la valeur par défaut, sans
   qu'il lui soit nécessaire de connaître cette valeur (les détails concernant les
   commandes de manipulation de données sont donnés dans le <xref linkend="dml"/>).
  </para>

  <para>
   <indexterm>
    <primary>valeur NULL</primary>
    <secondary>valeur par défaut</secondary>
   </indexterm>
   Si aucune valeur par défaut n'est déclarée explicitement, la valeur
   par défaut est la valeur NULL. Cela a un sens dans la mesure où l'on
   peut considérer que la valeur NULL représente des données inconnues.
  </para>

  <para>
   Dans la définition d'une table, les valeurs par défaut sont listées après
   le type de données de la colonne. Par exemple:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>DEFAULT 9.99</emphasis>
);</programlisting>
  </para>

  <para>
   La valeur par défaut peut être une expression, alors évaluée à l'insertion
   de cette valeur (<emphasis>pas</emphasis> à la création de la
   table). Un exemple commun est la colonne de type <type>timestamp</type>
   dont la valeur par défaut est <literal>now()</literal>. Elle se voit ainsi
   attribuée l'heure d'insertion. Un autre exemple est
   la génération d'un <quote>numéro de série</quote> pour chaque ligne.
   Dans <productname>PostgreSQL</productname>, cela s'obtient habituellement par
   quelque chose comme
<programlisting>CREATE TABLE produits (
    no_produit integer <emphasis>DEFAULT nextval('produits_no_produit_seq')</emphasis>,
    ...
);</programlisting>
   où la fonction <literal>nextval()</literal> fournit des valeurs successives à
   partir d'un <firstterm>objet séquence</firstterm> (voir la <xref
   linkend="functions-sequence"/>). Cet arrangement est suffisamment commun
   pour qu'il ait son propre raccourci&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit <emphasis>SERIAL</emphasis>,
    ...
);</programlisting>
   Le raccourci <literal>SERIAL</literal> est discuté plus tard dans la <xref
   linkend="datatype-serial"/>.
  </para>
 </sect1>

 <sect1 id="ddl-constraints">
  <title>Contraintes</title>

  <indexterm zone="ddl-constraints">
   <primary>contrainte</primary>
  </indexterm>

  <para>
   Les types de données sont un moyen de restreindre la nature des données qui
   peuvent être stockées dans une table. Pour beaucoup d'applications,
   toutefois, la contrainte fournie par ce biais est trop grossière.
   Par exemple, une colonne qui
   contient le prix d'un produit ne doit accepter que des valeurs
   positives. Mais il n'existe pas de type de données standard qui n'accepte que
   des valeurs positives. Un autre problème peut provenir de la volonté de
   contraindre les données d'une colonne par rapport aux autres colonnes ou lignes.
   Par exemple, dans une table contenant des informations de produit, il
   ne peut y avoir qu'une ligne par numéro de produit.
  </para>

  <para>
   Pour cela, SQL permet de définir des contraintes sur les colonnes
   et les tables. Les contraintes donnent autant de contrôle sur les
   données des tables qu'un utilisateur peut le souhaiter. Si un utilisateur
   tente de stocker des données dans une colonne en violation d'une contrainte, une erreur est
   levée. Cela s'applique même si la valeur vient de la définition de la
   valeur par défaut.
  </para>

  <sect2>
   <title>Contraintes de vérification</title>

   <indexterm>
    <primary>contrainte de vérification</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>vérification</secondary>
   </indexterm>

   <para>
    La contrainte de vérification est la contrainte la plus
    générique qui soit. Elle permet d'indiquer que la valeur
    d'une colonne particulière doit satisfaire une expression booléenne
    (valeur de vérité). Par
    exemple, pour obliger les prix des produits à être positifs, on peut
    utiliser&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>CHECK (prix &gt; 0)</emphasis>
);</programlisting>
   </para>

   <para>
    La définition de contrainte vient après
    le type de données, comme pour les définitions de valeur par défaut. Les
    valeurs par défaut et les contraintes peuvent être données dans
    n'importe quel ordre. Une contrainte de vérification s'utilise avec
    le mot clé <literal>CHECK</literal> suivi d'une expression entre
    parenthèses. L'expression de la contrainte implique habituellement la
    colonne à laquelle elle s'applique, la contrainte n'ayant dans le cas
    contraire que peu de sens.
   </para>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>nom</secondary>
   </indexterm>

   <para>
    la contrainte peut prendre un nom distinct. Cela
    clarifie les messages d'erreur et permet de faire référence
    à la contrainte lorsqu'elle doit être modifiée.
    La syntaxe est&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric <emphasis>CONSTRAINT prix_positif</emphasis> CHECK (prix &gt; 0)
);</programlisting>
    Pour indiquer une contrainte nommée, on utilise le mot-clé
    <literal>CONSTRAINT</literal> suivi d'un identifiant et de la
    définition de la contrainte (si aucun nom n'est précisé,
    le système en choisit un).
   </para>

   <para>
    Une contrainte de vérification peut aussi faire référence à plusieurs
    colonnes. Dans le cas d'un produit, on peut vouloir stocker le prix normal
    et un prix réduit en s'assurant que le prix réduit soit bien inférieur au
    prix normal.
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric CHECK (prix &gt; 0),
    prix_promotion numeric CHECK (prix_promotion &gt; 0),
    <emphasis>CHECK (prix &gt; prix_promotion)</emphasis>
);</programlisting>
   </para>

   <para>
    Si les deux premières contraintes n'offrent pas de nouveauté, la troisième
    utilise une nouvelle syntaxe. Elle n'est pas attachée à une colonne
    particulière mais apparaît comme un élément distinct dans
    la liste des colonnes. Les définitions de
    colonnes et ces définitions de contraintes peuvent être définies dans
    un ordre quelconque.
   </para>

   <para>
    Les deux premières contraintes sont appelées contraintes de
    colonnes tandis que la troisième est appelée contrainte de table parce
    qu'elle est écrite séparément d'une définition de colonne particulière.
    Les contraintes de colonnes peuvent être écrites comme des contraintes de
    tables, mais l'inverse n'est pas forcément possible puisqu'une contrainte de colonne est
    supposée ne faire référence qu'à la colonne à laquelle elle est
    attachée (<productname>PostgreSQL</productname> ne vérifie pas cette règle
    mais il est préférable de la suivre pour s'assurer que les définitions de 
    tables fonctionnent avec d'autres systèmes de bases de données). 
    L'exemple ci-dessus peut aussi s'écrire&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0),
    CHECK (prix &gt; prix_promotion)
);</programlisting>
    ou même
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0 AND prix &gt; prix_promotion)
);</programlisting>
    C'est une question de goût.
   </para>

   <para>
    Les contraintes de table peuvent être nommées, tout comme
    les contraintes de colonne&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    CHECK (prix &gt; 0),
    prix_promotion numeric,
    CHECK (prix_promotion &gt; 0),
    <emphasis>CONSTRAINT promo_valide</emphasis> CHECK (prix &gt; prix_promotion)
);</programlisting>
   </para>

   <indexterm>
    <primary>valeur NULL</primary>
    <secondary sortas="check constraints">avec contraintes de vérification</secondary>
   </indexterm>

   <para>
    Une contrainte de vérification est satisfaite si
    l'expression est évaluée vraie ou NULL. Puisque la
    plupart des expressions sont évaluées NULL si l'une
    des opérandes est nulle, elles n'interdisent pas les valeurs NULL
    dans les colonnes contraintes. Pour s'assurer qu'une colonne ne
    contient pas de valeurs NULL, la contrainte NOT NULL décrite
    dans la section suivante peut être utilisée.
   </para>
  </sect2>

  <sect2>
   <title>Contraintes de non nullité (NOT NULL)</title>

   <indexterm>
    <primary>contrainte NOT NULL</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>

   <para>
    Une contrainte NOT NULL indique simplement qu'une colonne ne peut
    pas prendre la valeur NULL. Par exemple&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer <emphasis>NOT NULL</emphasis>,
    nom text <emphasis>NOT NULL</emphasis>,
    prix numeric
);</programlisting>
   </para>

   <para>
    Une contrainte NOT NULL est toujours écrite comme une contrainte de
    colonne. Elle est fonctionnellement équivalente à la création d'une
    contrainte de vérification <literal>CHECK (<replaceable>nom_colonne</replaceable>
    IS NOT NULL)</literal>. Toutefois, dans <productname>PostgreSQL</productname>,
    il est plus efficace de créer explicitement une contrainte NOT NULL.
    L'inconvénient est que les contraintes de non-nullité ainsi créées ne
    peuvent pas être explicitement nommées.
   </para>

   <para>
    Une colonne peut évidemment avoir plus d'une contrainte. Il suffit
    d'écrire les contraintes les unes après les autres&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer NOT NULL,
    nom text NOT NULL,
    prix numeric NOT NULL CHECK (prix &gt; 0)
);</programlisting>
    L'ordre n'a aucune importance. Il ne détermine pas l'ordre de vérification
    des contraintes.
   </para>

   <para>
    La contrainte <literal>NOT NULL</literal> a un contraire&nbsp;; la contrainte
    <literal>NULL</literal>. Elle ne signifie pas que la colonne doit
    être NULL, ce qui est assurément inutile, mais sélectionne le comportement
    par défaut, à savoir que la colonne peut être NULL. La contrainte <literal>NULL
    </literal> n'est pas présente dans le standard SQL et ne doit pas
    être utilisée dans des applications portables (elle n'a été ajoutée
    dans <productname>PostgreSQL</productname> que pour assurer la
    compatibilité avec d'autres bases de données). Certains utilisateurs
    l'apprécient néanmoins car elle permet de basculer aisément d'une
    contrainte à l'autre dans un ficheir de script. On peut, par exemple, commencer avec&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer NULL,
    nom text NULL,
    prix numeric NULL
);</programlisting>
    puis insérer le mot-clé <literal>NOT</literal> en fonction des besoins.
   </para>

   <tip>
    <para>
     Dans la plupart des bases de données, la majorité des
     colonnes peut être marquée NOT NULL.
    </para>
   </tip>
  </sect2>

  <sect2>
   <title>Contraintes d'unicité</title>

   <indexterm>
    <primary>contrainte d'unicité</primary>
   </indexterm>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>unicité</secondary>
   </indexterm>

   <para>
    Les contraintes d'unicité garantissent l'unicité des données contenues dans
    une colonne ou un groupe de colonnes par rapport à toutes
    les lignes de la table. La syntaxe est&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer <emphasis>UNIQUE</emphasis>,
    nom text,
    prix numeric
);</programlisting>
    lorsque la contrainte est écrite comme contrainte de colonne et
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric,
    <emphasis>UNIQUE (no_produit)</emphasis>
);</programlisting>
    lorsqu'elle est écrite comme contrainte de table.
   </para>

   <para>
    Lorsqu'une contrainte d'unicité fait référence à un groupe de colonnes,
    celles-ci sont listées séparées par des virgules&nbsp;:
<programlisting>CREATE TABLE exemple (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);</programlisting>
    Cela précise que la combinaison de valeurs dans les colonnes indiquées
    est unique sur toute la table. Sur une colonne prise isolément ce
    n'est pas nécessairement le cas (et habituellement cela ne l'est pas).
   </para>

   <para>
    Une contrainte d'unicité peut être nommée, de la
    façon habituelle&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer <emphasis>CONSTRAINT doit_etre_different</emphasis> UNIQUE,
    nom text,
    prix numeric
);</programlisting>
   </para>

   <indexterm>
    <primary>valeur NULL</primary>
    <secondary sortas="unique constraints">avec contrainte d'unicité</secondary>
   </indexterm>

   <para>
	En général, une contrainte d'unicité est violée lorsqu'au moins deux
	lignes de la table possèdent des valeurs identiques sur toutes les
	colonnes de la contrainte. En revanche, deux valeurs NULL ne sont pas
	considérées égales. Cela signifie qu'il est possible
	de stocker des lignes dupliquées contenant une valeur NULL
	dans au moins une des colonnes contraintes. Ce comportement est conforme
	au standard SQL, mais d'autres bases SQL n'appliquent pas cette règle.
	Il est donc préférable d'être prudent lors du développement d'applications
	portables.
       </para>
      </sect2>

      <sect2>
       <title>Clés primaires</title>

       <indexterm>
	<primary>clé primaire</primary>
       </indexterm>

       <indexterm>
	<primary>contrainte</primary>
	<secondary>clé primaire</secondary>
       </indexterm>

       <para>
	Techniquement, une contrainte de clé primaire n'est
	que la combinaison d'une contrainte d'unicité et
	d'une contrainte NOT NULL. Les définitions de
	table suivantes acceptent de ce fait les mêmes données&nbsp;:
    <programlisting>CREATE TABLE produits (
	no_produit integer UNIQUE NOT NULL,
	nom text,
	prix numeric
    );</programlisting>

    <programlisting>CREATE TABLE produits (
	no_produit integer <emphasis>PRIMARY KEY</emphasis>,
	nom text,
	prix numeric
    );</programlisting>
       </para>

       <para>
	Les clés primaires peuvent également contraindre plusieurs colonnes&nbsp;; la
	syntaxe est semblable aux contraintes d'unicité&nbsp;:
    <programlisting>CREATE TABLE exemple (
	a integer,
	b integer,
	c integer,
	<emphasis>PRIMARY KEY (a, c)</emphasis>
    );</programlisting>
       </para>

       <para>
	Une clé primaire indique qu'une colonne ou un groupe de colonnes peut
	être utilisé(e) comme identifiant unique des lignes de la table. (C'est
	une conséquence directe de la définition d'une clé primaire. Une
	contrainte d'unicité ne suffit pas à fournir un identifiant unique
	car elle n'exclut pas les valeurs NULL). Ceci est utile à la fois
	pour des raisons documentaires et pour les applications clientes. Par
	exemple, une application graphique qui permet de modifier les valeurs de
	lignes a probablement besoin de connaître la clé primaire d'une table pour
	pouvoir identifier les lignes de manière unique.
       </para>

       <para>
	Une table a au plus une clé primaire. (Le nombre de contraintes UNIQUE NOT NULL,
	qui assurent la même fonction, n'est pas limité, mais une seule
	peut être identifiée comme clé primaire.) La théorie des
	bases de données relationnelles impose que chaque table ait
	une clé primaire. Cette règle n'est pas forcée par
	<productname>PostgreSQL</productname>, mais il est préférable de la
	respecter.
       </para>
      </sect2>

      <sect2 id="ddl-constraints-fk">
       <title>Clés étrangères</title>

       <indexterm>
	<primary>clé étrangère</primary>
       </indexterm>

       <indexterm>
	<primary>contrainte</primary>
	<secondary>clé étrangère</secondary>
       </indexterm>

       <indexterm>
	<primary>intégrité référentielle</primary>
       </indexterm>

       <para>
	Une contrainte de clé étrangère stipule que les valeurs d'une
	colonne (ou d'un groupe de colonnes) doivent correspondre aux valeurs
	qui apparaissent dans les lignes d'une autre table.
	On dit que cela maintient l'<firstterm>intégrité référentielle</firstterm>
	entre les deux tables.
       </para>

       <para>
	Soit la table de produits, déjà utilisée plusieurs fois&nbsp;:
    <programlisting>CREATE TABLE produits (
	no_produit integer PRIMARY KEY,
	nom text,
	prix numeric
    );</programlisting>
	Soit également une table qui stocke les commandes de
	ces produits. Il est intéressant de s'assurer que la table des
	commandes ne contient que des commandes de produits
	qui existent réellement. Pour cela, une contrainte
	de clé étrangère est définie dans la table des commandes qui référence la
	table produit&nbsp;:
    <programlisting>CREATE TABLE commandes (
	id_commande integer PRIMARY KEY,
	no_produit integer <emphasis>REFERENCES produits (no_produit)</emphasis>,
	quantite integer
    );</programlisting>
	Il est désormais impossible de créer des commandes pour lesquelles
	<structfield>no_produit</structfield> n'apparaît pas dans la table
	produits.
       </para>
    <!-- referencing/referenced 
	 référençant/référencée ? -->
    <!-- ICI -->
       <para>
	Dans cette situation, on dit que la table des commandes est la table
	<firstterm>qui référence</firstterm> et la table des produits est la table
	<firstterm>référencée</firstterm>.  De la même façon, il y a des colonnes
	qui référencent et des colonnes référencées.
       </para>

       <para>
	La commande précédente peut être raccourcie en
    <programlisting>CREATE TABLE commandes (
	id_commande integer PRIMARY KEY,
	no_produit integer <emphasis>REFERENCES produits</emphasis>,
	quantite integer
    );</programlisting>
	parce qu'en l'absence de liste de colonnes, la clé primaire de la
	table de référence est utilisée comme colonne de référence.
       </para>

       <para>
	Une clé étrangère peut aussi contraindre et référencer un groupe de colonnes.
	Comme cela a déjà été évoqué, il faut alors l'écrire sous forme d'une contrainte de table.
	Voici un exemple de syntaxe&nbsp;:
    <programlisting>CREATE TABLE t1 (
      a integer PRIMARY KEY,
      b integer,
      c integer,
      <emphasis>FOREIGN KEY (b, c) REFERENCES autre_table (c1, c2)</emphasis>
    );</programlisting>
	Le nombre et le type des colonnes contraintes doivent correspondre
	au nombre et au type des colonnes référencées.
       </para>

       <para>
	Une contrainte de clé étrangère peut être nommée de la façon habituelle.
       </para>

       <para>
	Une table peut contenir plusieurs contraintes de clé étrangère. Les
	relation n-n entre tables sont implantées ainsi. Soient 
	des tables qui contiennent des produits et des commandes, avec la
	possibilité d'autoriser une commande à contenir plusieurs produits
	(ce que la structure ci-dessus ne permet pas). On peut pour cela
	utiliser la structure de table suivante&nbsp;:
    <programlisting>CREATE TABLE produits (
	no_produit integer PRIMARY KEY,
	nom text,
	prix numeric
    );

    CREATE TABLE commandes (
	id_commande integer PRIMARY KEY,
	adresse_de_livraison text,
	...
    );

    CREATE TABLE commande_produits (
	no_produit integer REFERENCES produits,
	id_commande integer REFERENCES commandes,
	quantite integer,
	PRIMARY KEY (no_produit, id_commande)
    );</programlisting>
	La clé primaire de la dernière table recouvre les clés étrangères.
       </para>

       <indexterm>
	<primary>CASCADE</primary>
	<secondary>action clé étrangère</secondary>
       </indexterm>

       <indexterm>
	<primary>RESTRICT</primary>
	<secondary>action clé étrangère</secondary>
       </indexterm>

       <para>
	Les clés étrangères interdisent désormais la création
	de commandes qui ne soient pas liées à un produit. Qu'arrive-t-il si un produit
	est supprimé alors qu'une commande y fait référence&nbsp;? SQL
	permet aussi de le gérer. Intuitivement, plusieurs options existent&nbsp;:
	<itemizedlist spacing="compact">
	 <listitem><para>interdire d'effacer un produit référencé&nbsp;;</para></listitem>
	 <listitem><para>effacer aussi les commandes&nbsp;;</para></listitem>
	 <listitem><para>autre chose ?</para></listitem>
	</itemizedlist>
       </para>

       <para>
	Pour illustrer ce cas, la politique suivante est implantée sur
	l'exemple de relations n-n évoqué plus haut&nbsp;:
	<itemizedlist spacing="compact">
	 <listitem><para>quand quelqu'un veut retirer un produit qui est encore
	  référencé par une commande
	  (au travers de <literal>commande_produits</literal>), on
	  l'interdit&nbsp;;</para></listitem>
	 <listitem><para>si quelqu'un supprime une commande, les éléments
	  de la commande sont aussi supprimés.</para></listitem>
	</itemizedlist>

    <programlisting>CREATE TABLE produits (
	no_produit integer PRIMARY KEY,
	nom text,
	prix numeric
    );

    CREATE TABLE commandes (
	id_commande integer PRIMARY KEY,
	adresse_de_livraison text,
	...
    );

    CREATE TABLE commande_produits (
	no_produit integer REFERENCES produits <emphasis>ON DELETE RESTRICT</emphasis>,
	id_commande integer REFERENCES commandes <emphasis>ON DELETE CASCADE</emphasis>,
	quantite integer,
	PRIMARY KEY (no_produit, id_commande)
    );</programlisting>
       </para>

    <!-- CASCADE : cascader ? -->
       <para>
	 Restreindre les suppressions et les cascader sont les deux
	 options les plus communes. <literal>RESTRICT</literal> empêche la
	 suppression d'une ligne référencée. <literal>NO ACTION</literal> impose
	 la levée d'une erreur si des lignes référençant existent lors de la
	 vérification de la contrainte. Il s'agit du comportement par
	 défaut en l'absence de précision. La différence entre
	 <literal>RESTRICT</literal> et <literal>NO ACTION</literal> 
	 est l'autorisation par
	 <literal>NO ACTION</literal> du report de la vérification à la fin de la
	 transaction, ce que <literal>RESTRICT</literal> ne permet pas.
	 <literal>CASCADE</literal> indique que, lors de la suppression d'une ligne
	 référencée, les lignes la référençant doivent être automatiquement
	 supprimées. Il existe deux autres options&nbsp;:
	 <literal>SET NULL</literal> et <literal>SET DEFAULT</literal>.
	 Celles-ci imposent que les colonnes qui référencent soient
	 réinitialisées à NULL ou à leur valeur par défaut, respectivement, lors
	 de la suppression d'une ligne référencée. Elles ne dispensent pas pour
	 autant d'observer les contraintes. Par exemple, si une action précise 
	 <literal>SET DEFAULT</literal> mais que la valeur par défaut ne
	 satisfait pas la clé étrangère, l'opération échoue.
       </para>

       <para>
	À l'instar de <literal>ON DELETE</literal>, existe 
	<literal>ON UPDATE</literal>, évoqué lorsqu'une colonne référencée
	est modifiée (actualisée). Les actions possibles sont les mêmes.
       </para>

       <para>
	Le <xref linkend="dml"/> contient de plus amples informations sur
	l'actualisation et la suppression de données.
       </para>

       <para>
	Une clé étrangère peut faire référence à des colonnes qui constituent une clé
	primaire ou forment une contrainte d'unicité. Si la clé étrangère référence
	une contrainte d'unicité, des possibilités supplémentaires sont offertes
	concernant la correspondance des valeurs NULL. Celles-ci sont expliquées
	dans la documentation de référence de
	<xref linkend="sql-createtable" endterm="sql-createtable-title"/>.
       </para>
      </sect2>
     </sect1>

 <sect1 id="ddl-system-columns">
   <title>Colonnes système</title>

   <para>
     Chaque table contient plusieurs <firstterm>colonnes système</firstterm>
     implicitement définies par le système. De ce fait, leurs noms ne peuvent
     pas être utilisés comme noms de colonnes utilisateur (ces restrictions sont
     distinctes de celles sur l'utlisation de mot-clés&nbsp;; mettre le nom
     entre guillemets ne permet pas d'échapper à cette règle). Il n'est pas
     vraiment utile de se préoccuper de ces colonnes, mais au minimum de
     savoir qu'elles existent.
   </para>

 <indexterm>
   <primary>colonne</primary>
   <secondary>colonne système</secondary>
 </indexterm>

 <variablelist>
   <varlistentry>
     <term><structfield>oid</structfield></term>
     <listitem>
       <para>
        <indexterm>
         <primary>OID</primary>
         <secondary>colonne</secondary>
        </indexterm>
	L'identifiant objet (<foreignphrase>object ID</foreignphrase>) d'une ligne. Cette
	colonne n'est présente que si la table a été créée en précisant
	<literal>WITH OIDS</literal> ou si la variable de configuration 
	<xref linkend="guc-default-with-oids"/> était activée à ce moment-là.
	Cette colonne est de type oid (même nom que la colonne)&nbsp;; voir la
	<xref linkend="datatype-oid"/> pour obtenir plus d'informations sur ce type.
       </para>
     </listitem>
   </varlistentry>
   
   <varlistentry>
     <term><structfield>tableoid</structfield></term>
   <listitem>
     <indexterm>
       <primary>tableoid</primary>
     </indexterm>
     
     <para>
        L' OID de la table contenant la ligne. Cette colonne est
	particulièrement utile pour les requêtes qui utilisent des hiérarchies
	d'héritage (voir <xref linkend="ddl-inherit"/>). Il est, en effet,
	difficile, en son absence, de savoir de quelle table provient une ligne.
	<structfield>tableoid</structfield>
	peut être joint à la colonne <structfield>oid</structfield> de
	<structname>pg_class</structname> pour obtenir le nom de la table.
     </para>
   </listitem>
 </varlistentry>
 
 <varlistentry>
   <term><structfield>xmin</structfield></term>
 <listitem>
   <indexterm>
     <primary>xmin</primary>
   </indexterm>
   
   <para>
      L'identifiant (ID de transaction) de la transaction qui a inséré cette
      version de la ligne. (Une version de ligne est un état individuel
      de la ligne&nbsp;; toute mise à jour d'une ligne crée une nouvelle
      version de ligne pour la même ligne logique.)
   </para>
 </listitem>
</varlistentry>

<varlistentry>
  <term><structfield>cmin</structfield></term>
<listitem>
  <indexterm>
    <primary>cmin</primary>
  </indexterm>
  
  <para>
     L'identifiant de commande (à partir de zéro) au sein de la transaction
     d'insertion.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>xmax</structfield></term>
<listitem>
  <indexterm>
    <primary>xmax</primary>
  </indexterm>
  
  <para>
     L'identifiant (ID de transaction) de la transaction de suppression, ou zéro
     pour une version de ligne non effacée. Il est possible que la colonne ne
     soit pas nulle pour une version de ligne visible&nbsp;; cela
     indique habituellement que la transaction de suppression n'a pas été
     effectuée, ou qu'une tentative de suppression a été annulée.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>cmax</structfield></term>
<listitem>
  <indexterm>
    <primary>cmax</primary>
  </indexterm>
  
  <para>
     L'identifiant de commande au sein de la transaction de suppression, ou
     zéro.
  </para>
</listitem>
</varlistentry>

<varlistentry>
  <term><structfield>ctid</structfield></term>
<listitem>
  <indexterm>
    <primary>ctid</primary>
  </indexterm>
  
  <para>
     La localisation physique de la version de ligne au sein de sa table.
     Bien que le <structfield>ctid</structfield> puisse être utilisé
     pour trouver la version de ligne très rapidement, le
     <structfield>ctid</structfield>  d'une ligne change à chaque fois
     que la ligne est actualisée ou déplacée par un <command>VACUUM FULL</command>.
     <structfield>ctid</structfield> est donc inutilisable comme
     identifiant de ligne sur le long terme. Il est préférable d'utiliser l'OID,
     ou, mieux encore, un numéro
     de série utilisateur, pour identifier les lignes logiques.
</para>
</listitem>
</varlistentry>
</variablelist>

  <para>
   Les OID sont des nombres de 32 bits et sont attribués à partir d'un
   compteur unique sur le cluster. Dans une base de données volumineuse ou
   agée, il est possible que le compteur boucle. Il est de ce fait peu
   pertinent de
   considérer que les OID puissent être uniques&nbsp;; pour identifier les
   lignes d'une table, il est fortement
   recommandé d'utiliser un générateur de séquence.
   Néanmoins, les OID peuvent également être utilisés sous réserve que quelques
   précautions soient prises&nbsp;:
  
  <itemizedlist>
    <listitem>
      <para>
       une contrainte d'unicité doit être ajoutée sur la colonne OID de chaque
       table dont l'OID est utilisé pour identifier les lignes.
       Dans ce cas (ou dans celui d'un index d'unicité), le système
       n'engendre pas d'OID qui puisse correspondre à celui d'une ligne
       déjà présente. Cela n'est évidemment possible que si la table contient
       moins de 2<superscript>32</superscript> (4 milliards) lignes&nbsp;; en pratique, la
       taille de la table a tout intérêt à être bien plus petite que ça, dans
       un souci de performance&nbsp;;
      </para>
    </listitem>
    <listitem>
      <para>
       l'unicité inter-tables des OID ne doit jamais être envisagée&nbsp;;
       pour obtenir un identifiant unique sur l'ensemble de la base, il faut
       utiliser la combinaison du <structfield>tableoid</structfield> et de l'OID de
       ligne&nbsp;;
      </para>
    </listitem>
    <listitem>
      <para>
       les tables en question doivent être créées avec l'option
       <literal>WITH OIDS</literal>. Depuis <productname>PostgreSQL</productname> 8.1,
       <literal>WITHOUT OIDS</literal> est l'option par défaut.
      </para>
    </listitem>
  </itemizedlist>
 </para>

  <para>
    Les identifiants de transaction sont aussi des nombres de 32 bits. Dans 
    une base de données agée, il est possible que les ID de
    transaction bouclent. Cela n'est pas un problème fatal
    avec des procédures de maintenance appropriées&nbsp;; voir le <xref
    linkend="maintenance"/> pour les détails. Il est, en revanche, imprudent
    de considérer l'unicité des ID de transaction sur le long terme (plus
    d'un milliard de transactions).
  </para>
  
  <para>
     Les identifiants de commande sont aussi des nombres de 32 bits. Cela
     crée une limite dure de 2<superscript>32</superscript> (4 milliards) commandes
     <acronym>SQL</acronym> au sein d'une unique transaction. En pratique,
     cette limite n'est pas un problème &mdash; la limite est sur
     le nombre de commandes <acronym>SQL</acronym>, pas sur le nombre de lignes
     traitées.
  </para>
 </sect1>

 <sect1 id="ddl-alter">
  <title>Modification des tables</title>

  <indexterm zone="ddl-alter">
   <primary>table</primary>
   <secondary>modification</secondary>
  </indexterm>

  <para>
   Lorsqu'une table est créée et qu'une erreur a été commise ou que les
   besoins de l'application changent, il est alors possible de la supprimer et
   de la récréer. Cela n'est toutefois pas pratique si la table contient
   déjà des données ou qu'elle est référencée par d'autres objets de la base
   de données (une contrainte de clé étrangère, par exemple). C'est pourquoi
   <productname>PostgreSQL</productname> offre une série de commandes
   permettant de modifier une table existante. Cela n'a rien à voir 
   avec la modification des données contenues dans la table&nbsp;; il ne
   s'agit ici, que de modifier la définition, ou structure, de la table.
  </para>

  <para>
   Il est possible
   <itemizedlist spacing="compact">
    <listitem>
     <para>d'ajouter des colonnes&nbsp;;</para>
    </listitem>
    <listitem>
     <para>de supprimer des colonnes&nbsp;;</para>
    </listitem>
    <listitem>
     <para>d'ajouter des contraintes&nbsp;;</para>
    </listitem>
    <listitem>
     <para>de supprimer des contraintes&nbsp;;</para>
    </listitem>
    <listitem>
     <para>de modifier des valeurs par défaut&nbsp;;</para>
    </listitem>
    <listitem>
     <para>de modifier les types de données des colonnes&nbsp;;</para>
    </listitem>
    <listitem>
     <para>de renommer des colonnes&nbsp;;</para>
    </listitem>
    <listitem>
     <para>de renommer des tables.</para>
    </listitem>
   </itemizedlist>

   Toutes ces actions sont réalisées à l'aide de la commande <xref
   linkend="sql-altertable" endterm="sql-altertable-title"/>, dont la
   documentation est plus détaillée.
  </para>

  <sect2>
   <title>Ajouter une colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>ajouter</secondary>
   </indexterm>

   <para>
    Pour ajouter une colonne, une commande comme celle qui suit peut être
    utilisée&nbsp;:
<programlisting>ALTER TABLE produits ADD COLUMN description text;</programlisting>
    La nouvelle colonne est initialement remplie avec la valeur par défaut
    précisée (NULL en l'absence de clause <literal>DEFAULT</literal>).
   </para>

<!--ICI-->
   <para>
    Vous pouvez aussi définir des contraintes sur la colonne au même moment
    en utilisant la syntaxe habituelle&nbsp;:
<programlisting>ALTER TABLE produits ADD COLUMN description text CHECK (description &lt;&gt; '');</programlisting>
    En fait, toutes les options applicables à la description d'une colonne
    dans <command>CREATE TABLE</command> peuvent être utilisées ici. Néanmoins,
    gardez en tête que la valeur par défaut doit satisfaire les contraintes
    données. Sinon, <literal>ADD</literal> échouera. Autrement, vous pouvez ajouter
    les contraintes plus tard (voir ci-dessous) après avoir rempli la nouvelle
    colonne correctement.
   </para>

  <tip>
   <para>
    Ajouter une colonne avec une valeur par défaut nécessite la mise à jour
    de chaque ligne de la table pour stocker la valeur de la nouvelle colonne.
    Néanmoins, si aucune valeur par défaut n'est spécifiée,
    <productname>PostgreSQL</productname> peut éviter la mise à jour physique.
    Donc, si vous avez l'intention de remplir la colonne avec des valeurs qui
    ne sont principalement pas celles par défaut, il est préférable d'ajouter
    la colonne sans valeur par défaut, d'insérer les bonnes valeurs avec une
    commande <command>UPDATE</command>, puis d'ajouter la valeur par défaut désirée
    comme décrit ci-dessus.
   </para>
  </tip>

  </sect2>

  <sect2>
   <title>Retirer une colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>retirer</secondary>
   </indexterm>

   <para>
    Pour retirer une colonne, utilisez une commande comme celle-ci&nbsp;:
<programlisting>ALTER TABLE produits DROP COLUMN description;</programlisting>
    Les données de cette colonne disparaissent. Les contraintes de table
    impliquant la colonne sont aussi supprimées. Néanmoins, si la colonne est
    référencée par une contrainte de clé étrangère dans une autre table,
    <productname>PostgreSQL</productname> ne supprimera pas silencieusement
    cette contrainte. Vous pouvez autoriser la suppression de tout ce qui     
    dépend de la colonne en ajoutant <literal>CASCADE</literal>&nbsp;:
<programlisting>ALTER TABLE produits DROP COLUMN description CASCADE;</programlisting>
    Voir la <xref linkend="ddl-depend"/> pour une description du mécanisme général
    derrière ceci.
   </para>
  </sect2>

  <sect2>
   <title>Ajouter une contrainte</title>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>ajouter</secondary>
   </indexterm>

   <para>
    Pour ajouter une contrainte, la syntaxe de contrainte de table est utilisée.
    Par exemple&nbsp;:
<programlisting>ALTER TABLE produits ADD CHECK (nom &lt;&gt; '');
ALTER TABLE produits ADD CONSTRAINT autre_nom UNIQUE (no_produit);
ALTER TABLE produits ADD FOREIGN KEY (id_groupe_produit) REFERENCES groupes_produits;</programlisting>
    Pour ajouter une contrainte non NULL, qui ne peut pas être écrite
    sous forme d'une contrainte de table, utilisez cette syntaxe&nbsp;:
<programlisting>ALTER TABLE produits ALTER COLUMN no_produit SET NOT NULL;</programlisting>
   </para>

   <para>
    La contrainte sera vérifiée immédiatement, donc les données de la
    table doivent satisfaire la contrainte avant qu'elle soit ajoutée.
   </para>
  </sect2>

  <sect2>
   <title>Retirer une contrainte</title>

   <indexterm>
    <primary>contrainte</primary>
    <secondary>retirer</secondary>
   </indexterm>

   <para>
    Pour retirer la contrainte, il faut connaître son nom. Si vous lui avez donné
    un nom, alors c'est facile. Sinon, le système a attribué un nom généré que vous
    devez découvrir. La commande <literal>\d <replaceable>table</replaceable></literal>
    de <application>psql</application> peut être utile ici&nbsp;; d'autres interfaces peuvent
    aussi donner le moyen d'examiner les détails de table. La commande est&nbsp;:
<programlisting>ALTER TABLE produits DROP CONSTRAINT autre_nom;</programlisting>
    (si vous traitez avec un nom de contrainte généré comme <literal>$2</literal>,
    n'oubliez pas qu'il faudra l'entourer de guillemets double pour en faire
    un identifiant valable)
   </para>

   <para>
	Comme avec la suppression d'une colonne, vous avez besoin d'ajouter
	<literal>CASCADE</literal> si vous voulez supprimer une contrainte qui dépend
	d'autre chose. Un exemple concerne la contrainte de clé étrangère qui
	dépend d'une contrainte de clé unique ou primaire sur le(s) colonne(s)
    référencée(s).
   </para>

   <para>
    Ça fonctionne de la même manière pour toutes les types de contrainte
    sauf les contraintes non NULL. Pour retirer une contrainte non NULL,
    utilisez
<programlisting>ALTER TABLE produits ALTER COLUMN no_produit DROP NOT NULL;</programlisting>
    (Rappelez vous que les contraintes non NULL n'ont pas de noms.)
   </para>
  </sect2>

  <sect2>
   <title>Modifier la valeur par défaut d'une colonne</title>

   <indexterm>
    <primary>valeur par défaut</primary>
    <secondary>modifier</secondary>
   </indexterm>

   <para>
    Pour mettre une nouvelle valeur par défaut sur une colonne, utilisez une
    commande comme celle-ci&nbsp;:
<programlisting>ALTER TABLE produits ALTER COLUMN prix SET DEFAULT 7.77;</programlisting>
    Notez que ceci n'affecte pas les lignes existantes dans la table, cela ne
    modifie que la valeur par défaut pour les futures commandes
    <command>INSERT</command>.
   </para>

   <para>
    Pour retirer toute valeur par défaut, utilisez
<programlisting>ALTER TABLE produits ALTER COLUMN prix DROP DEFAULT;</programlisting>
    Ceci est équivalent à mettre la valeur par défaut à NULL. En conséquence,
    ce n'est pas une erreur de
    retirer une valeur par défaut qui n'a pas été définie car la valeur NULL
    est la valeur par défaut implicite.
   </para>
  </sect2>

  <sect2>
   <title>Modifier le type de données d'une colonne</title>

   <indexterm>
    <primary>type de données d'une colonne</primary>
    <secondary>modification</secondary>
   </indexterm>

   <para>
    Pour convertir une colonne en un autre type de données, utilisez une
    commande comme ceci&nbsp;:
    <programlisting>ALTER TABLE produits ALTER COLUMN prix TYPE numeric(10,2);</programlisting>
    Elle ne réussira que si chaque valeur dans la colonne peut être
    convertie dans le nouveau type par une conversion implicite. Si une
    conversion plus complexe est nécessaire, vous pouvez ajouter une clause
    <literal>USING</literal> qui spécifie comment calculer les nouveaux valeurs à
    partir des anciennes.
   </para>
  
   <para>
    <productname>PostgreSQL</productname> tentera de convertir la valeur par défaut de la
    colonne, si elle en a une. Mais ces conversions pourraient échouer ou
    pourraient produire des résultats surprenants. Il est souvent mieux de
    supprimer les contraintes sur une colonne avant de modifier son type, puis
    d'ajouter les contraintes modifiées convenablement.
   </para>
  </sect2>

  <sect2>
   <title>Renommer une colonne</title>

   <indexterm>
    <primary>colonne</primary>
    <secondary>renommer</secondary>
   </indexterm>

   <para>
    Pour renommer une colonne&nbsp;:
<programlisting>ALTER TABLE produits RENAME COLUMN no_produit TO numero_produit;</programlisting>
   </para>
  </sect2>

  <sect2>
   <title>Renommer une table</title>

   <indexterm>
    <primary>table</primary>
    <secondary>renommer</secondary>
   </indexterm>

   <para>
    Pour renommer une table&nbsp;:
<programlisting>ALTER TABLE produits RENAME TO elements;</programlisting>
   </para>
  </sect2>
 </sect1>
 
 <sect1 id="ddl-priv">
  <title>Droits</title>

  <indexterm zone="ddl-priv">
   <primary>droit</primary>
  </indexterm>

  <indexterm>
   <primary>permission</primary>
   <see>droit</see>
  </indexterm>

  <para>
   Quand vous créez un objet dans la base de données, vous en devenez le
   propriétaire. Avec les paramètres par défaut, seul le propriétaire
   d'un objet peut faire quelque chose avec. Pour que d'autres utilisateurs
   puissent s'en servir, des <firstterm>droits</firstterm> doivent être
   accordés (néanmoins, les superutilisateurs ont toujours accès à n'importe
   quel objet).
  </para>

  <para>
   Il existe plusieurs droits&nbsp;: <literal>SELECT</literal>,
   <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   <literal>REFERENCES</literal>, <literal>TRIGGER</literal>,
   <literal>CREATE</literal>, <literal>CONNECT</literal>, <literal>TEMPORARY</literal>,
   <literal>EXECUTE</literal>, et <literal>USAGE</literal>.
   Les droits applicables à un objet particulier varient
   suivant le type d'objet (table, fonction, etc.) Pour une
   information complète sur les différents types de droits gérés par
   <productname>PostgreSQL</productname>, lisez la page de référence
   <xref linkend="sql-grant" endterm="sql-grant-title"/>.  La section et
   les chapitres suivants vous montreront aussi comment ces droits
   sont utilisés.
  </para>

  <para>
   Le droit de modifier ou de détruire est le droit du propriétaire seul.
  </para>

  <note>
    <para>
      Pour modifier le propriétaire d'une table, d'un index, d'une séquence ou
      d'une vue, utilisez la commande <xref linkend="sql-altertable"
      endterm="sql-altertable-title"/>. Il
      existe des commandes <literal>ALTER</literal> correspondant aux autres types 
      d'objets.
    </para>
  </note>
  
  <para>
   Pour accorder des droits, la commande <command>GRANT</command> est
   utilisée. Par exemple, si <literal>joe</literal> est un utilisateur
   existant et <literal>comptes</literal> une table existante, le
   droit de mettre la table à jour peut être accordé avec
<programlisting>GRANT UPDATE ON comptes TO joe;</programlisting>
   Écrire <literal>ALL</literal> au lieu d'un droit spécifique accorde tous
   les droits adéquats pour ce type d'objet.
  </para>

  <para>
   Le nom d'<quote>utilisateur</quote> spécial <literal>PUBLIC</literal> peut
   être utilisé pour donner un droit à chaque utilisateur du système. De plus,
   les rôles de type <quote>group</quote> peuvent être configurés pour aider à
   la gestion des droits quand il y a beaucoup d'utilisateurs dans une base
   &mdash; pour les détails, voir <xref linkend="user-manag"/>.
  </para>

  <para>
   Pour révoquer un droit, utilisez la commande appropriée
   <command>REVOKE</command> ci-dessous&nbsp;:
<programlisting>REVOKE ALL ON comptes FROM PUBLIC;</programlisting>
   Les droits spéciaux du propriétaire de l'objet (c'est-à-dire, le droit de faire des
   <command>DROP</command>, <command>GRANT</command>, <command>REVOKE</command>, etc.)
   sont toujours implicitement ceux du propriétaire et ne peuvent être ni
   accordés ni révoqués. Mais le propriétaire de l'objet peut choisir
   de révoquer ses propres droits ordinaires pour, par exemple, mettre
   une table en lecture seule pour soi-même ainsi que pour les autres.
  </para>

  <para>
   Habituellement, seul le propriétaire de l'objet (ou un superutilisateur)
   peut donner ou révoquer les droits sur un objet. Néanmoins, il est possible
   de donner un droit <quote>avec une option de don de droits</quote>, qui donne
   à celui qui le reçoit de le donner à d'autres. Si cette option est ensuite
   révoquée, alors tous ceux qui ont reçu le droit de cet utilisateur
   (directement ou indirectement via la chaîne des dons)  perdront leur
   droit. Pour des détails, voir les pages de références <xref
   linkend="sql-grant" endterm="sql-grant-title"/> et <xref linkend="sql-revoke"
   endterm="sql-revoke-title"/>.
  </para>
 </sect1>

 <sect1 id="ddl-schemas">
  <title>Schémas</title>

  <indexterm zone="ddl-schemas">
   <primary>schéma</primary>
  </indexterm>

  <para>
   Un groupe de bases de données <productname>PostgreSQL</productname>
   contient une ou plusieurs bases nommées. Les utilisateurs et groupes
   d'utilisateurs sont partagés sur le groupe tout entier mais aucune
   autre donnée n'est partagée parmi les bases. Une connexion cliente
   donnée sur le serveur peut accéder aux données d'une seule base, celle
   spécifiée dans la connexion de requête.
  </para>

  <note>
   <para>
    Les utilisateurs d'un groupe n'ont pas forcément le droit d'accéder à
    toutes les bases du groupe. Le partage des noms d'utilisateur veut dire
    qu'il ne peut pas y avoir plusieurs utilisateurs nommés <literal>joe</literal>,
    par exemple, dans deux bases du même groupe&nbsp;; mais le système peut être
    configuré pour autoriser <literal>joe</literal> à accéder qu'à certaines bases.
   </para>
  </note>

  <para>
   Une base de données contient un ou plusieurs <firstterm>schémas</firstterm>
   nommés qui, eux, contiennent des tables. Les schémas contiennent aussi d'autres
   types d'objets nommés, y compris des types de données, fonctions et opérateurs.
   Seul le nom d'objet peut être utilisé sans conflit&nbsp;; par exemple,
   <literal>schema1</literal> et <literal>mon_schema</literal> peuvent tous les deux
   contenir une table nommée <literal>ma_table</literal>. Contrairement aux
   bases de données, les schémas ne sont pas séparés de manière rigide&nbsp;:
   un utilisateur peut accéder aux objets de n'importe lequel des schémas de la
   base de données auxquels il se connecte s'il a les droits pour le faire.
  </para>

  <para>
   Il existe plusieurs raisons pour lesquelles quelqu'un voudrait utiliser les
   schémas&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Pour autoriser beaucoup d'utilisateurs à utiliser une base de données sans se gêner
      les uns les autres.
     </para>
    </listitem>

    <listitem>
     <para>
      Pour organiser des objets de bases de données en groupes logiques afin de faciliter
      leur gestion.
     </para>
    </listitem>

    <listitem>
     <para>
      Les applications tierces peuvent être mises dans des schémas séparés pour qu'il n'y
      ait pas de collision avec les noms d'autres objets.
     </para>
    </listitem>
   </itemizedlist>

   Les schémas sont comparables aux répertoires au niveau du système d'exploitation
   sauf que les schémas ne peuvent pas être imbriqués.
  </para>

  <sect2 id="ddl-schemas-create">
   <title>Créer un schéma</title>

   <indexterm zone="ddl-schemas-create">
    <primary>schéma</primary>
    <secondary>créer</secondary>
   </indexterm>

   <para>
    Pour créer un schéma, utilisez la commande <xref linkend="sql-createschema"
    endterm="sql-createschema-title"/>. Donnez au schéma un nom de votre choix. Par
    exemple&nbsp;:
<programlisting>CREATE SCHEMA mon_schema;</programlisting>
   </para>

   <indexterm>
    <primary>nom qualifié</primary>
   </indexterm>

   <indexterm>
    <primary>nom</primary>
    <secondary>qualifié</secondary>
   </indexterm>

   <para>
    Pour créer ou accéder aux objets dans un schéma, écrivez un
    <firstterm>nom qualifié</firstterm> qui consiste en le nom du schéma et
    le nom de la table séparés par un point&nbsp;:
<synopsis><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable></synopsis>
    Ceci fonctionne partout où un nom de table est attendu, donc en incluant les
    commandes de modification de la table et les commandes d'accès aux données
    discutées dans les chapitres suivants (nous parlons uniquement
    des tables mais les mêmes idées s'appliquent aux autres genres d'objets
    nommés, comme les types et les fonctions).
   </para>
   
   <para>
    En fait, la syntaxe encore plus générale
<synopsis><replaceable>basededonnees</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable></synopsis>
    peut être utilisé aussi mais, pour le moment, ceci n'existe que pour
    être conforme au standard SQL. Si vous écrivez un nom de base de
    données, il devrait être celui de la base auquel vous êtes connecté.
   </para>

   <para>
    Donc, pour créer une table dans le nouveau schéma, utilisez
<programlisting>CREATE TABLE mon_schema.ma_table (
 ...
);</programlisting>
   </para>

   <indexterm>
    <primary>schéma</primary>
    <secondary>suppression</secondary>
   </indexterm>

   <para>
    Pour effacer un schéma vide (tous les objets qu'il contient ont été
    supprimés), utilisez
<programlisting>DROP SCHEMA mon_schema;</programlisting>
    Pour effacer un schéma avec les objets qu'il contient, utilisez
<programlisting>DROP SCHEMA mon_schema CASCADE;</programlisting>
    Lisez la <xref linkend="ddl-depend"/> pour une description du mécanisme
    général derrière tout ceci.
   </para>

   <para>
    Souvent, vous voudrez modifier le schéma utilisé par quelqu'un
    d'autre (puisque c'est l'une des méthodes par lesquelles on peut
    restreindre l'activité de vos utilisateurs à des espaces de nom
    définis). La syntaxe pour ceci est&nbsp;:
<programlisting>CREATE SCHEMA <replaceable>nom_schema</replaceable> AUTHORIZATION <replaceable>nom_utilisateur</replaceable>;</programlisting>
    Vous pouvez même omettre le nom du schéma auquel cas, le nom du schéma
    sera le même que le nom d'utilisateur. Voir la <xref
    linkend="ddl-schemas-patterns"/> pour voir comment cela peut être utilisé.
   </para>

   <para>
    Les noms de schéma commençant par <literal>pg_</literal> sont réservés pour
    les besoins du système et les schémas commençant ainsi ne peuvent pas être
    créés par les utilisateurs.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-public">
   <title>Le schéma public</title>

   <indexterm zone="ddl-schemas-public">
    <primary>schéma</primary>
    <secondary>public</secondary>
   </indexterm>

   <para>
    Dans les sections précédentes, on créait des tables sans spécifier un
    nom de schéma. Par défaut, ces tables (et autres objets) sont
    automatiquement placées dans un schéma nommé <quote>public</quote>. Toute
    nouvelle base de données contient un tel schéma. Donc, ces instructions
    sont équivalentes&nbsp;:
<programlisting>CREATE TABLE produits ( ... );</programlisting>
    et
<programlisting>CREATE TABLE public.produits ( ... );</programlisting>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-path">
   <title>Chemin de recherche de schéma</title>

   <indexterm>
    <primary>chemin de recherche</primary>
   </indexterm>

   <indexterm>
    <primary>nom non qualifié</primary>
   </indexterm>

   <indexterm>
    <primary>nom</primary>
    <secondary>non qualifié</secondary>
   </indexterm>

   <para>
    Les noms qualifiés sont pénibles à écrire et il est, de toute façon,
    préférable de ne pas coder un nom de schéma dans une application. Donc, les
    tables sont souvent appelées par des noms non <firstterm>qualifiés</firstterm>
    qui s'apparentent souvent au nom de la table lui-même. Le système détermine
    la table appelée en suivant un <firstterm>chemin de recherche</firstterm>
    qui est une liste de schémas à vérifier. La première table correspondante
    est considérée comme la table voulue. S'il n'y a pas de correspondance, une
    erreur est remontée, même si des noms de table correspondants existent dans
    d'autres schémas de la base.
   </para>

   <indexterm>
    <primary>schéma</primary>
    <secondary>courant</secondary>
   </indexterm>

   <para>
    Le premier schéma dans le chemin de recherche est appelé le schéma courant.
    En plus d'être le premier schéma parcouru, il est aussi le schéma dans lequel
    de nouvelles tables seront créées si la commande <command>CREATE TABLE</command>
    ne précise pas de nom de schéma.
   </para>

   <indexterm>
    <primary>search_path</primary>
   </indexterm>

   <para>
    Pour voir le chemin de recherche courant, utilisez la commande
    suivante&nbsp;:
<programlisting>SHOW search_path;</programlisting>
    Dans la configuration par défaut, ceci renvoie&nbsp;:
<screen> search_path
--------------
 "$user",public</screen>
    Le premier élément précise qu'un schéma avec le même nom que l'utilisateur
    en cours doit être parcouru. Le deuxième élément renvoie au schéma public
    que nous avons déjà vu.
   </para>

   <para>
    Le premier schéma existant dans le chemin de recherche est l'endroit
    par défaut pour la création de nouveaux objets. Ceci est la raison
    pour laquelle les objets sont créés dans le schéma public. Quand les
    objets sont liés dans tout autre contexte sans une qualification de
    schéma (modification de table, modification de données ou requête de
    commande), le chemin de recherche est traversé jusqu'à ce qu'un objet
    correspondant soit trouvé. Donc, dans la configuration par défaut,
    tout accès non qualifié ne peut que se référer au schéma public.
   </para>

   <para>
    Pour mettre notre nouveau schéma dans le chemin, nous utilisons
<programlisting>SET search_path TO mon_schema,public;</programlisting>
    (nous ne mettons pas le <literal>$user</literal> ici car nous n'en avons
    pas besoin pour l'instant). Et nous pouvons pas accéder à la table sans
    qualification de schéma&nbsp;:
<programlisting>DROP TABLE ma_table;</programlisting>
    Aussi, puisque <literal>mon_schema</literal> est le premier élément dans
    le chemin, les nouveaux objets seront créés dans ce schéma.
   </para>

   <para>
    On pourrait aussi écrire
<programlisting>SET search_path TO mon_schema;</programlisting>
    Dans ce cas, nous n'avons pas accès au schéma public sans qualification explicite.
    Il n'y a rien de spécial à propos du schéma public hormis le fait qu'il
    existe par défaut. Il peut aussi être effacé.
   </para>

   <para>
    Voir aussi la <xref linkend="functions-info"/> qui détaille les autres façons
    de manipuler le chemin de recherche des schémas.
   </para>

   <para>
    Le chemin de recherche fonctionne de la même façon pour les noms de type de
    données, les noms de fonction et les noms d'opérateur que pour les noms de
    tables. Les types de données et de fonctions peuvent être qualifiés de la
    même façon que les noms de table. Si vous avez besoin d'écrire un nom
    d'opérateur qualifié dans une expression, il y a une condition
    spéciale&nbsp;: vous devez écrire
<synopsis><literal>OPERATOR(</literal><replaceable>schéma</replaceable><literal>.</literal><replaceable>opérateur</replaceable><literal>)</literal></synopsis>
    Ceci est nécessaire afin d'éviter une ambiguïté syntaxique. En voici un
    exemple
<programlisting>SELECT 3 OPERATOR(pg_catalog.+) 4;</programlisting>
    En pratique, on dépend souvent du chemin de recherche pour les opérateurs,
    afin de ne pas avoir à écrire quelque chose d'aussi peu présentable.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-priv">
   <title>Schémas et droits</title>

   <indexterm zone="ddl-schemas-priv">
    <primary>droit</primary>
    <secondary sortas="schemas">pour les schémas</secondary>
   </indexterm>

   <para>
    Par défaut, les utilisateurs ne peuvent pas accéder aux objets présents
    dans les schémas qui ne leur appartiennent pas. Pour leur permettre, le
    propriétaire du schéma doit donner le droit <literal>USAGE</literal> sur
    le schéma. Pour autoriser les utilisateurs à manipuler les objets d'un
    schéma, des droits supplémentaires devront peut-être être accordés, suivant
    l'objet.
   </para>

   <para>
    Un utilisateur peut aussi être autorisé à créer des objets dans le
    schéma de quelqu'un d'autre. Pour permettre ceci, le droit
    <literal>CREATE</literal> doit être accordé. Notez que, par défaut,
    tout le monde a les droits <literal>CREATE</literal> et
    <literal>USAGE</literal> sur le schéma <literal>public</literal>.
    Ceci permet à tous les utilisateurs qui sont capables de se connecter
    à une base de données de créer des objets dans son schéma
    <literal>public</literal>. Si vous ne souhaitez pas ce comportement,
    vous pouvez révoquer ce droit&nbsp;:
<programlisting>REVOKE CREATE ON SCHEMA public FROM PUBLIC;</programlisting>
    Le premier <quote>public</quote> est le schéma, le second
    <quote>public</quote> veut dire <quote>chaque utilisateur</quote>. Dans le
    premier cas, c'est un identifiant. Dans le second, c'est un mot clé,
    d'où la casse différente. Souvenez-vous des règles de la
    <xref linkend="sql-syntax-identifiers"/>.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-catalog">
   <title>Catalogue du système de schémas</title>

   <indexterm zone="ddl-schemas-catalog">
    <primary>système de catalogue</primary>
    <secondary>schéma</secondary>
   </indexterm>

   <para>
    En plus du schéma <literal>public</literal> et de ceux créés par les
    utilisateurs, chaque
    base de données contient un schéma <literal>pg_catalog</literal>, qui contient
    les tables systèmes et tous les types de données, fonctions et opérateurs
    intégrés. <literal>pg_catalog</literal> fait toujours partie du chemin
    de recherche. S'il n'est pas nommé explicitement dans le chemin, il est
    parcouru implicitement <emphasis>avant</emphasis> la recherche dans les schémas
    du chemin. Ceci garantie qui les noms internes seront toujours trouvables.
    En revanche, vous pouvez explicitement placer <literal>pg_catalog</literal> à la
    fin si vous préférez que les noms définis par les utilisateurs surchargent
    les noms internes.
   </para>

   <para>
    Dans les versions de <productname>PostgreSQL</productname> antérieures à la 7.3,
    les noms de table commençant par <literal>pg_</literal> étaient réservés. Ceci
    n'est plus vrai&nbsp;: vous pouvez créer une telle table si vous le voulez
    dans n'importe quel schéma non système. En revanche, il vaut mieux
    continuer d'éviter de tels noms pour garantir que vous n'aurez pas
    de conflit si une prochaine version définit une table système qui
    porte le même nom que votre table (avec le chemin de recherche par
    défaut, une référence non qualifiée à votre table pointera au lieu
    vers la table système).
    Les tables systèmes continueront de suivre la convention de porter
    des noms commençant par <literal>pg_</literal> pour qu'ils n'aient pas de
    conflit avec des noms de table non qualifiés tant que les utilisateurs
    éviteront le préfixe <literal>pg_</literal>.
   </para>
  </sect2>

  <sect2 id="ddl-schemas-patterns">
   <title>Méthodes d'utilisation</title>

   <para>
    Les schémas peuvent être utilisés pour organiser vos données de plusieurs
    manières. Plusieurs sont recommandés et sont facilement supportés par la
    configuration par défaut&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Si vous ne créez aucun schéma, alors tout les utilisateurs
       auront accès au schéma public implicitement. Ceci simule la
       situation dans laquelle les schémas ne sont pas disponibles.
       Cette situation est recommandée lorsque il n'y a qu'un seul
       utilisateur ou quelques utilisateurs coopérants dans une base
       de données. Cette configuration permet aussi une transition
       en douceur d'une situation où on ne connaît pas le schéma.
      </para>
     </listitem>

     <listitem>
      <para>
       Vous pouvez créer un schéma pour chaque utilisateur avec un
       nom identique à celui de l'utilisateur. Souvenez-vous que le
       chemin de recherche par défaut commence par
       <literal>$user</literal>, ce qui correspond au nom d'utilisateur.
       Donc si chaque utilisateur a un schéma distinct, ils accèdent
       à leurs propres schémas par défaut.
      </para>

      <para>
       Si vous utilisez cette configuration, alors vous devriez peut-être
       aussi révoquer l'accès au schéma public (ou l'effacer complètement)
       pour que les utilisateurs soient réellement limités à leur propre
       schéma.
      </para>
     </listitem>

     <listitem>
      <para>
       Pour installer des applications partagées (tables utilisables
       par tout le monde, fonctionnalités supplémentaires fournies par
       des applications tiers, etc), insérez-les dans des schéma séparés.
       Rappelez-vous que vous devez donner les permissions appropriées
       pour permettre aux utilisateurs d'y accéder. Les utilisateurs
       peuvent alors se référer à ces objets additionnels en qualifiant
       les noms avec un nom de schéma ou ils peuvent mettre les schémas
       supplémentaires dans leur chemin de recherche, s'ils le souhaitent.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-portability">
   <title>Portabilité</title>

   <para>
    Dans le standard SQL, la notion d'objets du même schéma
    appartenant à des utilisateurs différents n'existe pas. De plus,
    certaines implémentations ne vous permettent pas de créer des
    schémas qui ont un nom différent de celui de leur propriétaire.
    En fait, les concepts de schéma et d'utilisateur sont presque
    équivalents dans un système de base de données qui n'implémente
    que le support basique des schémas spécifiés dans le standard.
    À partir de ce constat, beaucoup d'utilisateurs considèrent les noms
    qualifiés comme correspondant réellement à
    <literal><replaceable>utilisateur</replaceable>.<replaceable>table</replaceable></literal>.
    C'est comme cela que <productname>PostgreSQL</productname> se comporte
    si vous créez un schéma par utilisateur pour chaque utilisateur.
   </para>

   <para>
    De plus, il n'y a aucun concept d'un schéma <literal>public</literal> dans le
    standard SQL. Pour plus de conformité au standard, vous ne devriez pas
    utiliser (et sans doute effacer) le schéma <literal>public</literal>.
   </para>

   <para>
    Bien sûr, certains systèmes de bases de données n'implémentent pas du
    tout les schémas. ou donnent le support d'espace de nommage en
    autorisant (peut-être de façon limité) des accès sur plusieurs bases
    de données. Dans ce cas, la portabilité maximale sera obtenue en n'utilisant
    pas du tout les schémas.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-inherit">
  <title>Héritage</title>

  <indexterm>
   <primary>héritage</primary>
  </indexterm>

  <indexterm>
   <primary>table</primary>
   <secondary>héritage</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> implémente l'héritage des tables,
   un outil bien utile pour les concepteurs de bases de données (SQL:1999 et
   les versions ultérieures définissent une fonctionnalité d'héritage de
   type qui diffère par de nombreux aspects des fonctionnalités décrites ici).
  </para>

  <para>
   Commençons avec un exemple&nbsp;: supposons que nous essayons de construire
   un modèle de données pour les villes. Chaque état a plusieurs villes mais
   ne dispose que d'une capitale. Nous voulons être capable de retrouver
   rapidement la ville de la capitale pour tout état. Ceci peut se faire en
   créant deux tables, une pour les capitales et une pour les villes qui ne
   sont pas des capitales. Néanmoins, que se passe-t'il quand nous voulons
   récupérer les données de toutes les villes, capitales ou non&nbsp;?
   l'héritage nous permet de résoudre ce problème. Nous définissons une
   table <structname>capitales</structname> comme héritant de
   <structname>villes</structname>&nbsp;:

<programlisting>CREATE TABLE villes (
    nom             text,
    population      float,
    altitude        int     -- (en pied)
);

CREATE TABLE capitales (
    etat           char(2)
) INHERITS (villes);</programlisting>

   Dans ce cas, la table <structname>capitales</structname> <firstterm>hérite</firstterm> de
   toutes les colonnes de sa table parent, <structname>villes</structname>. Les capitales
   ont aussi une colonne supplémentaire, <structfield>état</structfield>, indiquant leur
   état.
  </para>

  <para>
   Dans <productname>PostgreSQL</productname>, une table peut hériter d'aucune,
   de une ou de plusieurs autres tables. Une requête peut référencer soit toutes
   les lignes d'une table soit toutes les lignes d'une table ainsi que celles
   des tables descendantes. Ce dernier comportement est celui par défaut. Par
   exemple, la requête suivante trouve les noms de toutes les villes, y compris
   les capitales, situées à une altitude supérieure à 500 pieds&nbsp;:

<programlisting>SELECT nom, altitude
    FROM villes
    WHERE altitude &gt; 500;</programlisting>

   Étant donné les données provenant du tutoriel de <productname>PostgreSQL</productname>
   (voir <xref linkend="tutorial-sql-intro"/>), ceci renvoie&nbsp;:

<programlisting>   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845</programlisting>
  </para>

  <para>
   D'un autre côté, la requête suivante trouve toutes les villes qui ne sont
   pas des capitales et qui sont situées à une altitude de plus de 500
   pieds&nbsp;:

<programlisting>SELECT nom, altitude
    FROM ONLY villes
    WHERE altitude &gt; 500;

   nom     | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953</programlisting>
  </para>

  <para>
   Le mot clé <literal>ONLY</literal> indique que la requête s'applique seulement
   aux <structname>villes</structname>, et non pas à toutes les tables en-dessous
   de <structname>cities</structname> suivant la hiérarchie de l'héritage. Un
   grand nombre des colonnes dont nous avons déjà discutées &mdash;
   <command>SELECT</command>, <command>UPDATE</command> et
   <command>DELETE</command> &mdash; supportent le mot clé
   <literal>ONLY</literal>.
  </para>

  <para>
  Dans certain cas, vous souhaitez savoir de quelle table provient une ligne
  donnée. Une colonne système appelée <structfield>TABLEOID</structfield>
  présente dans chaque table vous donne la table d'origine&nbsp;:

<programlisting>SELECT c.tableoid, c.nom, c.altitude
FROM villes c
WHERE c.altitude &gt; 500;</programlisting>

   qui renvoie&nbsp;:

<programlisting> tableoid |   nom     | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845</programlisting>

   (Si vous essayez de reproduire cet exemple, vous obtiendrez probablement des
   OID numériques différents). En faisant une jointure avec
   <structname>pg_class</structname>, vous pourrez voir les noms de tables
   actuelles&nbsp;:

<programlisting>SELECT p.relname, v.nom, v.altitude
FROM villes v, pg_class p
WHERE v.altitude &gt; 500 and v.tableoid = p.oid;</programlisting>

   ce qui retourne&nbsp;:

<programlisting> relname   |   nom     | altitude
-----------+-----------+----------
 villes    | Las Vegas |     2174
 villes    | Mariposa  |     1953
 capitales | Madison   |      845</programlisting>
   
  </para>

  <para>
   L'héritage ne propage pas automatiquement les données des commandes
   <command>INSERT</command> ou <command>COPY</command> aux autres tables de
   la hiérarchie de l'héritage. Dans notre exemple, l'instruction
   <command>INSERT</command> suivante échouera&nbsp;:
<programlisting>INSERT INTO villes (nom, population, altitude, etat)
VALUES ('New York', NULL, NULL, 'NY');</programlisting>
   Nous pouvions espérer que les données seraient renvoyées dans la table
   <structname>capitales</structname> mais ceci n'arrivera pas&nbsp;:
   <command>INSERT</command> insère toujours dans la table indiquée. Dans
   certains cas, il est possible de rediriger l'insertion en utilisant une
   règle (voir <xref linkend="rules"/>). Néanmoins, cela n'aide pas pour le
   cas ci-dessus car la table <structname>villes</structname> ne contient pas la
   colonne <structfield>etat</structfield>, donc la commande sera rejetée avant que la
   règle ne soit appliquée.
  </para>

  <para>
   Toutes les contraintes de vérification et toutes les contraintes NOT NULL
   sur une table parent sont automatiquement héritées par les tables enfants.
   Les autres types de contraintes (uniques, clés primaires, clés étrangères)
   ne sont pas hérités.
  </para>

  <para>
   Une table peut hériter de plus d'une table parent, auquel cas elle comprend
   l'union des colonnes définies par les tables parents. Toute colonne déclarée
   dans la définition de la table enfant est ajoutée à celles-ci. Si le même nom
   de colonne apparaît dans plusieurs tables parent, alors ces colonnes sont
   <quote>assemblées</quote> pour qu'il n'existe qu'une seule colonne dans la table
   enfant. Pour être assemblées, les colonnes doivent avoir le même type de
   données, sinon une erreur survient. La colonne assemblée copiera toutes les
   contraintes de vérification provenant de toutes les définitions de colonnes
   dont elle provient, et sera marquée non NULL si une d'entre elles l'est.
  </para>

  <para>
   L'héritage d'une table se fait typiquement lors de la création de la table
   enfant en utilisant la clause <literal>INHERITS</literal> de l'instruction
   <xref linkend="sql-createtable" endterm="sql-createtable-title"/>. Sinon,
   une table déjà définie d'une façon compatible peut ajouter cette relation
   de famille en utilisantla clause <literal>INHERIT</literal> de
   <xref linkend="sql-altertable" endterm="sql-altertable-title"/>. Pour cela,
   la nouvelle table enfant doit déjà disposer des colonnes de même nom et de
   même type que les colonnes de la table parent. Elle doit aussi disposer
   des contraintes de vérification de même nom et de même expression que celles
   de la table parent. De la même façon, un lien d'héritage peut être supprimé
   à partir d'un enfant en utilisant la variante <literal>NO INHERIT</literal>
   d'<command>ALTER TABLE</command>. Ajouter et supprimer dynamiquement des liens
   d'héritage de cette façon est utile quand cette relation d'héritage est
   utilisée pour le partitionnement des tables (voir <xref
   linkend="ddl-partitioning"/>).
  </para>

  <para>
   Un moyen pratique de créer une table compatible pour devenir plus tard une
   table enfant est d'utiliser la clause <literal>LIKE</literal> dans
   <command>CREATE TABLE</command>. Ceci crée une nouvelle table avec les même
   colonnes que la table source. S'il existe des contraintes
   <literal>CHECK</literal> définies sur la table source, l'option
   <literal>INCLUDING CONSTRAINTS</literal> de <literal>LIKE</literal> devra
   être indiquée car le nouvel enfant doit avoir des contraintes correspondant
   à celles du parent pour être considéré comme compatible.
  </para>

  <para>
   Une table parent ne peut pas être supprimée tant qu'elle a des enfants.
   Les colonnes des tables enfants ne peuvent être ni supprimées ni
   modifiées si elles sont héritées d'une table parent.
   Si vous souhaitez supprimer une table et tous ces descendants, une façon
   facile de le faire est de supprimer la table parent avec l'option
   <literal>CASCADE</literal>.
  </para>

  <para>
   <xref linkend="sql-altertable" endterm="sql-altertable-title"/>
   propagera toute modification dans les définitions des colonnes et dans les
   contraintes de vérification aux héritages. De nouveau, supprimer des colonnes
   ou des contraintes sur des tables parents est seulement possible lors de
   l'utilisation de l'option <literal>CASCADE</literal>. <command>ALTER TABLE</command>
   suit les mêmes règles pour l'assemblage des colonnes dupliquées et le rejet qui
   s'appliquent lors de l'instruction <command>CREATE TABLE</command>.
  </para>

 <sect2 id="ddl-inherit-caveats">
  <title>Astuces</title>

  <para>
   Les droits d'accès des tables ne sont pas automatiquement hérités. Du coup,
   un utilisateur tentant d'accéder à une table parent doit soit avoir aussi les
   droits pour réaliser l'opération sur toutes les tables enfants soit utiliser
   le mot clé <literal>ONLY</literal>. Lors de l'ajout d'une nouvelle table
   enfant à un héritage existant, faites attention de donner tous les droits
   nécessaires dessus.
  </para>

  <para>
    Une limitation sérieuse de la fonctionnalité d'héritage est que les index
    (incluant les contraintes d'unicité) et les contraintes de clés étrangères
    s'appliquent seulement à des tables seules, pas à leurs héritiers. Ceci
    est vrai pour le côté de référence et le côté référencé d'une contrainte
    de clé étrangère. Du coup, dans les termes de l'exemple ci-dessus&nbsp;:

    <itemizedlist>
      <listitem>
        <para>
          Si nous déclarons <structname>villes</structname>.<structfield>nom</structfield> comme
           <literal>UNIQUE</literal> ou comme une clé primaire (<literal>PRIMARY
	   KEY</literal>), ceci
           n'empêchera pas la table <structname>capitales</structname> d'avoir des lignes
           avec des noms dupliqués dans <structname>villes</structname>. Et ces lignes
           dupliquées pourraient par défaut s'afficher dans les requêtes sur
           <structname>villes</structname>. En fait, par défaut,
           <structname>capitales</structname> n'aurait pas du tout de contrainte
           unique et, du coup, pourrait contenir plusieurs lignes avec le
           même nom. Vous pouvez ajouter une contrainte d'unicité à
           <structname>capitales</structname> mais ceci n'empêcherait pas la duplication
           comparée à <structname>villes</structname>.
        </para>
      </listitem>

      <listitem>
        <para>
          De façon similaire, si nous devions spécifier que
          <structname>villes</structname>.<structfield>nom</structfield> fait référence
          (<literal>REFERENCES</literal>) une autre table, cette contrainte ne serait
          pas automatiquement propager à <structname>capitales</structname>. Dans ce cas,
          vous pourriez contourner ceci en ajoutant manuellement la même
          contrainte <literal>REFERENCES</literal> à <structname>capitales</structname>.
        </para>
      </listitem>

      <listitem>
        <para>
          Spécifier que la colonne d'une autre table <literal>REFERENCES
          villes(nom)</literal> autoriserait l'autre table à contenir les noms des
          villes mais pas les noms des capitales. Il n'existe pas de bons
          contournements pour ce cas.
        </para>
      </listitem>
    </itemizedlist>

    Ces déficiences seront probablement corrigées dans une version future mais
    en attendant, un soucis considérable est nécessaire dans la décision de
    l'utilité de l'héritage pour votre problème.
  </para>

  <note>
   <title>Obsolète</title>
   <para>
     Dans les précédentes versions de <productname>PostgreSQL</productname>, le
     comportement par défaut n'était pas d'inclure les tables enfants dans les
     requêtes. Ceci facilitait les erreurs et est en plus une violation du
     standard SQL. Vous pouvez obtenir le comportement des versions antérieures
     à la 7.1 en désactivant le paramètre <xref linkend="guc-sql-inheritance"/>.
   </para>
  </note>

   </sect2>
  </sect1>

  <sect1 id="ddl-partitioning">
   <title>Partitionnement</title>

   <indexterm>
    <primary>partitionnement</primary>
   </indexterm>

   <indexterm>
    <primary>table</primary>
    <secondary>partitionnement</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> offre un support basique du
    partitionnement de table. Cette section décrit pourquoi et comment vous
    pouvez implémenter le partitionnement dans la conception de votre base
    de données.
   </para>

   <sect2 id="ddl-partitioning-overview">
     <title>Aperçu</title>

   <para>
    Le partitionnement fait référence à la division logique d'une grosse table
    en plusieurs parties physiques. Le partitionnement apporte plusieurs
    bénéfices&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      Les performances des requêtes peuvent être significativement améliorées
      dans certaines situations, particulièrement lorsque la plupart des lignes
      les plus utilisées d'une table sont sur une seule partition ou sur un
      petit nombre de partitions. Le partitionnement se substitue aux colonnes
      principales des index, réduit la taille des index et fait en sorte que les
      parties les plus utilisées de l'index tiennent en mémoire.
     </para>
    </listitem>

    <listitem>
     <para>
      Quand les requêtes ou les mises à jour accèdent à un gros pourcentage
      d'une seule partition, les performances peuvent être grandement améliorées
      en prenant avantage des parcours séquentiels sur cette
      partition plutôt que d'utiliser un index et des lectures aléatoires sur
      toute la table.
     </para>
    </listitem>

    <listitem>
     <para>
      Les grosses charges de données et les suppressions peuvent s'accomplir en
      ajoutant ou en supprimant des partitions si ce besoin est pris en compte
      dans la conception du partitionnement.
      <command>ALTER TABLE</command> est bien plus rapide. Cela évite aussi
      entièrement la surcharge du <command>VACUUM</command> causé par un
      <command>DELETE</command> massif.
     </para>
    </listitem>

    <listitem>
     <para>
      Les données peu utilisées peuvent être déplacées sur un média peu cher et
      lent.
     </para>
    </listitem>
   </itemizedlist>

    Les bénéfices seront normalement intéressants quand une table sera
    suffisamment importante. Le point exact où une table bénéficierait d'un
    partitionnement dépend de l'application bien qu'une règle de base est que
    la taille de la table ne doit pas dépasser la mémoire physique du serveur.
   </para>

   <para>
    Actuellement, <productname>PostgreSQL</productname> supporte le
    partitionnement via l'héritage des tables. Chaque partition doit être
    créée comme une table enfant d'une seule table parent. La table parent
    elle-même est habituellement vide&nbsp;; elle existe seulement pour
    représenter l'ensemble complet des données. Vous devez être familier
    avec l'héritage (voir <xref linkend="ddl-inherit"/>) avant de tenter
    d'implanter le partitionnement.
   </para>

   <para>
    Les formes suivantes de partitionnement peuvent être implantées dans
    <productname>PostgreSQL</productname>&nbsp;:

    <variablelist>
     <varlistentry>
      <term>Partitionnement de groupe</term>

      <listitem>
       <para>
        La table est partitionnée en <quote>groupes</quote> définis par une
	colonne clé ou par un ensemble de colonnes, sans intersection dans
	les ensembles de valeurs affectées aux différentes partition. Par
	exemple, il est possible de partitionner par date ou par ensemble
	d'identifiants pour des objets métier particuliers.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Partitionnement de liste</term>

      <listitem>
       <para>
        La table est partitionnée en listant explicitement les valeurs clés
	apparaissant dans chaque partition.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

   </para>
   </sect2>

   <sect2 id="ddl-partitioning-implementation">
     <title>Implanter le partitionnement</title>

    <para>
     Pour configurer une table partitionnée, faites ce qui suit&nbsp;:
     <orderedlist spacing="compact">
      <listitem>
       <para>
        Créez la table <quote>maître</quote> à partir de laquelle toutes les
	partitions vont hériter.
       </para>
       <para>
        Cette table ne contiendra pas de données. Ne définissez pas de contraintes
	de vérification sur cette table sauf si vous avez l'intention de les
	appliquer sur toutes les partitions. Il n'y a non plus aucune raison de
	définir des index ou des contraintes d'unicité sur elle.
       </para>
      </listitem>

      <listitem>
       <para>
        Créez plusieurs tables <quote>filles</quote> qui héritent chacune de la
	table maître. Normalement, ces tables n'ajouteront pas de colonnes
	à l'ensemble hérité du maître.
       </para>

       <para>
        Nous ferons référence aux tables enfants par le mot partition bien
	qu'elles se comportent comme de vraies tables <productname>PostgreSQL</productname>.
       </para>
      </listitem>

      <listitem>
       <para>
        Ajoutez les contraintes de tables aux tables partition pour définir
	les valeurs des clés autorisées dans chaque partition.
       </para>

       <para>
        Voici quelques exemples typiques&nbsp;:
<programlisting>CHECK ( x = 1 )
CHECK ( comté IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( ID &gt;= 100 AND ID &lt; 200 )</programlisting>
        Assurez-vous que les contraintes garantissent qu'il n'y aura pas
	d'intersection entre les valeurs clés permises dans les différentes
	partitions. Une erreur commune est de configurer des contraintes
	d'échelle de cette façon&nbsp;:
<programlisting>CHECK ( comté BETWEEN 100 AND 200 )
CHECK ( comté BETWEEN 200 AND 300 )</programlisting>
        Ceci est mauvais car il n'est pas aisé de savoir à quelle partition
	appartient la clé 200.
       </para>

       <para>
        Notez qu'il n'y a aucune différence dans la syntaxe BETWEEN et le
	partitionnement de listes&nbsp;; ces termes sont seulement descriptifs.
       </para>
      </listitem>

      <listitem>
       <para>
        Pour chaque partition, créez un index sur la (ou les) colonne(s) clé(s),
        ainsi que tout autre index nécessaire (l'index clé n'est pas vraiment
	nécessaire mais, dans la plupart des scénarios, il est utile. Si vous
	avez l'intention que les valeurs clés soient uniques, alors vous devez
	toujours créer une contrainte d'unicité ou une clé primaire pour chaque
	partition.)
       </para>
      </listitem>

      <listitem>
       <para>
        En option, définissez une règle ou un déclencheur pour rediriger les
	modifications de la table maître vers la partition appropriée.
       </para>
      </listitem>

      <listitem>
       <para>
        Assurez-vous que le paramètre de configuration <xref
	linkend="guc-constraint-exclusion"/> est activé dans
	<filename>postgresql.conf</filename>. Sans ce dernier, les requêtes ne sont
	pas optimisées.
       </para>
      </listitem>

     </orderedlist>
    </para>

    <para>
     Par exemple, supposons que nous construisons une base de données pour une
     grande société de glaces. La compagnie mesure les piques de températures
     chaque jour ainsi que les ventes de glaces dans chaque région. À la base,
     nous voulons une table comme ceci&nbsp;:

<programlisting>CREATE TABLE mesure (
    id_ville        int not null,
    date_trace      date not null,
    temperature     int,
    ventes          int
);</programlisting>

     Nous savons que la plupart des requêtes accèdent seulement à la dernière
     semaine, au dernier mois ou au dernier trimestre des données car l'utilisation
     principale de cette table sera de préparer des rapports en ligne pour la
     gestion. Pour réduire le nombre de données anciennes devant être restaurées,
     nous décidons de conserver seulement les trois dernières années. Au début
     de chaque mois, nous supprimerons les données de l'ancien mois.
    </para>

    <para>
     Dans cette situation, nous pouvons utiliser le partitionnement pour nous
     aider dans nos différents besoins pour la table mesure. En suivant les
     étapes indiquées ci-dessus, le partitionnement peut être configuré de la
     façon suivante&nbsp;:
    </para>

    <para>
     <orderedlist spacing="compact">
      <listitem>
       <para>
        La table maître est la table <structname>mesure</structname>, déclarée exactement
	comme ci-dessous.
       </para>
      </listitem>

      <listitem>
       <para>
        Une partition est alors créée pour chaque mois actif&nbsp;:

<programlisting>CREATE TABLE mesure_a2004m02 ( ) INHERITS (mesure);
CREATE TABLE mesure_a2004m03 ( ) INHERITS (mesure);
...
CREATE TABLE mesure_a2005m11 ( ) INHERITS (mesure);
CREATE TABLE mesure_a2005m12 ( ) INHERITS (mesure);
CREATE TABLE mesure_a2006m01 ( ) INHERITS (mesure);</programlisting>

        Chaque partition est une table complète avec leur propre droits mais
	leur définition est héritée de la table <structname>mesure</structname>.
       </para>

       <para>
	Ceci résoud un de nos problèmes&nbsp;: supprimer les anciennes données.
	Chaque mois, tout ce que nous aurons à faire est un <command>DROP
	TABLE</command> sur l'ancienne table enfant et créez une nouvelle table
	enfant pour les données du nouveau mois.
       </para>
      </listitem>

      <listitem>
       <para>
	Nous devons ajouter des contraintes de table qui ne permettent pas
	l'intersection des ensembles de données, donc notre script de création
	de table devient&nbsp;:

<programlisting>CREATE TABLE mesure_a2004m02 (
    CHECK ( date_trace &gt;= DATE '2004-02-01' AND date_trace &lt; DATE '2004-03-01' )
) INHERITS (mesure);
CREATE TABLE mesure_a2004m03 (
    CHECK ( date_trace &gt;= DATE '2004-03-01' AND date_trace &lt; DATE '2004-04-01' )
) INHERITS (mesure);
...
CREATE TABLE mesure_a2005mm11 (
    CHECK ( date_trace &gt;= DATE '2005-11-01' AND date_trace &lt; DATE '2005-12-01' )
) INHERITS (mesure);
CREATE TABLE mesure_a2005mm12 (
    CHECK ( date_trace &gt;= DATE '2005-12-01' AND date_trace &lt; DATE '2006-01-01' )
) INHERITS (mesure);
CREATE TABLE mesure_a2006mm01 (
    CHECK ( date_trace &gt;= DATE '2006-01-01' AND date_trace &lt; DATE '2006-02-01' )
) INHERITS (mesure);</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Nous avons probablement besoin d'index sur les colonnes clés&nbsp;:

<programlisting>CREATE INDEX mesure_a2004m02_date_trace ON mesure_a2004m02 (date_trace);
CREATE INDEX mesure_a2004m03_date_trace ON mesure_a2004m03 (date_trace);
...
CREATE INDEX mesure_a2005m11_date_trace ON mesure_a2005m11 (date_trace);
CREATE INDEX mesure_a2005m12_date_trace ON mesure_a2005m12 (date_trace);
CREATE INDEX mesure_a2006m01_date_trace ON mesure_a2006m01 (date_trace);</programlisting>

        Nous choisissons de ne pas en ajouter d'autres pour l'instant.
       </para>
      </listitem>

      <listitem>
       <para>
        Si les données seront seulement ajoutées dans la dernière partition,
	nous pouvons configurer une règle très simple pour insérer des données.
	Nous devons la redéfinir chaque mois pour qu'elle pointe toujours vers
	la partition en cours.

<programlisting>CREATE OR REPLACE RULE partition_actuelle_mesure AS
ON INSERT TO mesure
DO INSTEAD
    INSERT INTO mesure_a2006m01 VALUES ( NEW.id_ville,
                                         NEW.date_trace,
                                         NEW.temperature,
                                         NEW.ventes );</programlisting>

        Nous pourrions vouloir insérer des données et que le serveur situe
	automatiquement la partition où cette ligne doit être ajoutée. Nous
	pouvons le faire avec un ensemble de règles plus complexes.

<programlisting>CREATE RULE mesure_insert_a2004m02 AS
ON INSERT TO mesure WHERE
    ( date_trace &gt;= DATE '2004-02-01' AND date_trace &lt; DATE '2004-03-01' )
DO INSTEAD
    INSERT INTO mesure_a2004m02 VALUES ( NEW.id_ville,
                                         NEW.date_trace,
                                         NEW.temperature,
                                         NEW.ventes );
...
CREATE RULE mesure_insert_a2005m12 AS
ON INSERT TO mesure WHERE
    ( date_trace &gt;= DATE '2005-12-01' AND date_trace &lt; DATE '2006-01-01' )
DO INSTEAD
    INSERT INTO mesure_a2005m12 VALUES ( NEW.id_ville,
                                         NEW.date_trace,
                                         NEW.temperature,
                                         NEW.ventes );
CREATE RULE mesure_insert_a2006m01 AS
ON INSERT TO mesure WHERE
    ( date_trace &gt;= DATE '2006-01-01' AND date_trace &lt; DATE '2006-02-01' )
DO INSTEAD
    INSERT INTO mesure_a2006m01 VALUES ( NEW.id_ville,
                                         NEW.date_trace,
                                         NEW.temperature,
                                         NEW.ventes );</programlisting>

        Notez que la clause <literal>WHERE</literal> de chaque règle correspond
	exactement à la contrainte de vérification pour cette partition.
       </para>
      </listitem>
     </orderedlist>
    </para>

    <para>
     Comme nous pouvons le voir, un schéma complexe de partitionnement demanderait
     un ajout substentiel de DDL. Dans l'exemple ci-dessus, nous pouvons créer une
     nouvelle partition chaque mois, donc il est conseillé d'écrire un script qui
     génère automatiquement la DDL requise.
    </para>


   <para>
    Le partitionnement peut aussi se faire en utilisant une vue <literal>UNION
    ALL</literal>&nbsp;:

<programlisting>
CREATE VIEW mesure AS
          SELECT * FROM measure_a2004m02
UNION ALL SELECT * FROM measure_a2004m03
...
UNION ALL SELECT * FROM measure_a2005m11
UNION ALL SELECT * FROM measure_a2005m12
UNION ALL SELECT * FROM measure_a2006m01;
</programlisting>

    Néanmoins, le besoin de recréer la vue ajoute une étape supplémentaire à
    l'ajout et à la suppression de partitions individuelles de l'ensemble
    de données.
   </para>
   </sect2>

   <sect2 id="ddl-partitioning-managing-partitions">
   <title>Gérer des partitions</title>

   <para>
     Généralement, l'ensemble des partitions établies lors de la définition
     initiale de la table n'a pas pour but de rester statique. Un besoin
     habituel est de supprimer les anciennes partitions de données et
     un autre est d'ajouter périodiquement de nouvelles partitions pour
     les nouvelles données. Un des avantages les plus importants du
     partitionnement est précisément qu'il permet une exécution pratiquement
     instantanée de cette tâche, autrement bien plus difficile. Cela se
     fait en manipulant la structure de la partition, plutôt qu'en déplaçant
     physiquement de grosses quantités de données.
   </para>

   <para>
     L'option la plus simple pour supprimer des anciennes données est de
     supprimer la partition qui n'est plus nécessaire&nbsp;:
<programlisting>DROP TABLE mesure_a2003m02;
</programlisting>
     Ceci peut supprimer très rapidement plusieurs millions d'enregistrements
     car il n'a pas à supprimer chaque enregistrement.
   </para>

   <para>
     Une autre option, souvent préférable, est de supprimer la partition de la
     table partitionnée mais de conserver l'accès à la table directement&nbsp;:
<programlisting>ALTER TABLE mesure_a2003m02 NO INHERIT mesure;
</programlisting>
     Ceci permet la réalisation d'opérations plus poussées sur les données
     avant qu'elle ne soit supprimée. Par exemple, c'est souvent le bon moment
     pour sauvegarder les données en utilisant <command>COPY</command>,
     <application>pg_dump</application> ou d'autres outils. C'est aussi le temps
     pour agréger des données en des formats plus petits, réaliser d'autres
     opérations sur les données ou créer des rapports.
   </para>

   <para>
     De façon similaire, nous pouvons ajouter une nouvelle partition pour
     gérer les nouvelles données. Nous pouvons créer une partition vide dans une
     table partitionnée comme les partitions individuelles que nous avons créé
     ci-dessus.

<programlisting>
CREATE TABLE mesure_a2006m02 (
    CHECK ( date_trace &gt;= DATE '2006-02-01' AND date_trace &lt; DATE '2006-03-01' )
    ) INHERITS (mesure);
</programlisting>

     Comme alternative, il est quelques fois plus intéressant de créer la
     nouvelle table en dehors de la structure de partitionnement et de
     la transformer en une partition adéquate plus tard. Cela permet de
     charger les données, vérifier et transformer avant son apparition
     dans la table partitionnée.

<programlisting>
CREATE TABLE mesure_a2006m02
  (LIKE mesure INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE mesure_a2006m02 ADD CONSTRAINT a2006m02
   CHECK ( date_trace &gt;= DATE '2006-02-01' AND date_trace &lt; DATE '2006-03-01' );
\copy mesure_a2006m02 from 'mesure_a2006m02'
-- travail de préparation des autres données
ALTER TABLE mesure_a2006m02 INHERIT mesure;
</programlisting>
    </para>
   </sect2>

   <sect2 id="ddl-partitioning-constraint-exclusion">
   <title>Partitionnement et exclusion de contrainte</title>

   <indexterm>
    <primary>exclusion de contrainte</primary>
   </indexterm>

   <para>
    L'<firstterm>exclusion de contrainte</firstterm> est une technique d'optimisation des
    requêtes pour améliorer les performances pour les tables partitionnées de la
    façon décrite ci-dessus. En exemple&nbsp;:

<programlisting>SET constraint_exclusion = on;
SELECT count(*) FROM mesure WHERE date_trace &gt;= DATE '2006-01-01';</programlisting>

    Sans exclusion de contrainte, la requête ci-dessus devrait parcourir chacune
    des partitions de la table <structname>mesure</structname>. Avec l'exclusion de
    contrainte activée, le planificateur examinera les contraintes de chaque
    partition et tentera de prouver que la partition n'a pas besoin d'être
    parcourue parce qu'elle ne pourrait pas contenir de lignes correspondant à
    la clause <literal>WHERE</literal> de la requête. Quand le planificateur peut le
    prouver, il exclut la partition du plan de requête.
   </para>

   <para>
    Vous pouvez utiliser la commande <command>EXPLAIN</command> pour afficher la
    différence avec entre un plan avec <varname>constraint_exclusion</varname> à on et
    un plan avec ce paramètre à off. Un plan typique par défaut pour ce type de
    table est&nbsp;:

<programlisting>SET constraint_exclusion = off;
EXPLAIN SELECT count(*) FROM mesure WHERE date_trace &gt;= DATE '2006-01-01';

                                          QUERY PLAN
-------------------------------------------------------------------------------------
 Aggregate  (cost=158.66..158.68 rows=1 width=0)
   ->  Append  (cost=0.00..151.88 rows=2715 width=0)
         ->  Seq Scan on mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
         ->  Seq Scan on mesure_aa04mm02 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
         ->  Seq Scan on mesure_aa04mm03 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
...
         ->  Seq Scan on mesure_aa05mm12 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
         ->  Seq Scan on mesure_aa06mm01 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)</programlisting>

    Certaines ou toutes les partitions pourraient utiliser des parcours d'index
    à la place de parcours séquentiels de la table complète mais le fait est
    qu'il n'est pas besoin de parcourir les anciennes partitions pour répondre
    à cette requête. Quand nous activons l'exclusion de contrainte, nous
    obtenons un plan réduit significativement et qui nous renvoie la même
    réponse&nbsp;:

<programlisting>SET constraint_exclusion = on;
EXPLAIN SELECT count(*) FROM mesure WHERE date_trace &gt;= DATE '2006-01-01';
                                          QUERY PLAN
-------------------------------------------------------------------------------------
 Aggregate  (cost=63.47..63.48 rows=1 width=0)
   ->  Append  (cost=0.00..60.75 rows=1086 width=0)
         ->  Seq Scan on mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)
         ->  Seq Scan on mesure_aa06mm01 mesure  (cost=0.00..30.38 rows=543 width=0)
               Filter: (date_trace &gt;= '2006-01-01'::date)</programlisting>
   </para>

   <para>
    Notez que l'exclusion de contraintes est seulement piloté par les contraintes
    <literal>CHECK</literal>, pas par la présence d'index. Du coup, il n'est pas
    nécessaire de définir des index sur les colonnes clés. Le fait qu'un index
    ait besoin d'être créé pour une partition donnée  dépend si vous vous
    attendez à ce que les requêtes qui parcourent la partition parcoureront
    aussi généralement une grande partie de la partition ou seulement une petite
    partie. Un index sera utile dans le dernier cas, pas dans le premier.
   </para>
   </sect2>

   <sect2 id="ddl-partitioning-caveats">
   <title>Conseils</title>

   <para>
    Voici quelques conseils s'appliquant aux tables partitionnées&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      Actuellement, il n'existe pas de moyen de vérifier que toutes les
      contraintes de vérification (<literal>CHECK</literal>) sont mutuellement
      exclusives. Le concepteur de la base de données doit faire attention.
     </para>
    </listitem>

    <listitem>
     <para>
      Il n'existe pas de façon simple de spécifier les lignes ne devant pas être
      insérées dans la table maître. Une contrainte <literal>CHECK (false)</literal>
      sur la table maître sera héritée par toutes les tables filles et ne peut donc
      pas être utilisée dans ce but. Une possibilité revient à configurer un
      déclencheur <literal>ON INSERT</literal> sur la table maître qui renvoie toujours
      une erreur (sinon, un déclencheur peut être utilisé pour rediriger les
      données dans la bonne table fille au lieu d'utiliser un ensemble de règles
      comme suggéré ci-dessus).
     </para>
    </listitem>
   </itemizedlist>
   </para>

   <para>
    Quelques conseils qui s'appliquent aux contraintes d'exclusion&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      L'exclusion de contrainte fonctionne seulement quand la clause
      <literal>WHERE</literal> de la requête contient des constantes. Une requête avec
      paramètre ne sera pas optimisée car le planificateur ne sait pas quelles
      partitions la valeur du paramètre pourrait sélectionner à son exécution.
      Pour la même raison, les fonctions <quote>stables</quote> comme
      <function>CURRENT_DATE</function> doivent être évitées.
     </para>
    </listitem>

    <listitem>
     <para>
      Évitez les comparaisons inter-type dans les contraintes <literal>CHECK</literal>
      car le planificateur échouera à prouver que de telles conditions sont
      fausses. Par exemple, la contrainte suivante fonctionnera si
      <varname>x</varname> est une colonne de type <type>integer</type>, mais
      pas si <varname>x</varname> est un <type>bigint</type>&nbsp;:
<programlisting>CHECK ( x = 1 )</programlisting>
      Pour une colonne <type>bigint</type>, nous devons utiliser une contrainte
      comme celle-ci&nbsp;:
<programlisting>CHECK ( x = 1::bigint )</programlisting>
      Le problème n'est pas limité au type <type>bigint</type> &mdash; il peut
      survenir quand le type de données par défaut de la constante ne correspond
      pas au type de données de la colonne avec laquelle elle est comparée. Les
      comparaisons inter-type dans les requêtes fournies sont habituellement
      gérées, mais pas dans les conditions <literal>CHECK</literal>.
     </para>
    </listitem>

    <listitem>
     <para>
      Toutes les constraintes de toutes les partitions de la table maître sont
      considérées pour l'exclusion de contraintes, donc un grand nombre de
      partitions a tendance à augmenter considérablement le temps de
      plannification de la requête.
     </para>
    </listitem>

    <listitem>
     <para>
      N'oubliez pas que vous avez toujours besoin d'exécuter <command>ANALYZE</command>
      individuellement sur chaque partition. Une commande comme
<programlisting>ANALYZE mesure;</programlisting>
      traitera seulement la table maître.
     </para>
    </listitem>

   </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-others">
  <title>Autres objets de la base de données</title>

  <para>
   Les tables sont les objets centraux dans une structure de base de
   données relationnelles. Mais ce ne sont pas les seuls objets qui
   existent dans une base de données. Plusieurs autres types d'objets
   peuvent être créés afin de rendre l'utilisation et la gestion
   des données plus efficace ou pratique. Ils ne seront pas abordés
   dans ce chapitre mais nous vous en faisons une liste ici pour que
   vous soyez informés de ce qui est possible.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Vues
    </para>
   </listitem>

   <listitem>
    <para>
     Fonctions et opérateurs
    </para>
   </listitem>

   <listitem>
    <para>
     Types de données et domaines
    </para>
   </listitem>

   <listitem>
    <para>
     Déclencheurs et règles de réécriture
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Des informations détaillées sur ces sujets apparaissent dans la <xref
   linkend="server-programming"/>.
  </para>
 </sect1>

 <sect1 id="ddl-depend">
  <title>Gestion des dépendances</title>

  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <para>
   Lorsque vous créez des structures de base complexes impliquant
   beaucoup de tables avec des contraintes de clés étrangères, des
   vues, des déclencheurs, des fonctions, etc, vous créez implicitement
   un filet de dépendances entre les objets.
   Par exemple, une table avec une contrainte de clé étrangère dépend
   de la table à laquelle elle fait référence.
  </para>

  <para>
   Pour garantir l'intégrité de la structure entière de la base,
   <productname>PostgreSQL</productname> vérifie que vous ne pouvez
   pas effacer des objets dont d'autres objets dépendent. Par
   exemple, la tentative d'effacer la table des produits que nous
   avons utilisé dans la <xref linkend="ddl-constraints-fk"/>, avec la
   table des commandes qui en dépend, donnera un message d'erreur
   comme celui-ci&nbsp;:
<screen>DROP TABLE produits;

NOTICE:  constraint commandes_no_produit_fkey on table commandes depends on table
produits
ERROR:  cannot drop table produits because other objects depend on it
HINT:  Use DROP ... CASCADE to drop the dependent objects too.</screen>
   Le message d'erreur contient un indice utile&nbsp;: si vous ne souhaitez
   pas effacer les objets dépendants individuellement, vous pouvez
   lancer
<screen>DROP TABLE produits CASCADE;</screen>
   et tous les objets seront effacés. Dans ce cas, cela n'effacera pas
   la table des commandes mais seulement la contrainte de clé étrangère
   (si vous voulez vérifier ce que <command>DROP ... CASCADE</command> fera,
   lancez <command>DROP</command> sans <literal>CASCADE</literal> et lisez les messages
   <literal>NOTICE</literal>).
  </para>

  <para>
   Toutes les commandes de suppression dans
   <productname>PostgreSQL</productname> supportent l'utilisation de
   <literal>CASCADE</literal>. Bien sûr, la nature des dépendances
   varie avec la nature des objets. Vous pouvez aussi écrire
   <literal>RESTRICT</literal> au lieu de <literal>CASCADE</literal>
   pour obtenir le comportement par défaut qui est d'empêcher les
   suppressions d'objets sur lesquelles dépendent d'autres objets.
  </para>

  <note>
   <para>
    D'après le standard SQL, spécifier
    <literal>RESTRICT</literal> ou <literal>CASCADE</literal> est
    requis. Aucun système de base de donnée ne force cette règle de cette
    manière actuellement mais le choix du comportement par défaut,
    <literal>RESTRICT</literal> ou <literal>CASCADE</literal>,
    varie suivant le système.
   </para>
  </note>

  <note>
   <para>
    Les dépendances de contraintes de clés étrangères et de colonnes
    en série des versions de <productname>PostgreSQL</productname>
    antérieures à 7.3 ne seront <emphasis>pas</emphasis> maintenues ou
    créées pendant le processus de mise à jour. Tout autre type de
    dépendance sera proprement créé pendant une mise à jour à partir d'une
    base de données antérieure à la 7.3.
   </para>
  </note>
 </sect1>

</chapter>
