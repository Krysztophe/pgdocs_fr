<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- SAS 20060728 : Traduction initiale -->
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" >

<article id="postgresqlconf" lang="fr">
 <articleinfo>
  <title>Fichier postgresql.conf et guide de configuration utilisateur générale
(<foreignphrase>Global User Configuration (GUC)</foreignphrase>) annotés</title>
  <subtitle>PostgreSQL 7.4.x</subtitle>
</articleinfo>

<sect1>
<title>Connexions et authentification</title>

<sect2>
<title>Paramètres de connexion</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>tcpip_socket</entry>
  <entry>true, false</entry>
  <entry>none</entry>
  <entry>false</entry>
  <entry>non</entry>
  <entry>-i</entry>
  <entry>
  Positionné à true, le serveur accepte les connexions TCP/IP. Dans le cas
  contraire, seules les connexions par la socket de domaine Unix sont
autorisées.
  </entry>
  <entry>
  Sauf dans le cas d'un serveur de test, ce paramètre doit probablement être
  positionné à true. Il est recommandé de faire cela
  <emphasis>après</emphasis> avoir configuré le fichier pg_hba.conf, pour
  sécuriser les accès.
  </entry>
 </row>
 <row>
  <entry>max_connections</entry>
  <entry>2 à Int Max</entry>
  <entry>14ko RAM</entry>
  <entry>32</entry>
  <entry>Non</entry>
  <entry>-N #</entry>
  <entry>
  Nombre maximum de connexions concurrentes à un serveur de bases de données.
  La valeur par défaut est 32 (à moins qu'elle n'ait été modifiée lors de
  la construction du serveur).
  </entry>
  <entry>
  Paramètre important. &Agrave; conserver le plus bas possible pour la
  configuration de l'application. En combinaison avec une application web
  à connexions persistantes, il doit être possible de l'abaisser vers 10-16.
  </entry>
 </row>
 <row>
  <entry>superuser_reserved_connections</entry>
  <entry>0 à max_connections - 1</entry>
  <entry>Reduces regular connections available</entry>
  <entry>2</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Nombre de connexions réservées aux superutilisateurs PostgreSQL. Au plus
  max_connections connexions peuvent être actives simultanément. Lorsque
  le nombre de connexions concurrentes atteint max_connections moins
  superuser_reserved_connections, seules les connexions de superutilisateurs
  sont encore autorisées.
  </entry>
  <entry>
  Cela protège l'accès des superutilisateurs en cas d'engorgement de la base.
  Ce paramètre ne doit être positionné à 0 que lorsqu'il est certain que
  toutes les connexions ne sont jamais utilisées. (NDR&nbsp;: Je positionne
  souvent ce paramètre à 1, puisque je ne me connecte en superutilisateur
  à la base qu'en cas de problème.) 
  </entry>
 </row>
 <row>
  <entry>port</entry>
  <entry>129 à 32768</entry>
  <entry>none</entry>
  <entry>5432</entry>
  <entry>Non</entry>
  <entry>-p #</entry>
  <entry>
  Le port TCP sur lequel le serveur écoute.
  </entry>
  <entry>
  <para>
  Le changement du port PostgreSQL peut être une protection contre les vers
  de bases et les <i>script kiddies</i>. Néanmoins, il ne faudra pas oublier
  de donner l'option de port à <emphasis>tous</emphasis> les logiciels et
  bibliothèques effectuant une connexion, ce qui peut s'avérer pénible.
  </para>
  </entry>
 </row>
 <row>
  <entry>unix_socket_directory</entry>
  <entry></entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Non</entry>
  <entry>-k $</entry>
  <entry>
  Répertoire du socket de domaine Unix sur lequel le serveur écoute
  les connections de clients. Par défaut, c'est /tmp, mais le paramètre
  peut être modifié à la compilation.
  </entry>
  <entry>
  Ces options s'appliquent aux connexions UDP vers le serveur, utilisées en
  général uniquement à partir d'une console sur le serveur. (NDR&nbsp;:
  Comme je considère les connexions UDP non sécurisées, je les désactive.
  Je n'ai donc pas de recommendation particulière.)
  </entry>
 </row>
 <row>
  <entry>unix_socket_group</entry>
  <entry></entry>
  <entry></entry>
  <entry>''</entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
  Groupe propriétaire du socket de domaine Unix. (L'utilisateur propriétaire
  de ce socket est toujours celui qui démarre le serveur.) Combiné avec l'option
  UNIX_SOCKET_PERMISSIONS, ce paramètre peut être utilisé comme mécanisme
  supplémentaire de contrôle des accès pour ce type de socket. Par défaut, 
  c'est une chaîne vide, soit le groupe par défaut de l'utilisateur.
  </entry>
 </row>
 <row>
  <entry>unix_socket_permissions</entry>
  <entry></entry>
  <entry></entry>
  <entry>0777</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  <para>Permissions d'accès au socket de domaine Unix. Les sockets de domaine
Unix
  utilisent le système habituel de gestion des permissions des systèmes de 
  fichiers Unix. La valeur de l'option doit être précisée sous la forme
numérique
  acceptée par les outils système chmod et umask. L'utilisation du format 
  octal impose un 0 (zéro) en début de nombre.
  </para>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Sécurité et authentification</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>authentication_timeout</entry>
  <entry>1-600 sec</entry>
  <entry></entry>
  <entry>60</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Temps maximum laissé à un client pour réussir l'authentification, en secondes.
  Si un client potentiel n'a pas terminé la séquence d'authentification
  pendant ce temps, le serveur met fin à la connexion. Cela permet 
  d'éviter qu'un client bloqué n'occupe indéfiniment une connexion.
  Cette option ne peut être positionnée qu'au démarrage ou dans le fichier
  postgresql.conf.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>ssl</entry>
  <entry>true, false</entry>
  <entry>Voir les notes</entry>
  <entry>false</entry>
  <entry>Non</entry>
  <entry>-l</entry>
  <entry>Autoriser les connexions SSL</entry>
  <entry>
  SSL chiffre le traffic sur le post TCP/IP de sorte que les données
  transférées ne puissent pas être lues normallement. Du fait du chiffrement,
  cela implique une charge intense du CPU à la fois sur le client et le
  serveur. Cela peut aussi accroître la taille des données transférée.
  Néanmoins, SSL peut être difficile
  à configurer, et tout les clients ne supportent pas l'accès SSL.
  </entry>
 </row>
 <row>
  <entry>krb_server_keyfile</entry>
  <entry></entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Positionne l'implantation du fichier de clés du serveur Kerberos.
  </entry>
  <entry>
  Utilisé uniquement pour l'authentification Kerberos des utilisateurs.
  </entry>
 </row>
 <row>
  <entry>virtual_host</entry>
  <entry></entry>
  <entry></entry>
  <entry>''</entry>
  <entry>No</entry>
  <entry>-h x</entry>
  <entry>
  Positionne le nom d'hôte ou l'adresse TCP/IP sur lequel/laquelle le
  postmaster écoute les connexions des applications clientes. Par défaut,
  écoute sur toutes les adresses configurées (y compris localhost).
  </entry>
  <entry>
  Essentiel pour les bases sur un réseau sécurisé comprenant une DMZ, ou
  lorsque le serveur de bases de données possède une adresse TCP/IP publique
  et une privée.
  </entry>
 </row>
 <row>
  <entry>db_user_namespace</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Permet les noms d'utilisateur par base de données. Désactivé par défaut.
  default.
  </entry>
  <entry>
  Par défaut, les utilisateurs peuvent, avec PostgreSQL, se connecter à
  n'importe quelle base. Dans certains cas, ce scénario n'est pas acceptable.
  Dans de tels cas, il est possible d'utiliser cette option. Cette
  fonctionnalité s'entend comme une mesure intérmédiaire en attendant une
  solution complète. Cette option sera supprimée par la suite.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Utilisation des ressources</title>

<sect2>
<title>Mémoire</title>

<note>
 <para>
  L'augmentation de la plupart de ces paramètres impose de règler les options
  du noyau système à la valeur de la mémoire autorisée par processus ou par
  utilisateur. La documentation en ligne donne des informations sur les
  commandes en fonction des systèmes d'exploitation. Sauf indication contraire,
  toutes les options mémoire s'additionnent pour déterminer la quantité totale
  de mémoire utilisée par PostgreSQL.
 </para>
</note>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>shared_buffers</entry>
  <entry>16 à Int Max</entry>
  <entry>8K RAM</entry>
  <entry>64</entry>
  <entry>Non</entry>
  <entry>-B x</entry>
  <entry>
  Positionne le nombre de tampons de mémoire partagée utilisé par le 
  serveur de bases de données. Le minimum est 2 X max_connections.
  </entry>
  <entry>
  <para>
  Positionne la taille du tampon mémoire de PostgreSQL où les requêtes sont
  stockées avant d'être passées au tampon noyau du système. Ce n'est qu'une
  zone de stockage, et <emphasis>non</emphasis> le total de la taille
  mémoire disponible pour le serveur. De ce fait, il est fortement
  déconseillé de positionner ce nombre à une part importante de la RAM, cela
  ayant des conséquences désastreuses sur les performances avec beaucoup de
  systèmes d'exploitation. Les membres de la liste de diffusion
  pgsql-performance ont abouti à une échelle utile se situant entre 1000 et
  6000, fonction de la RAM, de la taille de la base de données et du nombre de
  requêtes concurrentes. Pour les serveurs qui disposent d'une grande quantité
  de RAM (supérieure à 1 Go), l'augmentation de ce paramètre vers 6 à 15% de
  la RAM disponible a donné de bons résultats dans la plupart des cas.
  L'analyse réelle du meilleur paramétrage n'est pas exactement comprise,
  et l'expérience plus que le calcul permet l'ajustement de ce paramètre.
  </para>
  <para>
  Une règle empirique consiste à observer l'utilisation de la mémoire partagée
  par PostgreSQL à l'aide d'outils tel ipcs pour déterminer la valeur du
  paramètre. Cela ne représente toutefois que la moitié du paramétrage.
  Il est également nécessaire de régler effective_cache_size pour que
  PostgreSQL puisse utiliser efficacement la mémoire disponible.
  </para>
  </entry>
 </row>
 <row>
  <entry>
  sort_mem
  </entry>
  <entry>64 à Int Max</entry>
  <entry>1 KB</entry>
  <entry>1024</entry>
  <entry>Oui</entry>
  <entry>-S #</entry>
  <entry>
  <para>
  Précise la quantité de mémoire utisable par les opérations de tri interne et
  les tables de hachage avant d'utiliser des fichiers temporaires. La valeur
  est indiquée en kilooctets, la valeur par défaut est 1024 kilooctets (1Mo).
  En cas de requête complexe, de nombreuses opérations de tri ou de hachage
  peuvent s'exécuter en parallèle&nbsp;; chacune peut utiliser la quantité
  de mémoire indiquée par la valeur de ce paramètre avant de commencer à
  utiliser des fichiers temporaires. De plus, de nombreuses sessions
  peuvent effectuer ces opérations concurrentiellement. La mémoire totale
  utilisée peut être plusieurs fois la valeur de SORT_MEM. Les opérations
  de tri sont utilisées par ORDER BY, DISTINCT et les jointures.
  </para>
  <para>
  Les options en ligne de commande nécessite d'utiliser -o 'option'.
  </para>
  </entry>
  <entry>
  <para>
  sort_mem est difficile à ajuster. Une plus grande valeur est utilisée
pour&nbsp;: les
  bases de données volumineuses, les requêtes complexes, une grande quantité de 
  RAM disponible. Une plus petite valeur est recherchée pour&nbsp;: une faible
  quantité de RAM ou de nombreux accès concurrents. Trouver le bon compromis
  peut s'avérer délicat.
  </para>
  <para>
  Une autre façon d'ajuster cette valeur consiste à surveiller les fichiers
  temporaires de PostgreSQL (dans PGDATA/base/DB_OID/pgsql_tmp) et d'accroître
  la valeur de sort_mem si de nombreuses requêtes permutent avec ces fichiers.
  </para>
  <para>
  Il ne faut pas oublier que ce paramètre peut être positionné par connexion.
  Ainsi, dans le cas où seules quelques requêtes très complexes sont à
  exécuter, la valeur peut être augmentée avant leur exécution, mais conservée
  basse pour les autres connexions.
  </para>
  </entry>
 </row>
 <row>
  <entry>vacuum_mem</entry>
  <entry>1024 à Int Max</entry>
  <entry>1 KB</entry>
  <entry>8192</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Précise la quantité maximale de mémoire que VACUUM peut utiliser pour
  conserver une trace des tuples à rendre. La valeur est précisée en kilooctets.
la valeur par défaut est de 8&nbsp;192&nbsp;ko. Une valeur supérieure peut
accélérer le nettoyage de grandes tables dont de nombreux tuples ont été
supprimés.
  </entry>
  <entry>
  <para>
  Ce paramètre n'utilise de RAm que lors des VACUUM. Il peut donc être augmenté
sur les machines disposant de beaucoup de RAM pour accéler les VACUUM (mais pas
plus de 20% de la RAM disponible).
  </para>
  <para>
  Ce paramètre peut de plus être positionné à l'exécution. il peut alors être
judicieux de le régler à une valeur basse pour les VACUUM réguliers et de le
positionner à une valeur plus élevée pour les VACUUM FULL de
nuit/hebdomadaires/périodiques.
  </para>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Free Space Map</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>max_fsm_pages</entry>
  <entry>1000 à Int Max</entry>
  <entry>6 octets RAM</entry>
  <entry>10000</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Positionne le nombre maximum de pages disque pour lesquels l'espace
  libre est recherché dans la mappe de l'espace libre partagé.
  La valeur par défaut est 10&nbsp;000. Cette option ne peut être positionnée 
  qu'au démarrage du serveur.
  </entry>
  <entry>
  <para>
    Un paramétrage correct de la FSM peut éliminer, ou au moins, retarder
  l'obligation d'exécuter VACUUM FULL et REINDEX. La meilleure façon de le
régler 
  est la suivante&nbsp;: 1) calculer la fréquence du VACUUM (normal) de la
  base en fonction des écritures&nbsp;; 2) utiliser la base en fonctionnement
  normal et exécuter VACUUM VERBOSE ANALYZE à la place de VACUUM, en
sauvegardant
  la sortie dans un fichier&nbsp;; 3) calculer le nombre de pages maximum
réclamé
  par VACUUM et utiliser ce chiffre.
  </para>
  <para>
  Si l'approche précédente n'est pas réalisable, essayer d'estimer le nombre
total de lignes qui peuvent être actualisées ou supprimées entre deux VACUUM, et
utiliser la moitié de ce nombre, en l'augmentant en fonction de la quantité de
travail qu'un VACUUM FULL périodique continue d'effectuer.
  </para>
  <para>
  Pour les base de données qui connaissent des &laquo;&nbsp;pics&nbsp;&raquo;
  d'activité (rafales d'un million de mises à jour mais pas d'autre
  activité des minutes ou des heures durant), ce nombre peut être 
  impossible à optimiser. Les lignes insérées n'ont pas d'impact
  sur la FSM. Enfin, si le serveur est peu fourni en RAM, augmenter
  cette valeur peut s'avérer contre-productif.
  </para>
  </entry>
 </row>
 <row>
  <entry>max_fsm_relations</entry>
  <entry>10 à Int Max</entry>
  <entry>40 octets RAM</entry>
  <entry>100</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Positionne le nombre maximum de relations (tables) pour
  lesquels l'espace libre est recherché dans la mappe de l'espce libre
  partagé.
  </entry>
  <entry>
  Ce paramètre doit être positionné au nombre de tables attendues dans la
base... entre 300 et 500. PostgreSQL a un comportement étrange s'il ne possède
pas assez de FSM_relations.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Disk Resource Usage</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>max_files_per_process</entry>
  <entry>25 à Int Max</entry>
  <entry></entry>
  <entry>1000</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Fixe le nombre maximum de fichiers simultanément ouverts par chaque
  sous-processus du serveur. La valeur par défaut est 1&nbsp;000. 
  La limite actuellement utilisée par le code est la plus petite valeur du
paramètre et le résultat de sysconf(_SC_OPEN_MAX). Toutefois, sur les systèmes
pour lesquels sysconf retourne une valeur raisonnable, il n'est pas nécessaire
  de s'inquiéter de ce paramètre. Mais sur la plupart des plateformes
  (et notamment BSD), sysconf retourne une valeur
  beaucoup plus grande que ce que le système peut réellement prendre en charge
  lorsque de nombreux processus essayent tous d'ouvrir ce nombre de fichiers.
  Si le message d'erreur &laquo;&nbsp;Trop de fichiers ouverts&nbsp;&raquo;
  (<foreignphrase>"Too many open files"</foreignphrase>) apparaît, 
  il faut alors essayer de réduire ce paramètre. Il ne peut être
  fixé qu'au démarrage du serveur ou dans le fichier postgresql.conf. Modifié
dans le fichier de configuration, il n'affectera que les sous-processus serveur
ouverts après modification.
  </entry>
  <entry>
  D'après la documentation, utilisé essentiellement pour BSD. À considérer
uniquement
  à l'appartion de messages &laquo;&nbsp;Trop de fichiers ouverts&nbsp;&raquo;
  (<foreignphrase>"Too many open files"</foreignphrase>).
  </entry>
 </row>
 <row>
  <entry>preload_libraries</entry>
  <entry>Chemin de fichier</entry>
  <entry>Voir les notes</entry>
  <entry>Vide</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Indique les bibliothèques à précharger au démarrage du serveur. Une
  fonction d'initialisation peut optionnellement être
  appelée pour chaque bibliothèque. Pour cela, il suffit d'ajouter un 
  double-point et le nom de la fonction d'initialisation après le
  nom de la bibliothèque. '$libdir/mylib:mylib_init' implique, par exemple,
  le préchargement de mylib et l'exécution de la fonction mylib_init.
  Si plusieurs bibliothèques doivent être chargées, leurs noms
  sont séparés par des virgules. Si mylib n'est pas trouvée, le serveur ne
démarrera pas. En revanche, si init_mylib n'est pas trouvée, mylib est
préchargée sans exécuter la fonction d'initialisation.  </entry>
  <entry>
  Le préchargement (et l'initialisation éventuelle) d'une bibliothèque
  partagée permet d'éviter le temps de chargement de la bibliothèque
  la première fois qu'elle est utilisée. Cela se traduit par un temps de
démarrage du serveur plus long et des temps d'appel des bibliothèques qui ne
sont pas chargées en mémoire plus courts.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Options WAL</title>

<sect2>
<title>Paramètres</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>fsync</entry>
  <entry>true, false</entry>
  <entry>Voir les notes</entry>
  <entry>true</entry>
  <entry>Non</entry>
  <entry>-F (off)</entry>
  <entry>
  Lorsque cette option est activée, le serveur PostgreSQL utilise les appels
  système fsync() pour s'assurer que les mises à jour sont physiquement écrites
  sur le disque. Cela garantit la récupération d'une bases de données
  cohérente après une panne matérielle ou système. Ce fonctionnement n'a aucune
incidence sur la gestion des pannes du serveur de bases de données.
  </entry>
  <entry>
  <note>
  <para>
  Depuis la version 7.2, la désactivation de fsync n'arrête
<emphasis>PAS</emphasis> le WAL. Toutefois, il n'y a plus de points de reprise.
La journalisation des écritures anticipées (<foreignphrase>Write-Ahead
  Logging ou WAL</foreignphrase>) ne doit être désactivée (fsync=off) que sur
les bases en
  lecture seule ou celles qu'il est possible de régénérer à l'aide de logiciels
  externes. Tandis que du RAID associé à un système de haute-disponibilité
  électrique peuvent aider à la protection des données, la désactivation de
  fsync <emphasis>impose</emphasis> la restauration des données à partir de
  sauvegardes en cas de pannes matériel ou électrique.
  </para>
  </note>
  <para>
  D'un autre côté, le WAL implique une baisse de performances lors des
écritures, à
  plus forte raison sur des systèmes mono-disques. Pour l'essentiel l'activité
  nécessaire aux opérations de lecture/écriture est doublée à chaque mise à
  jour. De plus, les fonctionnalités d'amélioration des performances par cache
  disque matériel ou logiciel sont désactivées.
  </para>
  <para>
   Si le WAL est arrêté, les options qui suivent n'ont pas d'intérêt.
  </para>
  </entry>
 </row>
 <row>
  <entry>wal_sync_method</entry>
  <entry>fsync, fdatasync, open_sync, ou open_datasync</entry>
  <entry></entry>
  <entry>Dépend de la plateforme</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Méthode utilisée pour forcer la mise à jour des WAL sur le disque. Les valeurs
  possibles sont FSYNC (fsync() est appelé à chaque validation), FDATASYNC
  (fdatasync() est appelé à chaque validation), OPEN_SYNC (écrit les fichiers
  WAL avec l'option O_SYNC d'open()) et OPEN_DATASYNC (écrit les fichiers WAL
  avec l'option O_DSYNC d'open()). Ces choix ne sont pas tous disponibles sur
  toutes les plateformes.
  </entry>
  <entry>
  Il s'agit de l'appel système utilisé pour synchroniser les WAL sur disque. La
  valeur par défaut a été réglée pour chaque OS en fonction de la documentation
  de l'OS. En revanche, aucun test comparatif n'a été mené. Il est possible que
  le changement de méthode accélère l'écriture sur une plateforme spécifique,
  mais cela ne doit être tenté que si les ressources nécessaires à des tests
  comparatifs et de régression sont disponibles. La modification des valeurs par
défaut peut altérer la protection par le WAL.
  </entry>
 </row>
 <row>
  <entry>wal_buffers</entry>
  <entry>4 à Int Max</entry>
  <entry>8K RAM</entry>
  <entry>8</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Nombre de tampons de pages disque alloués dans la mémoire partagée
  pour la journalisation du WAL.
  </entry>
  <entry>
  L'accroissement de ce paramètre peut accélérer les écritures du WAL pour les
transactions volumineuses. &Agrave; ce jour, personne n'a rendu compte d'une
analyse de l'impact de ce paramètre.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Checkpoints</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>checkpoint_segments</entry>
  <entry>1 à Int Max</entry>
  <entry>16 Mo sur disque</entry>
  <entry>3</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Distance maximale entre deux points de contôle WAL automatiques, en segments
de
  fichier journal (chaque segment représente normalement 16 Mo).
  </entry>
  <entry>
  Ce paramètre est augmenté lorsque la base requiert de nombreux écritures
d'arrière-plan pour diminuer la fréquence des points de reprise (et ainsi
diminuer l'éctivité du disque). Si la place disque manque ou que l'environnement
présente un risque de coupures de courant inattendues sce paramètre peut être
diminué. En effet, toute transaction non visée par un point de reprise sera
supprimée au redémarrage.
  </entry>
 </row>
 <row>
  <entry>checkpoint_timeout</entry>
  <entry>30 à 3600</entry>
  <entry>Voie les notes</entry>
  <entry>300</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Temps maximal entre deux points de contôle WAL automatiques, en secondes.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>checkpoint_warning</entry>
  <entry>0 à Int Max</entry>
  <entry>Voir les notes</entry>
  <entry>0</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Un message est envoyé dans les journaux du serveur si la fréquence des points
de contrôle
  engendrés par le remplissage des fichiers de segments de points de contrôle 
  est supérieure à ce temps, en secondes. Zéro désactive les alertes.
  </entry>
  <entry>
  Nouvelle option qui peut être utile pour affiner les checkpoint_segments sur
les bases à forte activité d'écriture. Des alertes
  nombreuses dans les journaux incitent à accroitre le paramètre
checkpoint_segments.
  </entry>
 </row>
 <row>
  <entry>commit_delay</entry>
  <entry>0-100000</entry>
  <entry>Voir les notes</entry>
  <entry>0</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Indique le délai, en microsecondes, entre l'écriture d'une validation dans le
  tampon WAL et la purge du tampon sur disque. Un délai positif peut permettre
  la validation de plusieurs transactions avec un seul appel système fsync(), si
  la charge système est suffisamment élevée pour que de nouvelles transactions
  soient prêtes pendant cet interval. Mais ce délai est perdu dans le cas
  contraire. Ainsi, le délai n'est exécuté que si au moins commit_siblings
autres
  transactions sont actives au moment où le processus serveur a écrit sa
  validation.
  </entry>
  <entry>
  Ces deux paramètres sont configurés ensemble pour un environnement à fort
  volume de petites transactions. Activés, ils permettent de purger en même
  temps sur disques des transactions sans relation entre elles, qui autrement ne
  le seraient pas, avec à la clé un potentiel accroissement des performances.
  En revanche, si l'espace disque est restreint ou que la stabilité électrique
de l'environnement ne peut être garantie, il est préférable de ne pas modifier
ces paramètres.
  </entry>
 </row>
 <row>
  <entry>commit_siblings</entry>
  <entry>1-1000</entry>
  <entry>Voir les notes</entry>
  <entry>5</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Indique le nombre minimum de transactions concurrentes ouvertes avant
  l'éxécution du délai COMMIT_DELAY. Plus la valeur est grande, plus la
  probabilité de valider une autre transaction pendant cet interval grandit.
  </entry>
  <entry>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Optimisation des requêtes</title>

<sect2>
<title>Méthodes du planificateur</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>enable_hashagg</para>
  <para>enable_hashjoin</para>
  <para>enable_indexscan</para>
  <para>enable_mergejoin</para>
  <para>enable_nestloop</para>
  <para>enable_seqscan</para>
  <para>enable_sort</para>
  <para>enable_tidscan</para>
  </entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>true</entry>
  <entry>Oui</entry>
  <entry>
  <para></para>
  <para>-fi</para>
  <para>-fm</para>
  <para>-fn</para>
  <para>-fs</para>
  <para></para>
  <para>-ft*</para>
  <para></para>
  </entry>
  <entry>
  <para>
  Enables or disables the query planner's use of the respective plan types.
  The default is on. This is used for debugging the query planner.
  </para>
  <para>
  Les options en ligne de commande requièrent l'utilisation de -o 'option'.
  </para>
  </entry>
  <entry>
  <para>
  Ces options ne devraient être utilisées que pour tester les requêtes&nbsp;; il
  est courant, par exemple, de positionner &laquo;&nbsp;enable_seqscan =
false&nbsp;&raquo;
  pour déterminer si le planificateur n'omet pas inutilement un index. Quoi
  qu'il en soit, seules des circonstances extraordinaires nécessitent qu'un
  de ces paramètres soit positionné à <foreignphrase>false</foreignphrase> dans
  le fichier .conf.
  </para>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Constantes de coût du planificateur</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>effective_cache_size</entry>
  <entry>0 à Int Max</entry>
  <entry>8 KB</entry>
  <entry>1000</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Fournit à l'optimiseur une estimation de la taille efficace du cache
  disque (c'est-à-dire la partie du cache disque du noyau utilisée pour les
  fichiers de données PostgreSQL). Elle est mesurée en pages disque, chacune
  de 8 ko.
  </entry>
  <entry>
  Ce paramètre, bien que souvent négligé, peut, s'il est correctement réglé
conduire à une meilleure utilisation de la RAM sur les ordianteurs disposant de
beaucoup de mémoire. (NDR&nbsp;: J'utilise 25% de ma &laquo;&nbsp;RAM
disponible&nbsp;&raquo; (après Linux et les applications) comme niveau général,
mais n'ai pas testé plus avant.) Si ce paramètre est optimisé, il n'est pas
nécessaire d'augmenter inutilement shared_buffers.
  </entry>
 </row>
 <row>
  <entry>
  <para>random_page_cost</para>
  <para>cpu_tuple_cost</para>
  <para>cpu_index_tuple_cost</para>
  <para>cpu_operator_cost</para>
  </entry>
  <entry>0 à Double</entry>
  <entry>
  <para></para>
  <para>0.01</para>
  <para>0.001</para>
  <para>0.0025</para>
  </entry>
  <entry>4</entry>
  <entry>
  </entry>
  <entry>Oui</entry>
  <entry>
  Fournit au planificateur une estimation du coût de traitement de chaque
consultation de page, tuple, consultation d'index et item de clause where
(respectivement) lors d'une requête. Elle est mesurée en multiples du coût de
  récupération séquentielle d'une page.
  </entry>
  <entry>
  Les coûts par défaut sont fondés entièrement sur l'expérience et ne sont
probablement pas optimaux pour tout système. Par exemple, les machines disposant
de disques rapides peuvent abaisser le random_page_cost. Lorsque différentes
valeurs sont testées pour ces paramètres, il est nécessaire de tester une grande
variété de requêtes, car un bon paramétrage pour une requête peut ne pas
s'appliquer à une autre. Heureusement, ces paramètres étant tous relatifs au
coût d'un parcours séquentiel, le risque qu'ils soient trop élevés dans un
système équilibré est assez faible.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Optimisation génétique de requêtes (<foreignphrase>Genetic Estimate Query
Optimizer, GEQO</foreignphrase>)</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>geqo</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>true</entry>
  <entry></entry>
  <entry></entry>
  <entry>
  Active ou désactive l'optimisation génétique de requêtes. Il s'agit en fait
  d'un algorithme génétique de planification de requêtes qui tente d'éviter
  les recherches exhaustives. Activé par défaut. Divers paramètres GEQO_
  permettent d'en affiner le comportement.
  </entry>
  <entry>
  <para>
  GEQO a été introduit dans PostgreSQL 6.5 pour optimiser les requêtes de
  jointures qui utilisent trop de tables pour permettre une analyse exhaustive
  par le planificateur. C'était assez révolutionnaire, alors, mais n'a jamais
été complètement optimisé. Depuis, sa maintenance est aléatoire. (NDR&nbsp;:
Maintenant que de nouveaux CPU, plus rapides et plus de RAM, plus rapide, sont
devenus accessible, je positionne le seuil GEQO aux environs de 20-25 tables.)
Cela permet de s'assurer que GEQO n'est utilisé que lorsque c'est la seule
solution. Il est évident que si PostgreSQL tourne sur une machine à CPU limité,
le seuil GEQO peut être abaissé.
  </para>
  <para>
  GEQO peut être désactivé si aucune requête de cette complexité n'est jamais
envisagée.
  </para>
  </entry>
 </row>
 <row>
  <entry>geqo_threshold</entry>
  <entry>2 à Int Max</entry>
  <entry></entry>
  <entry>11</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  L'optimisation génétique de requête est utilisée pour planifier les requêtes
  qui contiennent au minimum ce nombre d'items dans la clause FROM. Une jointure
  compte pour un item FROM. La valeur par défaut est 11. Pour les requêtes plus
  simples, il est généralement plus efficace d'utiliser une stratégie de
  planification déterministique, exhaustive. Ce paramètre contrôle également la
  façon dont l'optimiseur tente de fusionner les sous-requêtes de clause FROM
  avec la requête principale.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>
  <para>geqo_selection_bias</para>
  <para>geqo_pool_size</para>
  <para>geqo_effort</para>
  <para>geqo_generations</para>
  <para>geqo_random_seed</para>
  </entry>
  <entry>1.5-2.0</entry>
  <entry></entry>
  <entry>
  <para>2.0</para>
  <para>0</para>
  <para>1</para>
  <para>0</para>
  <para>-1</para>
  </entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Divers paramètres d'affinage de l'algorithme d'optimisation génétique&nbsp;:
  la taille du <i>pool</i> correspond au nombre d'individus d'une population.
  L'échelle
  s'étend de 128 à 1024. Lorsqu'elle est positionnée à 0 (valeur par défaut), la
  taille du pool est obtenu par le calcul. Elle vaut alors 2^(QS+1), avec QS le
  nombre d'items FROM de la requête.
  L'<i>effort</i> est utilisé pour calculer une valeur par défaut pour les
  générations.
  L'échelle s'étend de 1 à 80, 40 étant la valeur par défaut.
  <i>generations</i> précise le nombre d'itérations de l'algorithme. Ce nombre
  doit être entier et positif. Si une valeur nulle est utilisée,
  <i>generations</i> est calculé. Le nombre vaut alors effort * Log2(PoolSize). 
  Le temps d'exécution de l'algorithme est approximativement proportionnel à la
  somme de la taille du <i>pool</i> et de <i>generations</i>. 
  <foreignphrase>selection bias</foreignphrase> affine la sélectivité au sein
  d'une population. Ses valeurs vont de 1.5 à 2.0&nbsp;; 2.0 étant la valeur 
  par défaut.
  <foreignphrase>random seed</foreignphrase> permet d'ajuster l'algorithme pour
  obtenir des résultats reproductibles. Positionné à -1, l'algorithme a un
  comportement non déterministe.
  </entry>
  <entry></entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Statistiques concernant les requêtes et les index</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>stats_start_collector</para>
  <para>stats_reset_on_server_start</para>
  <para>stats_command_string</para>
  <para>stats_row_level</para>
  <para>stats_block_level</para>
  </entry>
  <entry>true, false</entry>
  <entry>
  <para>true</para>
  <para>true</para>
  <para>false</para>
  <para>false</para>
  <para>false</para>
  </entry>
  <entry></entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Ces drapeaux détermine les informations envoyées par les serveurs au processus
  de collecte des statistiques&nbsp;: commande en cours, statistiques d'activité
  au niveau bloc ou statistiques d'activité au niveau ligne. Tous sont
désactivés  par défaut. La collecte de statistiques coûte un peu de temps par
requête, mais  est inestimable pour le débogage et l'optimisation des
performances.
  </entry>
  <entry>
  NDR&nbsp;: J'écris un article sur Techdocs qui explique comment utiliser les
  statistiques de requête pour optimiser l'utilisation des index. Elles sont
  particulièrement utiles pour avoir une approche
  &laquo;&nbsp;déductive&nbsp;&raquo; de l'indexation, qui consiste à tout
indexer  et supprimer ensuite les index inutiles.
  </entry>
 </row>
 <row>
  <entry>default_statistics_target</entry>
  <entry>1 -1000</entry>
  <entry></entry>
  <entry>10</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Positionne la cible par défaut des statistiques pour les tables dont la cible
  spécifique à la colonne n'a pas été positionnée à l'aide de ALTER TABLE SET
  STATISTICS. 
  Plus la valeur est grande, plus long est le temps nécessaire à l'ANALYZE. 
  En revanche, la qualité des estimations du planificateur s'améliore.
  </entry>
  <entry>
  Il peut s'avérer utile de positionner la cible lorsque toutes les tables
principales 
  possèdent une distribution irrégulière au sein des colonnes les plus souvent
interrogées. En revanche, le temps nécessaire à ANALYZE est rallongé.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Autres modificateurs de requêtes</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>explain_pretty_print</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
   Règle le format de sortie d'EXPLAIN VERBOSE, indenté ou non, pour l'affichage
   des arbres de requête détaillés.
  </entry>
  <entry>
  Essayer et voir. Le formattage supplémentaire est utile pour certains, mais
pas pour tout le monde.
  </entry>
 </row>
 <row>
  <entry>from_collapse_limit</entry>
  <entry>0 à Int Max</entry>
  <entry></entry>
  <entry>8</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Le planificateur fusionne les sous-requêtes dans la requête principale si la
  liste FROM résultante ne contient pas plus de ce nombre d'items. Une valeur
  inférieure réduit le temps de planification, mais peut conduire à des plans de
  moindre qualité. 8 est la valeur par défaut. Il est préférable de conserver
  une valeur inférieure à GEQO_THRESHOLD.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>join_collapse_limit</entry>
  <entry>1 à Int Max</entry>
  <entry></entry>
  <entry>8</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Le planificateur résout les jointures internes (<foreignphrase>inner
  JOIN</foreignphrase>) explicites en listes d'items FROM si
  la liste résultante ne contient pas plus de ce nombre d'items. En général, ce
  paramètre a la même valeur que FROM_COLLAPSE_LIMIT. Le positionner à 1 empêche
  toute résolution des jointures internes, ce qui permet d'utiliser la syntaxe
  JOIN explicitement pour contrôler l'ordre de la jointure. Les valeurs
  intermédiaires permettent d'arbitrer entre le temps de planification et la
  qualité du plan.
  </entry>
  <entry>
  Cette option est conçue pour ceux qui préfèrent écrire leurs requêtes en
  utilisant la syntaxe des jointures explicites (e.g. &laquo;&nbsp;a join b
  using (1) join c using (2)&nbsp;&raquo;), mais apprécient néanmoins que le
  planificateur choisisse le meilleur ordre de jointure. En particulier, les
  gens migrant de MS SQL Server peuvent utiliser ce paramètre en le positionnant
  à une valeur modérément élevée, puisque cette base trie les jointures
  automatiquement.
  </entry>
 </row>
 <row>
  <entry>max_expr_depth</entry>
  <entry>10 à Int Max</entry>
  <entry></entry>
  <entry>10000</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Positionne la profondeur d'emboîtement maximale d'une expression. La valeur
par défaut est assez élevée pour une requête habituelle, mais elle peut être
augmentée au besoin. Attention toutefois à ne pas l'augmenter trop, au risque
d'aboutir à un plantage du serveur pour dépassement de la taille de pile.
  </entry>
  <entry>
  NDR&nbsp;: Je ne vois pas qui pourrait avoir besoin d'augmenter ce paramètre.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Options de journalisation et de messages</title>

<sect2>
<title>Syslog</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>syslog</para>
  <para>syslog_facility</para>
  <para>syslog_ident</para>
  </entry>
  <entry>0-2</entry>
  <entry>
  <para>0</para>
  <para>LOCAL0</para>
  <para>postgres</para>
  </entry>
  <entry></entry>
  <entry></entry>
  <entry>Non</entry>
  <entry>
  PostgreSQL autorise l'utilisation de syslog pour la journalisation. Lorsque
l'option est positionnée à 1, les messages sont dirigés à la fois vers syslog et
la sortie standard. Positionnée à 2, les messages ne sont envoyés que vers
syslog. (Certains messages sont toujours dirigés vers la sortie/l'erreur
standard). La valeur par défaut est 0, ce qui désactive syslog. L'option doit
être positionné au démarrage du serveur.
  </entry>
  <entry>
  Très utile lorsqu'un outil de gestion de syslog est disponible. Dans le cas
contraire, il peut être difficile de séparer la sortie de PostgreSQL de celle
des autres processus.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Quand journaliser</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>server_min_messages</para>
  <para>client_min_messages</para>
  <para>log_min_error_statement</para>
  </entry>
  <entry>
  debug5, debug4, debug3, debug2, debug1,
  info, notice, warning, error, log, fatal, panic
  </entry>
  <entry></entry>
  <entry>notice</entry>
  <entry>Oui</entry>
  <entry>-d x</entry>
  <entry>
  Permet de contrôler le détail des messages écrits dans les journaux du serveur
  et sur le client. Les valeurs valides sont DEBUG5, DEBUG4, DEBUG3, DEBUG2,
  DEBUG1, INFO, NOTICE, WARNING, ERROR, LOG, FATAL et PANIC. Les dernières
  envoient moins de détails dans les journaux. La valeur par défaut est NOTICE.
  LOG n'a pas le même comportement ici que dans CLIENT_MIN_MESSAGES.
  </entry>
  <entry>
  Les niveaux debug sont intéressant en phase de test des applications.
  Le coût en est une plus grande occupation du disque et un léger impact sur les
  performances (généralement inférieur à 5%). Néanmoins, l'impact sur les
  performances augmente considérablement si les journaux se situent sur le même
  disque/la même baie que les WAL de la base, puisqu'une forte sortie de
  débogage ampute l'activité E/S de la base. L'impact de DEBUG5 sur un système
  monodisque fortement transactionnel peut être très élevé. Cet avertissement
  vaut pour toutes les options de journalisation vues plus haut.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Que journaliser</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>debug_print_parse</para>
  <para>debug_print_rewritten</para>
  <para>debug_print_plan</para>
  <para>debug_pretty_print</para>
  </entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Ces drapeaux active la sortie d'informations de débogage ver les journaux du
  serveur. Pour chaque requête exécutée, écrit soit le texte de la requête,
  l'arbre syntaxique résultant, la sortie du rédacteur de requête ou le plan
  d'exécution. DEBUG_PRETTY_PRINT indente les affichages pour faciliter la
  lecture, au prix d'une écriture plus longue. 
  </entry>
  <entry>
  Utile pour détecter les requêtes lentes, sous réserve de réussir à parcourir
  le volumineux journal. Particulièrement utile dans un mode intercatif de
  surveillance des journaux lorsque les procédures stagnent&nbsp;; il est
  parfois possible de voir à quel endroit la procédure stagne (parfois, cela
  n'est pas possible, parce que le journal attend une information de la base).
  </entry>
 </row>
 <row>
  <entry>
  <para>log_connections</para>
  <para>log_pid</para>
  <para>log_statement</para>
  <para>log_duration</para>
  <para>log_timestamp</para>
  </entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>
  <para>Non</para>
  <para>Non</para>
  <para>Oui</para>
  <para>Oui</para>
  <para>Oui</para>
  </entry>
  <entry></entry>
  <entry>
  Journalise les items correspondants.
  </entry>
  <entry>
  <para>
  Chaque paramètre a son utilité, fonction du problème attendu. NDR&nbsp;: En
général, je conserve log_timestamp active, et tous les autres désactivés.
  </para>
  <note>
  <para>
  Un correctif a été proposé pour permettre à un utilisateur d'activer les
options de journalisation, mais seul le superutilisateur peut alors les
désactiver. Il n'est pas sûr que ce correctif soit intégré à la version 7.4.
  </para>
  </note>
  </entry>
 </row>
 <row>
  <entry>
  log_hostname
  </entry>
  <entry>true, false</entry>
  <entry>See notes</entry>
  <entry>false</entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
  Par défaut, les journaux de connexions ne présentent que l'adresse IP de
  provenance de la connexion. En activant cette option, le nom de l'hôte est
  également présenté. Mais, en fonction du paramétrage de la résolution de noms,
  cela peut induire une baisse non négligeable des performances.
  </entry>
  <entry>
  Cela peut être utile pour la gestion des débogages et de la sécurité, mais
  dans le cas où le DNS n'est pas local, les nouvelles connexions peuvent se
  trouver considérablement ralenties.
  </entry>
 </row>
 <row>
  <entry>
  log_source_port
  </entry>
  <entry>true, false</entry>
  <entry>See notes</entry>
  <entry>false</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Affiche le numéro du port de sortie de l'hôte se connectant dans les jounaux
des messages de connexion. Cela permet, en remontant le numéro de port, de
retrouver l'utilisateur qui s'est connecté. &Agrave; part cela, l'intérêt est
restreint, d'uù sa désactivation par défaut.
  </entry>
  <entry>
  Implique une pénalité significative, mais non mesurée, sur les performances du
fait de la recherche et des activités de journalisation supplémentaires.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Journalisation des statistiques</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>show_parser_stats</para>
  <para>show_planner_stats</para>
  <para>show_executor_stats</para>
  <para>show_statement_stats</para>
  <para>log_parser_stats</para>
  <para>log_planner_stats</para>
  <para>log_executor_stats</para>
  <para>log_statement_stats</para>
  </entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Non</entry>
  <entry>
  <para>-tpa</para>
  <para>-tpl</para>
  <para>-te</para>
  <para>-s</para>
  </entry>
  <entry>
  <para>
  Pour chaque requête, les statistiques de performance du module respectif sont
  écrites dans le journal du serveur. C'est un outil d'analyse redoutable.
  </para>
  <para>
  Les options en ligne de commande requièrent l'utilisation de -o 'option'.
  </para>
  </entry>
  <entry>
  Peut être positionné par le superutilisateur.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Valeur par défaut des connexions client</title>

<sect2>
<title>Comportement des instructions</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>search_path</entry>
  <entry>path</entry>
  <entry>None</entry>
  <entry>'$user,public'</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
   Cette variable précise l'ordre de consultation des schémas lorsqu'il est fait
   référence à un objet (table, type de données, fonction...) par un nom simple,
   sans composante schéma. Lorsque plusieurs objets portent le même nom dans
   différents schémas, le premier trouvé dans l'ordre du chemin est utilisé.
   Il ne peut être fait référence à un objet qui ne se trouve dans aucun des 
   schémas du chemin qu'en qualifiant son nom avec le schéma qui le contient
   (schema.objet).
  </entry>
  <entry>
  Lorsqu'une application utilise intensément les schéma, il est possible de
renverser le chemin de recherche pour remplacer les objets des schémas
utilisateur par ceux du schéma public qui portent le même nom. Sinon, autant ne
pas y toucher.
  </entry>
 </row>
 <row>
  <entry>default_transaction_isolation</entry>
  <entry>read committed, serializable</entry>
  <entry>Voir les notes</entry>
  <entry>'read committed'</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
   Chaque transaction SQL dispose d'un niveau d'isolation. Il peut être 
   &laquo;&nbsp;read committed&nbsp;&raquo; (lecture des entrées validées) ou
   &laquo;&nbsp;serializable&nbsp;&raquo; (sérialisable). Ce paramètre contrôle
   le niveau d'isolation par défaut de chaque nouvelle transaction. La valeur
   par défaut est &laquo;&nbsp;read committed&nbsp;&raquo;. Le guide de
l'utilisateur PostgreSQL et la documentation de la commande SET TRANSACTION 
fournissent des informations complémentaires.
  </entry>
  <entry>
   La valeur par défaut, ici, est en accord avec le comportement MVCC.
   &laquo;&nbsp;serializable&nbsp;&raquo; est surtout utile lors du lancement de
   procédures longues et éventuellement successives, ou lorsqu'une mise à jour
   entraîne un risque conséquent et régulier de verrou mort. En environnement
   fortement concurrentiel (nombreux utilisateurs), son utilisation peut
   avoir des conséquences sur les performances, puisque de nombreuses
   transactions doivent attendre la fin de la transaction sérialisée. Dans le
   cas d'une base mono-utilisateur, cela n'a que peu de conséquence.
  </entry>
 </row>
 <row>
  <entry>default_transaction_read_only</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
   Une transaction SQL en lecture seule ne peut modifier une table temporaire.
   Ce paramètre contrôle le statut de lecture seule par défaut de toute nouvelle
   transaction. Par défaut à false (lecture/écriture).
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>statement_timeout</entry>
  <entry>0 à Int Max</entry>
  <entry>Voir les notes</entry>
  <entry>0</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
   Interrompt toute instruction qui dure plus que le nombre de millisecondes
   précisées. La valeur zéro désactive le chronomètre..
  </entry>
  <entry>
   Conçu pour faciliter le fonctionnement d'une application lorsque les
   utilisateurs peuvent exécuter des requêtes qui monopolisent la CPU pendant
   plusieurs minutes, telles que les applications qui autorisent les requêtes
   dynamiques. Positionner ce paramètre à une valeur finie peut empêcher les
   utilisateurs de monopoliser les ressources, mais il faut alors gérer
   l'exception.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Locale et formattage</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>datestyle</para>
  <para>timezone</para>
  <para>australian_timezones</para>
  </entry>
  <entry></entry>
  <entry>None</entry>
  <entry>
  <para>'iso, us'</para>
  <para>unknown</para>
  <para>false</para>
  </entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  <para>
   Positionne le format d'affichage des dates et les règles d'interprétation des
   dates ambigues en entrée .
  </para>
  <para>
   Positionne le fuseau horaire pour l'affichage et l'interprétation des
   estampilles temporelles. Le comportement par défaut utilise le fuseau horaire
   fourni par le système.
  </para>
  <para>
   Positionné à true, CST, EST et SAT sont interprétés comme des fuseaux
   horaires australiens et non comme des fuseaux North American Central/Eastern
   et samedi (Saturday).
  </para>
  </entry>
  <entry>
   Permet de modifier l'affichage par défaut des dates et l'interprétation des
   fuseaux horaires pour coller aux standard et à la
   localisation de l'utilisateur.
  </entry>
 </row>
 <row>
  <entry>extra_float_digits</entry>
  <entry>-14 à 2</entry>
  <entry>None</entry>
  <entry>0</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
   Ce paramètre permet d'ajuster le nombre de chiffres affichés pour les valeurs
   à virgule flottante, ce qui inclut les float4, float8 et les types de données
   géométriques. La valeur du paramètre est ajoutée au nombre standard de
   chiffres (FLT_DIG ou DBL_DIG, selon les cas). La valeur 2, la plus haute
   possible, permet d'inclure les chiffres partiellement significatifs&nbsp;;
   cela est particulièrement utile pour copier des flottants dont la
   restauration doit être exacte. Les valeurs négatives permettent de supprimer
   les chiffres non souhaités.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>
  <para>lc_messages</para>
  <para>lc_monetary</para>
  <para>lc_time</para>
  <para>lc_numeric</para>
  </entry>
  <entry>System-dependent</entry>
  <entry>None</entry>
  <entry>Special</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
   Positionne la locale à utiliser pour le formatage des messages d'erreur, des
   montants monétaires, des valeurs de temps et des valeurs numériques. Les
   valeurs acceptables dépendent du système&nbsp;; voir à ce propos la section
   7.1. Lorsque la valeur est constituée d'une chaîne vide (valeur par défaut),
   la valeur est héritée de l'environnement d'exécution du serveur.
  </entry>
  <entry>
   Ces paramètres sont positionnés par le script initdb lors de la création du
   répertoire PGDATA. En général positionné à la langue, la monnaie... de
   l'utilisateur.
  </entry>
 </row>
 <row>
  <entry>client_encoding</entry>
  <entry>OS-dependent</entry>
  <entry>None</entry>
  <entry>sql_ascii</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
   Positionne l'encodage côté client pour les jeux de caractères multi-octet.
   Par défaut, l'encodage de la base est utilisé.
  </entry>
  <entry>
   Généralement ignoré au profit de l'encodage de la base. Ne doit être
positionné par
   client que dans les applications multilingues, ce qui requiert un effort
   considérable de gestion des différents encodages.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Autres valeurs par défaut</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>password_encryption</entry>
  <entry>true, false</entry>
  <entry>None</entry>
  <entry>true</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Détermine le chiffrement du mot de passe lorsque ni ENCRYPTED ni UNENCRYPTED
  ne sont précisés lors de l'indication d'un mot de passe avec les commandes
  CREATE USER et ALTER USER.
  </entry>
  <entry>
  Il est préférable de laisser la valeur à <foreignphrase>true</foreignphrase>
  (vrai), dans tous les cas.
  </entry>
 </row>
 <row>
  <entry>dynamic_library_path</entry>
  <entry>path</entry>
  <entry>None</entry>
  <entry>'$libdir'</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
   Si un module chargeable dynamiquement doit être ouvert et que le nom ne
   précise le répertoire (i.e. le nom ne contient pas de slash), le système
   recherche le ficheir dans ce chemin. Le nom utilisé est celui précisé par la
   commande CREATE FUNCTION ou LOAD.
  </entry>
  <entry>
   Peut être positionné par le superutilisateur.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Lock Management</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>deadlock_timeout</entry>
  <entry>1 à Int Max</entry>
  <entry>Voir les notes</entry>
  <entry>1000</entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
   Temps d'attente, en millisecondes, avant de vérifier qu'un verrou est en
   condition de verrou mort. La recherche de verrou mort étant relativement
lente,
   le serveur ne la lance pas à chaque fois qu'il attend le relâchement d'un
verrou. 
   Les auteurs
   estiment (de façon optimiste ?) que les verrous morts ne sont pas légion en
   production et de fait patientent quelques instants après la pose d'un verrou 
   avant de rechercher les verrous morts. L'augmentation de cette valeur réduit
   le temps perdu à rechercher inutilement les verrous morts, mais retarde la
   découverte des erreurs de verrous réellement morts. La valeur par défaut est
   1000 (i.e., une seconde), ce qui est probablement la plus petite valeur
   acceptable dans la pratique. Sur un serveur en charge, cette valeur peut être
   augmentée. Dans l'idéal, la valeur dépasse le temps habituel d'une
   transaction, de façon à accroître les chances que le verrou soit relâché
   avant que le serveur ne recherche les verrous morts.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>max_locks_per_transaction</entry>
  <entry>10 à Int Max</entry>
  <entry></entry>
  <entry>64</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
   La table partagée de verrous est dimensionnée d'après l'hypothèse qu'au
   maximum max_locks_per_transaction * max_connections objets distincts sont
   verrouillés au même moment. La valeur par défaut, 64, qui a prouvé au fil des
   ans qu'elle était suffisante, peut toutefois être augmentée lorsque
différents
   clients attaquent de nombreuses tables au sein d'une même transaction.
   L'option ne peut être positionnée qu'au démarrage du serveur.
  </entry>
  <entry></entry>
 </row>
</tbody>
</tgroup>
</table>

</sect1>

<sect1>
<title>Compatibilité de version et de plateforme Compatibility</title>

<sect2>
<title>Versions précédentes de PostgreSQL</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>add_missing_from</entry>
  <entry>true, false</entry>
  <entry>None</entry>
  <entry>true</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
   Autorise le planificateur à &laquo;&nbsp;ajouter les clauses FROM
   manquantes&nbsp;&raquo; (add missing from clause) lorsqu'une table est
   omise dans la requête. Sera positionné à false dans les prochaines versions.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>regex_flavor</entry>
  <entry>advanced, extended, basic</entry>
  <entry>None</entry>
  <entry>advanced</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
   La &laquo;&nbsp;flaveur&nbsp;&raquo; d'une expression rationnelle peut être
   positionnée à advanced (avancée), extended (étendue) ou basic (basique). La
   valeur par défaut est advanced. L'option extended peut être utile pour une
   compatibilité exacte avec les versions pre-7.4 de PostgreSQL.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>sql_inheritance</entry>
  <entry>true, false</entry>
  <entry>None</entry>
  <entry>true</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
   Contrôle la sémantique de l'héritage, en particulier l'inclusion par défaut
   ou non des tables filles par diverses commandes. Elles ne l'étaient pas dans
   les versions antérieures à la 7.1. Pour retrouver l'ancien comportement, ce
   paramètre est positionné à off. Toutefois, sur le long terme, il est
   préférable de modifier les applications afin d'utiliser le mot-clé ONLY pour
   exclure les tables filles.
  </entry>
  <entry></entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Compatibilité plateforme et client</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>transform_null_equals</entry>
  <entry>true, false</entry>
  <entry>None</entry>
  <entry>false</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
   Lorsque ce paramètre est positionné, les expressions de la forme expr = NULL
   (ou NULL = expr) sont traitées comme expr IS NULL, c'est-à-dire qu'elles
   retournent true si expr s'évalue à null et false dans le cas contraire. Le
   comportement correct de expr = NULL est de toujours retourner null (unknown).
  </entry>
  <entry></entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Options pour les développeurs</title>

<note>
<para>
Ces options ont été supprimées du fichier postgresql.conf dans la version 7.4
parce qu'elles n'ont aucune utilité pour les utilisateurs, mais sont destinées
aux développeurs des sources. La plupart des DBA n'ont aucune raison de modifier
ces paramètres.
</para>
</note>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>wal_debug</entry>
  <entry>0-16</entry>
  <entry></entry>
  <entry>0</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Positionné à une valeur non-nulle, active la sortie de débogage relative au
WAL sur l'erreur standard.
  </entry>
  <entry>
  Peut-être positionné par le superutilisateur.
  </entry>
 </row>
 <row>
  <entry>trace_notify</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Engendre une grande quantité de sortie de débogage pour les commandes LISTEN
et NOTIFY.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>
  <para>trace_locks</para>
  <para>trace_userlocks</para>
  <para>trace_lwlocks</para>
  <para>debug_deadlocks</para>
  <para>trace_lock_oidmin</para>
  <para>trace_lock_table</para>
  <para>log_btree_build_stats</para>
  </entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>
  <para>false</para>
  <para>false</para>
  <para>false</para>
  <para>false</para>
  <para>16384</para>
  <para>0</para>
  <para>false</para>
  </entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  &Agrave; ce jour, ces options ne sont pas documentées.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>debug_assertions</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>true</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Active les vérifications de diverses assertions. C'est une aide au débogage.
Ce paramètre peut être activé en cas de problèmes ou plantages étranges, car il
peut mettre en exergue des erreurs de programmation. Pour utiliser cette option,
il est nécessaire de définir la macro USE_ASSERT_CHECKING à la construction de
PostgreSQL (à l'aide de l'option de configuration --enable-cassert).
DEBUG_ASSERTIONS est activé par défaut si PostgreSQL a été construit avec
l'activation des assertions.
  </entry>
  <entry>
  Utile uniquement si le système PostgreSQL plante ou pour les hackers.
  </entry>
 </row>
 <row>
  <entry>zero_damaged_pages</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry></entry>
  <entry>Non</entry>
  <entry>
  La détection d'un entête de page endommagé entraîne PostgreSQL à rapporter une
erreur, interrompant la transaction en cours. Le positionnement de
zero_damaged_pages à true impose au système de rapporter plutôt un
avertissement, réinitialiser la page endommager et continuer le processus. Ce
comportement détruit les données, à savoir toutes les lignes sur la page
endommagée. Mais il permet également de passer outre l'erreur et récupérer les
lignes de toutes les pages non endommagées de la table. Cette toption est donc
utile pour récupérer des données si une corruption a suivi un plantage matériel
ou logiciel. Ce paramètre ne devrait être positionné à true que lorsque tout
espoir de récupérer les données à partir des pages endommagées d'une table est
perdu. Par défaut le paramètre est désactivé. Il ne peut être changé que par le
superutilisateur.
  </entry>
  <entry>
  Peut être positionné par le superutilisateur.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect1>

</article>
