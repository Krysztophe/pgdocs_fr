<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- SAS 20060728 : Traduction initiale -->
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" >

<article id="postgresqlconf" lang="fr">
 <articleinfo>
  <title>Fichier postgresql.conf et guide de configuration utilisateur générale
(<foreignphrase>Global User Configuration (GUC)</foreignphrase>) annotés</title>
  <subtitle>PostgreSQL 7.4.x</subtitle>
</articleinfo>

<sect1>
<title>Connexions et authentification</title>

<sect2>
<title>Paramètres de connexion</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>Échelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>tcpip_socket</entry>
  <entry>true, false</entry>
  <entry>none</entry>
  <entry>false</entry>
  <entry>non</entry>
  <entry>-i</entry>
  <entry>
  Positionné à true, le serveur accepte les connexions TCP/IP. Dans le cas
  contraire, seules les connexions par la socket de domaine Unix sont
autorisées.
  </entry>
  <entry>
  Sauf dans le cas d'un serveur de test, ce paramètre doit probablement être
  positionné à true. Il est recommandé de faire cela
  <emphasis>après</emphasis> avoir configuré le fichier pg_hba.conf, pour
  sécuriser les accès.
  </entry>
 </row>
 <row>
  <entry>max_connections</entry>
  <entry>2 à Int Max</entry>
  <entry>14ko RAM</entry>
  <entry>32</entry>
  <entry>Non</entry>
  <entry>-N #</entry>
  <entry>
  Nombre maximum de connexions concurrentes à un serveur de bases de données.
  La valeur par défaut est 32 (à moins qu'elle n'ait été modifiée lors de
  la construction du serveur).
  </entry>
  <entry>
  Paramètre important. &Agrave; conserver le plus bas possible pour la
  configuration de l'application. En combinaison avec une application web
  à connexions persistantes, il doit être possible de l'abaisser vers 10-16.
  </entry>
 </row>
 <row>
  <entry>superuser_reserved_connections</entry>
  <entry>0 à max_connections - 1</entry>
  <entry>Reduces regular connections available</entry>
  <entry>2</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Nombre de connexions réservées aux superutilisateurs PostgreSQL. Au plus
  max_connections connexions peuvent être actives simultanément. Lorsque
  le nombre de connexions concurrentes atteint max_connections moins
  superuser_reserved_connections, seules les connexions de superutilisateurs
  sont encore autorisées.
  </entry>
  <entry>
  Cela protège l'accès des superutilisateurs en cas d'engorgement de la base.
  Ce paramètre ne doit être positionné à 0 que lorsqu'il est certain que
  toutes les connexions ne sont jamais utilisées. (NDR&nbsp;: Je positionne
  souvent ce paramètre à 1, puisque je ne me connecte en superutilisateur
  à la base qu'en cas de problème.) 
  </entry>
 </row>
 <row>
  <entry>port</entry>
  <entry>129 à 32768</entry>
  <entry>none</entry>
  <entry>5432</entry>
  <entry>Non</entry>
  <entry>-p #</entry>
  <entry>
  Le port TCP sur lequel le serveur écoute.
  </entry>
  <entry>
  <para>
  Le changement du port PostgreSQL peut être une protection contre les vers
  de bases et les <i>script kiddies</i>. Néanmoins, il ne faudra pas oublier
  de donner l'option de port à <emphasis>tous</emphasis> les logiciels et
  bibliothèques effectuant une connexion, ce qui peut s'avérer pénible.
  </para>
  </entry>
 </row>
 <row>
  <entry>unix_socket_directory</entry>
  <entry></entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Non</entry>
  <entry>-k $</entry>
  <entry>
  Répertoire du socket de domaine Unix sur lequel le serveur écoute
  les connections de clients. Par défaut, c'est /tmp, mais le paramètre
  peut être modifié à la compilation.
  </entry>
  <entry>
  Ces options s'appliquent aux connexions UDP vers le serveur, utilisées en
  général uniquement à partir d'une console sur le serveur. (NDR&nbsp;:
  Comme je considère les connexions UDP non sécurisées, je les désactive.
  Je n'ai donc pas de recommendation particulière.)
  </entry>
 </row>
 <row>
  <entry>unix_socket_group</entry>
  <entry></entry>
  <entry></entry>
  <entry>''</entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
  Groupe propriétaire du socket de domaine Unix. (L'utilisateur propriétaire
  de ce socket est toujours celui qui démarre le serveur.) Combiné avec l'option
  UNIX_SOCKET_PERMISSIONS, ce paramètre peut être utilisé comme mécanisme
  supplémentaire de contrôle des accès pour ce type de socket. Par défaut, 
  c'est une chaîne vide, soit le groupe par défaut de l'utilisateur.
  </entry>
 </row>
 <row>
  <entry>unix_socket_permissions</entry>
  <entry></entry>
  <entry></entry>
  <entry>0777</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  <para>Permissions d'accès au socket de domaine Unix. Les sockets de domaine
Unix
  utilisent le système habituel de gestion des permissions des systèmes de 
  fichiers Unix. La valeur de l'option doit être précisée sous la forme
numérique
  acceptée par les outils système chmod et umask. L'utilisation du format 
  octal impose un 0 (zéro) en début de nombre.
  </para>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Sécurité et authentification</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>authentication_timeout</entry>
  <entry>1-600 sec</entry>
  <entry></entry>
  <entry>60</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Temps maximum laissé à un client pour réussir l'authentification, en secondes.
  Si un client potentiel n'a pas terminé la séquence d'authentification
  pendant ce temps, le serveur met fin à la connexion. Cela permet 
  d'éviter qu'un client bloqué n'occupe indéfiniment une connexion.
  Cette option ne peut être positionnée qu'au démarrage ou dans le fichier
  postgresql.conf.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>ssl</entry>
  <entry>true, false</entry>
  <entry>Voir les notes</entry>
  <entry>false</entry>
  <entry>Non</entry>
  <entry>-l</entry>
  <entry>Autoriser les connexions SSL</entry>
  <entry>
  SSL chiffre le traffic sur le post TCP/IP de sorte que les données
  transférées ne puissent pas être lues normallement. Du fait du chiffrement,
  cela implique une charge intense du CPU à la fois sur le client et le
  serveur. Cela peut aussi accroître la taille des données transférée.
  Néanmoins, SSL peut être difficile
  à configurer, et tout les clients ne supportent pas l'accès SSL.
  </entry>
 </row>
 <row>
  <entry>krb_server_keyfile</entry>
  <entry></entry>
  <entry></entry>
  <entry>''</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Positionne l'implantation du fichier de clés du serveur Kerberos.
  </entry>
  <entry>
  Utilisé uniquement pour l'authentification Kerberos des utilisateurs.
  </entry>
 </row>
 <row>
  <entry>virtual_host</entry>
  <entry></entry>
  <entry></entry>
  <entry>''</entry>
  <entry>No</entry>
  <entry>-h x</entry>
  <entry>
  Positionne le nom d'hôte ou l'adresse TCP/IP sur lequel/laquelle le
  postmaster écoute les connexions des applications clientes. Par défaut,
  écoute sur toutes les adresses configurées (y compris localhost).
  </entry>
  <entry>
  Essentiel pour les bases sur un réseau sécurisé comprenant une DMZ, ou
  lorsque le serveur de bases de données possède une adresse TCP/IP publique
  et une privée.
  </entry>
 </row>
 <row>
  <entry>db_user_namespace</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Permet les noms d'utilisateur par base de données. Désactivé par défaut.
  default.
  </entry>
  <entry>
  Par défaut, les utilisateurs peuvent, avec PostgreSQL, se connecter à
  n'importe quelle base. Dans certains cas, ce scénario n'est pas acceptable.
  Dans de tels cas, il est possible d'utiliser cette option. Cette
  fonctionnalité s'entend comme une mesure intérmédiaire en attendant une
  solution complète. Cette option sera supprimée par la suite.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Utilisation des ressources</title>

<sect2>
<title>Mémoire</title>

<note>
 <para>
  L'augmentation de la plupart de ces paramètres impose de règler les options
  du noyau système à la valeur de la mémoire autorisée par processus ou par
  utilisateur. La documentation en ligne donne des informations sur les
  commandes en fonction des systèmes d'exploitation. Sauf indication contraire,
  toutes les options mémoire s'additionnent pour déterminer la quantité totale
  de mémoire utilisée par PostgreSQL.
 </para>
</note>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>shared_buffers</entry>
  <entry>16 à Int Max</entry>
  <entry>8K RAM</entry>
  <entry>64</entry>
  <entry>Non</entry>
  <entry>-B x</entry>
  <entry>
  Positionne le nombre de tampons de mémoire partagée utilisé par le 
  serveur de bases de données. Le minimum est 2 X max_connections.
  </entry>
  <entry>
  <para>
  Positionne la taille du tampon mémoire de PostgreSQL où les requêtes sont
  stockées avant d'être passées au tampon noyau du système. Ce n'est qu'une
  zone de stockage, et <emphasis>non</emphasis> le total de la taille
  mémoire disponible pour le serveur. De ce fait, il est fortement
  déconseillé de positionner ce nombre à une part importante de la RAM, cela
  ayant des conséquences désastreuses sur les performances avec beaucoup de
  systèmes d'exploitation. Les membres de la liste de diffusion
  pgsql-performance ont abouti à une échelle utile se situant entre 1000 et
  6000, fonction de la RAM, de la taille de la base de données et du nombre de
  requêtes concurrentes. Pour les serveurs qui disposent d'une grande quantité
  de RAM (supérieure à 1 Go), l'augmentation de ce paramètre vers 6 à 15% de
  la RAM disponible a donné de bons résultats dans la plupart des cas.
  L'analyse réelle du meilleur paramétrage n'est pas exactement comprise,
  et l'expérience plus que le calcul permet l'ajustement de ce paramètre.
  </para>
  <para>
  Une règle empirique consiste à observer l'utilisation de la mémoire partagée
  par PostgreSQL à l'aide d'outils tel ipcs pour déterminer la valeur du
  paramètre. Cela ne représente toutefois que la moitié du paramétrage.
  Il est également nécessaire de régler effective_cache_size pour que
  PostgreSQL puisse utiliser efficacement la mémoire disponible.
  </para>
  </entry>
 </row>
 <row>
  <entry>
  sort_mem
  </entry>
  <entry>64 à Int Max</entry>
  <entry>1 KB</entry>
  <entry>1024</entry>
  <entry>Oui</entry>
  <entry>-S #</entry>
  <entry>
  <para>
  Précise la quantité de mémoire utisable par les opérations de tri interne et
  les tables de hachage avant d'utiliser des fichiers temporaires. La valeur
  est indiquée en kilooctets, la valeur par défaut est 1024 kilooctets (1Mo).
  En cas de requête complexe, de nombreuses opérations de tri ou de hachage
  peuvent s'exécuter en parallèle&nbsp;; chacune peut utiliser la quantité
  de mémoire indiquée par la valeur de ce paramètre avant de commencer à
  utiliser des fichiers temporaires. De plus, de nombreuses sessions
  peuvent effectuer ces opérations concurrentiellement. La mémoire totale
  utilisée peut être plusieurs fois la valeur de SORT_MEM. Les opérations
  de tri sont utilisées par ORDER BY, DISTINCT et les jointures.
  </para>
  <para>
  Les options en ligne de commande nécessite d'utiliser -o 'option'.
  </para>
  </entry>
  <entry>
  <para>
  sort_mem est difficile à ajuster. Une plus grande valeur est utilisée
pour&nbsp;: les
  bases de données volumineuses, les requêtes complexes, une grande quantité de 
  RAM disponible. Une plus petite valeur est recherchée pour&nbsp;: une faible
  quantité de RAM ou de nombreux accès concurrents. Trouver le bon compromis
  peut s'avérer délicat.
  </para>
  <para>
  Une autre façon d'ajuster cette valeur consiste à surveiller les fichiers
  temporaires de PostgreSQL (dans PGDATA/base/DB_OID/pgsql_tmp) et d'accroître
  la valeur de sort_mem si de nombreuses requêtes permutent avec ces fichiers.
  </para>
  <para>
  Il ne faut pas oublier que ce paramètre peut être positionné par connexion.
  Ainsi, dans le cas où seules quelques requêtes très complexes sont à
  exécuter, la valeur peut être augmentée avant leur exécution, mais conservée
  basse pour les autres connexions.
  </para>
  </entry>
 </row>
 <row>
  <entry>vacuum_mem</entry>
  <entry>1024 à Int Max</entry>
  <entry>1 KB</entry>
  <entry>8192</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Précise la quantité maximale de mémoire que VACUUM peut utiliser pour
  conserver une trace des tuples à rendre. La valeur est précisée en kilooctets.
la valeur par défaut est de 8&nbsp;192&nbsp;ko. Une valeur supérieure peut
accélérer le nettoyage de grandes tables dont de nombreux tuples ont été
supprimés.
  </entry>
  <entry>
  <para>
  Ce paramètre n'utilise de RAm que lors des VACUUM. Il peut donc être augmenté
sur les machines disposant de beaucoup de RAM pour accéler les VACUUM (mais pas
plus de 20% de la RAM disponible).
  </para>
  <para>
  Ce paramètre peut de plus être positionné à l'exécution. il peut alors être
judicieux de le régler à une valeur basse pour les VACUUM réguliers et de le
positionner à une valeur plus élevée pour les VACUUM FULL de
nuit/hebdomadaires/périodiques.
  </para>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Free Space Map</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>max_fsm_pages</entry>
  <entry>1000 à Int Max</entry>
  <entry>6 octets RAM</entry>
  <entry>10000</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Positionne le nombre maximum de pages disque pour lesquels l'espace
  libre est recherché dans la mappe de l'espace libre partagé.
  La valeur par défaut est 10&nbsp;000. Cette option ne peut être positionnée 
  qu'au démarrage du serveur.
  </entry>
  <entry>
  <para>
    Un paramétrage correct de la FSM peut éliminer, ou au moins, retarder
  l'obligation d'exécuter VACUUM FULL et REINDEX. La meilleure façon de le
régler 
  est la suivante&nbsp;: 1) calculer la fréquence du VACUUM (normal) de la
  base en fonction des écritures&nbsp;; 2) utiliser la base en fonctionnement
  normal et exécuter VACUUM VERBOSE ANALYZE à la place de VACUUM, en
sauvegardant
  la sortie dans un fichier&nbsp;; 3) calculer le nombre de pages maximum
réclamé
  par VACUUM et utiliser ce chiffre.
  </para>
  <para>
  Si l'approche précédente n'est pas réalisable, essayer d'estimer le nombre
total de lignes qui peuvent être actualisées ou supprimées entre deux VACUUM, et
utiliser la moitié de ce nombre, en l'augmentant en fonction de la quantité de
travail qu'un VACUUM FULL périodique continue d'effectuer.
  </para>
  <para>
  Pour les base de données qui connaissent des &laquo;&nbsp;pics&nbsp;&raquo;
  d'activité (rafales d'un million de mises à jour mais pas d'autre
  activité des minutes ou des heures durant), ce nombre peut être 
  impossible à optimiser. Les lignes insérées n'ont pas d'impact
  sur la FSM. Enfin, si le serveur est peu fourni en RAM, augmenter
  cette valeur peut s'avérer contre-productif.
  </para>
  </entry>
 </row>
 <row>
  <entry>max_fsm_relations</entry>
  <entry>10 à Int Max</entry>
  <entry>40 octets RAM</entry>
  <entry>100</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Positionne le nombre maximum de relations (tables) pour
  lesquels l'espace libre est recherché dans la mappe de l'espce libre
  partagé.
  </entry>
  <entry>
  Ce paramètre doit être positionné au nombre de tables attendues dans la
base... entre 300 et 500. PostgreSQL a un comportement étrange s'il ne possède
pas assez de FSM_relations.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Disk Resource Usage</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>max_files_per_process</entry>
  <entry>25 à Int Max</entry>
  <entry></entry>
  <entry>1000</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Fixe le nombre maximum de fichiers simultanément ouverts par chaque
  sous-processus du serveur. La valeur par défaut est 1&nbsp;000. 
  La limite actuellement utilisée par le code est la plus petite valeur du
paramètre et le résultat de sysconf(_SC_OPEN_MAX). Toutefois, sur les systèmes
pour lesquels sysconf retourne une valeur raisonnable, il n'est pas nécessaire
  de s'inquiéter de ce paramètre. Mais sur la plupart des plateformes
  (et notamment BSD), sysconf retourne une valeur
  beaucoup plus grande que ce que le système peut réellement prendre en charge
  lorsque de nombreux processus essayent tous d'ouvrir ce nombre de fichiers.
  Si le message d'erreur &laquo;&nbsp;Trop de fichiers ouverts&nbsp;&raquo;
  (<foreignphrase>"Too many open files"</foreignphrase>) apparaît, 
  il faut alors essayer de réduire ce paramètre. Il ne peut être
  fixé qu'au démarrage du serveur ou dans le fichier postgresql.conf. Modifié
dans le fichier de configuration, il n'affectera que les sous-processus serveur
ouverts après modification.
  </entry>
  <entry>
  D'après la documentation, utilisé essentiellement pour BSD. À considérer
uniquement
  à l'appartion de messages &laquo;&nbsp;Trop de fichiers ouverts&nbsp;&raquo;
  (<foreignphrase>"Too many open files"</foreignphrase>).
  </entry>
 </row>
 <row>
  <entry>preload_libraries</entry>
  <entry>Chemin de fichier</entry>
  <entry>Voir les notes</entry>
  <entry>Vide</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Indique les bibliothèques à précharger au démarrage du serveur. Une
  fonction d'initialisation peut optionnellement être
  appelée pour chaque bibliothèque. Pour cela, il suffit d'ajouter un 
  double-point et le nom de la fonction d'initialisation après le
  nom de la bibliothèque. '$libdir/mylib:mylib_init' implique, par exemple,
  le préchargement de mylib et l'exécution de la fonction mylib_init.
  Si plusieurs bibliothèques doivent être chargées, leurs noms
  sont séparés par des virgules. Si mylib n'est pas trouvée, le serveur ne
démarrera pas. En revanche, si init_mylib n'est pas trouvée, mylib est
préchargée sans exécuter la fonction d'initialisation.  </entry>
  <entry>
  Le préchargement (et l'initialisation éventuelle) d'une bibliothèque
  partagée permet d'éviter le temps de chargement de la bibliothèque
  la première fois qu'elle est utilisée. Cela se traduit par un temps de
démarrage du serveur plus long et des temps d'appel des bibliothèques qui ne
sont pas chargées en mémoire plus courts.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Options WAL</title>

<sect2>
<title>Paramètres</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>fsync</entry>
  <entry>true, false</entry>
  <entry>Voir les notes</entry>
  <entry>true</entry>
  <entry>Non</entry>
  <entry>-F (off)</entry>
  <entry>
  Lorsque cette option est activée, le serveur PostgreSQL utilise les appels
  système fsync() pour s'assurer que les mises à jour sont physiquement écrites
  sur le disque. Cela garantit la récupération d'une bases de données
  cohérente après une panne matérielle ou système. Ce fonctionnement n'a aucune
incidence sur la gestion des pannes du serveur de bases de données.
  </entry>
  <entry>
  <note>
  <para>
  Depuis la version 7.2, la désactivation de fsync n'arrête
<emphasis>PAS</emphasis> le WAL. Toutefois, il n'y a plus de points de reprise.
La journalisation des écritures anticipées (<foreignphrase>Write-Ahead
  Logging ou WAL</foreignphrase>) ne doit être désactivée (fsync=off) que sur
les bases en
  lecture seule ou celles qu'il est possible de régénérer à l'aide de logiciels
  externes. Tandis que du RAID associé à un système de haute-disponibilité
  électrique peuvent aider à la protection des données, la désactivation de
  fsync <emphasis>impose</emphasis> la restauration des données à partir de
  sauvegardes en cas de pannes matériel ou électrique.
  </para>
  </note>
  <para>
  D'un autre côté, le WAL implique une baisse de performances lors des
écritures, à
  plus forte raison sur des systèmes mono-disques. Pour l'essentiel l'activité
  nécessaire aux opérations de lecture/écriture est doublée à chaque mise à
  jour. De plus, les fonctionnalités d'amélioration des performances par cache
  disque matériel ou logiciel sont désactivées.
  </para>
  <para>
   Si le WAL est arrêté, les options qui suivent n'ont pas d'intérêt.
  </para>
  </entry>
 </row>
 <row>
  <entry>wal_sync_method</entry>
  <entry>fsync, fdatasync, open_sync, ou open_datasync</entry>
  <entry></entry>
  <entry>Dépend de la plateforme</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Méthode utilisée pour forcer la mise à jour des WAL sur le disque. Les valeurs
  possibles sont FSYNC (fsync() est appelé à chaque validation), FDATASYNC
  (fdatasync() est appelé à chaque validation), OPEN_SYNC (écrit les fichiers
  WAL avec l'option O_SYNC d'open()) et OPEN_DATASYNC (écrit les fichiers WAL
  avec l'option O_DSYNC d'open()). Ces choix ne sont pas tous disponibles sur
  toutes les plateformes.
  </entry>
  <entry>
  Il s'agit de l'appel système utilisé pour synchroniser les WAL sur disque. La
  valeur par défaut a été réglée pour chaque OS en fonction de la documentation
  de l'OS. En revanche, aucun test comparatif n'a été mené. Il est possible que
  le changement de méthode accélère l'écriture sur une plateforme spécifique,
  mais cela ne doit être tenté que si les ressources nécessaires à des tests
  comparatifs et de régression sont disponibles. La modification des valeurs par
défaut peut altérer la protection par le WAL.
  </entry>
 </row>
 <row>
  <entry>wal_buffers</entry>
  <entry>4 à Int Max</entry>
  <entry>8K RAM</entry>
  <entry>8</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Nombre de tampons de pages disque alloués dans la mémoire partagée
  pour la journalisation du WAL.
  </entry>
  <entry>
  L'accroissement de ce paramètre peut accélérer les écritures du WAL pour les
transactions volumineuses. &Agrave; ce jour, personne n'a rendu compte d'une
analyse de l'impact de ce paramètre.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Checkpoints</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>checkpoint_segments</entry>
  <entry>1 à Int Max</entry>
  <entry>16 Mo sur disque</entry>
  <entry>3</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Distance maximale entre deux points de contôle WAL automatiques, en segments de
  fichier journal (chaque segment représente normalement 16 Mo).
  </entry>
  <entry>
  Ce paramètre est augmenté lorsque la base requiert de nombreux écritures d'arrière-plan pour diminuer la fréquence des points de reprise (et ainsi diminuer l'éctivité du disque). Si la place disque manque ou que l'environnement présente un risque de coupures de courant inattendues sce paramètre peut être diminué. En effet, toute transaction non visée par un point de reprise sera supprimée au redémarrage.
  </entry>
 </row>
 <row>
  <entry>checkpoint_timeout</entry>
  <entry>30 à 3600</entry>
  <entry>Voie les notes</entry>
  <entry>300</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Temps maximal entre deux points de contôle WAL automatiques, en secondes.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>checkpoint_warning</entry>
  <entry>0 à Int Max</entry>
  <entry>Voir les notes</entry>
  <entry>0</entry>
  <entry>Non</entry>
  <entry></entry>
  <entry>
  Un message est envoyé dans les journaux du serveur si la fréquence des points
de contrôle
  engendrés par le remplissage des fichiers de segments de points de contrôle 
  est supérieure à ce temps, en secondes. Zéro désactive les alertes.
  </entry>
  <entry>
  Nouvelle option qui peut être utile pour affiner les checkpoint_segments sur les bases à forte activité d'écriture. Des alertes
  nombreuses dans les journaux incitent à accroitre le paramètre checkpoint_segments.
  </entry>
 </row>
 <row>
  <entry>commit_delay</entry>
  <entry>0-100000</entry>
  <entry>Voir les notes</entry>
  <entry>0</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Indique le délai, en microsecondes, entre l'écriture d'une validation dans le
  tampon WAL et la purge du tampon sur disque. Un délai positif peut permettre
  la validation de plusieurs transactions avec un seul appel système fsync(), si
  la charge système est suffisamment élevée pour que de nouvelles transactions
  soient prêtes pendant cet interval. Mais ce délai est perdu dans le cas
  contraire. Ainsi, le délai n'est exécuté que si au moins commit_siblings autres
  transactions sont actives au moment où le processus serveur a écrit sa
  validation.
  </entry>
  <entry>
  Ces deux paramètres sont configurés ensemble pour un environnement à fort
  volume de petites transactions. Activés, ils permettent de purger en même
  temps sur disques des transactions sans relation entre elles, qui autrement ne
  le seraient pas, avec à la clé un potentiel accroissement des performances.
  En revanche, si l'espace disque est restreint ou que la stabilité électrique de l'environnement ne peut être garantie, il est préférable de ne pas modifier ces paramètres.
  </entry>
 </row>
 <row>
  <entry>commit_siblings</entry>
  <entry>1-1000</entry>
  <entry>Voir les notes</entry>
  <entry>5</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Indique le nombre minimum de transactions concurrentes ouvertes avant
  l'éxécution du délai COMMIT_DELAY. Plus la valeur est grande, plus la
  probabilité de valider une autre transaction pendant cet interval grandit.
  </entry>
  <entry>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Optimisation des requêtes</title>

<sect2>
<title>Méthodes du planificateur</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>enable_hashagg</para>
  <para>enable_hashjoin</para>
  <para>enable_indexscan</para>
  <para>enable_mergejoin</para>
  <para>enable_nestloop</para>
  <para>enable_seqscan</para>
  <para>enable_sort</para>
  <para>enable_tidscan</para>
  </entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>true</entry>
  <entry>Oui</entry>
  <entry>
  <para></para>
  <para>-fi</para>
  <para>-fm</para>
  <para>-fn</para>
  <para>-fs</para>
  <para></para>
  <para>-ft*</para>
  <para></para>
  </entry>
  <entry>
  <para>
  Enables or disables the query planner's use of the respective plan types.
  The default is on. This is used for debugging the query planner.
  </para>
  <para>
  Les options en ligne de commande requièrent l'utilisation de -o 'option'.
  </para>
  </entry>
  <entry>
  <para>
  Ces options ne devraient être utilisées que pour tester les requêtes&nbsp;; il
  est courant, par exemple, de positionner &laquo;&nbsp;enable_seqscan =
false&nbsp;&raquo;
  pour déterminer si le planificateur n'omet pas inutilement un index. Quoi
  qu'il en soit, seules des circonstances extraordinaires nécessitent qu'un
  de ces paramètres soit positionné à <foreignphrase>false</foreignphrase> dans
  le fichier .conf.
  </para>
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Constantes de coût du planificateur</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>effective_cache_size</entry>
  <entry>0 à Int Max</entry>
  <entry>8 KB</entry>
  <entry>1000</entry>
  <entry>Oui</entry>
  <entry></entry>
  <entry>
  Sets the optimizer's assumption about the effective size of the disk cache
  (that is, the portion of the kernel's disk cache that will be used for
  PostgreSQL data files). This is measured in disk pages, which are normally
  8 kB each.
  </entry>
  <entry>
  An oft-overlooked setting that can result in better use of RAM on high-memory
  computers if raised to a correct level. I use 25% of my &#8220;available
  RAM&#8221; (after Linux and applications) as a general level, but have not
  tested extensively. Please note that if this setting is tuned, one need not
  increase shared_buffers unnecessarily.
  </entry>
 </row>
 <row>
  <entry>
  <para>random_page_cost</para>
  <para>cpu_tuple_cost</para>
  <para>cpu_index_tuple_cost</para>
  <para>cpu_operator_cost</para>
  </entry>
  <entry>0 to Double</entry>
  <entry>
  <para></para>
  <para>0.01</para>
  <para>0.001</para>
  <para>0.0025</para>
  </entry>
  <entry>4</entry>
  <entry>
  </entry>
  <entry>Yes</entry>
  <entry>
  Sets the query optimizer's estimate of the cost of processing each page
  lookup, tuple, index lookup, and where clause item (respectively) during a
  query. This is measured as a fraction of the cost of a sequential page
  fetch.
  </entry>
  <entry>
  The default costs are based entirely on anecdotal experience, and are
  probably not ideal for your system. For example, machines with very fast
  seeking disk arrays should probably lower the random_page_cost. Remember,
  though, that when testing values for these settings you need to test a
  variety of queries, as the right setting for one kind of query can hurt
  another. Fortunately, since these settings are all relative to the cost of a
  sequential fetch, they are unlikely to be too far off in a balanced system.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Genetic Estimate Query Optimizer</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>geqo</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>true</entry>
  <entry></entry>
  <entry></entry>
  <entry>
  Enables or disables genetic query optimization, which is an algorithm that
  attempts to do query planning without exhaustive searching. This is on by
  default. See also the various other GEQO_ settings.
  </entry>
  <entry>
  <para>
  GEQO was introduced in PostgreSQL 6.5 as a way of dealing with join
  optimization queries with too many tables for an exhaustive analysis by the
  planner. It was quite revolutionary at the time, but was never fully
  optimized, and has been relatively indifferently maintained since then. Since
  new, faster CPUs and more, faster RAM has made exhaustive query planning more
  affordable, I raise the GEQO threshold, usually to 20-25 tables. This
  prevents GEQO from being used except in the situations where it is really the
  only option. Of course, if you are running PostgreSQL on a machine with
  limited (available) CPU power, you may want to use a lower GEQO threshold
  than that.
  </para>
  <para>
  If you are certain that you will never have a query that complex, you can
  just turn it off.
  </para>
  </entry>
 </row>
 <row>
  <entry>geqo_threshold</entry>
  <entry>2 to Int Max</entry>
  <entry></entry>
  <entry>11</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Use genetic query optimization to plan queries with at least this many FROM
  items involved. (Note that a JOIN construct counts as only one FROM item.)
  The default is 11. For simpler queries it is usually best to use the
  deterministic, exhaustive planner. This parameter also controls how hard
  the optimizer will try to merge subquery FROM clauses into the upper query.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>
  <para>geqo_selection_bias</para>
  <para>geqo_pool_size</para>
  <para>geqo_effort</para>
  <para>geqo_generations</para>
  <para>geqo_random_seed</para>
  </entry>
  <entry>1.5-2.0</entry>
  <entry></entry>
  <entry>
  <para>2.0</para>
  <para>0</para>
  <para>1</para>
  <para>0</para>
  <para>-1</para>
  </entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Various tuning parameters for the genetic query optimization algorithm: The
  pool size is the number of individuals in one population. Valid values are
  between 128 and 1024. If it is set to 0 (the default) a pool size of
  2^(QS+1), where QS is the number of FROM items in the query, is taken. The
  effort is used to calculate a default for generations. Valid values are
  between 1 and 80, 40 being the default. Generations specifies the number of
  iterations in the algorithm. The number must be a positive integer. If 0 is
  specified then Effort * Log2(PoolSize) is used. The run time of the algorithm
  is roughly proportional to the sum of pool size and generations. The
  selection bias is the selective pressure within the population. Values can be
  from 1.50 to 2.00; the latter is the default. The random seed can be set to
  get reproducible results from the algorithm. If it is set to -1 then the
  algorithm behaves non-deterministically.
  </entry>
  <entry></entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Query and Index Statistics</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>stats_start_collector</para>
  <para>stats_reset_on_server_start</para>
  <para>stats_command_string</para>
  <para>stats_row_level</para>
  <para>stats_block_level</para>
  </entry>
  <entry>true, false</entry>
  <entry>
  <para>true</para>
  <para>true</para>
  <para>false</para>
  <para>false</para>
  <para>false</para>
  </entry>
  <entry></entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
  These flags determine what information backends send to the statistics
  collector process: current commands, block-level activity statistics, or
  row-level activity statistics. All default to off. Enabling statistics
  collection costs a small amount of time per query, but is invaluable for
  debugging and performance tuning.
  </entry>
  <entry>
  Eventually I will have an article on Techdocs explaining how to use the
  query statistics to tune your use of indexes. These are particularly useful
  for a &#8220;deductive&#8221; approach to indexing, where you index
  everything and then drop the indexes which are not used.
  </entry>
 </row>
 <row>
  <entry>default_statistics_target</entry>
  <entry>1 -1000</entry>
  <entry></entry>
  <entry>10</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Sets the default statistics target for table columns that have not had a
  column-specific target set via ALTER TABLE SET STATISTICS. Larger values
  increase the time needed to do ANALYZE, but may improve the quality of the
  planner's estimates.
  </entry>
  <entry>
  It can be useful to raise this target if your main tables all have very
  uneven distribution in often-queried columns. Raising it does make ANALYZE
  take longer.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Other Query Modifiers</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>explain_pretty_print</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Determines whether EXPLAIN VERBOSE uses the indented or non-indented format
  for displaying detailed query-tree dumps.
  </entry>
  <entry>
  Try it and see. The extra formatting is useful for some people, but not for
  everyone.
  </entry>
 </row>
 <row>
  <entry>from_collapse_limit</entry>
  <entry>0 to Int Max</entry>
  <entry></entry>
  <entry>8</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  The planner will merge sub-queries into upper queries if the resulting FROM
  list would have no more than this many items. Smaller values reduce planning
  time but may yield inferior query plans. The default is 8. It is usually
  wise to keep this less than GEQO_THRESHOLD.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>join_collapse_limit</entry>
  <entry>1 to Int Max</entry>
  <entry></entry>
  <entry>8</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  The planner will flatten explicit inner JOIN constructs into lists of FROM
  items whenever a list of no more than this many items would result. Usually
  this is set the same as FROM_COLLAPSE_LIMIT. Setting it to 1 prevents any
  flattening of inner JOINs, allowing explicit JOIN syntax to be used to
  control the join order. Intermediate values might be useful to trade off
  planning time against quality of plan.
  </entry>
  <entry>
  This option is designed for those of us who like writing our queries using
  explicit JOIN syntax (e.g. &#8220;a join b using (1) join c using (2)&#8221;),
  but would still like the planner to select the join order for best execution.
  Particularly, people switching from MS SQL Server will want to enable this
  option with a moderately high value, as that database does JOIN collapsing
  automatically.
  </entry>
 </row>
 <row>
  <entry>max_expr_depth</entry>
  <entry>10 to Int Max</entry>
  <entry></entry>
  <entry>10000</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Sets the maximum expression nesting depth of the parser. The default value
  is high enough for any normal query, but you can raise it if needed. (But if
  you raise it too high, you run the risk of backend crashes due to stack
  overflow.)
  </entry>
  <entry>
  I cannot imagine anyone needing to raise this.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Logging and Messaging Options</title>

<sect2>
<title>Syslog</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>syslog</para>
  <para>syslog_facility</para>
  <para>syslog_ident</para>
  </entry>
  <entry>0-2</entry>
  <entry>
  <para>0</para>
  <para>LOCAL0</para>
  <para>postgres</para>
  </entry>
  <entry></entry>
  <entry></entry>
  <entry>No</entry>
  <entry>
  PostgreSQL allows the use of syslog for logging. If this option is set to
  1, messages go both to syslog and the standard output. A setting of 2 sends
  output only to syslog. (Some messages will still go to the standard
  output/error.) The default is 0, which means syslog is off. This option must
  be set at server start.
  </entry>
  <entry>
  Very useful if you have syslog management tools of some sort. Otherwise can
  make it difficult to separate PostgreSQL output from numerous other
  processes.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>When to Log/Message</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>server_min_messages</para>
  <para>client_min_messages</para>
  <para>log_min_error_statement</para>
  </entry>
  <entry>
  debug5, debug4, debug3, debug2, debug1,
  info, notice, warning, error, log, fatal, panic
  </entry>
  <entry></entry>
  <entry>notice</entry>
  <entry>Yes</entry>
  <entry>-d x</entry>
  <entry>
  This controls how much message detail is written to the server logs. Valid
  values are DEBUG5, DEBUG4, DEBUG3, DEBUG2, DEBUG1, INFO, NOTICE, WARNING,
  ERROR, LOG, FATAL, and PANIC. Later values send less detail to the logs. The
  default is NOTICE. Note that LOG has a different precedence here than in
  CLIENT_MIN_MESSAGES.
  </entry>
  <entry>
  Raising debug levels is always good for testing applications. The cost is
  greater use of disk space, some minor performance cost for output (usually
  &lt; 5%). However, the performance cost increases significantly if your logs
  are on the same disk/array as WAL or your database, as heavy debug output
  will take I/O away from database activity. The impact of debug5 on a
  high-transaction single-disk system can be quite high. This caution applies
  to all of the logging options below.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>What to Log</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>debug_print_parse</para>
  <para>debug_print_rewritten</para>
  <para>debug_print_plan</para>
  <para>debug_pretty_print</para>
  </entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  These flags enable various debugging output to be sent to the server log. For
  each executed query, print either the query text, the resulting parse tree,
  the query rewriter output, or the execution plan. DEBUG_PRETTY_PRINT indents
  these displays to produce a more readable but much longer output format.
  </entry>
  <entry>
  Can be useful for detecting common slow queries if you are able to wade
  through the voluminous log output. Particularly useful in interactive log
  watching when procedures hang; you can sometimes see exactly what step
  hangs (sometimes you can't, though, because the log waits on the database).
  </entry>
 </row>
 <row>
  <entry>
  <para>log_connections</para>
  <para>log_pid</para>
  <para>log_statement</para>
  <para>log_duration</para>
  <para>log_timestamp</para>
  </entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>
  <para>No</para>
  <para>No</para>
  <para>Yes</para>
  <para>Yes</para>
  <para>Yes</para>
  </entry>
  <entry></entry>
  <entry>
  Logs respective items.
  </entry>
  <entry>
  <para>
  All can be useful depending on what problems you are expecting. I generally
  leave log_timestamp on and the others off.
  </para>
  <note>
  <para>
  A patch was proposed which would allow users to turn logging options on, but
  only the superuser would be able to turn them off. I don't know whether this
  patch will make it into 7.4 or not.
  </para>
  </note>
  </entry>
 </row>
 <row>
  <entry>
  log_hostname
  </entry>
  <entry>true, false</entry>
  <entry>See notes</entry>
  <entry>false</entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
  By default, connection logs only show the IP address of the connecting host.
  If you want it to show the host name you can turn this on, but depending on
  your host name resolution setup it might impose a non-negligible performance
  penalty.
  </entry>
  <entry>
  This can be useful for debugging/security management, but if DNS is not local
  can delay new connections significantly.
  </entry>
 </row>
 <row>
  <entry>
  log_source_port
  </entry>
  <entry>true, false</entry>
  <entry>See notes</entry>
  <entry>false</entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
  Shows the outgoing port number of the connecting host in the connection log
  messages. You could trace back the port number to find out what user initiated
  the connection. Other than that, it's pretty useless and therefore off by
  default.
  </entry>
  <entry>
  Imposes a significant but unmeasured performance penalty due to lookup as
  well as extra logging activity.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Statistics Logging</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>show_parser_stats</para>
          <para>show_planner_stats</para>
          <para>show_executor_stats</para>
          <para>show_statement_stats</para>
          <para>log_parser_stats</para>
	  <para>log_planner_stats</para>
          <para>log_executor_stats</para>
          <para>log_statement_stats</para>
  </entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>No*</entry>
  <entry>
  <para>-tpa</para>
  <para>-tpl</para>
  <para>-te</para>
  <para>-s</para>
  </entry>
  <entry>
  <para>
  For each query, write performance statistics of the respective module to
  the server log. This is a crude profiling instrument.
  </para>
  <para>
  Command-line options require use of -o &#8220;option&#8221;.
  </para>
  </entry>
  <entry>
  May be SET by superuser.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Client Connection Defaults</title>

<sect2>
<title>Statement Behavior</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>search_path</entry>
  <entry>path</entry>
  <entry>None</entry>
  <entry>'$user,public'</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  This variable specifies the order in which schemas are searched when an
  object (table, data type, function, etc.) is referenced by a simple name
  with no schema component. When there are objects of identical names in
  different schemas, the one found first in the search path is used. An object
  that is not in any of the schemas in the search path can only be referenced
  by specifying its containing schema with a qualified (dotted) name.
  </entry>
  <entry>
  If your application makes heavy use of schema, you can reverse this search
  path to make sure that public objects will override user-schema objects with
  the same name. Otherwise, leave it alone.
  </entry>
 </row>
 <row>
  <entry>default_transaction_isolation</entry>
  <entry>read committed, serializable</entry>
  <entry>See Note</entry>
  <entry>'read committed'</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Each SQL transaction has an isolation level, which can be either "read
  committed" or "serializable". This parameter controls the default isolation
  level of each new transaction. Consult the PostgreSQL User's Guide and the
  command SET TRANSACTION for more information.
  </entry>
  <entry>
  The default, here, is the value that supports standard MVCC behavior.
  &#8220;Serializable&#8221; is mainly useful for when you need to launch
  long-running procedures which must be successive, or when your updates pose a
  significant and regular risk of deadlock. Under a heavy multi-user load,
  setting &#8220;serializable&#8221; can impose a significant penalty as
  numerous transactions are forced to wait for the serialized transaction to
  complete. In a single-concurrent-user database, there should be little
  effect.
  </entry>
 </row>
 <row>
  <entry>default_transaction_read_only</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  A read-only SQL transaction cannot alter non-temporary tables. This parameter
  controls the default read-only status of each new transaction. The default is
  false (read/write).
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>statement_timeout</entry>
  <entry>0 to Int Max</entry>
  <entry>See Note</entry>
  <entry>0</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Aborts any statement that takes over the specified number of milliseconds.
  A value of zero turns off the timer.
  </entry>
  <entry>
  Designed to help the application where it is possible to users to execute
  queries that swamp the CPU for minutes, such as apps that allow dynamic
  queries. Setting this value to a finite amount can prevent those users from
  monopolizing resources, but you'll need to be prepared to deal with the
  exception.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Locale and Formatting</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>
  <para>datestyle</para>
  <para>timezone</para>
  <para>australian_timezones</para>
  </entry>
  <entry></entry>
  <entry>None</entry>
  <entry>
  <para>'iso, us'</para>
  <para>unknown</para>
  <para>false</para>
  </entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  <para>
  Sets the display format for dates, as well as the rules for interpreting
  ambiguous input dates.
  </para>
  <para>
  Sets the time zone for displaying and interpreting timestamps. The default
  is to use whatever the system environment specifies as the time zone.
  </para>
  <para>
  If set to true, CST, EST, and SAT are interpreted as Australian time zones
  rather than as North American Central/Eastern time zones and Saturday.
  </para>
  </entry>
  <entry>
  For changing the default display of dates and interpretation of timezones to
  suit your locality and/or organization standards.
  </entry>
 </row>
 <row>
  <entry>extra_float_digits</entry>
  <entry>-14 to 2</entry>
  <entry>None</entry>
  <entry>0</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  This parameter adjusts the number of digits displayed for floating-point
  values, including float4, float8, and geometric data types. The parameter
  value is added to the standard number of digits (FLT_DIG or DBL_DIG as
  appropriate). The value can be set as high as 2, to include
  partially-significant digits; this is especially useful for dumping float
  data that needs to be restored exactly. Or it can be set negative to suppress
  unwanted digits.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>
  <para>lc_messages</para>
  <para>lc_monetary</para>
  <para>lc_time</para>
  <para>lc_numeric</para>
  </entry>
  <entry>System-dependent</entry>
  <entry>None</entry>
  <entry>Special</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Sets the locale to use for formatting error messages, monetary amounts, time
  and numeric values. Acceptable values are system-dependent; see Section 7.1
  for more information. If this variable is set to the empty string (which is
  the default) then the value is inherited from the execution environment of
  the server in a system-dependent way.
  </entry>
  <entry>
  These settings are set by the initdb script when it creates your PGDATA
  directory. Should be set to your language, currency, etc.
  </entry>
 </row>
 <row>
  <entry>client_encoding</entry>
  <entry>OS-dependent</entry>
  <entry>None</entry>
  <entry>sql_ascii</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Sets the client-side encoding for multi-byte character sets. The default is
  to use the database encoding.
  </entry>
  <entry>
  Usually ignored in favor of database encoding. Would be set per client only
  for multi-lingual applications, which would then require considerable care to
  manage the different encodings.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Other Defaults</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>password_encryption</entry>
  <entry>true, false</entry>
  <entry>None</entry>
  <entry>true</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  When a password is specified in CREATE USER or ALTER USER without writing
  either ENCRYPTED or UNENCRYPTED, this flag determines whether the password
  is to be encrypted.
  </entry>
  <entry>
  Should remain set to true, for all practical purposes.
  </entry>
 </row>
 <row>
  <entry>dynamic_library_path</entry>
  <entry>path</entry>
  <entry>None</entry>
  <entry>'$libdir'</entry>
  <entry>No*</entry>
  <entry></entry>
  <entry>
  If a dynamically loadable module needs to be opened and the specified name
  does not have a directory component (i.e. the name does not contain a slash),
  the system will search this path for the specified file. (The name that is
  used is the name specified in the CREATE FUNCTION or LOAD command.)
  </entry>
  <entry>
  Can be SET by superuser.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Lock Management</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>deadlock_timeout</entry>
  <entry>1 to Int Max</entry>
  <entry>See Note</entry>
  <entry>1000</entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
  This is the amount of time, in milliseconds, to wait on a lock before
  checking to see if there is a deadlock condition. The check for deadlock is
  relatively slow, so the server doesn't run it every time it waits for a lock.
  We (optimistically?) assume that deadlocks are not common in production
  applications and just wait on the lock for a while before starting check for
  a deadlock. Increasing this value reduces the amount of time wasted in
  needless deadlock checks, but slows down reporting of real deadlock errors.
  The default is 1000 (i.e., one second), which is probably about the smallest
  value you would want in practice. On a heavily loaded server you might want
  to raise it. Ideally the setting should exceed your typical transaction time,
  so as to improve the odds that the lock will be released before the waiter
  decides to check for deadlock.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>max_locks_per_transaction</entry>
  <entry>10 to Int Max</entry>
  <entry></entry>
  <entry>64</entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
  The shared lock table is sized on the assumption that at most
  max_locks_per_transaction * max_connections distinct objects will need to be
  locked at any one time. The default, 64, which has historically proven
  sufficient, but you might need to raise this value if you have clients that
  touch many different tables in a single transaction. This option can only be
  set at server start.
  </entry>
  <entry></entry>
 </row>
</tbody>
</tgroup>
</table>

</sect1>

<sect1>
<title>Version and Platform Compatibility</title>

<sect2>
<title>Previous PostgreSQL Versions</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>add_missing_from</entry>
  <entry>true, false</entry>
  <entry>None</entry>
  <entry>true</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Enables planner to &#8220;Add Missing From Clause&#8221; when you omit a
  table from your query. Will be false by default in future versions.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>regex_flavor</entry>
  <entry>advanced, extended, basic</entry>
  <entry>None</entry>
  <entry>advanced</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  The regular expression "flavor" can be set to advanced, extended, or basic.
  The usual default is advanced. The extended setting may be useful for exact
  backwards compatibility with pre-7.4 releases of PostgreSQL.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>sql_inheritance</entry>
  <entry>true, false</entry>
  <entry>None</entry>
  <entry>true</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  This controls the inheritance semantics, in particular whether subtables are
  included by various commands by default. They were not included in versions
  prior to 7.1. If you need the old behavior you can set this variable to off,
  but in the long run you are encouraged to change your applications to use the
  ONLY keyword to exclude subtables.
  </entry>
  <entry></entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Platform and Client Compatibility</title>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>transform_null_equals</entry>
  <entry>true, false</entry>
  <entry>None</entry>
  <entry>false</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  When turned on, expressions of the form expr = NULL (or NULL = expr) are
  treated as expr IS NULL, that is, they return true if expr evaluates to the
  null value, and false otherwise. The correct behavior of expr = NULL is to
  always return null (unknown).
  </entry>
  <entry></entry>
 </row>
</tbody>
</tgroup>
</table>

</sect2>

</sect1>

<sect1>
<title>Source Developer Options</title>

<note>
<para>
These options have been dropped from postgresql.conf in 7.4 because there are
not useful user options, but instead are aimed at source developers. Most DBAs
should have no reason to modify them.
</para>
</note>

<table>
<tgroup cols="8" align="left" colsep="1" rowsep="1">

<thead>
 <row>
  <entry>Paramètre</entry>
  <entry>&Eacute;chelle</entry>
  <entry>Ressources</entry>
  <entry>Valeur par défaut</entry>
  <entry>Positionnement</entry>
  <entry>-o</entry>
  <entry>Ce que dit la documentation</entry>
  <entry>Commentaires</entry>
 </row>
</thead>

<tbody>
 <row>
  <entry>wal_debug</entry>
  <entry>0-16</entry>
  <entry></entry>
  <entry>0</entry>
  <entry>No*</entry>
  <entry></entry>
  <entry>
  If nonzero, turn on WAL-related debugging output on standard error.
  </entry>
  <entry>
  May be SET by superuser.
  </entry>
 </row>
 <row>
  <entry>trace_notify</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Generates a great amount of debugging output for the LISTEN and NOTIFY
  commands.
  </entry>
  <entry>
  </entry>
 </row>
 <row>
  <entry>
  <para>trace_locks</para>
  <para>trace_userlocks</para>
  <para>trace_lwlocks</para>
  <para>debug_deadlocks</para>
  <para>trace_lock_oidmin</para>
  <para>trace_lock_table</para>
  <para>log_btree_build_stats</para>
  </entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>
  <para>false</para>
  <para>false</para>
  <para>false</para>
  <para>false</para>
  <para>16384</para>
  <para>0</para>
  <para>false</para>
  </entry>
  <entry>No</entry>
  <entry></entry>
  <entry>
  No documentation is available for these options at this time.
  </entry>
  <entry></entry>
 </row>
 <row>
  <entry>debug_assertions</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>true</entry>
  <entry>Yes</entry>
  <entry></entry>
  <entry>
  Turns on various assertion checks. This is a debugging aid. If you are
  experiencing strange problems or crashes you might want to turn this on, as
  it might expose programming mistakes. To use this option, the macro
  USE_ASSERT_CHECKING must be defined when PostgreSQL is built (accomplished
  by the configure option --enable-cassert). Note that DEBUG_ASSERTIONS
  defaults to on if PostgreSQL has been built with assertions enabled.
  </entry>
  <entry>
  Only useful if your PostgreSQL system is crashing, and then only if you are
  a source hacker.
  </entry>
 </row>
 <row>
  <entry>zero_damaged_pages</entry>
  <entry>true, false</entry>
  <entry></entry>
  <entry>false</entry>
  <entry></entry>
  <entry>No*</entry>
  <entry>
  Detection of a damaged page header normally causes PostgreSQL to report an
  error, aborting the current transaction. Setting zero_damaged_pages to true
  causes the system to instead report a warning, zero out the damaged page and
  continue processing. This behavior will destroy data, namely all the rows on
  the damaged page. But it allows you to get past the error and retrieve rows
  from any undamaged pages that may be present in the table. So it is useful
  for recovering data if corruption has occurred due to hardware or software
  error. You should generally not set this true until you have given up hope of
  recovering data from the damaged page(s) of a table. The default setting is
  off, and it can only be changed by a superuser.
  </entry>
  <entry>
  May be SET by superuser.
  </entry>
 </row>
</tbody>
</tgroup>
</table>

</sect1>

</article>
