<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/dml.sgml,v 1.8 2005/09/15 07:03:16 guillaume Exp $ -->

<chapter id="dml">
 <title>Manipulation de données</title>

 <remark>
  Ce chapitre est toujours assez incomplet.
 </remark>

 <para>
  Le chapitre précédent expliquait comment créer des tables et
  d'autres structures pour stocker vos données. Nous allons maintenant remplir
  ces tables avec des données. Ce chapitre montre comment insérer,
  mettre à jour et supprimer des données des tables.
  Nous allons aussi montrer des méthodes pour effectuer des changements
  automatiquement dans les données quand certains événements ont lieu&nbsp;:
  les déclencheurs et les règles de réécriture. Le chapitre suivant expliquera
  enfin comment extraire des données perdues depuis longtemps dans la base de
  données.
 </para>

 <sect1 id="dml-insert">
  <title>Insérer des données</title>

  <indexterm zone="dml-insert">
   <primary>insertion</primary>
  </indexterm>

  <indexterm zone="dml-insert">
   <primary>INSERT</primary>
  </indexterm>

  <para>
   Quand une table est créée, elle ne contient aucune donnée.
   La première chose à faire, c'est d'y insérer des données. Sinon,
   la base de données n'est pas d'une grande utilité.
   Les données sont insérées ligne par ligne. Bien sûr, il est possible
   d'insérer plus d'une ligne mais il n'est pas possible d'entrer moins
   qu'une ligne à la fois. Même si vous ne connaissez les valeurs que 
   pour quelques colonnes, une ligne complète doit être créée.
  </para>

  <para>
   Pour créer une nouvelle ligne, utilisez la commande <xref
   linkend="sql-insert" xreflabel="sql-insert-title">.
   La commande a besoin du nom de la table et d'une valeur pour
   chaque colonne de cette table.
   Par exemple, utilisons produits, la table des produits
   du <xref linkend="ddl">&nbsp;:
<programlisting>
CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric
);
</programlisting>
   Un exemple de commande pour insérer une ligne serait&nbsp;:
<programlisting>
INSERT INTO produits VALUES (1, 'Fromage', 9.99);
</programlisting>
   Les données sont listées dans l'ordre dans lequel les colonnes 
   apparaissent dans la table, séparées par des virgules. Souvent, les
   données sont des littéraux (constantes) mais les expressions
   scalaires sont aussi acceptées.
  </para>

  <para>
   La syntaxe précédente a le défaut qu'il faut connaître l'ordre des colonnes.
   Pour éviter ce problème, vous pouvez aussi lister les colonnes explicitement.
   Par exemple, les deux commandes suivantes ont le même effet que la 
   précédente&nbsp;:
<programlisting>
INSERT INTO produits (no_produit, nom, prix) VALUES (1, 'Fromage', 9.99);
INSERT INTO produits (nom, prix, no_produit) VALUES ('Fromage', 9.99, 1);
</programlisting>
   Beaucoup d'utilisateurs recommandent de toujours lister les noms de colonnes.
  </para>

  <para>
   Si vous ne connaissez pas les valeurs de certaines colonnes, 
   vous pouvez les omettre. Dans ce cas, elles seront remplies avec leur 
   valeur par défaut. Par exemple,
<programlisting>
INSERT INTO produits (no_produit, nom) VALUES (1, 'Fromage');
INSERT INTO produits VALUES (1, 'Fromage');
</programlisting>
   La seconde instruction est une extension de 
   <productname>PostgreSQL</productname>. Elle remplit les colonnes de 
   gauche à droite avec toutes les valeurs données, et les autres prennent
   leur valeur par défaut.
  </para>

  <para>
   Pour plus de clarté, vous pouvez aussi explicitement demander les valeurs
   par défaut pour des colonnes spécifiques ou pour la ligne complète.
<programlisting>
INSERT INTO produits (no_produit, nom, prix) VALUES (1, 'Fromage', DEFAULT);
INSERT INTO produits DEFAULT VALUES;
</programlisting>
  </para>

  <tip>
   <para>
    Pour faire des chargements en masse (insertion de grandes quantités 
    de données), jetez un &oelig;il à la commande <xref linkend="sql-copy"
    endterm="sql-copy-title">. Elle n'est pas aussi souple que la
    commande <xref linkend="sql-insert" endterm="sql-insert-title"> mais elle
    est plus efficace. Référez-vous à la <xref linkend="populate"> pour plus
    d'informations sur l'amélioration des performances lors de chargements
    importants.
   </para>
  </tip>
 </sect1>

 <sect1 id="dml-update">
  <title>Modifier des données</title>

  <indexterm zone="dml-update">
   <primary>modification</primary>
  </indexterm>

  <indexterm zone="dml-update">
   <primary>UPDATE</primary>
  </indexterm>

  <para>
   La modification de données déjà présentes dans la base est
   appelée mise à jour (update en anglais).
   Vous pouvez mettre à jour une ligne spécifique, toutes
   les lignes d'une table ou un sous-ensemble des lignes
   de la table. Chaque colonne peut être mise à jour séparément&nbsp;;
   les autres colonnes ne sont pas modifiées.
  </para>

  <para>
   Pour faire une mise à jour, il faut trois informations&nbsp;:
   <orderedlist spacing=compact>
    <listitem>
     <para>le nom de la table et de la colonne à mettre à jour&nbsp;;</para>
    </listitem>

    <listitem>
     <para>la nouvelle valeur de la colonne&nbsp;;</para>
    </listitem>

    <listitem>
     <para>les lignes à mettre à jour.</para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Nous avons vu dans le <xref linkend="ddl"> que le SQL ne donne pas
   par défaut d'identifiant unique pour les lignes. Du coup,
   il n'est pas nécessairement possible d'indiquer directement quelle
   ligne il faut mettre à jour. À la place, nous indiquons quelles conditions
   une ligne doit remplir pour être mise à jour. Si la table a une clé primaire
   (qu'elle soit déclarée ou non), nous pouvons indiquer une ligne unique en
   donnant une condition qui porte sur la clé primaire. Les outils graphiques
   d'accès aux bases de données utilisent ce principe pour vous permettre de
   modifier les lignes individuellement.
  </para>

  <para>
   Par exemple, cette commande modifie tous les produits qui ont un prix de
   5 et met leur prix à 10.
<programlisting>
UPDATE produits SET prix = 10 WHERE prix = 5;
</programlisting>
    Ceci peut mettre à jour zéro, une ou plusieurs lignes.
    Ce n'est pas une erreur d'exécuter une commande 
    <literal>UPDATE</literal> qui ne met à jour aucune ligne.
  </para>

  <para>
   Voyons cette commande en détail. Tout d'abord, il y a le mot clé
   <literal>UPDATE</literal> suivi par le nom de la table.
   Comme d'habitude, le nom de la table peut être précisé par un nom de
   schéma, sans quoi le schéma est recherché dans le chemin.
   Ensuite, il y a le mot clé <literal>SET</literal> suivi par
   le nom de la colonne, un signe égal et la nouvelle valeur de la colonne.
   La nouvelle valeur de la colonne peut être une constante ou une 
   expression scalaire. Par exemple, pour augmenter de 10% le prix de tous les
   produits, on peut exécuter&nbsp;:
<programlisting>
UPDATE produits SET prix = prix * 1.10;
</programlisting>
   Comme vous le voyez, l'expression donnant la nouvelle valeur peut
   faire référence à la valeur actuelle dans la ligne.
   Nous n'avons pas indiqué de clause <literal>WHERE</literal>.
   Si elle est omise, cela veut dire que toutes les lignes de la table sont
   modifiées. Si elle est présente, seules les lignes qui remplissent la
   condition <literal>WHERE</literal> sont mises à jour.
   Remarquez que le signe égal dans la clause <literal>SET</literal>
   est une affectation, alors que celui de la clause 
   <literal>WHERE</literal> est une comparaison, mais cela ne crée pas
   d'ambiguïté. Bien sûr, la condition <literal>WHERE</literal> n'est pas
   nécessairement un test d'égalité. De nombreux autres opérateurs existent
   (voir le <xref linkend="functions">). Mais l'expression doit s'évaluer en une
   expression booléenne.
  </para>

  <para>
   Il est possible de mettre plus d'une colonne à jour dans 
   une commande <command>UPDATE</command> en indiquant plusieurs
   colonnes dans la clause <literal>SET</literal>. Par exemple&nbsp;:
<programlisting>
UPDATE ma_table SET a = 5, b = 3, c = 1 WHERE a &gt; 0;
</programlisting>
  </para>
 </sect1>

 <sect1 id="dml-delete">
  <title>Supprimer des données</title>

  <indexterm zone="dml-delete">
   <primary>suppression</primary>
  </indexterm>

  <indexterm zone="dml-delete">
   <primary>DELETE</primary>
  </indexterm>

  <para>
   Jusqu'ici, nous avons expliqué comment ajouter des données à une table
   et comment les modifier. Il nous reste à voir comment les enlever quand
   elles ne sont plus nécessaires. De la même façon que pour l'insertion, la
   suppression ne peut se faire que par ligne entière. Dans la section
   précédente, nous avons expliqué que le SQL ne propose pas de moyen
   d'accéder à une ligne particulière. C'est pourquoi la suppression de
   lignes se fait en indiquant les conditions à remplir par les lignes à
   supprimer. S'il y a une clé primaire dans la table, alors il est
   possible d'indiquer exactement la ligne à supprimer.
   Mais on peut aussi supprimer un groupe de lignes qui remplissent une
   condition, ou même toutes les lignes d'une table d'un coup.
  </para>

  <para>
   On utilise la commande <xref linkend="sql-delete"
   xreflabel="sql-delete-title"> pour supprimer des
   lignes&nbsp;; la syntaxe est très similaire à la commande 
   <command>UPDATE</command>. Par exemple, pour supprimer toutes les lignes de
   la table produits qui ont un prix de 10, on exécute&nbsp;:
<programlisting>
DELETE FROM produits WHERE prix = 10;
</programlisting>
  </para>

  <para>
   En indiquant simplement
<programlisting>
DELETE FROM produits;
</programlisting>
   on supprime toutes les lignes de la table. Attention aux mauvaises
   manipulations&nbsp;!
  </para>
 </sect1>
</chapter>

