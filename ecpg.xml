<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ecpg.sgml,v 1.14 2005/10/02 12:42:20 guillaume Exp $
-->

<chapter id="ecpg">
 <title><application>ECPG</application> - <acronym>SQL</acronym> embarqué dans
  du C</title>

 <indexterm zone="ecpg"><primary>SQL embarqué</primary><secondary>dans du
  C</secondary></indexterm>
 <indexterm zone="ecpg"><primary>C</primary></indexterm>
 <indexterm zone="ecpg"><primary>ECPG</primary></indexterm>

 <para>
  Ce chapitre décrit l'interface <acronym>SQL</acronym> embarqué pour
  <productname>PostgreSQL</productname>. Il a été écrit par
  Linus Tolke (<email>linus@epact.se</email>) et Michael Meskes
  (<email>meskes@postgresql.org</email>). Originellement, il a été écrit pour
  fonctionner avec le langage <acronym>C</acronym>. Il fonctionne aussi avec le
  <acronym>C++</acronym> mais il ne reconnaît pas encore toutes les
  constructions <acronym>C++</acronym>.
 </para>

 <para>
  Cette documentation est assez incomplète. Mais du fait de la standardisation
  de cette interface, des informations complémentaires sont
  disponibles à travers de nombreuses ressources traitant du SQL.
 </para>

 <sect1 id="ecpg-concept">
  <title>Concept</title>

  <para>
   Un programme <acronym>SQL</acronym> embarqué consiste en du code écrit dans
   un langage de programmation ordinaire, dans le cas présent, le
   <acronym>C</acronym>, mélangé à des commandes SQL incluses dans des sections
   spécialement marquées. Pour construire le programme, le code source est
   d'abord passé au préprocesseur <acronym>SQL</acronym> embarqué qui le
   convertit en un programme <acronym>C</acronym> ordinaire. Il peut alors être
   traité par un compilateur <acronym>C</acronym>.
  </para>

  <para>
   Le <acronym>SQL</acronym> embarqué a des avantages par rapport aux autres méthodes
   de gestion de commandes <acronym>SQL</acronym> dans du code C. Premièrement,
   il gère le passage laborieux des informations de et vers les variables du
   programme <acronym>C</acronym>. Deuxièmement, le code SQL du programme est
   vérifié syntaxiquement au moment de la construction. Troisièmement, le
   <acronym>SQL</acronym> embarqué en C est spécifié dans le standard
   <acronym>SQL</acronym> et supporté par de nombreux systèmes de bases de
   données <acronym>SQL</acronym>. L'implémentation <productname>PostgreSQL</productname>
   est conçue pour correspondre au mieux à ce standard. Il est de ce fait
   assez facile de porter les programmes <acronym>SQL</acronym>
   embarqués écrits pour d'autres bases de données SQL vers
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   Comme indiqué précédemment, les programmes écrits pour l'interface <acronym>SQL</acronym>
   embarqué sont des programmes C normaux contenant un code spécial inséré pour
   réaliser les actions en relation avec la base de données. Ce code spécial a
   toujours la forme
<programlisting>EXEC SQL ...;
</programlisting>
   Ces instructions prennent syntaxiquement la place d'une instruction C.
   Suivant l'instruction particulière, elles peuvent apparaître dans le
   contexte global ou à l'intérieur d'une fonction. Les instructions
   <acronym>SQL</acronym> embarquées suivent les règles de sensibilité à la
   casse d'un code <acronym>SQL</acronym> normal, et non pas ceux du C.
  </para>

  <para>
   Les sections suivantes expliquent toutes les instructions SQL embarquées.
  </para>
 </sect1>

 <sect1 id="ecpg-connect">
  <title>Se connecter au serveur de bases de données</title>

  <para>
   La connexion à une base de données se fait en utilisant l'instruction
   suivante&nbsp;:
<programlisting>EXEC SQL CONNECT TO <replaceable>cible</replaceable> <optional>AS <replaceable>nom-connexion</replaceable></optional> <optional>USER <replaceable>nom-utilisateur</replaceable></optional>;
</programlisting>
   La <replaceable>cible</replaceable> peut être spécifiée d'une des façons
   suivantes&nbsp;:

   <itemizedlist>
    <listitem>
     <simpara><literal><replaceable>nom_base</replaceable><optional>@<replaceable>nomhôte</replaceable>
      </optional><optional>:<replaceable>port</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara><literal>tcp:postgresql://<replaceable>nomhôte</replaceable>
      <optional>:<replaceable>port</replaceable> </optional>
      <optional>/<replaceable>nom_base</replaceable></optional><optional>?<replaceable>
      options</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>unix:postgresql://<replaceable>nomhôte</replaceable><optional>:
      <replaceable>port</replaceable></optional><optional>/<replaceable>nom_base</replaceable>
      </optional><optional>?<replaceable> options</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      une chaîne SQL littérale contenant une des formes précédentes
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      une référence à une variable contenant une des formes précédentes (voir les
      exemples)
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   Si la cible de connexion est spécifiée littéralement (c'est-à-dire non pas via une
   variable de référence) et la valeur n'est pas mise entre guillemets,
   les règles d'insensibilité à la casse du SQL standard sont appliquées.
   Dans ce cas, il est possible, si cela s'avérait nécessaire, d'encadrer
   séparément les paramètres individuels de guillemets doubles.
   En pratique, l'utilisation d'une chaîne littérale (entre guillemets
   simples) ou d'une variable de référence engendre moins d'erreurs. La cible de
   connexion <literal>DEFAULT</literal> initie une connexion à la base de
   données standard avec l'utilisateur standard. Aucun nom d'utilisateur ou
   de connexion ne peut être spécifié isolément dans ce cas.
  </para>

  <para>
   Il existe également différentes façons de préciser le nom de l'utilisateur&nbsp;:

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>nomutilisateur</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>nomutilisateur</replaceable>/
      <replaceable>motdepasse</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>nomutilisateur</replaceable> IDENTIFIED BY
      <replaceable>motdepasse</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>nomutilisateur</replaceable> USING
      <replaceable>motdepasse</replaceable></literal>
     </simpara>
    </listitem>
   </itemizedlist>

   Comme indiqué ci-dessus, les paramètres
   <replaceable>nomutilisateur</replaceable> et
   <replaceable>motdepasse</replaceable> peuvent être un identificateur SQL, une
   chaîne SQL littérale ou une référence à une variable de type caractère.
  </para>

  <para>
   <replaceable>nom-connexion</replaceable> est utilisé pour gérer plusieurs
   connexions dans un même programme. Il peut être omis si un programme n'utilise
   qu'une seule connexion. La connexion la plus récemment ouverte devient la
   connexion courante, utilisée par défaut lorsqu'une instruction SQL est à
   exécuter (voir plus loin dans ce chapitre).
  </para>

  <para>
   Voici quelques exemples d'instructions <command>CONNECT</command>&nbsp;:
<programlisting>EXEC SQL CONNECT TO ma_base@sql.mondomaine.com;

EXEC SQL CONNECT TO unix:postgresql://sql.mondomaine.com/ma_base AS maconnexion USER john;

EXEC SQL BEGIN DECLARE SECTION;
const char *cible = "ma_base@sql.mondomaine.com";
const char *utilisateur = "john";
EXEC SQL END DECLARE SECTION;
 ...
EXEC SQL CONNECT TO :cible USER :utilisateur;
</programlisting>
   La dernière forme utilise la variante dite de la variable de référence,
   à laquelle il est fait allusion ci-dessus. Nous verrons dans les prochaines sections comment
   utiliser des variables C dans des instructions SQL en les
   préfixant par un caractère deux-points.
  </para>

  <para>
   Il est à noter que le format de la cible de connexion n'est pas spécifié dans
   le standard SQL. Ainsi, lorsque l'on souhaite développer des applications portables,
   il est préférable d'utiliser une syntaxe basée sur le dernier exemple ci-dessus
   pour encapsuler la chaîne de la cible de connexion.
  </para>
 </sect1>

 <sect1 id="ecpg-disconnect">
  <title>Fermer une connexion</title>

  <para>
   Pour fermer une connexion, l'instruction suivante est utilisée&nbsp;:
<programlisting>EXEC SQL DISCONNECT <optional><replaceable>connexion</replaceable></optional>;
</programlisting>
   <replaceable>connexion</replaceable> peut être spécifiée de
   différentes façons&nbsp;:

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>nom-connexion</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>CURRENT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>ALL</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   Si aucun nom de connexion n'est spécifié, la connexion en cours est fermée.
  </para>

  <para>
   Il est toujours préférable qu'une application ferme explicitement
   chaque connexion qu'elle a ouverte.
  </para>
 </sect1>

 <sect1 id="ecpg-commands">
  <title>Exécuter des commandes SQL</title>

  <para>
   Toute commande SQL peut être exécutée à l'intérieur d'une application SQL
   embarquée. Ci-dessous se trouvent quelques exemples de façons de procéder.
  </para>

  <para>
   Création d'une table&nbsp;:
<programlisting>EXEC SQL CREATE TABLE foo (nombre integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(nombre);
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   Insertion de lignes&nbsp;:
<programlisting>EXEC SQL INSERT INTO foo (nombre, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   Suppression de lignes&nbsp;:
<programlisting>EXEC SQL DELETE FROM foo WHERE nombre = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   Sélection d'une ligne&nbsp;:
<programlisting>EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';
</programlisting>
  </para>

  <para>
   Sélection utilisant des curseurs&nbsp;:
<programlisting>EXEC SQL DECLARE foo_bar CURSOR FOR
    SELECT nombre, ascii FROM foo
    ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   Mises à jour&nbsp;:
<programlisting>EXEC SQL UPDATE foo
    SET ascii = 'foobar'
    WHERE nombre = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
   Les marques de la forme
   <quote><literal>:<replaceable>quelquechose</replaceable></literal></quote>
   sont des <firstterm>variables hôtes</firstterm>, c'est-à-dire qu'elles font
   référence à des variables dans le programme C. Elles sont expliquées dans
   la <xref linkend="ecpg-variables"/>.
  </para>

  <para>
   Dans le mode par défaut, les instructions ne sont validées que lorsque
   <command>EXEC SQL COMMIT</command> est exécuté. L'interface SQL embarquée
   supporte aussi la validation automatique des transactions (similaire au
   comportement de <application>libpq</application>) via l'option
   <option>-t</option> en ligne de commande pour
   <command>ecpg</command> (voir ci-dessous) ou via l'instruction <literal>EXEC
   SQL SET AUTOCOMMIT TO ON</literal>. En mode de validation automatique, chaque
   commande est automatiquement validée sauf si elle est à l'intérieur d'un bloc
   de transaction explicite. Ce mode peut être explicitement désactivé en
   utilisant <literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal>.
  </para>
 </sect1>

 <sect1 id="ecpg-set-connection">
  <title>Choisir une connexion</title>

  <para>
   Les instructions SQL affichées dans la section précédente sont exécutées à
   partir de la connexion courante, c'est-à-dire la dernière à avoir été ouverte.
   Il y a deux façons de gérer l'utilisation de plusieurs connexions dans une
   application.
  </para>

  <para>
   La première option est de choisir explicitement une connexion pour chaque
   instruction SQL, par exemple
<programlisting>EXEC SQL AT <replaceable>nom-connexion</replaceable> SELECT ...;
</programlisting>
   Cette option est particulièrement adaptée si l'application a besoin
   d'utiliser plusieurs connexions en ordre divers.
  </para>

  <para>
   Si votre application utilise plusieurs threads d'exécution, ils ne peuvent
   pas partager de connexion. Vous devez soit contrôler explicitement l'accès
   à la connexion (en utilisant des mutex) soit utiliser une connexion pour
   chaque thread. Si chaque thread utilise sa propre connexion, vous aurez
   besoin d'utiliser la clause AT pour spécifier la connexion utilisée par le
   thread.
  </para>

  <para>
   La seconde option est d'exécuter une instruction pour basculer la connexion
   courante. L'instruction est&nbsp;:
<programlisting>EXEC SQL SET CONNECTION <replaceable>nom-connexion</replaceable>;
</programlisting>
   Cette option est particulièrement intéressante si un grand nombre
   d'instructions doivent être exécutées à partir de la même connexion. Elle ne tient pas
   compte des threads.
  </para>
 </sect1>

 <sect1 id="ecpg-variables">
  <title>Utiliser des variables hôtes</title>

  <para>
   Dans la <xref linkend="ecpg-commands"/>, nous avons vu comment exécuter des
   instructions SQL à partir d'un programme SQL embarqué. Quelques-unes de ces
   instructions n'utilisent que des valeurs fixes. Elles n'offrent pas la
   possibilité d'insérer des valeurs fournies par l'utilisateur dans les
   instructions. Elles ne permettent pas non plus au programme de traiter
   les valeurs renvoyées par la requête.
   Ces types d'instructions ne sont pas vraiment utiles dans les
   applications réelles. Cette section explique en détail comment
   échanger des données entre votre programme C et les instructions SQL embarquées
   en utilisant un mécanisme simple appelé <firstterm>variables
   hôtes</firstterm>. In an embedded SQL program  we
   consider the SQL statements to be <firstterm>guests</firstterm> in the C
   program code which is the <firstterm>host language</firstterm>. Therefore
   the variables of the C program are called <firstterm>host
   variables</firstterm>.
  </para>

  <sect2>
   <title>Aperçu</title>

   <para>
    Échanger des données entre le programme C et les instructions SQL est
    particulièrement simple en SQL embarqué. Plutôt que de laisser le programme
    copier les données dans l'instruction, ce qui implique un certain nombre de
    complications, dont la bonne mise entre guillemets de la valeur, il est plus simple
    d'écrire le nom de la variable C dans l'instruction SQL en la préfixant par un
    caractère deux-points. Par exemple&nbsp;:
<programlisting>EXEC SQL INSERT INTO unetable VALUES (:v1, 'foo', :v2);
</programlisting>
    Cette instruction fait référence à deux variables C nommées
    <varname>v1</varname> et <varname>v2</varname>, et utilise également une
    chaîne littérale SQL pour illustrer l'absence de restriction à l'utilisation
    d'un type de données ou d'un autre.
   </para>

   <para>
    Ce style d'insertions de variables C dans des instructions SQL fonctionne
    dans tous les cas où l'on attend une expression de valeur dans une instruction SQL.
   </para>
  </sect2>

  <sect2>
   <title>Sections de déclaration</title>

   <para>
    Pour passer des données du programme à la base de données,
    comme paramètre d'une requête par exemple, ou pour passer des données de la
    base au programme, les variables C supposées contenir ces données doivent être
    déclarées dans des sections spécialement marquées pour que le préprocesseur
    du SQL embarqué soit averti de leur présence.
   </para>

   <para>
    Cette section commence avec
<programlisting>EXEC SQL BEGIN DECLARE SECTION;
</programlisting>
    et se termine avec
<programlisting>EXEC SQL END DECLARE SECTION;
</programlisting>
    Entre ces lignes, on trouvera des déclarations normales de variables C, comme
<programlisting>int   x = 4;
char  foo[16], bar[16];
</programlisting>
    As you can see, you can optionally assign an initial value to the variable.
    The variable's scope is determined by the location of its declaring
    section within the program.
    You can also declare variables with the following syntax which implicitly
    creates a declare section:
<programlisting>
EXEC SQL int i = 4;
</programlisting>
    Il peut y avoir autant de sections de déclarations dans un programme que
    souhaité.
   </para>

   <para>
    Les déclarations sont aussi placées dans le fichier de sortie comme des
    variables C normales. Du coup, il n'est plus besoin de les déclarer à
    nouveau. Les variables qui n'ont pas pour but d'être utilisées dans des
    commandes SQL peuvent être normalement déclarées en dehors des sections
    spéciales.
   </para>

   <para>
    La définition d'une structure ou union doit aussi être saisie dans une
    section <literal>DECLARE</literal>. Sinon, le préprocesseur, ne connaissant pas leur
    définition, ne pourra pas gérer ces types.
   </para>
  </sect2>

  <sect2>
   <title>Different types of host variables</title>
   <para>
    As a host variable you can also use arrays, typedefs, structs and
    pointers. Moreover there are special types of host variables that exist
    only in ecpg.
   </para>

   <para>
    A few examples on host variables:
    <variablelist>
     <varlistentry>
      <term>Arrays</term>
      <listitem>
      <para>
       One of the most common uses of an array declaration is probably the
       allocation of a char array as in
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    char str[50];
EXEC SQL END DECLARE SECTION;
</programlisting>
       Note that you have to take care of the length for yourself. If you use
       this host variable as the target variable of a query which returns a
       string with more than 49 characters, a buffer overflow occurs.
      </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Typedefs</term>
      <listitem>
      <para>
      Use the <literal>typedef</literal> keyword to map new types to already
      existing types.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef char mychartype[40];
    typedef long serial_t;
EXEC SQL END DECLARE SECTION;
</programlisting>
       Note that you could also use
<programlisting>
EXEC SQL TYPE serial_t IS long;
</programlisting>
       This declaration does not need to be part of a declare section.
      </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Pointers</term>
      <listitem>
      <para>
       You can declare pointers to the most common types. Note however that
       you can not use pointers as target variables of queries without
       auto-allocation. See <xref linkend="ecpg-descriptors"/> for more
       information on auto-allocation.
      </para>
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    int   *intp;
    char **charp;
EXEC SQL END DECLARE SECTION;
</programlisting>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Special types of variables</term>
      <listitem>
       <para>
        ecpg contains some special types that help you to interact easily with
        data from the SQL server. For example it has implemented support for
        the varchar, numeric, date, timestamp and interval types.
        <xref linkend="ecpg-pgtypes"/> contains basic functions to deal with
        those types, such that you do not need to send a query to the SQL
        server just for adding an interval to a timestamp for example.
       </para>

   <para>
    Le type spécial <type>VARCHAR</type> est converti dans une <type>struct</type>
    nommée pour chaque variable. Une déclaration telle que
<programlisting>VARCHAR var[180];
</programlisting>
    est convertie en
<programlisting>struct varchar_var { int len; char arr[180]; } var;
</programlisting>
    Cette structure est utilisable pour créer une interface des données SQL de type
    <type>varchar</type>.
   </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2>
   <title><command>SELECT INTO</command> et <command>FETCH
    INTO</command></title>

   <para>
    Nous savons maintenant insérer des données engendrées par un
    programme dans une commande SQL. Mais comment récupérer les résultats d'une
    requête&nbsp;? Dans ce but, le SQL embarqué fournit des variantes spéciales
    des commandes habituelles <command>SELECT</command> et
    <command>FETCH</command>. Ces commandes ont une clause
    <literal>INTO</literal> particulière qui spécifie les variables hôtes dans
    lesquelles seront stockées les valeurs récupérées.
   </para>

   <para>
    Voici un exemple&nbsp;:
<programlisting>/*
 * Soit la table suivante :
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
</programlisting>
    La clause <literal>INTO</literal> apparaît donc entre les champs du
    <command>select</command> et la clause <literal>FROM</literal>.
    Le nombre d'éléments dans la liste du <command>select</command>
    et celui de la liste après <literal>INTO</literal> (aussi appelée liste
    cible) doivent être identiques.
   </para>

   <para>
    Voici un exemple utilisant la commande <command>FETCH</command>&nbsp;:
<programlisting>EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;

 ...

do {
    ...
    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
    ...
} while (...);
</programlisting>
    Ici, la clause <literal>INTO</literal> apparaît après toutes les autres
    clauses.
   </para>

   <para>
    Ces deux méthodes ne permettent de récupérer qu'une ligne à la
    fois. Pour traiter des ensembles de résultats
    contenant potentiellement plus d'une ligne, il faut utiliser un
    curseur, comme indiqué dans le second exemple.
   </para>
  </sect2>

  <sect2>
   <title>Indicateurs</title>

   <para>
    Les exemples ci-dessus ne gèrent pas les valeurs NULL. En fait, ces
    exemples de récupération afficheront une erreur s'ils récupèrent une
    valeur NULL à partir de la base de données. Pour être capable de passer des
    valeurs NULL à la base de données ou de récupérer des valeurs NULL de la
    base de données, il est nécessaire d'ajouter une deuxième spécification de
    variable hôte pour chaque variable hôte contenant des données. Cette seconde
    variable est appelée l'<firstterm>indicateur</firstterm> et contient un
    drapeau indiquant si la valeur est NULL, auquel cas la valeur de la variable
    hôte réelle est ignorée. Voici un exemple qui gère correctement la
    récupération de valeurs NULL&nbsp;:
<programlisting>EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;
</programlisting>
    La variable indicateur <varname>val_ind</varname> vaudra zéro si la valeur
    est non NULL et elle sera négative si la valeur est NULL.
   </para>

   <para>
    L'indicateur a une autre fonction&nbsp;: si la valeur de l'indicateur est
    positive, cela signifie que la valeur est non NULL mais qu'elle a été
    tronquée lors de son stockage dans la variable hôte.
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-dynamic">
  <title>SQL dynamique</title>

  <para>
   Dans de nombreux cas, les instructions SQL particulières qu'une application
   doit exécuter sont connues au moment de l'écriture de l'application.
   Néanmoins, dans certains cas, les instructions SQL sont composées à
   l'exécution ou fournies par une source externe. Dans ces cas, il n'est pas possible
   d'embarquer directement les instructions SQL dans le code source C. Pour ce faire, il
   existe une fonction permettant d'appeler des instructions SQL arbitraires
   fournies par l'intermédiaire d'une variable de type chaîne.
  </para>

  <para>
   La façon la plus simple d'exécuter une instruction SQL arbitraire est
   d'utiliser la commande <command>EXECUTE IMMEDIATE</command>. Par
   exemple&nbsp;:
<programlisting>EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;
</programlisting>
   Les instructions de ce type ne peuvent pas être utilisées pour récupérer des
   données (c'est-à-dire un <command>SELECT</command>).
  </para>

  <para>
   Une façon plus puissante d'exécuter des instructions SQL arbitraires est de
   les préparer une seule fois et de les exécuter ensuite aussi souvent que nécessaire.
   Il est
   également possible de préparer une version généralisée d'une instruction, puis
   d'exécuter les versions spécifiques en substituant les paramètres. Lors de la
   préparation de l'instruction, il suffit d'écrire des points d'interrogation
   aux endroits où des paramètres seront substitués par la suite. Par exemple&nbsp;:
<programlisting>EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
</programlisting>
   Si l'instruction exécutée retourne des valeurs, il est nécessaire d'ajouter une
   clause <literal>INTO</literal>&nbsp;:
<programlisting>EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a &gt; ?";
int v1, v2;
VARCHAR v3;
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO v1, v2, v3 USING 37;
</programlisting>
   Une commande <command>EXECUTE</command> peut avoir une clause
   <literal>INTO</literal>, une clause <literal>USING</literal>, les deux ou
   aucune.
  </para>

  <para>
   Lorsqu'une instruction préparée n'est plus utile, il est préférable de la
   désallouer&nbsp;:
<programlisting>EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
  </para>
 </sect1>

 <sect1 id="ecpg-pgtypes">
  <title>pgtypes library</title>

  <para>
   The pgtypes library maps <productname>PostgreSQL</productname> database
   types to C equivalents that can be used in C programs. It also offers
   functions to do basic calculations with those types within C, i.e. without
   the help of the <productname>PostgreSQL</productname> server. See the
   following example:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&amp;date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&amp;ts1, &amp;iv1, &amp;tsout);
out = PGTYPEStimestamp_to_asc(&amp;tsout);
printf("Started + duration: %s\n", out);
free(out);
</programlisting>
  </para>

  <sect2>
   <title>The numeric type</title>
   <para>
    The numeric type offers to do calculations with arbitrary precision. See
    <xref linkend="datatype-numeric"> for the equivalent type in the
    <productname>PostgreSQL</productname> server. Because of the arbitrary precision this
    variable needs to be able to expand and shrink dynamically. That's why you
    can only create variables on the heap by means of the
    <function>PGTYPESnumeric_new</function> and <function>PGTYPESnumeric_free</function>
    functions. The decimal type, which is similar but limited in the precision,
    can be created on the stack as well as on the heap.
   </para>
   <para>
   The following functions can be used to work with the numeric type:
   <variablelist>
    <varlistentry>
     <term><function>PGTYPESnumeric_new</function></term>
     <listitem>
      <para>
      Request a pointer to a newly allocated numeric variable.
<synopsis>
numeric *PGTYPESnumeric_new(void);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_free</function></term>
     <listitem>
      <para>
      Free a numeric type, release all of its memory.
<synopsis>
void PGTYPESnumeric_free(numeric *var);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_asc</function></term>
     <listitem>
      <para>
       Parse a numeric type from its string notation.
<synopsis>
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
</synopsis>
       Valid formats are for example:
        <literal>-2</literal>,
        <literal>.794</literal>,
        <literal>+3.44</literal>,
        <literal>592.49E07</literal> or
        <literal>-32.84e-4</literal>.
       If the value could be parsed successfully, a valid pointer is returned,
       else the NULL pointer. At the moment ecpg always parses the complete
       string and so it currently does not support to store the address of the
       first invalid character in <literal>*endptr</literal>. You can safely
       set <literal>endptr</literal> to NULL.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_asc</function></term>
     <listitem>
      <para>
       Returns a pointer to a malloced string that contains the string
       representation of the numeric type <literal>num</literal>.
<synopsis>
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
</synopsis>
       The numeric value will be printed with <literal>dscale</literal> decimal
       digits, with rounding applied if necessary.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_add</function></term>
     <listitem>
      <para>
       Add two numeric variables into a third one.
<synopsis>
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function adds the variables <literal>var1</literal> and
       <literal>var2</literal> into the result variable
       <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_sub</function></term>
     <listitem>
      <para>
       Subtract two numeric variables and return the result in a third one.
<synopsis>
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function subtracts the variable <literal>var2</literal> from
       the variable <literal>var1</literal>. The result of the operation is
       stored in the variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_mul</function></term>
     <listitem>
      <para>
       Multiply two numeric variables and return the result in a third one.
<synopsis>
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function multiplies the variables <literal>var1</literal> and
       <literal>var2</literal>. The result of the operation is stored in the
       variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_div</function></term>
     <listitem>
      <para>
       Divide two numeric variables and return the result in a third one.
<synopsis>
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function divides the variables <literal>var1</literal> by
       <literal>var2</literal>. The result of the operation is stored in the
       variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_cmp</function></term>
     <listitem>
      <para>
       Compare two numeric variables.
<synopsis>
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
</synopsis>
       This function compares two numeric variables. In case of error,
       <literal>INT_MAX</literal> is returned. On success, the function
       returns one of three possible results:
       <itemizedlist>
        <listitem>
         <para>
          1, if <literal>var1</literal> is bigger than <literal>var2</literal>
         </para>
        </listitem>
        <listitem>
         <para>
          -1, if <literal>var1</literal> is smaller than <literal>var2</literal>
         </para>
        </listitem>
        <listitem>
         <para>
          0, if <literal>var1</literal> and <literal>var2</literal> are equal
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_int</function></term>
     <listitem>
      <para>
       Convert an int variable to a numeric variable.
<synopsis>
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
</synopsis>
       This function accepts a variable of type signed int and stores it
       in the numeric variable <literal>var</literal>. Upon success, 0 is returned and
       -1 in case of a failure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_long</function></term>
     <listitem>
      <para>
       Convert a long int variable to a numeric variable.
<synopsis>
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
</synopsis>
       This function accepts a variable of type signed long int and stores it
       in the numeric variable <literal>var</literal>. Upon success, 0 is returned and
       -1 in case of a failure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_copy</function></term>
     <listitem>
      <para>
       Copy over one numeric variable into another one.
<synopsis>
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
</synopsis>
       This function copies over the value of the variable that
       <literal>src</literal> points to into the variable that <literal>dst</literal>
       points to. It returns 0 on success and -1 if an error occurs.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_double</function></term>
     <listitem>
      <para>
       Convert a variable of type double to a numeric.
<synopsis>
int  PGTYPESnumeric_from_double(double d, numeric *dst);
</synopsis>
       This function accepts a variable of type double and stores the result
       in the variable that <literal>dst</literal> points to. It returns 0 on success
       and -1 if an error occurs.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_double</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to double.
<synopsis>
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
</synopsis>
       The function converts the numeric value from the variable that
       <literal>nv</literal> points to into the double variable that <literal>dp</literal> points
       to. It retuns 0 on success and -1 if an error occurs, including
       overflow. On overflow, the global variable <literal>errno</literal> will be set
       to <literal>PGTYPES_NUM_OVERFLOW</literal> additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_int</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to int.
<synopsis>
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
</synopsis>
       The function converts the numeric value from the variable that
       <literal>nv</literal> points to into the integer variable that <literal>ip</literal>
       points to. It retuns 0 on success and -1 if an error occurs, including
       overflow. On overflow, the global variable <literal>errno</literal> will be set
       to <literal>PGTYPES_NUM_OVERFLOW</literal> additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_long</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to long.
<synopsis>
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
</synopsis>
       The function converts the numeric value from the variable that
       <literal>nv</literal> points to into the long integer variable that
       <literal>lp</literal> points to. It retuns 0 on success and -1 if an error
       occurs, including overflow. On overflow, the global variable
       <literal>errno</literal> will be set to <literal>PGTYPES_NUM_OVERFLOW</literal>
       additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_decimal</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to decimal.
<synopsis>
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
</synopsis>
       The function converts the numeric value from the variable that
       <literal>src</literal> points to into the decimal variable that
       <literal>dst</literal> points to. It retuns 0 on success and -1 if an error
       occurs, including overflow. On overflow, the global variable
       <literal>errno</literal> will be set to <literal>PGTYPES_NUM_OVERFLOW</literal>
       additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_decimal</function></term>
     <listitem>
      <para>
       Convert a variable of type decimal to numeric.
<synopsis>
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
</synopsis>
       The function converts the decimal value from the variable that
       <literal>src</literal> points to into the numeric variable that
       <literal>dst</literal> points to. It retuns 0 on success and -1 if an error
       occurs. Since the decimal type is implemented as a limited version of
       the numeric type, overflow can not occur with this conversion.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>
  </sect2>

  <sect2>
   <title>The date type</title>
   <para>
    The date type in C enables your programs to deal with data of the SQL type
    date. See <xref linkend="datatype-datetime"/> for the equivalent type in the
    <productname>PostgreSQL</productname> server.
   </para>
   <para>
    The following functions can be used to work with the date type:
    <variablelist>
     <varlistentry id="PGTYPESdatefromtimestamp">
      <term><function>PGTYPESdate_from_timestamp</function></term>
      <listitem>
       <para>
        Extract the date part from a timestamp.
<synopsis>
date PGTYPESdate_from_timestamp(timestamp dt);
</synopsis>
	The function receives a timestamp as its only argument and returns the
	extracted date part from this timestamp.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefromasc">
      <term><function>PGTYPESdate_from_asc</function></term>
      <listitem>
       <para>
       Parse a date from its textual representation.
<synopsis>
date PGTYPESdate_from_asc(char *str, char **endptr);
</synopsis>
	The function receives a C char* string <literal>str</literal> and a pointer to
	a C char* string <literal>endptr</literal>. At the moment ecpg always parses
	the complete string and so it currently does not support to store the
	address of the first invalid character in <literal>*endptr</literal>.
	You can safely set <literal>endptr</literal> to NULL.
       </para>
       <para>
	Note that the function always assumes MDY-formatted dates and there is
	currently no variable to change that within ecpg.
       </para>
       <para>
        The following input formats are allowed:
        <table>
	 <title>Valid input formats for <function>PGTYPESdate_from_asc</function></title>
	 <tgroup cols="2"/>
	  <thead>
	   <row>
	    <entry>Input</entry>
	    <entry>Result</entry>
	   </row>
	  </thead>
	  <tbody>
	   <row>
	    <entry><literal>January 8, 1999</literal></entry>
	    <entry><literal>January 8, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>1999-01-08</literal></entry>
	    <entry><literal>January 8, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>1/8/1999</literal></entry>
	    <entry><literal>January 8, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>1/18/1999</literal></entry>
	    <entry><literal>January 18, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>01/02/03</literal></entry>
	    <entry><literal>February 1, 2003</literal></entry>
	   </row>
	   <row>
	    <entry><literal>1999-Jan-08</literal></entry>
	    <entry><literal>January 8, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>Jan-08-1999</literal></entry>
	    <entry><literal>January 8, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>08-Jan-1999</literal></entry>
	    <entry><literal>January 8, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>99-Jan-08</literal></entry>
	    <entry><literal>January 8, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>08-Jan-99</literal></entry>
	    <entry><literal>January 8, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>08-Jan-06</literal></entry>
	    <entry><literal>January 8, 2006</literal></entry>
	   </row>
	   <row>
	    <entry><literal>Jan-08-99</literal></entry>
	    <entry><literal>January 8, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>19990108</literal></entry>
	    <entry><literal>ISO 8601; January 8, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>990108</literal></entry>
	    <entry><literal>ISO 8601; January 8, 1999</literal></entry>
	   </row>
	   <row>
	    <entry><literal>1999.008</literal></entry>
	    <entry><literal>year and day of year</literal></entry>
	   </row>
	   <row>
	    <entry><literal>J2451187</literal></entry>
	    <entry><literal>Julian day</literal></entry>
	   </row>
	   <row>
	    <entry><literal>January 8, 99 BC</literal></entry>
	    <entry><literal>year 99 before the Common Era</literal></entry>
	   </row>
          </tbody>
         </tgroup>
        </table>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoasc">
      <term><function>PGTYPESdate_to_asc</function></term>
      <listitem>
       <para>
        Return the textual representation of a date variable.
<synopsis>
char *PGTYPESdate_to_asc(date dDate);
</synopsis>
	The function receives the date <literal>dDate</literal> as its only parameter.
	It will output the date in the form <literal>1999-01-18</literal>, i.e. in the
	<literal>YYYY-MM-DD</literal> format.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatejulmdy">
      <term><function>PGTYPESdate_julmdy</function></term>
      <listitem>
       <para>
	Extract the values for the day, the month and the year from a variable
	of type date.
<synopsis>
void PGTYPESdate_julmdy(date d, int *mdy);
</synopsis>
       <!-- almost same description as for rjulmdy() -->
	The function receives the date <literal>d</literal> and a pointer to an array
	of 3 integer values <literal>mdy</literal>. The variable name indicates
	the sequential order: <literal>mdy[0]</literal> will be set to contain the
	number of the month, <literal>mdy[1]</literal> will be set to the value of the
	day and <literal>mdy[2]</literal> will contain the year.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatemdyjul">
      <term><function>PGTYPESdate_mdyjul</function></term>
      <listitem>
       <para>
	Create a date value from an array of 3 integers that specify the
	day, the month and the year of the date.
<synopsis>
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
</synopsis>
	The function receives the array of the 3 integers (<literal>mdy</literal>) as
	its first argument and as its second argument a pointer to a variable
	of type date that should hold the result of the operation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedayofweek">
      <term><function>PGTYPESdate_dayofweek</function></term>
      <listitem>
       <para>
        Return a number representing the day of the week for a date value.
<synopsis>
int PGTYPESdate_dayofweek(date d);
</synopsis>
	The function receives the date variable <literal>d</literal> as its only
	argument and returns an integer that indicates the day of the week for
	this date.
        <itemizedlist>
         <listitem>
          <para>
	   0 - Sunday
          </para>
         </listitem>
         <listitem>
          <para>
	   1 - Monday
          </para>
         </listitem>
         <listitem>
          <para>
	   2 - Tuesday
          </para>
         </listitem>
         <listitem>
          <para>
	   3 - Wednesday
          </para>
         </listitem>
         <listitem>
          <para>
	   4 - Thursday
          </para>
         </listitem>
         <listitem>
          <para>
	   5 - Friday
          </para>
         </listitem>
         <listitem>
          <para>
	   6 - Saturday
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoday">
      <term><function>PGTYPESdate_today</function></term>
      <listitem>
       <para>
        Get the current date.
<synopsis>
void PGTYPESdate_today(date *d);
</synopsis>
	The function receives a pointer to a date variable (<literal>d</literal>)
	that it sets to the current date.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefmtasc">
      <term><function>PGTYPESdate_fmt_asc</function></term>
      <listitem>
       <para>
	Convert a variable of type date to its textual representation using a
	format mask.
<synopsis>
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
</synopsis>
	The function receives the date to convert (<literal>dDate</literal>), the
	format mask (<literal>fmtstring</literal>) and the string that will hold the
	textual representation of the date (<literal>outbuf</literal>).
       </para>
       <para>
        On success, 0 is returned and a negative value if an error occurred.
       </para>
       <para>
        The following literals are the field specifiers you can use:
        <itemizedlist>
         <listitem>
          <para>
           <literal>dd</literal> - The number of the day of the month.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mm</literal> - The number of the month of the year.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yy</literal> - The number of the year as a two digit number.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yyyy</literal> - The number of the year as a four digit number.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ddd</literal> - The name of the day (abbreviated).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mmm</literal> - The name of the month (abbreviated).
          </para>
         </listitem>
        </itemizedlist>
	All other characters are copied 1:1 to the output string.
       </para>
       <para>
	The following table indicates a few possible formats. This will give
	you an idea of how to use this function. All output lines are based on
	the same date: November, 23rd, 1959.
        <table>
	 <title>Valid input formats for <function>PGTYPESdate_fmt_asc</function></title>
	 <tgroup cols="2">
	  <thead>
	   <row>
	    <entry>fmt</entry>
	    <entry>result</entry>
	   </row>
	  </thead>
	  <tbody>
	   <row>
	    <entry><literal>mmddyy</literal></entry>
	    <entry><literal>112359</literal></entry>
	   </row>
	   <row>
	    <entry><literal>ddmmyy</literal></entry>
	    <entry><literal>231159</literal></entry>
	   </row>
	   <row>
	    <entry><literal>yymmdd</literal></entry>
	    <entry><literal>591123</literal></entry>
	   </row>
	   <row>
	    <entry><literal>yy/mm/dd</literal></entry>
	    <entry><literal>59/11/23</literal></entry>
	   </row>
	   <row>
	    <entry><literal>yy mm dd</literal></entry>
	    <entry><literal>59 11 23</literal></entry>
	   </row>
	   <row>
	    <entry><literal>yy.mm.dd</literal></entry>
	    <entry><literal>59.11.23</literal></entry>
	   </row>
	   <row>
	    <entry><literal>.mm.yyyy.dd.</literal></entry>
	    <entry><literal>.11.1959.23.</literal></entry>
	   </row>
	   <row>
	    <entry><literal>mmm. dd, yyyy</literal></entry>
	    <entry><literal>Nov. 23, 1959</literal></entry>
	   </row>
	   <row>
	    <entry><literal>mmm dd yyyy</literal></entry>
	    <entry><literal>Nov 23 1959</literal></entry>
	   </row>
	   <row>
	    <entry><literal>yyyy dd mm</literal></entry>
	    <entry><literal>1959 23 11</literal></entry>
	   </row>
	   <row>
	    <entry><literal>ddd, mmm. dd, yyyy</literal></entry>
	    <entry><literal>Mon, Nov. 23, 1959</literal></entry>
	   </row>
	   <row>
	    <entry><literal>(ddd) mmm. dd, yyyy</literal></entry>
	    <entry><literal>(Mon) Nov. 23, 1959</literal></entry>
	   </row>
          </tbody>
         </tgroup>
        </table>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedefmtasc">
      <term><function>PGTYPESdate_defmt_asc</function></term>
      <listitem>
       <para>
	Use a format mask to convert a C char* string to a value of type
	date.
<synopsis>
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
</synopsis>
	<!-- same description as rdefmtdate -->
	The function receives a pointer to the date value that should hold the
	result of the operation (<literal>d</literal>), the format mask to use for
	parsing the date (<literal>fmt</literal>) and the C char* string containing
	the textual representation of the date (<literal>str</literal>). The textual
	representation is expected to match the format mask. However you do not
	need to have a 1:1 mapping of the string to the format mask. The
	function only analyzes the sequential order and looks for the literals
	<literal>yy</literal> or <literal>yyyy</literal> that indicate the
	position of the year, <literal>mm</literal> to indicate the position of
	the month and <literal>dd</literal> to indicate the position of the
	day.
       </para>
       <para>
	The following table indicates a few possible formats. This will give
	you an idea of how to use this function.
        <table>
	 <title>Valid input formats for <function>rdefmtdate</function></title>
	 <tgroup cols="2">
	  <thead>
	   <row>
	    <entry>fmt</entry>
	    <entry>str</entry>
	    <entry>result</entry>
	   </row>
	  </thead>
	  <tbody>
	   <row>
	    <entry><literal>ddmmyy</literal></entry>
	    <entry><literal>21-2-54</literal></entry>
	    <entry><literal>1954-02-21</literal></entry>
	   </row>
	   <row>
	    <entry><literal>ddmmyy</literal></entry>
	    <entry><literal>2-12-54</literal></entry>
	    <entry><literal>1954-12-02</literal></entry>
	   </row>
	   <row>
	    <entry><literal>ddmmyy</literal></entry>
	    <entry><literal>20111954</literal></entry>
	    <entry><literal>1954-11-20</literal></entry>
	   </row>
	   <row>
	    <entry><literal>ddmmyy</literal></entry>
	    <entry><literal>130464</literal></entry>
	    <entry><literal>1964-04-13</literal></entry>
	   </row>
	   <row>
	    <entry><literal>mmm.dd.yyyy</literal></entry>
	    <entry><literal>MAR-12-1967</literal></entry>
	    <entry><literal>1967-03-12</literal></entry>
	   </row>
	   <row>
	    <entry><literal>yy/mm/dd</literal></entry>
	    <entry><literal>1954, February 3rd</literal></entry>
	    <entry><literal>1954-02-03</literal></entry>
	   </row>
	   <row>
	    <entry><literal>mmm.dd.yyyy</literal></entry>
	    <entry><literal>041269</literal></entry>
	    <entry><literal>1969-04-12</literal></entry>
	   </row>
	   <row>
	    <entry><literal>yy/mm/dd</literal></entry>
	    <entry><literal>In the year 2525, in the month of July, mankind will be alive on the 28th day</literal></entry>
	    <entry><literal>2525-07-28</literal></entry>
	   </row>
	   <row>
	    <entry><literal>dd-mm-yy</literal></entry>
	    <entry><literal>I said on the 28th of July in the year 2525</literal></entry>
	    <entry><literal>2525-07-28</literal></entry>
	   </row>
	   <row>
	    <entry><literal>mmm.dd.yyyy</literal></entry>
	    <entry><literal>9/14/58</literal></entry>
	    <entry><literal>1958-09-14</literal></entry>
	   </row>
	   <row>
	    <entry><literal>yy/mm/dd</literal></entry>
	    <entry><literal>47/03/29</literal></entry>
	    <entry><literal>1947-03-29</literal></entry>
	   </row>
	   <row>
	    <entry><literal>mmm.dd.yyyy</literal></entry>
	    <entry><literal>oct 28 1975</literal></entry>
	    <entry><literal>1975-10-28</literal></entry>
	   </row>
	   <row>
	    <entry><literal>mmddyy</literal></entry>
	    <entry><literal>Nov 14th, 1985</literal></entry>
	    <entry><literal>1985-11-14</literal></entry>
	   </row>
          </tbody>
         </tgroup>
        </table>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 
  <sect2>
   <title>The timestamp type</title>
   <para>
    The timestamp type in C enables your programs to deal with data of the SQL
    type timestamp. See <xref linkend="datatype-datetime"> for the equivalent
    type in the <productname>PostgreSQL</productname> server.
   </para>
   <para>
    The following functions can be used to work with the timestamp type:
    <variablelist>
     <varlistentry id="PGTYPEStimestampfromasc">
      <term><function>PGTYPEStimestamp_from_asc</function></term>
      <listitem>
       <para>
	Parse a timestamp from its textual representation into a timestamp
	variable.
<synopsis>
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
</synopsis>
	The function receives the string to parse (<literal>str</literal>) and a
	pointer to a C char* (<literal>endptr</literal>).
	At the moment ecpg always parses
	the complete string and so it currently does not support to store the
	address of the first invalid character in <literal>*endptr</literal>.
	You can safely set <literal>endptr</literal> to NULL.
       </para>
       <para>
	The function returns the parsed timestamp on success. On error,
	<literal>PGTYPESInvalidTimestamp</literal> is returned and errno is
	set to <literal>PGTYPES_TS_BAD_TIMESTAMP</literal>. See <xref linkend="PGTYPESInvalidTimestamp"/> for important notes on this value.
	
       </para>
       <para>
	In general, the input string can contain any combination of an allowed
	date specification, a whitespace character and an allowed time
	specification. Note that timezones are not supported by ecpg. It can
	parse them but does not apply any calculation as the
	<productname>PostgreSQL</productname> server does for example. Timezone
	specificiers are silently discarded.
       </para>
       <para>
        The following table contains a few examples for input strings:
        <table>
	 <title>Valid input formats for <function>PGTYPEStimestamp_from_asc</function></title>
	 <tgroup cols="2">
	  <thead>
	   <row>
	    <entry>Input</entry>
	    <entry>Result</entry>
	   </row>
	  </thead>
	  <tbody>
	   <row>
	    <entry><literal>1999-01-08 04:05:06</literal></entry>
	    <entry><literal>1999-01-08 04:05:06</literal></entry>
	   </row>
	   <row>
	    <entry><literal>January 8 04:05:06 1999 PST</literal></entry>
	    <entry><literal>1999-01-08 04:05:06</literal></entry>
	   </row>
	   <row>
	    <entry><literal>1999-Jan-08 04:05:06.789-8</literal></entry>
	    <entry><literal>1999-01-08 04:05:06.789 (time zone specifier ignored)</literal></entry>
	   </row>
	   <row>
	    <entry><literal>J2451187 04:05-08:00</literal></entry>
	    <entry><literal>1999-01-08 04:05:00 (time zone specifier ignored)</literal></entry>
	   </row>
          </tbody>
         </tgroup>
        </table>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestamptoasc">
      <term><function>PGTYPEStimestamp_to_asc</function></term>
      <listitem>
       <para>
        Converts a date to a C char* string.
<synopsis>
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
</synopsis>
	The function receives the timestamp <literal>tstamp</literal> as
	its only argument and returns an allocated string that contains the
	textual representation of the timestamp.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampcurrent">
      <term><function>PGTYPEStimestamp_current</function></term>
      <listitem>
       <para>
        Retrieve the current timestamp.
<synopsis>
void PGTYPEStimestamp_current(timestamp *ts);
</synopsis>
	The function retrieves the current timestamp and saves it into the
	timestamp variable that <literal>ts</literal> points to.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampfmtasc">
      <term><function>PGTYPEStimestamp_fmt_asc</function></term>
      <listitem>
       <para>
        Convert a timestamp variable to a C char* using a format mask.
<synopsis>
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
	The function receives a pointer to the timestamp to convert as its
	first argument (<literal>ts</literal>), a pointer to the output buffer
	(<literal>output</literal>), the maximal length that has been allocated for
	the output buffer (<literal>str_len</literal>) and the format mask to
	use for the conversion (<literal>fmtstr</literal>).
       </para>
       <para>
	Upon success, the function returns 0 and a negative value if an
	error occurred.
       </para>
       <para>
	You can use the following format specifiers for the format mask. The
	format specifiers are the same ones that are used in the
	<function>strftime</function> function in <productname>libc</productname>. Any
	non-format specifier will be copied into the output buffer. 
	<!-- This is from the FreeBSD man page:
	     http://www.freebsd.org/cgi/man.cgi?query=strftime&apropos=0&sektion=3&manpath=FreeBSD+7.0-current&format=html
	-->
        <itemizedlist>
         <listitem>
          <para>
	   <literal>%A</literal> - is replaced by national representation of
	   the full weekday name.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%a</literal> - is replaced by national representation of
	   the abbreviated weekday name.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%B</literal> - is replaced by national representation of
	   the full month name.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%b</literal> - is replaced by national representation of
	   the abbreviated month name.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%C</literal> - is replaced by (year / 100) as decimal
	   number; single digits are preceded by a zero.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%c</literal> - is replaced by national representation of
	   time and date.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%D</literal> - is equivalent to
	   <literal>%m/%d/%y</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%d</literal> - is replaced by the day of the month as a
	   decimal number (01-31).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%E*</literal> <literal>%O*</literal> -  POSIX locale
	   extensions. The sequences
	   <literal>%Ec</literal>
	   <literal>%EC</literal> 
	   <literal>%Ex</literal> 
	   <literal>%EX</literal> 
	   <literal>%Ey</literal> 
	   <literal>%EY</literal> 
	   <literal>%Od</literal> 
	   <literal>%Oe</literal>
	   <literal>%OH</literal> 
	   <literal>%OI</literal> 
	   <literal>%Om</literal> 
	   <literal>%OM</literal> 
	   <literal>%OS</literal> 
	   <literal>%Ou</literal> 
	   <literal>%OU</literal> 
	   <literal>%OV</literal> 
	   <literal>%Ow</literal> 
	   <literal>%OW</literal> 
	   <literal>%Oy</literal> 
	   are supposed to provide alternate representations.
          </para>
          <para>
	   Additionally <literal>%OB</literal> implemented to represent
	   alternative months names (used standalone, without day mentioned).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%e</literal> - is replaced by the day of month as a decimal
	   number (1-31); single digits are preceded by a blank.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%F</literal> - is equivalent to <literal>%Y-%m-%d</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%G</literal> - is replaced by a year as a decimal number
	   with century. This year is the one that contains the greater part of
	   the week (Monday as the first day of the week).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%g</literal> - is replaced by the same year as in
	   <literal>%G</literal>, but as a decimal number without century
	   (00-99).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%H</literal> - is replaced by the hour (24-hour clock) as a
	   decimal number (00-23).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%h</literal> - the same as <literal>%b</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%I</literal> - is replaced by the hour (12-hour clock) as a
	   decimal number (01-12).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%j</literal> - is replaced by the day of the year as a
	   decimal number (001-366).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%k</literal> - is replaced by the hour (24-hour clock) as a
	   decimal number (0-23); single digits are preceded by a blank.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%l</literal> - is replaced by the hour (12-hour clock) as a
	   decimal number (1-12); single digits are preceded by a blank.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%M</literal> - is replaced by the minute as a decimal
	   number (00-59).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%m</literal> - is replaced by the month as a decimal number
	   (01-12).
          </para>
         </listitem>
         <listitem>
          <para>
	  <literal>%n</literal> - is replaced by a newline.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%O*</literal> - the same as <literal>%E*</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%p</literal> - is replaced by national representation of
	   either "ante meridiem" or "post meridiem" as appropriate.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%R</literal> - is equivalent to <literal>%H:%M</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%r</literal> - is equivalent to <literal>%I:%M:%S
	   %p</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%S</literal> - is replaced by the second as a decimal
	   number (00-60).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%s</literal> - is replaced by the number of seconds since
	   the Epoch, UTC.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%T</literal> - is equivalent to <literal>%H:%M:%S</literal>
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%t</literal> - is replaced by a tab.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%U</literal> - is replaced by the week number of the year
	   (Sunday as the first day of the week) as a decimal number (00-53).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%u</literal> - is replaced by the weekday (Monday as the
	   first day of the week) as a decimal number (1-7).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%V</literal> - is replaced by the week number of the year
	   (Monday as the first day of the week) as a decimal number (01-53).
	   If the week containing January 1 has four or more days in the new
	   year, then it is week 1; otherwise it is the last week of the
	   previous year, and the next week is week 1.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%v</literal> - is equivalent to
	   <literal>%e-%b-%Y</literal>.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%W</literal> - is replaced by the week number of the year
	   (Monday as the first day of the week) as a decimal number (00-53).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%w</literal> - is replaced by the weekday (Sunday as the
	   first day of the week) as a decimal number (0-6).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%X</literal> - is replaced by national representation of
	   the time.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%x</literal> - is replaced by national representation of
	   the date.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%Y</literal> - is replaced by the year with century as a
	   decimal number.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%y</literal> - is replaced by the year without century as a
	   decimal number (00-99).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%Z</literal> - is replaced by the time zone name.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%z</literal> - is replaced by the time zone offset from
	   UTC; a leading plus sign stands for east of UTC, a minus sign for
	   west of UTC, hours and minutes follow with two digits each and no
	   delimiter between them (common form for RFC 822 date headers).
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%+</literal> - is replaced by national representation of
	   the date and time.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%-*</literal> - GNU libc extension.	Do not do any padding
	   when performing numerical outputs.
          </para>
         </listitem>
         <listitem>
          <para>
	   $_* - GNU libc extension.	Explicitly specify space for padding.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%0*</literal> - GNU libc extension.	Explicitly specify zero
	   for padding.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>%%</literal> - is replaced by <literal>%</literal>.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsub">
      <term><function>PGTYPEStimestamp_sub</function></term>
      <listitem>
       <para>
	Subtract one timestamp from another one and save the result in a
	variable of type interval.
<synopsis>
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
	The function will subtract the timestamp variable that <literal>ts2</literal>
	points to from the timestamp variable that <literal>ts1</literal> points to
	and will store the result in the interval variable that <literal>iv</literal>
	points to.
       </para>
       <para>
	Upon success, the function returns 0 and a negative value if an
	error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampdefmtasc">
      <term><function>PGTYPEStimestamp_defmt_asc</function></term>
      <listitem>
       <para>
	Parse a timestamp value from its textual representation using a
	formatting mask.
<synopsis>
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
</synopsis>
	The function receives the textual representation of a timestamp in the
	variable <literal>str</literal> as well as the formatting mask to use in the
	variable <literal>fmt</literal>. The result will be stored in the variable
	that <literal>d</literal> points to.
       </para>
       <para>
	       If the formatting mask <literal>fmt</literal> is NULL, the function will fall
	back to the default formatting mask which is <literal>%Y-%m-%d
	%H:%M:%S</literal>.
       </para>
       <para>
	This is the reverse function to <xref
	linkend="PGTYPEStimestampfmtasc"/>.  See the documentation there in
	order to find out about the possible formatting mask entries.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampaddinterval">
      <term><function>PGTYPEStimestamp_add_interval</function></term>
      <listitem>
       <para>
        Add an interval variable to a timestamp variable.
<synopsis>
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
	The function receives a pointer to a timestamp variable <literal>tin</literal>
	and a pointer to an interval variable <literal>span</literal>. It adds the
	interval to the timestamp and saves the resulting timestamp in the
	variable that <literal>tout</literal> points to.
       </para>
       <para>
	Upon success, the function returns 0 and a negative value if an
	error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsubinterval">
      <term><function>PGTYPEStimestamp_sub_interval</function></term>
      <listitem>
       <para>
        Subtract an interval variable from a timestamp variable.
<synopsis>
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
	The function subtracts the interval variable that <literal>span</literal>
	points to from the timestamp variable that <literal>tin</literal> points to
	and saves the result into the variable that <literal>tout</literal> points
	to.
       </para>
       <para>
	Upon success, the function returns 0 and a negative value if an
	error occurred.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2>
   <title>The interval type</title>
   <para>
    The interval type in C enables your programs to deal with data of the SQL
    type interval. See <xref linkend="datatype-datetime"/> for the equivalent
    type in the <productname>PostgreSQL</productname> server.
   </para>
   <para>
    The following functions can be used to work with the interval type:
    <variablelist>

     <varlistentry id="PGTYPESintervalnew">
      <term><function>PGTYPESinterval_new</function></term>
      <listitem>
       <para>
        Return a pointer to a newly allocated interval variable.
<synopsis>
interval *PGTYPESinterval_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfree">
      <term><function>PGTYPESinterval_free</function></term>
      <listitem>
       <para>
        Release the memory of a previously allocated interval variable.
<synopsis>
void PGTYPESinterval_new(interval *intvl);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfromasc">
      <term><function>PGTYPESinterval_from_asc</function></term>
      <listitem>
       <para>
        Parse an interval from its textual representation.
<synopsis>
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
</synopsis>
	The function parses the input string <literal>str</literal> and returns a
	pointer to an allocated interval variable.
	At the moment ecpg always parses
	the complete string and so it currently does not support to store the
	address of the first invalid character in <literal>*endptr</literal>.
	You can safely set <literal>endptr</literal> to NULL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervaltoasc">
      <term><function>PGTYPESinterval_to_asc</function></term>
      <listitem>
       <para>
        Convert a variable of type interval to its textual representation.
<synopsis>
char *PGTYPESinterval_to_asc(interval *span);
</synopsis>
	The function converts the interval variable that <literal>span</literal>
	points to into a C char*. The output looks like this example:
	<literal>@ 1 day 12 hours 59 mins 10 secs</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalcopy">
      <term><function>PGTYPESinterval_copy</function></term>
      <listitem>
       <para>
        Copy a variable of type interval.
<synopsis>
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
</synopsis>
	The function copies the interval variable that <literal>intvlsrc</literal>
	points to into the variable that <literal>intvldest</literal> points to. Note
	that you need to allocate the memory for the destination variable
	before.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2>
   <title>The decimal type</title>
   <para>
     The decimal type is similar to the numeric type. However it is limited to
     a maximal precision of 30 significant digits. In contrast to the numeric
     type which can be created on the heap only, the decimal type can be
     created either on the stack or on the heap (by means of the functions
     PGTYPESdecimal_new() and PGTYPESdecimal_free(). There are a lot of other
     functions that deal with the decimal type in the Informix compatibility
     mode described in <xref linkend="ecpg-informix-compat">.
   </para>
   <para>
    The following functions can be used to work with the decimal type and are
    not only contained in the <literal>libcompat</literal> library.
    <variablelist>
     <varlistentry>
      <term><function>PGTYPESdecimal_new</function></term>
      <listitem>
       <para>
       Request a pointer to a newly allocated decimal variable.
<synopsis>
decimal *PGTYPESdecimal_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESdecimal_free</function></term>
      <listitem>
       <para>
       Free a decimal type, release all of its memory.
<synopsis>
void PGTYPESdecimal_free(decimal *var);
</synopsis>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 
   <sect2>
    <title>errno values of pgtypeslib </title>
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>PGTYPES_NUM_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
	An argument should contain a numeric variable (or point to a numeric
	variable) but in fact its in-memory representation was invalid.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
	An overflow occurred. Since the numeric type can deal with almost
	arbitrary precision, converting a numeric variable into other types
	might cause overflow.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
	An underflow occurred. Since the numeric type can deal with almost
	arbitrary precision, converting a numeric variable into other types
	might cause underflow.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>
        A division by zero has been attempted.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DATE</literal></term>
      <listitem>
       <para>
        
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_EARGS</literal></term>
      <listitem>
       <para>
        
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOSHORTDATE</literal></term>
      <listitem>
       <para>
        
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_INTVL_BAD_INTERVAL</literal></term>
      <listitem>
       <para>
        
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOTDMY</literal></term>
      <listitem>
       <para>
        
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DAY</literal></term>
      <listitem>
       <para>
        
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_MONTH</literal></term>
      <listitem>
       <para>
        
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_BAD_TIMESTAMP</literal></term>
      <listitem>
       <para>
        
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

   <sect2>
    <title>Special constants of pgtypeslib </title>
   <para>
    <variablelist>
     <varlistentry id="PGTYPESInvalidTimestamp">
      <term><literal>PGTYPESInvalidTimestamp</literal></term>
      <listitem>
       <para>
	A value of type timestamp representing an invalid time stamp. This is
	returned by the function <function>PGTYPEStimestamp_from_asc</function> on
	parse error.
	Note that due to the internal representation of the timestamp datatype,
	<literal>PGTYPESInvalidTimestamp</literal> is also a valid timestamp at
	the same time. It is set to <literal>1899-12-31 23:59:59</literal>. In order
	to detect errors, make sure that your application does not only test
	for <literal>PGTYPESInvalidTimestamp</literal> but also for
	<literal>errno != 0</literal> after each call to
	<function>PGTYPEStimestamp_from_asc</function>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-informix-compat">
  <title>Informix compatibility mode</title>
  <para>
   ecpg can be run in a so-called <firstterm>Informix compatibility mode</firstterm>. If
   this mode is active, it tries to behave as if it were the Informix
   precompiler for Informix E/SQL. Generally spoken this will allow you to use
   the dollar sign instead of the <literal>EXEC SQL</literal> primitive to introduce
   embedded SQL commands.
<programlisting>
   $int j = 3;
   $CONNECT TO :dbname;
   $CREATE TABLE test(i INT PRIMARY KEY, j INT);
   $INSERT INTO test(i, j) VALUES (7, :j);
   $COMMIT;
</programlisting>
  </para>
  <para>
   There are two compatiblity modes: INFORMIX, INFORMIX_SE
  </para>
  <para>
   When linking programs that use this compatibility mode, remember to link
   against <literal>libcompat</literal> that is shipped with ecpg.
  </para>
  <para>
   Besides the previously explained syntactic sugar, the Informix compatibility
   mode ports some functions for input, output and transformation of data as
   well as embedded SQL statements known from E/SQL to ecpg.
  </para>
  <para>
   Informix compatibility mode is closely connected to the pgtypeslib library
   of ecpg. pgtypeslib maps SQL data types to data types within the C host
   program and most of the additional functions of the Informix compatibility
   mode allow you to operate on those C host program types. Note however that
   the extent of the compatibility is limited. It does not try to copy Informix
   behaviour; it allows you to do more or less the same operations and gives
   you functions that have the same name and the same basic behavior but it is
   no drop-in replacement if you are using Informix at the moment. Moreover,
   some of the data types are different. For example,
   <productname>PostgreSQL's</productname> datetime and interval types do not
   know about ranges like for example <literal>YEAR TO MINUTE</literal> so you won't
   find support in ecpg for that either.
  </para>

  <sect2>
   <title>Additional embedded SQL statements</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>CLOSE DATABASE</literal></term>
      <listitem>
       <para>
	This statement closes the current connection. In fact, this is a
	synonym for ecpg's <literal>DISCONNECT CURRENT</literal>.
<programlisting>
    $CLOSE DATABASE;                /* close the current connection */
    EXEC SQL CLOSE DATABASE;
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2>
   <title>Additional functions</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><function>decadd</function></term>
      <listitem>
       <para>
        Add two decimal type values.
<synopsis>
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
</synopsis>
	The function receives a pointer to the first operand of type decimal
	(<literal>arg1</literal>), a pointer to the second operand of type decimal
	(<literal>arg2</literal>) and a pointer to a value of type decimal that will
	contain the sum (<literal>sum</literal>). On success, the function returns 0.
	ECPG_INFORMIX_NUM_OVERFLOW is returned in case of overflow and 
	ECPG_INFORMIX_NUM_UNDERFLOW in case of underflow. -1 is returned for
	other failures and errno is set to the respective errno number of the
	pgtypeslib.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccmp</function></term>
      <listitem>
       <para>
        Compare two variables of type decimal.
<synopsis>
int deccmp(decimal *arg1, decimal *arg2);
</synopsis>
	The function receives a pointer to the first decimal value
	(<literal>arg1</literal>), a pointer to the second decimal value
	(<literal>arg2</literal>) and returns an integer value that indicates which is
	the bigger value.
        <itemizedlist>
         <listitem>
          <para>
	   1, if the value that <literal>arg1</literal> points to is bigger than the
	   value that <literal>var2</literal> points to
          </para>
         </listitem>
         <listitem>
          <para>
	   -1, if the value that <literal>arg1</literal> points to is smaller than the
	   value that <literal>arg2</literal> points to </para>
         </listitem>
         <listitem>
          <para>
	   0, if the value that <literal>arg1</literal> points to and the value that
	   <literal>arg2</literal> points to are equal
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccopy</function></term>
      <listitem>
       <para>
        Copy a decimal value.
<synopsis>
void deccopy(decimal *src, decimal *target);
</synopsis>
	The function receives a pointer to the decimal value that should be
	copied as the first argument (<literal>src</literal>) and a pointer to the
	target structure of type decimal (<literal>target</literal>) as the second
	argument.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvasc</function></term>
      <listitem>
       <para>
        Convert a value from its ASCII representation into a decimal type.
<synopsis>
int deccvasc(char *cp, int len, decimal *np);
</synopsis>
	The function receives a pointer to string that contains the string
	representation of the number to be converted (<literal>cp</literal>) as well
	as its length <literal>len</literal>. <literal>np</literal> is a pointer to the
	decimal value that saves the result of the operation.
       </para>
       <para>
        Valid formats are for example:
         <literal>-2</literal>,
         <literal>.794</literal>,
         <literal>+3.44</literal>,
         <literal>592.49E07</literal> or
         <literal>-32.84e-4</literal>.
       </para>
       <para>
	The function returns 0 on success. If overflow or underflow occurred,
	<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or
	<literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> is returned. If the ASCII
	representation could not be parsed,
	<literal>ECPG_INFORMIX_BAD_NUMERIC</literal> is returned or
	<literal>ECPG_INFORMIX_BAD_EXPONENT</literal> if this problem ocurred while
	parsing the exponent.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvdbl</function></term>
      <listitem>
       <para>
        Convert a value of type double to a value of type decimal.
<synopsis>
int deccvdbl(double dbl, decimal *np);
</synopsis>
	The function receives the variable of type double that should be
	converted as its first argument (<literal>dbl</literal>). As the second
	argument (<literal>np</literal>), the function receives a pointer to the
	decimal variable that should hold the result of the operation.
       </para>
       <para>
	The function returns 0 on success and a negative value if the
	conversion failed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvint</function></term>
      <listitem>
       <para>
        Convert a value of type int to a value of type decimal.
<synopsis>
int deccvint(int in, decimal *np);
</synopsis>
	The function receives the variable of type int that should be
	converted as its first argument (<literal>in</literal>). As the second
	argument (<literal>np</literal>), the function receives a pointer to the
	decimal variable that should hold the result of the operation.
       </para>
       <para>
	The function returns 0 on success and a negative value if the
	conversion failed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
	     <term><function>deccvlong</function></term>
      <listitem>
       <para>
        Convert a value of type long to a value of type decimal.
<synopsis>
int deccvlong(long lng, decimal *np);
</synopsis>
	The function receives the variable of type long that should be
	converted as its first argument (<literal>lng</literal>). As the second
	argument (<literal>np</literal>), the function receives a pointer to the
	decimal variable that should hold the result of the operation.
       </para>
       <para>
	The function returns 0 on success and a negative value if the
	conversion failed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decdiv</function></term>
      <listitem>
       <para>
        Divide two variables of type decimal.
<synopsis>
int decdiv(decimal *n1, decimal *n2, decimal *result);
</synopsis>
	The function receives pointers to the variables that are the first
	(<literal>n1</literal>) and the second (<literal>n2</literal>) operands and
	calculates <literal>n1</literal>/<literal>n2</literal>. <literal>result</literal> is a
	pointer to the variable that should hold the result of the operation.
       </para>
       <para>
	On success, 0 is returned and a negative value if the division fails.
	If overflow or underflow occurred, the function returns
	<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or
	<literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectively. If an attempt to
	divide by zero is observed, the function returns
	<literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decmul</function></term>
      <listitem>
       <para>
        Multiply two decimal values.
<synopsis>
int decmul(decimal *n1, decimal *n2, decimal *result);
</synopsis>
	The function receives pointers to the variables that are the first
	(<literal>n1</literal>) and the second (<literal>n2</literal>) operands and
	calculates <literal>n1</literal>*<literal>n2</literal>. <literal>result</literal> is a
	pointer to the variable that should hold the result of the operation.
       </para>
       <para>
	On success, 0 is returned and a negative value if the multiplication
	fails. If overflow or underflow occurred, the function returns
	<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or
	<literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectively.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decsub</function></term>
      <listitem>
       <para>
        Subtract one decimal value from another.
<synopsis>
int decsub(decimal *n1, decimal *n2, decimal *result);
</synopsis>
	The function receives pointers to the variables that are the first
	(<literal>n1</literal>) and the second (<literal>n2</literal>) operands and
	calculates <literal>n1</literal>-<literal>n2</literal>. <literal>result</literal> is a
	pointer to the variable that should hold the result of the operation.
       </para>
       <para>
	On success, 0 is returned and a negative value if the subtraction
	fails. If overflow or underflow occurred, the function returns
	<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or
	<literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectively.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoasc</function></term>
      <listitem>
       <para>
	Convert a variable of type decimal to its ASCII representation in a C
	char* string.
<synopsis>
int dectoasc(decimal *np, char *cp, int len, int right)
</synopsis>
	The function receives a pointer to a variable of type decimal
	(<literal>np</literal>) that it converts to its textual representation.
	<literal>cp</literal> is the buffer that should hold the result of the
	operation. The parameter <literal>right</literal> specifies, how many digits
	right of the decimal point should be included in the output. The result
	will be rounded to this number of decimal digits. Setting
	<literal>right</literal> to -1 indicates that all available decimal digits
	should be included in the output. If the length of the output buffer,
	which is indicated by <literal>len</literal> is not sufficient to hold the
	textual representation including the trailing NUL character, only a
	single <literal>*</literal> character is stored in the result and -1 is
	returned.
       </para>
       <para>
	The function returns either -1 if the buffer <literal>cp</literal> was too
	small or <literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal> if memory was
	exhausted. 
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectodbl</function></term>
      <listitem>
       <para>
        Convert a variable of type decimal to a double.
<synopsis>
int dectodbl(decimal *np, double *dblp);
</synopsis>
	The function receives a pointer to the decimal value to convert
	(<literal>np</literal>) and a pointer to the double variable that
	should hold the result of the operation (<literal>dblp</literal>).
       </para>
       <para>
	On success, 0 is returned and a negative value if the conversion
	failed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoint</function></term>
      <listitem>
       <para>
        Convert a variable to type decimal to an integer.
<synopsis>
int dectoint(decimal *np, int *ip);
</synopsis>
	The function receives a pointer to the decimal value to convert
	(<literal>np</literal>) and a pointer to the integer variable that
	should hold the result of the operation (<literal>ip</literal>).
       </para>
       <para>
	On success, 0 is returned and a negative value if the conversion
	failed. If an overflow occurred, <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>
	is returned.
       </para>
       <para>
	Note that the ecpg implementation differs from the Informix
	implementation. Informix limits an integer to the range from -32767 to
	32767, while the limits in the ecpg implementation depend on the
	architecture (<literal>-INT_MAX .. INT_MAX</literal>).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectolong</function></term>
      <listitem>
       <para>
        Convert a variable to type decimal to a long integer.
<synopsis>
int dectolong(decimal *np, long *lngp);
</synopsis>
	The function receives a pointer to the decimal value to convert
	(<literal>np</literal>) and a pointer to the long variable that
	should hold the result of the operation (<literal>lngp</literal>).
       </para>
       <para>
	On success, 0 is returned and a negative value if the conversion
	failed. If an overflow occurred, <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>
	is returned.
       </para>
       <para>
	Note that the ecpg implementation differs from the Informix
	implementation. Informix limits a long integer to the range from
	-2,147,483,647 to 2,147,483,647, while the limits in the ecpg
	implementation depend on the architecture (<literal>-LONG_MAX ..
	LONG_MAX</literal>).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdatestr</function></term>
      <listitem>
       <para>
        Converts a date to a C char* string.
<synopsis>
int rdatestr(date d, char *str);
</synopsis>
	The function receives two arguments, the first one is the date to
	convert (<literal>d</literal> and the second one is a pointer to the target
	string. The output format is always <literal>yyyy-mm-dd</literal>, so you need
	to allocate at least 11 bytes (including the NUL-terminator) for the
	string.
       </para>
       <para>
	The function returns 0 on success and a negative value in case of
	error.
       </para>
       <para>
	Note that ecpg's implementation differs from the Informix
	implementation. In Informix the format can be influenced by setting
	environment variables. In ecpg however, you cannot change the output
	format.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rstrdate</function></term>
      <listitem>
       <para>
        Parse the textual representation of a date.
<synopsis>
int rstrdate(char *str, date *d);
</synopsis>
	The function receives the textual representation of the date to convert
	(<literal>str</literal>) and a pointer to a variable of type date
	(<literal>d</literal>). This function does not allow you to specify a format
	mask. It uses the default format mask of Informix which is
	<literal>mm/dd/yyyy</literal>. Internally, this function is implemented by
	means of <function>rdefmtdate</function>. Therefore, <function>rstrdate</function> is
	not faster and if you have the choice you should opt for
	<function>rdefmtdate</function> which allows you to specify the format mask
	explicitly.
       </para>
       <para>
        The function returns the same values as <function>rdefmtdate</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtoday</function></term>
      <listitem>
       <para>
        Get the current date.
<synopsis>
void rtoday(date *d);
</synopsis>
	The function receives a pointer to a date variable (<literal>d</literal>)
	that it sets to the current date.
       </para>
       <para>
	Internally this function uses the <xref linkend="PGTYPESdatetoday"/>
	function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rjulmdy</function></term>
      <listitem>
       <para>
	Extract the values for the day, the month and the year from a variable
	of type date.
<synopsis>
int rjulmdy(date d, short mdy[3]);
</synopsis>
	The function receives the date <literal>d</literal> and a pointer to an array
	of 3 short integer values <literal>mdy</literal>. The variable name indicates
	the sequential order: <literal>mdy[0]</literal> will be set to contain the
	number of the month, <literal>mdy[1]</literal> will be set to the value of the
	day and <literal>mdy[2]</literal> will contain the year.
       </para>
       <para>
        The function always returns 0 at the moment.
       </para>
       <para>
	Internally the function uses the <xref linkend="PGTYPESdatejulmdy"/>
	function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdefmtdate</function></term>
      <listitem>
       <para>
	Use a format mask to convert a character string to a value of type
	date.
<synopsis>
int rdefmtdate(date *d, char *fmt, char *str);
</synopsis>
	The function receives a pointer to the date value that should hold the
	result of the operation (<literal>d</literal>), the format mask to use for
	parsing the date (<literal>fmt</literal>) and the C char* string containing
	the textual representation of the date (<literal>str</literal>). The textual
	representation is expected to match the format mask. However you do not
	need to have a 1:1 mapping of the string to the format mask. The
	function only analyzes the sequential order and looks for the literals
	<literal>yy</literal> or <literal>yyyy</literal> that indicate the
	position of the year, <literal>mm</literal> to indicate the position of
	the month and <literal>dd</literal> to indicate the position of the
	day.
       </para>
       <para>
        The function returns the following values:
        <itemizedlist>
         <listitem>
          <para>
           0 - The function terminated successfully.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>ECPG_INFORMIX_ENOSHORTDATE</literal> - The date does not contain
	   delimiters between day, month and year. In this case the input
	   string must be exactly 6 or 8 bytes long but isn't.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>ECPG_INFORMIX_ENOTDMY</literal> - The format string did not
	   correctly indicate the sequential order of year, month and day.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>ECPG_INFORMIX_BAD_DAY</literal> - The input string does not
	   contain a valid day.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>ECPG_INFORMIX_BAD_MONTH</literal> - The input string does not
	   contain a valid month.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>ECPG_INFORMIX_BAD_YEAR</literal> - The input string does not
	   contain a valid year.
          </para>
         </listitem>
	</itemizedlist>
       </para>
       <para>
	Internally this function is implemented to use the <xref
	linkend="PGTYPESdatedefmtasc"/> function. See the reference there for a
	table of example input.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtdate</function></term>
      <listitem>
       <para>
	Convert a variable of type date to its textual representation using a
	format mask.
<synopsis>
int rfmtdate(date d, char *fmt, char *str);
</synopsis>
	The function receives the date to convert (<literal>d</literal>), the format
	mask (<literal>fmt</literal>) and the string that will hold the textual
	representation of the date (<literal>str</literal>).
       </para>
       <para>
        On success, 0 is returned and a negative value if an error occurred.
       </para>
       <para>
	Internally this function uses the <xref linkend="PGTYPESdatefmtasc"/>
	function, see the reference there for examples.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rmdyjul</function></term>
      <listitem>
       <para>
	Create a date value from an array of 3 short integers that specify the
	day, the month and the year of the date.
<synopsis>
int rmdyjul(short mdy[3], date *d);
</synopsis>
	The function receives the array of the 3 short integers
	(<literal>mdy</literal>) and a pointer to a variable of type date that should
	hold the result of the operation.
       </para>
       <para>
        Currently the function returns always 0.
       </para>
       <para>
	Internally the function is implemented to use the function <xref
	linkend="PGTYPESdatemdyjul"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdayofweek</function></term>
      <listitem>
       <para>
        Return a number representing the day of the week for a date value.
<synopsis>
int rdayofweek(date d);
</synopsis>
	The function receives the date variable <literal>d</literal> as its only
	argument and returns an integer that indicates the day of the week for
	this date.
        <itemizedlist>
         <listitem>
          <para>
	   0 - Sunday
          </para>
         </listitem>
         <listitem>
          <para>
	   1 - Monday
          </para>
         </listitem>
         <listitem>
          <para>
	   2 - Tuesday
          </para>
         </listitem>
         <listitem>
          <para>
	   3 - Wednesday
          </para>
         </listitem>
         <listitem>
          <para>
	   4 - Thursday
          </para>
         </listitem>
         <listitem>
          <para>
	   5 - Friday
          </para>
         </listitem>
         <listitem>
          <para>
	   6 - Saturday
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
	Internally the function is implemented to use the function <xref
	linkend="PGTYPESdatedayofweek"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcurrent</function></term>
      <listitem>
       <para>
        Retrieve the current timestamp.
<synopsis>
void dtcurrent(timestamp *ts);
</synopsis>
	The function retrieves the current timestamp and saves it into the
	timestamp variable that <literal>ts</literal> points to.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvasc</function></term>
      <listitem>
       <para>
	Parses a timestamp from its textual representation in ANSI standard
	into a timestamp variable.
<synopsis>
int dtcvasc(char *str, timestamp *ts);
</synopsis>
	The function receives the string to parse (<literal>str</literal>) and a
	pointer to the timestamp variable that should hold the result of the
	operation (<literal>ts</literal>).
       </para>
       <para>
	The function returns 0 on success and a negative value in case of
	error.
       </para>
       <para>
	Internally this function uses the <xref
	linkend="PGTYPEStimestampfromasc"/> function. See the reference there
	for a table with example inputs.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvfmtasc</function></term>
      <listitem>
       <para>
	Parses a timestamp from its textual representation in ANSI standard
	using a format mask into a timestamp variable.
<synopsis>
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
</synopsis>
	The function receives the string to parse (<literal>inbuf</literal>), the
	format mask to use (<literal>fmtstr</literal>) and a pointer to the timestamp
	variable that should hold the result of the operation (<literal>ts</literal>).
       </para>
       <para>
	This functions is implemented by means of the <xref
	linkend="PGTYPEStimestampdefmtasc"/>. See the documentation
	there for a list of format specifiers that can be used.
       </para>
       <para>
	The function returns 0 on success and a negative value in case of
	error.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtsub</function></term>
      <listitem>
       <para>
	Subtract one timestamp from another and return a variable of type
	interval.
<synopsis>
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
	The function will subtract the timestamp variable that <literal>ts2</literal>
	points to from the timestamp variable that <literal>ts1</literal> points to
	and will store the result in the interval variable that <literal>iv</literal>
	points to.
       </para>
       <para>
	Upon success, the function returns 0 and a negative value if an
	error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttoasc</function></term>
      <listitem>
       <para>
        Convert a timestamp variable to a C char* string.
<synopsis>
int dttoasc(timestamp *ts, char *output);
</synopsis>
	The function receives a pointer to the timestamp variable to convert
	(<literal>ts</literal>) and the string that should hold the result of the
	operation <literal>output</literal>). It converts <literal>ts</literal> to its
	textual representation in the ANSI SQL standard which is defined to
	be <literal>YYYY-MM-DD HH:MM:SS</literal>.
       </para>
       <para>
	Upon success, the function returns 0 and a negative value if an
	error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttofmtasc</function></term>
      <listitem>
       <para>
        Convert a timestamp variable to a C char* using a format mask.
<synopsis>
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
	The function receives a pointer to the timestamp to convert as its
	first argument (<literal>ts</literal>), a pointer to the output buffer
	(<literal>output</literal>), the maximal length that has been allocated for
	the output buffer (<literal>str_len</literal>) and the format mask to
	use for the conversion (<literal>fmtstr</literal>).
       </para>
       <para>
	Upon success, the function returns 0 and a negative value if an
	error occurred.
       </para>
       <para>
	Internally this function uses the <xref
	linkend="PGTYPEStimestampfmtasc"/> function. See the reference there for
	informations on what format mask specifiers can be used.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>intoasc</function></term>
      <listitem>
       <para>
        Convert an interval variable to a C char* string.
<synopsis>
int intoasc(interval *i, char *str);
</synopsis>
	The function receives a pointer to the interval variable to convert
	(<literal>i</literal>) and the string that should hold the result of the
	operation <literal>str</literal>). It converts <literal>i</literal> to its
	textual representation in the ANSI SQL standard which is defined to
	be <literal>YYYY-MM-DD HH:MM:SS</literal>.
       </para>
       <para>
	Upon success, the function returns 0 and a negative value if an
	error occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtlong</function></term>
      <listitem>
       <para>
	Convert a long integer value to its textual representation using a
	format mask.
<synopsis>
int rfmtlong(long lng_val, char *fmt, char *outbuf);
</synopsis>
	The function receives the long value <literal>lng_val</literal>, the format
	mask <literal>fmt</literal> and a pointer to the output buffer
	<literal>outbuf</literal>. It converts the long value according to the format
	mask to its textual representation.
       </para>
       <para>
	The format mask can be composed of the following format specifying
	characters:
        <itemizedlist>
         <listitem>
          <para>
	   <literal>*</literal> (asterisk) - if this position would be blank
	   otherwise, fill it with an asterisk.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>&amp;</literal> (ampersand) - if this position would be
	   blank otherwise, fill it with a zero.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>#</literal> - turn leading zeroes into blanks.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>&lt;</literal> - left-justify the number in the string.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>,</literal> (comma) - group numbers of four or more digits
	   into groups of three digits separated by a comma.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>.</literal> (period) - this character separates the
	   whole-number part of the number from the fractional part.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>-</literal> (minus) - the minus sign appears if the number
	   is a negative value.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>+</literal> (plus) - the plus sign appears if the number is
	   a positive value.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>(</literal> - this replaces the minus sign in front of the
	   negative number. The minus sign will not appear.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>)</literal> - this character replaces the minus and is
	   printed behind the negative value.
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>$</literal> - the currency symbol.
          </para>
         </listitem>
	</itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rupshift</function></term>
      <listitem>
       <para>
        Convert a string to upper case.
<synopsis>
void rupshift(char *str);
</synopsis>
	The function receives a pointer to the string and transforms every
	lower case character to upper case.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>byleng</function></term>
      <listitem>
       <para>
	Return the number of characters in a string without counting trailing
	blanks.
<synopsis>
int byleng(char *str, int len);
</synopsis>
	The function expects a fixed-length string as its first argument
	(<literal>str</literal>) and its length as its second argument
	(<literal>len</literal>). It returns the number of significant characters,
	that is the length of the string without trailing blanks.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>ldchar</function></term>
      <listitem>
       <para>
        Copy a fixed-length string into a null-terminated string.
<synopsis>
void ldchar(char *src, int len, char *dest);
</synopsis>
	The function receives the fixed-length string to copy
	(<literal>src</literal>), its length (<literal>len</literal>) and a pointer to the
	destination memory (<literal>dest</literal>). Note that you need to reserve at
	least <literal>len+1</literal> bytes for the string that <literal>dest</literal>
	points to. The function copies at most <literal>len</literal> bytes to the new
	location (less if the source string has trailing blanks) and adds the
	null-terminator.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rgetmsg</function></term>
      <listitem>
       <para>
<synopsis>
int rgetmsg(int msgnum, char *s, int maxsize);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypalign</function></term>
      <listitem>
       <para>
<synopsis>
int rtypalign(int offset, int type);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypmsize</function></term>
      <listitem>
       <para>
<synopsis>
int rtypmsize(int type, int len);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypwidth</function></term>
      <listitem>
       <para>
<synopsis>
int rtypwidth(int sqltype, int sqllen);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="rsetnull">
      <term><function>rsetnull</function></term>
      <listitem>
       <para>
        Set a variable to NULL.
<synopsis>
int rsetnull(int t, char *ptr);
</synopsis>
	The function receives an integer that indicates the type of the
	variable and a pointer to the variable itself that is casted to a C
	char* pointer.
       </para>
       <para>
        The following types exist:
        <itemizedlist>
         <listitem>
          <para>
	   <literal>CCHARTYPE</literal> - For a variable of type char or char*
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>CSHORTTYPE</literal> - For a variable of type short int
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>CINTTYPE</literal> - For a variable of type int
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>CBOOLTYPE</literal> - For a variable of type boolean
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>CFLOATTYPE</literal> - For a variable of type float
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>CLONGTYPE</literal> - For a variable of type long
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>CDOUBLETYPE</literal> - For a variable of type double
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>CDECIMALTYPE</literal> - For a variable of type decimal
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>CDATETYPE</literal> - For a variable of type date
          </para>
         </listitem>
         <listitem>
          <para>
	   <literal>CDTIMETYPE</literal> - For a variable of type timestamp
          </para>
         </listitem>
        </itemizedlist>
       </para>

       <para>
        Here is an example of a call to this function:
<programlisting>
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &amp;s);
rsetnull(CINTTYPE, (char *) &amp;i);
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>risnull</function></term>
      <listitem>
       <para>
        Test if a variable is NULL.
<synopsis>
int risnull(int t, char *ptr);
</synopsis>
	The function receives the type of the variable to test (<literal>t</literal>)
	as well a pointer to this variable (<literal>ptr</literal>). Note that the
	latter needs to be casted to a char*. See the function <xref
	linkend="rsetnull"/> for a list of possible variable types.
       </para>
       <para>
        Here is an example of how to use this function:
<programlisting>
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &amp;s);
risnull(CINTTYPE, (char *) &amp;i);
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2>
   <title>Additional constants</title>
   <para>
    Note that all constants here describe errors and all of them are defined
    to represent negative values. In the descriptions of the different
    constants you can also find the value that the constants represent in the
    current implementation. However you should not rely on this number. You can
    however rely on the fact all of them are defined to represent negative
    values.
    <variablelist>
     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
	Functions return this value if an overflow occurred in a
	calculation. Internally it is defined to -1200 (the Informix
	definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>
	Functions return this value if an underflow occurred in a calculation.
	Internally it is defined to -1201 (the Informix definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>
	Functions return this value if an attempt to divide by zero is
	observed. Internally it is defined to -1202 (the Informix definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_YEAR</literal></term>
      <listitem>
       <para>
	Functions return this value if a bad value for a year was found while
	parsing a date. Internally it is defined to -1204 (the Informix
	definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_MONTH</literal></term>
      <listitem>
       <para>
	Functions return this value if a bad value for a month was found while
	parsing a date. Internally it is defined to -1205 (the Informix
	definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DAY</literal></term>
      <listitem>
       <para>
	Functions return this value if a bad value for a day was found while
	parsing a date. Internally it is defined to -1206 (the Informix
	definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOSHORTDATE</literal></term>
      <listitem>
       <para>
	Functions return this value if a parsing routine needs a short date
	representation but did not get the date string in the right length.
	Internally it is defined to -1209 (the Informix definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DATE_CONVERT</literal></term>
      <listitem>
       <para>
	Functions return this value if Internally it is defined to -1210 (the
	Informix definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal></term>
      <listitem>
       <para>
	Functions return this value if Internally it is defined to -1211 (the
	Informix definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOTDMY</literal></term>
      <listitem>
       <para>
	Functions return this value if a parsing routine was supposed to get a
	format mask (like <literal>mmddyy</literal>) but not all fields were listed
	correctly. Internally it is defined to -1212 (the Informix definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
	Functions return this value either if a parsing routine cannot parse
	the textual representation for a numeric value because it contains
	errors or if a routine cannot complete a calculation involving numeric
	variables because at least one of the numeric variables is invalid.
	Internally it is defined to -1213 (the Informix definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_EXPONENT</literal></term>
      <listitem>
       <para>
	Functions return this value if Internally it is defined to -1216 (the
	Informix definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DATE</literal></term>
      <listitem>
       <para>
	Functions return this value if Internally it is defined to -1218 (the
	Informix definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_EXTRA_CHARS</literal></term>
      <listitem>
       <para>
	Functions return this value if Internally it is defined to -1264 (the
	Informix definition).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-descriptors">
  <title>Utiliser les zones des descripteurs SQL</title>

  <para>
   Une zone de descripteur SQL est une méthode plus sophistiquée pour traiter
   le résultat d'un <command>SELECT</command> ou d'un <command>FETCH</command>.
   La zone du descripteur SQL groupe les données d'une ligne avec les éléments
   de métadonnées en une seule structure de données. Les métadonnées sont
   particulièrement utiles lors de l'exécution d'instructions SQL dynamiques
   pour lesquelles la nature des colonnes de résultats n'est pas forcément
   connue à l'avance.
  </para>

  <para>
   Une zone de descripteur SQL consiste en un en-tête, contenant des
   informations sur le descripteur complet, et un ou plusieurs éléments
   des zones du descripteur, décrivant basiquement une colonne de la ligne de
   résultat.
  </para>

  <para>
   Avant d'utiliser une zone de descripteur SQL, il est nécessaire d'en
   allouer une&nbsp;:
<programlisting>EXEC SQL ALLOCATE DESCRIPTOR <replaceable>identifiant</replaceable>;
</programlisting>
   L'identifiant sert de <quote>nom de variable</quote> à la zone du
   descripteur. <remark>La portée du descripteur alloué est QUOI&nbsp;?</remark>
   Lorsque le descripteur n'est plus utilisé, il est recommandé de le désallouer&nbsp;:
<programlisting>EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>identifiant</replaceable>;
</programlisting>
  </para>

  <para>
   Pour utiliser la zone d'un descripteur, il faut le spécifier comme cible de
   stockage dans une clause <literal>INTO</literal> à la place de la liste des
   variables hôtes&nbsp;:
<programlisting>EXEC SQL FETCH NEXT FROM moncurseur INTO DESCRIPTOR mondesc;
</programlisting>
  </para>

  <para>
   Comment récupérer les données de la zone du descripteur&nbsp;?
   Celle-ci peut être envisagée comme une structure contenant des champs nommés. Pour
   récupérer la valeur d'un champ à partir de l'en-tête et la stocker dans une
   variable hôte, on utilise la commande suivante&nbsp;:
<programlisting>EXEC SQL GET DESCRIPTOR <replaceable>nom</replaceable> :<replaceable>varhote</replaceable> = <replaceable>champ</replaceable>;
</programlisting>
   Actuellement, il n'existe qu'un seul champ d'en-tête défini&nbsp;:
   <replaceable>COUNT</replaceable>, qui indique le nombre d'éléments dans
   la zone de descripteur (c'est-à-dire le nombre de colonnes contenues dans le
   résultat). La variable hôte nécessite d'être du type entier. Pour récupérer
   un champ à partir de l'élément de la zone du descripteur, on utilise la commande
   suivante&nbsp;:
<programlisting>EXEC SQL GET DESCRIPTOR <replaceable>nom</replaceable> VALUE
<replaceable>numero</replaceable> :<replaceable>varhote</replaceable> =
<replaceable>champ</replaceable>;
</programlisting>
   <replaceable>numero</replaceable> peut être un entier littéral ou une
   variable hôte contenant un entier. Les champs possibles sont&nbsp;:

   <variablelist>
    <varlistentry>
     <term><literal>CARDINALITY</literal> (integer)</term>
     <listitem>
      <para>
       nombre de lignes dans l'ensemble du résultat
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DATA</literal></term>
     <listitem>
      <para>
       élément de données en cours (de fait, le type de données de ce champ
       dépend de la requête)
      </para>
     </listitem>
    </varlistentry>


    <varlistentry>
     <term><literal>DATETIME_INTERVAL_CODE</literal> (integer)</term>
     <listitem>
      <para>
       ?
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DATETIME_INTERVAL_PRECISION</literal> (integer)</term>
     <listitem>
      <para>
       non implémenté
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>INDICATOR</literal> (integer)</term>
     <listitem>
      <para>
       l'indicateur (indiquant une valeur NULL ou une troncature de la
       valeur)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>KEY_MEMBER</literal> (integer)</term>
     <listitem>
      <para>
       non implémenté
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>LENGTH</literal> (integer)</term>
     <listitem>
      <para>
       longueur de la donnée en caractères
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>NAME</literal> (string)</term>
     <listitem>
      <para>
       nom de la colonne
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>NULLABLE</literal> (integer)</term>
     <listitem>
      <para>
       non implémenté
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>OCTET_LENGTH</literal> (integer)</term>
     <listitem>
      <para>
       longueur en octets de la représentation en caractères de la donnée
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>PRECISION</literal> (integer)</term>
     <listitem>
      <para>
       précision (pour le type <type>numeric</type>)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>RETURNED_LENGTH</literal> (integer)</term>
     <listitem>
      <para>
       longueur de la donnée en caractère
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>RETURNED_OCTET_LENGTH</literal> (integer)</term>
     <listitem>
      <para>
       longueur en octets de la représentation en caractères de la donnée
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SCALE</literal> (integer)</term>
     <listitem>
      <para>
       échelle (pour le type <type>numeric</type>)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TYPE</literal> (integer)</term>
     <listitem>
      <para>
       code numérique du type de données de la colonne
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect1>

 <sect1 id="ecpg-errors">
  <title>Gestion des erreurs</title>

  <para>
   Cette section décrit la gestion des conditions exceptionnelles
   et des avertissements dans un programme SQL embarqué. Il existe
   plusieurs fonctions non exclusives pour cela.
  </para>

  <sect2>
   <title>Configurer des rappels</title>

   <para>
    Une méthode simple de récupération des erreurs et des avertissements consiste à
    configurer une action spécifique à exécuter à chaque fois qu'une condition
    particulière survient. En général&nbsp;:
<programlisting>EXEC SQL WHENEVER <replaceable>condition</replaceable> <replaceable>action</replaceable>;
</programlisting>
   </para>

   <para>
    <replaceable>condition</replaceable> peut prendre une des valeurs
    suivantes&nbsp;:

    <variablelist>
     <varlistentry>
      <term><literal>SQLERROR</literal></term>
      <listitem>
       <para>
        L'action spécifiée est appelée lorsqu'une erreur survient
        pendant l'exécution d'une instruction SQL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLWARNING</literal></term>
      <listitem>
       <para>
        L'action spécifiée est appelée lorsqu'un avertissement
        survient pendant l'exécution d'une instruction SQL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT FOUND</literal></term>
      <listitem>
       <para>
        L'action spécifiée est appelée lorsqu'une instruction ne
        récupère ou n'affecte aucune ligne (cette condition n'est pas une
        erreur mais il peut être intéressant de la gérer de façon particulière).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <replaceable>action</replaceable> peut avoir une des valeurs
    suivantes&nbsp;:

    <variablelist>
     <varlistentry>
      <term><literal>CONTINUE</literal></term>
      <listitem>
       <para>
        Signifie effectivement que la condition est ignorée. Ceci est la
        valeur par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>GOTO <replaceable>label</replaceable></literal></term>
      <term><literal>GO TO <replaceable>label</replaceable></literal></term>
      <listitem>
       <para>
        Saute au label spécifié (en utilisant une instruction C
        <literal>goto</literal>).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLPRINT</literal></term>
      <listitem>
       <para>
        Affiche un message sur la sortie standard. Ceci est utile pour des
        programmes simples ou lors d'un prototypage. Les détails du message ne
        peuvent pas être configurés.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>STOP</literal></term>
      <listitem>
       <para>
        Appel de <literal>exit(1)</literal>, ce qui terminera le programme.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO BREAK</literal></term>
      <listitem>
       <para>
        Exécute l'instruction C <literal>break</literal>. Ceci devrait être
        utilisé uniquement dans des boucles ou dans des instructions
        <literal>switch</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CALL <replaceable>nom</replaceable>
        (<replaceable>args</replaceable>)</literal></term>
      <term><literal>DO <replaceable>nom</replaceable>
        (<replaceable>args</replaceable>)</literal></term>
      <listitem>
       <para>
        Appelle les fonctions C spécifiées avec les arguments spécifiés.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Le standard SQL ne définit que les actions
    <literal>CONTINUE</literal> et <literal>GOTO</literal> (et
    <literal>GO TO</literal>).
   </para>

   <para>
    Voici un exemple utilisable dans un programme simple. Il affiche un message
    lorsqu'un avertissement survient et termine le programme quand une erreur se
    produit.
<programlisting>EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
   </para>

   <para>
    L'instruction <literal>EXEC SQL WHENEVER</literal> est une directive du
    préprocesseur SQL, pas une instruction C. Les actions sur les erreurs
    et avertissements qu'elle définit s'appliquent à toutes les instructions
    SQL embarquées qui apparaissent avant l'endroit où le gestionnaire est défini,
    à moins qu'une action différente n'ait été définie pour la même condition
    entre le premier <literal>EXEC SQL WHENEVER</literal> et l'instruction SQL
    qui a engendré la condition, quelque soit le flux de contrôle du programme C.
    De ce fait, aucun des deux extraits de programme C qui suivent n'aura le
    comportement désiré.
<programlisting>/*
 * MAUVAIS
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}
</programlisting>

<programlisting>/*
 * MAUVAIS
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}
</programlisting>
   </para>
  </sect2>

  <sect2>
   <title>sqlca</title>

   <para>
    Pour une gestion plus puissante des erreurs, l'interface du SQL embarqué
    fournit une variable globale de nom <varname>sqlca</varname> qui a la
    structure suivante&nbsp;:
<programlisting>struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[70];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;
</programlisting>
    (Dans un programme multithreadé, chaque thread obtient automatiquement sa
    propre copie de <varname>sqlca</varname>. Ceci fonctionne de façon similaire
    à la gestion de la variable globale C standard <varname>errno</varname>.)
   </para>

   <para>
    <varname>sqlca</varname> couvre à la fois les avertissements et les
    erreurs. Si plusieurs avertissements ou erreurs surviennent lors de
    l'exécution d'une instruction, alors <varname>sqlca</varname> ne contiendra
    que les informations relatives à la dernière.
   </para>

   <para>
    Si aucune erreur ne survient dans la dernière instruction <acronym>SQL</acronym>,
    <literal>sqlca.sqlcode</literal> vaudra 0 et
    <literal>sqlca.sqlstate</literal> vaudra <literal>"00000"</literal>. Si un
    avertissement ou une erreur a eu lieu, alors
    <literal>sqlca.sqlcode</literal> sera négatif et
    <literal>sqlca.sqlstate</literal> sera différent de
    <literal>"00000"</literal>. Un <literal>sqlca.sqlcode</literal> positif
    indique une condition sans dommage, telle que <quote>aucune ligne renvoyée
    par la dernière requête</quote>. <literal>sqlcode</literal> et
    <literal>sqlstate</literal> sont deux schémas de code d'erreur
    différents&nbsp;; les détails apparaissent ci-dessous.
   </para>

   <para>
    Si la dernière instruction SQL a réussi, alors
    <literal>sqlca.sqlerrd[1]</literal> contient l'OID de la ligne traitée, si
    applicable, et <literal>sqlca.sqlerrd[2]</literal> contient le nombre de
    lignes traitées ou renvoyées, si applicable à la commande.
   </para>

   <para>
    Dans le cas d'une erreur ou d'un avertissement,
    <literal>sqlca.sqlerrm.sqlerrmc</literal> contiendra une chaîne décrivant
    l'erreur. Le champ <literal>sqlca.sqlerrm.sqlerrml</literal> contient la
    longueur du message d'erreur stocké dans
    <literal>sqlca.sqlerrm.sqlerrmc</literal> (le résultat de
    <function>strlen()</function>, sans réel intérêt pour un
    programmeur C). Notez que certains messages sont trop longs pour entrer
    dans le tableau <literal>sqlerrmc</literal> de taille fixe&nbsp;; ils seront
    tronqués.
   </para>

   <para>
    Dans le cas d'un avertissement,
    <literal>sqlca.sqlwarn[2]</literal> est positionné à <literal>W</literal>.
    (Dans tous les autres cas, il est positionné à quelque chose de différent de
    <literal>W</literal>.) Si <literal>sqlca.sqlwarn[1]</literal> est positionné
    à <literal>W</literal>, alors une valeur a été tronquée lors de son stockage
    dans une variable hôte. <literal>sqlca.sqlwarn[0]</literal> est
    positionné à <literal>W</literal> si un autre élément est positionné pour
    indiquer un avertissement.
   </para>

   <para>
    Les champs <structfield>sqlcaid</structfield>,
    <structfield>sqlcabc</structfield>,
    <structfield>sqlerrp</structfield>, et les éléments restant de
    <structfield>sqlerrd</structfield> et
    <structfield>sqlwarn</structfield> ne contiennent actuellement
    aucune information utile.
   </para>

   <para>
    La structure <varname>sqlca</varname> n'est pas définie dans le standard
    SQL mais elle est implémentée dans plusieurs autres systèmes de bases de données SQL.
    Leurs définitions sont similaires dans leur esprit, mais l'écriture d'applications
    portables nécessite une étude attentive des autres implémentations.
   </para>
  </sect2>

  <sect2>
   <title><literal>SQLSTATE</literal> contre <literal>SQLCODE</literal></title>

   <para>
    Les champs <literal>sqlca.sqlstate</literal> et
    <literal>sqlca.sqlcode</literal> sont deux schémas différents fournissant
    des codes d'erreur. Les deux sont dérivés du standard SQL mais
    <literal>SQLCODE</literal> est indiqué comme obsolète dans l'édition de
    SQL-92 du standard et a été supprimé dans les éditions ultérieures. Du coup,
    les nouvelles applications sont fortement encouragées à utiliser
    <literal>SQLSTATE</literal> dans les nouvelles applications.
   </para>

   <para>
    <literal>SQLSTATE</literal> est un tableau de cinq caractères. Ces cinq
    caractères contiennent des chiffres ou des lettres en majuscules
    représentant les codes de différentes conditions d'erreurs ou
    d'avertissements. <literal>SQLSTATE</literal> dispose d'un schéma
    hiérarchique&nbsp;: les deux premiers caractères indiquent la classe
    générale de la condition, les trois derniers caractères indiquent une
    sous-classe de la condition générale. Un état de succès est indiqué par le
    code <literal>00000</literal>. Les codes <literal>SQLSTATE</literal> sont
    pour la plupart définis dans le standard SQL. Le serveur
    <productname>PostgreSQL</productname> supporte nativement les codes
    d'erreurs <literal>SQLSTATE</literal>&nbsp;; du coup, un haut degré de
    cohérence peut être atteint en utilisant ce schéma de code d'erreur au
    travers de toutes vos applications. Pour plus d'informations, voir l'<xref
    linkend="errcodes-appendix"/>.
   </para>

   <para>
    <literal>SQLCODE</literal>, le schéma obsolète de codes d'erreurs, est un
    simple entier. Une valeur 0 indique un succès, une valeur positive
    indique un succès avec des informations supplémentaires, une valeur négative
    indique une erreur. Le standard SQL définit seulement la valeur positive
    +100, qui indique que la dernière commande n'a renvoyé ou modifié de ligne,
    et aucune valeur négative. Du coup, ce schéma n'est que faiblement portable
    et n'a pas d'affectation de code hiérarchique.
    Historiquement, le processeur de SQL embarqué pour
    <productname>PostgreSQL</productname> a affecté quelques valeurs
    <literal>SQLCODE</literal> spécifiques pour sa propre utilisation, qui sont listées
    ci-dessous avec leurs valeurs numériques et leurs noms symboliques. Il est important
    de garder à l'esprit qu'elles ne sont pas portables vers d'autres implémentations SQL. Pour
    simplifier le portage d'applications au schéma <literal>SQLSTATE</literal>,
    le code <literal>SQLSTATE</literal> correspondant est également affiché.
    Néanmoins, il n'y a pas de correspondance une-à-une ou une-à-plusieurs
    entre les deux schémas (en fait, c'est plutôt plusieurs-à-plusieurs).
    Il est préférable de consulter le schéma <literal>SQLSTATE</literal> global
    dans l'<xref linkend="errcodes-appendix"/> pour chaque cas.
   </para>

   <para>
    Voici les valeurs affectées à <literal>SQLCODE</literal>&nbsp;:

    <variablelist>
     <varlistentry>
      <term>-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)</term>
      <listitem>
       <para>
        Indique que la mémoire virtuelle est épuisée. (SQLSTATE
        YE001)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-200 (<symbol>ECPG_UNSUPPORTED</symbol>)</term>
     <listitem>
      <para>
       Indique que le préprocesseur a engendré quelque chose que la bibliothèque
       ne connaît pas. Il peut s'agir de l'exécution de versions incompatibles
       du préprocesseur et de la bibliothèque (SQLSTATE YE002).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       Ceci signifie que la commande spécifie plus de variables hôtes que n'en
       attend la commande (SQLSTATE 07001 ou 07002).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       Ceci signifie que la commande spécifie moins de variables hôtes
       que n'en attend la commande (SQLSTATE 07001 ou 07002).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)</term>
     <listitem>
      <para>
       Ceci signifie qu'une requête a retourné plusieurs lignes mais que
       l'instruction n'était préparée à ne stocker qu'une ligne de résultat (par
       exemple, parce que les variables spécifiées ne sont pas des tableaux)
       (SQLSTATE 21000).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-204 (<symbol>ECPG_INT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       La variable hôte est de type <type>int</type>, et la donnée de la base
       de données est d'un type différent et contient une valeur qui ne peut pas
       être interprétée comme un <type>int</type>. La bibliothèque utilise
       <function>strtol()</function> pour cette conversion (SQLSTATE
       42804).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-205 (<symbol>ECPG_UINT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       La variable hôte est de type <type>unsigned int</type>, et la donnée de la
       base de données est d'un type différent et contient une valeur qui ne
       peut pas être interprétée comme un <type>unsigned int</type>. La
       bibliothèque utilise <function>strtoul()</function> pour cette
       conversion (SQLSTATE 42804).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       La variable hôte est de type <type>float</type>, et la donnée de la
       base de données est d'un type différent et contient une valeur qui ne
       peut pas être interprétée comme un <type>float</type>. La
       bibliothèque utilise <function>strtod()</function> pour cette conversion
       (SQLSTATE 42804).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-207 (<symbol>ECPG_CONVERT_BOOL</symbol>)</term>
     <listitem>
      <para>
       Ceci signifie que la variable hôte est de type <type>bool</type> et que
       la donnée de la base de données n'est ni <literal>'t'</literal> ni
       <literal>'f'</literal> (SQLSTATE 42804).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-208 (<symbol>ECPG_EMPTY</symbol>)</term>
     <listitem>
      <para>
       L'instruction envoyée au serveur <productname>PostgreSQL</productname>
       était vide (ceci ne peut normalement pas survenir dans un programme SQL
       embarqué, cela peut donc indiquer une erreur interne)  (SQLSTATE
       YE002).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-209 (<symbol>ECPG_MISSING_INDICATOR</symbol>)</term>
     <listitem>
      <para>
       Une valeur NULL a été retournée et aucune variable d'indicateur nul n'a
       été fournie (SQLSTATE 22002).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-210 (<symbol>ECPG_NO_ARRAY</symbol>)</term>
     <listitem>
      <para>
       Une variable ordinaire a été utilisée à un endroit qui requiert un tableau
       (SQLSTATE 42804).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-211 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)</term>
     <listitem>
      <para>
       La base de données a retourné une variable ordinaire à un endroit qui
       requiert une valeur de tableau (SQLSTATE 42804).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-220 (<symbol>ECPG_NO_CONN</symbol>)</term>
     <listitem>
      <para>
       Le programme a tenté d'accéder à une connexion qui n'existe pas
       (SQLSTATE 08003).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-221 (<symbol>ECPG_NOT_CONN</symbol>)</term>
     <listitem>
      <para>
       Le programme a tenté d'accéder à une connexion qui existe mais n'est pas
       ouverte (ceci est une erreur interne) (SQLSTATE YE002).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-230 (<symbol>ECPG_INVALID_STMT</symbol>)</term>
     <listitem>
      <para>
       Une tentative d'utilisation d'une instruction qui n'a pas été préparée
       est survenue (SQLSTATE 26000).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)</term>
     <listitem>
      <para>
       Le descripteur spécifié n'a pas été trouvé. Une tentative d'utilisation
       d'une instruction qui n'a pas été préparée est survenue (SQLSTATE 33000).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)</term>
     <listitem>
      <para>
       L'index du descripteur spécifié est hors échelle (SQLSTATE
       07009).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)</term>
     <listitem>
      <para>
       Un élément invalide du descripteur a été demandé (ceci est une erreur
       interne) (SQLSTATE YE002).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)</term>
     <listitem>
      <para>
       Lors de l'exécution d'une instruction dynamique, la base de données a
       retourné une valeur numérique et la variable hôte n'était pas numérique
       (SQLSTATE 07006).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)</term>
     <listitem>
      <para>
       Lors de l'exécution d'une instruction dynamique, la base de données a
       retourné une valeur non numérique et la variable hôte était numérique
       (SQLSTATE 07006).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-400 (<symbol>ECPG_PGSQL</symbol>)</term>
     <listitem>
      <para>
       Une erreur a été causée par le serveur
       <productname>PostgreSQL</productname>. Le message contient le message
       d'erreur du serveur <productname>PostgreSQL</productname>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-401 (<symbol>ECPG_TRANS</symbol>)</term>
     <listitem>
      <para>
       Le serveur <productname>PostgreSQL</productname> a signalé que la transaction
       ne peut être commencée, validée ou annulée
       (SQLSTATE 08007).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-402 (<symbol>ECPG_CONNECT</symbol>)</term>
     <listitem>
      <para>
       La tentative de connexion à la base de données a échoué
       (SQLSTATE 08001).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>100 (<symbol>ECPG_NOT_FOUND</symbol>)</term>
     <listitem>
      <para>
       Ceci est une condition sans gravité indiquant que la dernière commande
       n'a récupéré ou traité aucune ligne, ou que la fin du curseur est atteinte
       (SQLSTATE 02000).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-preproc">
  <title>Directives du préprocesseur</title>

  <sect2>
   <title>Inclure des fichiers</title>

  <para>
   Pour inclure un fichier externe dans un programme SQL embarqué,
   il suffit d'utiliser&nbsp;:
<programlisting>EXEC SQL INCLUDE <replaceable>nomfichier</replaceable>;
</programlisting>
   Le préprocesseur du SQL embarqué cherchera un fichier nommé
   <literal><replaceable>nomfichier</replaceable>.h</literal>, le traitera et
   l'inclura dans la sortie C résultante. Du coup, les instructions C
   embarquées du fichier inclus sont gérées correctement.
  </para>

  <para>
   Il est à noter que ceci n'est <emphasis>pas</emphasis> la même chose que
<programlisting>#include &lt;<replaceable>nomfichier</replaceable>.h&gt;
</programlisting>
   parce que ce fichier ne sera pas sujet au pré-traitement des commandes SQL.
   Naturellement, la directive C <literal>#include</literal> peut toujours être
   utilisée pour inclure d'autres fichiers d'en-tête.
  </para>

  <note>
   <para>
    Le nom du fichier inclus est sensible à la casse, même si le reste de la
    commande <literal>EXEC SQL INCLUDE</literal> suit les règles habituelles de
    sensibilité à la casse.
   </para>
  </note>
  </sect2>

  <sect2>
   <title>The #define and #undef directives</title>
   <para>
    Similar to the directive <literal>#define</literal> that is known from C,
    embedded SQL has a similar concept:
<programlisting>
EXEC SQL DEFINE <replaceable>name</replaceable>;
EXEC SQL DEFINE <replaceable>name</replaceable> <replaceable>value</replaceable>;
</programlisting>
    So you can define a name:
<programlisting>
EXEC SQL DEFINE HAVE_FEATURE;
</programlisting>
    And you can also define constants:
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';
</programlisting>
    Use <literal>undef</literal> to remove a previous definition:
<programlisting>
EXEC SQL UNDEF MYNUMBER;
</programlisting>
   </para>

   <para>
    Of course you can continue to use the C versions <literal>#define</literal>
    and <literal>#undef</literal> in your embedded SQL program. The difference
    is where your defined values get evaluated. If you use <literal>EXEC SQL
    DEFINE</literal> then the ecpg preprocessor evaluates the defines and substitutes
    the values. For example if you write:
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;
</programlisting>
    then ecpg will already do the substitution and your C compiler will never
    see any name or identifier <literal>MYNUMBER</literal>. Note that you can not use
    <literal>#define</literal> for a constant that you are going to use in an
    embedded SQL query because in this case the embedded SQL precompiler is not
    able to see this declaration.
   </para>
  </sect2>

  <sect2>
   <title>ifdef, ifndef, else, elif and endif directives</title>
   <para>
   You can use the following directives to compile code sections conditionally:

   <variablelist>
    <varlistentry>
     <term><literal>EXEC SQL ifdef <replaceable>name</replaceable>;</literal></term>
     <listitem>
     <para>
      Checks a <replaceable>name</replaceable> and processes subsequent lines if
      <replaceable>name</replaceable> has been created with <literal>EXEC SQL define
      <replaceable>name</replaceable></literal>.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL ifndef <replaceable>name</replaceable>;</literal></term>
     <listitem>
     <para>
      Checks a <replaceable>name</replaceable> and processes subsequent lines if
      <replaceable>name</replaceable> has <emphasis>not</emphasis> been created with
      <literal>EXEC SQL define <replaceable>name</replaceable></literal>.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL else;</literal></term>
     <listitem>
     <para>
      Starts processing an alternative section to a section introduced by
      either <literal>EXEC SQL ifdef <replaceable>name</replaceable></literal> or
      <literal>EXEC SQL ifndef <replaceable>name</replaceable></literal>.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL elif <replaceable>name</replaceable>;</literal></term>
     <listitem>
     <para>
      Checks <replaceable>name</replaceable> and starts an alternative section if
      <replaceable>name</replaceable> has been created with <literal>EXEC SQL define
      <replaceable>name</replaceable></literal>.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL endif;</literal></term>
     <listitem>
     <para>
      Ends an alternative section.
     </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>

   <para>
    Example:
<programlisting>
   exec sql ifndef TZVAR;
   exec sql SET TIMEZONE TO 'GMT';
   exec sql elif TZNAME;
   exec sql SET TIMEZONE TO TZNAME;
   exec sql else;
   exec sql SET TIMEZONE TO TZVAR;
   exec sql endif;
</programlisting>
   </para>

  </sect2>
 </sect1>

 <sect1 id="ecpg-process">
  <title>Traiter les programmes comportant du SQL embarqué</title>

  <para>
   Après avoir vu comment former des programmes C incluant du SQL embarqué, il
   est tout aussi intéressant de savoir comment les compiler. Avant d'être compilé,
   le fichier est passé au travers du préprocesseur <acronym>C</acronym> pour le
   <acronym>SQL</acronym> embarqué, qui convertit les instructions
   <acronym>SQL</acronym> utilisées en appels de fonctions spéciales.
   Après compilation, le programme doit être lié avec une bibliothèque spéciale
   contenant les fonctions nécessaires. Ces fonctions récupèrent l'information
   provenant des arguments, exécutent la commande <acronym>SQL</acronym> en
   utilisant l'interface <application>libpq</application> et placent le résultat
   dans les arguments spécifiés pour la sortie.
  </para>

  <para>
   Le préprocesseur est appelé <filename>ecpg</filename> et est inclus dans une
   installation standard de <productname>PostgreSQL</productname>. Les programmes SQL embarqués
   sont nommés typiquement avec une extension <filename>.pgc</filename>. Un
   fichier programme nommé <filename>prog1.pgc</filename> peut être passé au
   préprocesseur par la simple commande
<programlisting>ecpg prog1.pgc
</programlisting>
   Ceci créera un fichier nommé <filename>prog1.c</filename>. Si les fichiers
   en entrée ne suivent pas le modèle de nommage suggéré, il est possible de
   spécifier explicitement le fichier de sortie en utilisant l'option <option>-o</option>.
  </para>

  <para>
   Le fichier traité par le préprocesseur peut être compilé normalement.
   Par exemple&nbsp;:
<programlisting>cc -c prog1.c
</programlisting>
   Les fichiers sources en C engendrés incluent les fichiers d'en-tête provenant
   de l'installation de <productname>PostgreSQL</productname>, donc si <productname>PostgreSQL</productname>
   a été installé à un emplacement qui n'est pas parcouru par défaut,
   il faudra ajouter une option comme
   <literal>-I/usr/local/pgsql/include</literal> sur la ligne de commande de la
   compilation.
  </para>

  <para>
   Pour lier un programme SQL embarqué, il faudra inclure la
   bibliothèque <filename>libecpg</filename> de cette façon&nbsp;:
<programlisting>cc -o monprog prog1.o prog2.o ... -lecpg
</programlisting>
   Là encore, il pourrait être nécessaire d'ajouter une option comme
   <literal>-L/usr/local/pgsql/lib</literal> sur la ligne de commande.
  </para>

  <para>
   Si le processus de construction d'un grand projet est géré par l'utilisation de
   <application>make</application>, il pourrait être plus agréable d'inclure la
   règle implicite suivante dans les fichiers makefile&nbsp;:
<programlisting>ECPG = ecpg

%.c: %.pgc
        $(ECPG) $&lt;
</programlisting>
  </para>

  <para>
   La syntaxe complète de la commande <command>ecpg</command> est détaillée dans
   <xref linkend="app-ecpg"/>.
  </para>

  <para>
   La bibliothèque <application>ecpg</application> est compatible avec les
   threads si elle a été compilée en utilisant l'option en ligne de commande
   <option>--enable-thread-safety</option> de <filename>configure</filename> (il
   pourrait s'avérer nécessaire de préciser d'autres options de threading sur la
   ligne de commande pour compiler le code client).
  </para>
 </sect1>

 <sect1 id="ecpg-library">
  <title>Fonctions de la bibliothèque</title>

  <para>
   La bibliothèque <filename>libecpg</filename> contient principalement des
   fonctions <quote>cachées</quote> utilisées pour implémenter les
   fonctionnalités exprimées par les commandes SQL embarquées. Mais il existe
   quelques fonctions qu'il peut être utile d'appeler directement. Il est à noter
   que ceci rendra le code non portable.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     <function>ECPGdebug(int <replaceable>on</replaceable>, FILE
     *<replaceable>flux</replaceable>)</function> active le débogage s'il est
     appelé avec une valeur différente de zéro pour le premier argument. Les traces
     de débogage sont envoyées sur le <replaceable>flux</replaceable>. Les
     traces contiennent toutes les instructions <acronym>SQL</acronym> avec
     toutes les variables en entrée et les résultats du serveur
     <productname>PostgreSQL</productname>. Ceci peut être très utile pour
     rechercher des erreurs dans les instructions <acronym>SQL</acronym>.
    </para>
    <note>
    <para>
    Sur Windows, si les bibliothèques <application>ecpg</application> et une application
    sont compilés avec des options différentes, cet appel de fonction arrêtera
    brutalement l'application car la représentation interne des pointeurs
    <literal>FILE</literal> diffère. Spécifiquement, les options
    multi-threaded/single-threaded, release/debug et static/dynamic devront
    être identiques à celles utilisées par la bibliothèque et par toutes les
    applications utilisant cette bibliothèque.
    </para>
    </note>
   </listitem>

   <listitem>
    <para>
     <function>ECPGstatus(int <replaceable>no_ligne</replaceable>,
     const char* <replaceable>nom_connexion</replaceable>)</function> retourne
     vrai si vous êtes connecté à une base de données, faux sinon.
     <replaceable>nom_connexion</replaceable> peut être <literal>NULL</literal> si une
     seule connexion est en cours d'utilisation.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="ecpg-develop">
  <title>Internes</title>

  <para>
   Cette section explique comment <application>ECPG</application> fonctionne en
   interne. Quelque fois, cette information peut être utile pour aider les
   utilisateurs à comprendre l'utilisation d'<application>ECPG</application>.
  </para>

   <para>
    Les quatre premières lignes écrites par <command>ecpg</command> sur la
    sortie sont des lignes figées. Deux sont des commentaires et deux sont des
    lignes d'inclusion de fichiers d'en-tête nécessaires pour l'interfaçage
    avec la bibliothèque. Ensuite, le préprocesseur lit le fichier et écrit
    la sortie. Normalement, il répète tout sur la sortie.
   </para>

   <para>
    Lorsqu'ecpg lit une instruction <command>EXEC SQL</command>, il
    intervient et la modifie. La commande commence avec <command>EXEC
    SQL</command> et se termine avec <command>;</command>. Tout ce qui se trouve
    entre est traité comme une instruction <acronym>SQL</acronym> et est analysé
    pour la substitution de variable.
   </para>

   <para>
    La substitution de variable intervient quand un symbole commence avec un
    caractère deux-points (<literal>:</literal>). La variable possédant ce nom
    est recherchée parmi toutes les variables précédemment déclarées dans une
    section <literal>EXEC SQL DECLARE</literal>.
   </para>

   <para>
    La fonction la plus importante de la bibliothèque est
    <function>ECPGdo</function>, qui prend en charge l'exécution de la plupart
    des commandes. Elle prend un nombre variable d'arguments. Ceci permet d'aller
    jusqu'à environ 50 arguments, et nous espérons que cela ne posera
    de problème sur aucune plateforme.
   </para>

   <para>
    Les arguments sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>Un numéro de ligne</term>
      <listitem>
       <para>
        C'est le numéro de ligne de la ligne originale&nbsp;; utilisé
        seulement dans les messages d'erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Une chaîne</term>
      <listitem>
       <para>
        C'est la commande <acronym>SQL</acronym> à exécuter. Elle est modifiée
        par les variables en entrée, c'est-à-dire les variables qui n'étaient
        pas connues au moment de la compilation mais qui doivent être précisées
        dans la commande. À l'emplacement des variables, la chaîne contient
        le signe <literal>?</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Variables en entrée</term>
      <listitem>
       <para>
        Chaque variable en entrée entraîne la création de dix arguments
        (voir ci-dessous).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><parameter>ECPGt_EOIT</parameter></term>
      <listitem>
       <para>
        Un <type>enum</type> indiquant qu'il n'y a plus de variables en entrée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Variables en sortie</term>
      <listitem>
       <para>
        Chaque variable en sortie entraîne la création de dix arguments
        (voir ci-dessous). La valeur des variables est fournie par la fonction.
       </para>
      </listitem>
     </varlistentry>

      <varlistentry>
       <term><parameter>ECPGt_EORT</parameter></term>
       <listitem>
       <para>
        Un <type>enum</type> indiquant qu'il n'y a plus de variables.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Pour chaque variable faisant partie de la commande <acronym>SQL</acronym>, la
    fonction récupère dix arguments&nbsp;:

    <orderedlist>
     <listitem>
      <para>
       Le type comme symbole spécial.
      </para>
     </listitem>

     <listitem>
      <para>
       Un pointeur vers la valeur ou un pointeur vers le pointeur.
      </para>
     </listitem>

     <listitem>
      <para>
       La taille de la variable dans le cas d'un type <type>char</type> ou
       <type>varchar</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       Le nombre d'éléments du tableau (pour les parcours de tableaux).
      </para>
     </listitem>

     <listitem>
      <para>
       Le décalage pour obtenir le prochain élément dans le tableau (pour les
       parcours de tableaux).
      </para>
     </listitem>

     <listitem>
      <para>
       Le type de variable indicateur comme un symbole spécial.
      </para>
     </listitem>

     <listitem>
      <para>
       Un pointeur vers la variable indicateur.
      </para>
     </listitem>

     <listitem>
      <para>
       0
      </para>
     </listitem>

     <listitem>
      <para>
       Le nombre d'éléments dans le tableau indicateur (pour les parcours
       de tableaux).
      </para>
     </listitem>

     <listitem>
      <para>
       Le décalage pour obtenir le prochain élément dans le tableau indicateur
       (pour les parcours de tableaux).
      </para>
     </listitem>
    </orderedlist>
   </para>

   <para>
    Il est à noter que toutes les commandes SQL ne sont pas traitées ainsi.
    Par exemple, une instruction d'ouverture de curseur comme
<programlisting>EXEC SQL OPEN <replaceable>curseur</replaceable>;
</programlisting>
    n'est pas copiée sur la sortie. À la place, la commande <command>DECLARE</command>
    de déclaration du curseur est utilisée à la position de la commande <command>OPEN</command>
    car, en fait, elle ouvre le curseur.
   </para>

   <para>
    Voici un exemple complet décrivant la sortie du préprocesseur d'un
    fichier <filename>foo.pgc</filename> (les détails pourraient varier avec
    chaque version particulière du préprocesseur)&nbsp;:
<programlisting>EXEC SQL BEGIN DECLARE SECTION;
int index;
int resultat;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :resultat FROM matable WHERE index = :index;
</programlisting>
    est traduit en&nbsp;:
<programlisting>/* Processed by ecpg (2.6.0) */
/* These two include files are added by the preprocessor */
#include &lt;ecpgtype.h&gt;;
#include &lt;ecpglib.h&gt;;

/* exec sql begin declare section */

#line 1 "foo.pgc"

 int index;
 int resultat;
/* exec sql end declare section */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM matable WHERE index = ?     ",
        ECPGt_int,&amp;(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&amp;(resultat),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
</programlisting>
    (l'indentation a été ajoutée ici pour des raisons de lisibilité et n'est pas
    réalisée par le préprocesseur)
   </para>
 </sect1>
</chapter>
