<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/geqo.sgml,v 1.7 2005/09/15 07:03:17 guillaume Exp $ -->
<!-- SAS : 20071220, PG83b4 -->

 <chapter id="geqo">
  <chapterinfo>
   <author>
    <firstname>Martin</firstname>
    <surname>Utesch</surname>
    <affiliation>
     <orgname>
      University of Mining and Technology
     </orgname>
     <orgdiv>
      Institute of Automatic Control
     </orgdiv>
     <address>
      <city>
       Freiberg
      </city>
      <country>
       Germany
      </country>
     </address>
    </affiliation>
   </author>
   <date>1997-10-02</date>
  </chapterinfo>

  <title id="geqo-title">Optimiseur génétique de requêtes
    (<foreignphrase>Genetic Query Optimizer</foreignphrase>)</title>

  <para>
   <note>
    <title>Auteur</title>
    <para>
     Écrit par Martin Utesch (<email>utesch@aut.tu-freiberg.de</email>)
     de l'Institut de Contrôle Automatique à l'Université des Mines et de 
     Technologie de Freiberg, Allemagne.
    </para>
   </note>
  </para>

  <sect1 id="geqo-intro">
   <title>Gérer les requêtes, un problème d'optimisation complexe</title>

   <para>
    De tous les opérateurs relationnels, le plus difficile à exécuter et à
    optimiser est la jointure (<firstterm>join</firstterm>). Le nombre de plans
    de requêtes possibles croît exponentiellement avec le nombre de jointures
    de la requête. Un effort supplémentaire d'optimisation est dû
    au support d'une variété de <firstterm>méthodes de jointure</firstterm>
    (boucles imbriquées, jointures de hachage, jointures de fusion...) pour
    exécuter des jointures individuelles et une diversité
    d'<firstterm>index</firstterm> (B-tree, hash, GiST et GIN...) pour accéder
    aux relations.
   </para>

   <para>
    L'optimiseur standard de requêtes pour <productname>PostgreSQL</productname>
    réalise une <firstterm>recherche quasi-exhaustive</firstterm> sur
    l'ensemble des stratégies alternatives. Cet algorithme,
    introduit à l'origine dans la base de données System R d'IBM, produit un ordre
    de jointure quasi-optimal mais peut occuper beaucoup de temps et de
    mémoire à mesure que le nombre de jointures d'une requête augmente.
    L'optimiseur ordinaire de requêtes de <productname>PostgreSQL</productname>
    devient donc inapproprié pour les requêtes qui joignent un grand nombre de tables.
   </para>

<!-- electrical power grid ? -->
   <para>
    L'Institut de Contrôle Automatique de l'Université des Mines et de 
    Technologie basé à Freiberg, Allemagne, a rencontré des difficultés
    lorsqu'il s'est agi d'utiliser <productname>PostgreSQL</productname>
    comme moteur d'un système d'aide à la décision reposant sur une base de
    connaissance utilisé pour la maintenance d'une grille
    de courant électrique. Le SGBD devait gérer des requêtes
    à nombreuses jointures pour la machine d'inférence de la base de
    connaissances. Le nombre de jointures de ces requêtes empêchait
    l'utilisation de l'optimiseur de requête standard.
   </para>

<!-- Supprimé dans la v83
   <para>
    Les difficultés en terme de performance pour l'exploration des plans de
    requêtes possibles ont créé la demande du développement d'une nouvelle
    technique d'optimisation.
   </para>
-->

   <para>
    La suite du document décrit le codage d'un <firstterm>algorithme
    génétique</firstterm> de résolution de l'ordonnancement des jointures
    qui soit efficace pour les requêtes à jointures nombreuses.
   </para>
  </sect1>

  <sect1 id="geqo-intro2">
   <title>Algorithmes génétiques</title>

<!-- fitness : ? Je doute qu'il s'agisse de forme physique :-/ 
     to fit : s'intégrer, entrer, s'encaster... -->
   <para>
    L'algorithme génétique (<acronym>GA</acronym>) est une méthode
    d'optimisation heuristique qui opère par recherches non déterministes,
    aléatoires. L'ensemble des solutions possibles au problème d'optimisation
    est considéré comme une <firstterm>population</firstterm>
    d'<firstterm>individus</firstterm>. Le degré d'adaptation d'un individu
    à son environnement est indiqué par son <firstterm>intégration</firstterm>
    (<foreignphrase>fitness</foreignphrase>).
   </para>

<!-- gêne ou gène ? -->
   <para>
    Les coordonnées d'un individu dans l'espace de recherche sont représentées
    par des <firstterm>chromosomes</firstterm>, en fait un ensemble de chaînes
    de caractères. Un <firstterm>gêne</firstterm> est une sous-section de
    chromosome qui code la valeur d'un paramètre simple en cours d'optimisation.
    Les codages habituels d'un gène sont
    <firstterm>binary</firstterm> ou <firstterm>integer</firstterm>.
   </para>

   <para>
    La simulation des opérations d'évolution
    (<firstterm>recombinaison</firstterm>, <firstterm>mutation</firstterm> et
    <firstterm>sélection</firstterm>) permet de trouver de nouvelles
    générations de points de recherche qui présentent une meilleure intégration
    moyenne que leurs ancêtres.
   </para>

   <para>
    Selon la <acronym>FAQ</acronym> de <systemitem
    class="resource">comp.ai.genetic</systemitem>, on ne peut pas réellement
    affirmer qu'un <acronym>GA</acronym> n'est pas purement une recherche
    aléatoire. Un <acronym>GA</acronym> utilise des processus stochastiques, mais
    le résultat est assurément non-aléatoire (il est mieux qu'aléatoire). 
   </para>

   <figure id="geqo-diagram">
    <title>Diagramme structuré d'un algorithme génétique</title>

    <informaltable frame="none">
     <tgroup cols="2">
      <tbody>
       <row>
        <entry>P(t)</entry>
        <entry>génération des ancêtres au temps t</entry>
       </row>

       <row>
        <entry>P''(t)</entry>
        <entry>génération des descendants au temps t</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

<literallayout class="monospaced">
+=========================================+
|&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Algorithme GA  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;|
+=========================================+
| INITIALISE t := 0                       |
+=========================================+
| INITIALISE P(t)                         |
+=========================================+
| évalue FITNESS de P(t)                  |
+=========================================+
| tant que pas CRITERE ARRET faire        |
|   +-------------------------------------+
|   | P'(t)  := RECOMBINAISON{P(t)}       |
|   +-------------------------------------+
|   | P''(t) := MUTATION{P'(t)}           |
|   +-------------------------------------+
|   | P(t+1) := SELECTION{P''(t) + P(t)}  |
|   +-------------------------------------+
|   | évalue FORMEPHYSIQUE de P''(t)      |
|   +-------------------------------------+
|   | t := t + 1                          |
+===+=====================================+
</literallayout>
   </figure>
  </sect1>

<!-- ICI -->
  <sect1 id="geqo-pg-intro">
   <title>Optimisation génétique des requêtes (<acronym>GEQO</acronym>) dans
     PostgreSQL</title>

   <para>
    Le module <acronym>GEQO</acronym> offre une approche du problème
    d'optimisation des requêtes similaire au problème du voyageur
    de commerce (<acronym>TSP</acronym>). L'approche du module
    <acronym>GEQO</acronym> concernant le problème d'optimisation de requêtes
    revient au problème bien connu du marchand de commerce
    (<acronym>TSP</acronym>). Les plans de requêtes possibles sont
    codés comme des chaînes d'entiers. Chaque chaîne représente l'ordre de
    jointure d'une relation de la requête à une autre. Par exemple, l'arbre de
    jointure
<literallayout class="monospaced">
   /\
  /\ 2
 /\ 3
4  1
</literallayout>
    est codé avec la chaîne d'entiers '4-1-3-2', ce qui signifie&nbsp;:
    première jointure entre les relations '4' et '1', puis '3' et enfin
    '2', avec 1, 2, 3, 4 les identifiants des relations pour l'optimiseur de
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    Les caractéristiques spécifiques de l'implémentation de
    <acronym>GEQO</acronym> dans <productname>PostgreSQL</productname>
    sont&nbsp;:

    <itemizedlist spacing="compact" mark="bullet">
     <listitem>
      <para>
       Utilisation d'un <firstterm>état d'équilibre</firstterm> du
       <acronym>GA</acronym> (remplacement des individus les moins performants
       d'une population, pas un remplacement d'une génération complète) qui
       permet une convergence rapide vers les plans de requêtes améliorés. C'est
       essentiel pour une gestion des requêtes sur un temps raisonnable&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       Utilisation d'un <firstterm>croisement de recombinaison de
       bord</firstterm> qui convient tout spécialement pour garder bas le
       nombre de pertes aux bords pour la solution du <acronym>TSP</acronym> en
       utilisant un <acronym>GA</acronym>;
      </para>
     </listitem>

     <listitem>
      <para>
       La mutation comme opérateur génétique est obsolète d'une telle façon
       qu'aucun mécanisme de réparation n'est nécessaire pour générer des tours
       <acronym>TSP</acronym> légaux.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Des parties du module <acronym>GEQO</acronym> sont adaptées de l'algorithme
    Genitor de D. Whitley.
   </para>

   <para>
    Le module <acronym>GEQO</acronym> permet à l'optimiseur de requêtes de
    <productname>PostgreSQL</productname> de supporter les requêtes disposant
    de jointures importantes de manière efficace via une recherche non
    exhaustive.
   </para>

  <sect2>
   <title>Generating Possible Plans with <acronym>GEQO</acronym></title>

   <para>
    The <acronym>GEQO</acronym> planning process uses the standard planner
    code to generate plans for scans of individual relations.  Then join
    plans are developed using the genetic approach.  As shown above, each
    candidate join plan is represented by a sequence in which to join
    the base relations.  In the initial stage, the <acronym>GEQO</acronym>
    code simply generates some possible join sequences at random.  For each
    join sequence considered, the standard planner code is invoked to
    estimate the cost of performing the query using that join sequence.
    (For each step of the join sequence, all three possible join strategies
    are considered; and all the initially-determined relation scan plans
    are available.  The estimated cost is the cheapest of these
    possibilities.)  Join sequences with lower estimated cost are considered
	<quote>more fit</quote> than those with higher cost.  The genetic algorithm
    discards the least fit candidates.  Then new candidates are generated
    by combining genes of more-fit candidates &mdash; that is, by using
    randomly-chosen portions of known low-cost join sequences to create
    new sequences for consideration.  This process is repeated until a
    preset number of join sequences have been considered; then the best
    one found at any time during the search is used to generate the finished
    plan.
   </para>

   <para>
    This process is inherently nondeterministic, because of the randomized
    choices made during both the initial population selection and subsequent
	<quote>mutation</quote> of the best candidates.  Hence different plans may
    be selected from one run to the next, resulting in varying run time
    and varying output row order.
   </para>

  </sect2>

  <sect2 id="geqo-future">
   <title>Tâches pour la future implémentation de <acronym>GEQO</acronym> pour
    <productname>PostgreSQL</productname></title>

     <para>
      Un gros travail est toujours nécessaire pour améliorer les paramètres de
      l'algorithme génétique.
      Dans le fichier
      <filename>src/backend/optimizer/geqo/geqo_main.c</filename>,
      pour les routines <function>gimme_pool_size</function> et
      <function>gimme_number_generations</function>, nous devons trouver un
      compromis dans les paramètres pour satisfaire deux demandes
      concurrentes&nbsp;:
      <itemizedlist spacing="compact">
       <listitem>
	<para>
	 Plan de requête optimum
	</para>
       </listitem>
       <listitem>
	<para>
	 Temps de calcul
	</para>
       </listitem>
      </itemizedlist>
     </para>

     <para>
      In the current implementation, the fitness of each candidate join
      sequence is estimated by running the standard planner's join selection
      and cost estimation code from scratch.  To the extent that different
      candidates use similar sub-sequences of joins, a great deal of work
      will be repeated.  This could be made significantly faster by retaining
      cost estimates for sub-joins.  The problem is to avoid expending
      unreasonable amounts of memory on retaining that state.
     </para>

     <para>
      À un niveau plus basique, il n'est pas clair que résoudre l'optimisation 
      d'une requête avec un algorithme GA conçu pour TSP soit appropriée. Dans
      le cas TSP, le coût associé avec toute sous-chaîne (tour partiel) est
      indépendant du reste du tour mais ceci n'est certainement pas vrai pour
      l'optimisation de requêtes. Du coup, la question reste posée quant au fait
      que la recombinaison soit la procédure de mutation la plus efficace.
     </para>

   </sect2>
  </sect1>

 <sect1 id="geqo-biblio">
  <title>Lectures supplémentaires</title>

  <para>
   Les ressources suivantes contiennent des informations supplémentaires sur
   les algorithmes génétiques&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      <ulink url="http://www.cs.bham.ac.uk/Mirrors/ftp.de.uu.net/EC/clife/www/location.htm">The
      Hitch-Hiker's Guide to Evolutionary Computation</ulink> (FAQ de <ulink
      url="news://comp.ai.genetic"></ulink>)
     </para>
    </listitem>
   
    <listitem>
     <para>
      <ulink url="http://www.red3d.com/cwr/evolve.html">Evolutionary
      Computation and its application to art and design</ulink>, par
      Craig Reynolds
     </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="elma04"/>
     </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="fong"/>
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>
</chapter>
