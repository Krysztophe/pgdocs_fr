<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="GIN">
<title>Index GIN</title>

   <indexterm>
    <primary>index</primary>
    <secondary>GIN</secondary>
   </indexterm>

<sect1 id="gin-intro">
 <title>Introduction</title>

<!-- posting list ? 
     liste postée me semble malheureux. Je mets "liste" en attendant mieux -->
 <para>
   <acronym>GIN</acronym> est l'acronyme de <foreignphrase>Generalized Inverted
   Index</foreignphrase> (ou index générique inverse). C'est une structure
   d'index stockant des ensembles de
   paires (clé, liste de lignes) où le terme <quote>liste de lignes</quote>
   est un ensemble de lignes dans lesquelles la clé est valable. Chaque valeur
   indexée peut contenir plusieurs clés, le même identifiant de ligne
   peut ainsi apparaître dans plusieurs listes.
 </para>

 <para>
   Il est généralisé dans le sens où un index <acronym>GIN</acronym> n'a pas
   à connaître l'opération qu'il accélère. À la place, il utilise
   des stratégies adaptées définies pour des types de données particuliers.
 </para>

 <para>
  Un des avantages de <acronym>GIN</acronym> est la possibilité qu'il offre que
  des types de données personnalisés et les méthodes d'accès appropriées soient
  développés par un expert du domaine du type de données, plutôt que par un
  expert en bases de données. L'utilisation de <acronym>GiST</acronym> offre le
  même avantage.
 </para>

  <para>
   L'implantation de <acronym>GIN</acronym> dans
   <productname>PostgreSQL</productname> est principalement l'oeuvre de
   Teodor Sigaev et Oleg Bartunov. Plus d'informations sur <acronym>GIN</acronym>
   sont disponibles sur leur <ulink
   url="http://www.sai.msu.su/~megera/wiki/Gin">site web</ulink>.
  </para>
</sect1>

<sect1 id="gin-extensibility">
 <title>Extensibilité</title>

 <para>
   L'interface <acronym>GIN</acronym> a un haut niveau d'abstraction. De ce
   fait, la personne qui code la méthode d'accès n'a besoin d'implanter que les
   sémantiques du type de données accédé. La couche 
   <acronym>GIN</acronym> prend en charge la gestion de la concurrence, des traces
   et des recherches dans la structure de l'arbre.
 </para>

 <para>
   Pour obtenir une méthode d'accès <acronym>GIN</acronym>
   fonctionnelle, il suffit d'implanter quatre (ou cinq) méthodes utilisateur. Celles-ci
   définissent le comportement des clés dans l'arbre
   et les relations entre clés, valeurs indexées et requêtes
   indexables. En résumé, <acronym>GIN</acronym> combine extensibilité,
   généralisation, ré-utilisation du code à une interface
   claire.
 </para>

 <para>
   Les quatre méthodes qu'une classe d'opérateur
   <acronym>GIN</acronym> doit fournir sont&nbsp;:
 </para>

 <variablelist>
    <varlistentry>
     <term>int compare(Datum a, Datum b)</term>
     <listitem>
      <para>
	   Compare les clés (et non les valeurs indexées&nbsp;!) et renvoie un entier
	   négatif, zéro ou un entier positif, qui indique si la
	   première clé est inférieure, égale à ou supérieure à la seconde.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Datum *extractValue(Datum inputValue, int32 *nkeys)</term>
     <listitem>
      <para>
	   Renvoie un tableau de clés à partir d'une valeur à indexer. Le nombre
	   de clés renvoyées doit être stocké dans <literal>*nkeys</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Datum *extractQuery(Datum query, int32 *nkeys,
		StrategyNumber n, bool **pmatch, Pointer **extra_data)</term>
     <listitem>
      <para>
       Renvoie un tableau de clés en fonction de la valeur à requêter&nbsp;; c'est-à-dire
       que <literal>query</literal> est la valeur du côté droit d'un opérateur
       indexable dont le côté gauche est la colonne indexée.
       <literal>n</literal> est le numéro de stratégie de l'opérateur dans la
       classe d'opérateur (voir <xref linkend="xindex-strategies"/>). Souvent,
       <function>extractQuery</function> doit consulter
       <literal>n</literal> pour déterminer le type de données de
       <literal>query</literal> et les valeurs de clés à extraire.
       Le nombre de clés renvoyées doit être stocké dans
       <literal>*nkeys</literal>.
       Si <literal>query</literal> ne contient aucune clé alors <function>extractQuery</function>
       devra retourner 0 ou -1 dans <literal>*nkeys</literal>, en fonction des sémantiques
       de l'opérateur. 0 signifie que toutes les valeurs correspondent à <literal>query</literal>
       et qu'un parcours d'index complet doit être effectué (mais voir
       <xref linkend="gin-limit"/> pour plus de détails).
       -1 signifie que rien ne peut correspondre à <literal>query</literal>, ce qui entraîne
       que le parcours d'index peut être totalement évité.
       <literal>pmatch</literal> est un paramètre de sortie à utiliser quand une correspondance
       partielle est permise. Pour l'utiliser, <function>extractQuery</function> doit allouer
       un tableau de booléens <literal>*nkeys</literal> et stocker son adresse dans
       <literal>*pmatch</literal>. Chaque élément du tableau devrait être positionné
       à TRUE si la clé correspondante a besoin d'une correspondance partielle, FALSE sinon.
       Si <literal>*pmatch</literal> est positionné à NULL alors GIN suppose qu'une
       mise en correspondance partielle n'est pas nécessaire. La variable est 
       initialisée à NULL avant l'appel, et peut donc être simplement ignorée
       par les classes d'opérateurs qui ne supportent pas les correspondances
       partielles.
       <literal>extra_data</literal> est un paramètre de sortie qui autorise
       <function>extractQuery</function> à passer des données supplémentaires aux
       méthodes <function>consistent</function> et <function>comparePartial</function>.
       Pour l'utiliser, <function>extractQuery</function> doit allouer un tableau
       de pointeurs <literal>*nkeys</literal> et stocker son adresse à
       <literal>*extra_data</literal>, puis stocker ce qu'il souhaite dans les
       pointeurs individuels. La variable est initialisée à NULL avant l'appel,
       afin que ce paramètre soit simplement ignoré par une classe d'opérateurs
       qui n'a pas besoin de données supplémentaires. Si <literal>*extra_data</literal>
       est positionné, le tableau dans son ensemble est passé à la méthode
       <function>consistent</function> method, et l'élément approprié à la méthode
       <function>comparePartial</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>bool consistent(bool check[], StrategyNumber n, Datum query,
                           int32 nkeys, Pointer extra_data[], bool *recheck)</term>
     <listitem>
      <para>
       Retourne TRUE si la valeur indexée satisfait à l'opérateur de requête
       avec le numéro de stratégie <literal>n</literal> (ou pourrait satisfaire,
       si l'indication recheck est retournée). Le tableau <literal>check</literal>
       a la longueur <literal>nkeys</literal>, qui est la même que le nombre
       de clés retournées précédemment par <function>extractQuery</function>
       pour ce datum, <literal>query</literal>.
       Chaque élément du tableau <literal>check</literal> est
       TRUE si la valeur indexée contient la clé correspondante de la requête,
       c'est-à-dire que si (check[i] == TRUE), la i-ème clé du tableau résultant
       d'<function>extractQuery</function> est présente dans la valeur indexée.
       Le datum <literal>query</literal> d'origine (pas le tableau de clés
       extrait&nbsp;!) est passé au cas où la méthode
       <function>consistent</function> a besoin de le consulter.
       <literal>extra_data</literal> est le tableau de données supplémentaires
       retourné par <function>extractQuery</function>, ou NULL si aucun.
       En cas de succès, <literal>*recheck</literal> devrait être positionné à
       TRUE si l'enregistrement du heap a besoin d'être revérifié vis-à-vis de
       l'opérateur de la requête, ou FALSE si le test sur l'index est exact.
      </para>
     </listitem>
    </varlistentry>

  </variablelist>


 <para>
  En option, une classe d'opérateurs pour <acronym>GIN</acronym> peut fournir une
  cinquième méthode&nbsp;:
 </para>

  <variablelist>

    <varlistentry>
     <term>int comparePartial(Datum partial_key, Datum key, StrategyNumber n,
                              Pointer extra_data)</term>
     <listitem>
      <para>
       Compare une requête de correspondance partielle à une clé d'index. Renvoie
       un entier dont le signe indique le résultat&nbsp;: inférieur à zéro
       signifie que la clé d'index ne correspond pas à la requête mais que le
       parcours d'index va continuer&nbsp;; zéro signifie que la clé d'index
       ne correspond pas à la requête&nbsp;; supérieur à zéro indique que le
       parcours d'index doit s'arrêter car il n'existe pas d'autres
       correspondances. Le numéro de stratégie <literal>n</literal> de l'opérateur
       qui a généré la requête de correspondance partielle est fourni au cas où
       sa sémantique est nécessaire pour déterminer la fin du parcours. De plus,
       <literal>extra_data</literal> est l'élément correspondant du tableau
       extra-data fait par <function>extractQuery</function>, ou NULL sinon.
      </para>
     </listitem>
    </varlistentry>

  </variablelist>

 <para>
  Pour supporter des requêtes à <quote>correspondance partielle</quote>,
  une classe d'opérateur doit fournir la méthode <function>comparePartial</function>,
  et sa méthode <function>extractQuery</function> doit positionner le
  paramètre <literal>pmatch</literal> quand une requête à correspondance
  partielle est rencontrée. Voir <xref linkend="gin-partial-match"/> pour les détails.
 </para>
</sect1>

<sect1 id="gin-implementation">
 <title>Implantation</title>

 <para>
  En interne, un index <acronym>GIN</acronym> contient un index B-tree construit
  sur des clés, où chaque clé est un élément de la valeur indexée (un membre d'un
  tableau par exemple) et où chaque ligne d'une page feuille est, soit un pointeur
  vers un B-tree de pointeurs heap (PT, posting tree), soit une liste de
  pointeurs heap (PL, posting list) si la liste est suffisamment petite.
 </para>

 <sect2 id="gin-fast-update">
  <title>Technique GIN de mise à jour rapide</title>

  <para>
   Mettre à jour un index <acronym>GIN</acronym> a tendance à être lent en raison
   de la nature intrinsèque des index inversés&nbsp;: insérer ou mettre à jour
   un enregistrement de la table peut causer de nombreuses insertions dans l'index
   (une pour chaque clé extraite de la valeur indexée). À partir de 
   <productname>PostgreSQL</productname> 8.4, <acronym>GIN</acronym> est capable
   de reporter à plus tard la plupart de ce travail en insérant les nouveaux
   enregistrements dans une liste temporaire et non triée des entrées en attente.
   Quand un vacuum est déclenché sur la table, ou si la liste en attente devient
   trop grosse (plus grande que <xref linkend="guc-work-mem"/>), les entrées
   sont déplacées vers la structure de données <acronym>GIN</acronym> principale
   en utilisant la même technique d'insertion de masse que durant la création
   de l'index. Ceci améliore grandement la vitesse de mise à jour de l'index
   <acronym>GIN</acronym>, même en prenant en compte le surcoût engendré au
   niveau du vacuum. De plus, ce surcoût peut être attribué à un processus
   d'arrière-plan plutôt qu'à la requête en avant-plan.
  </para>

  <para>
   Le principal défaut de cette approche est que les recherches doivent
   parcourir la liste d'entrées en attente en plus de l'index habituel, et
   que par conséquent une grande liste d'entrées en attente ralentira les
   recherches de façon significative. Un autre défaut est que, bien que la majorité
   des mises à jour seront rapides, une mise à jour qui rend la liste d'attente
   <quote>trop grande</quote> déclenchera un cycle de nettoyage immédiat et sera
   donc bien plus lente que les autres mises à jour. Une utilisation appropriée
   d'autovacuum peut minimiser ces deux problèmes.
  </para>

  <para>
   Si la cohérence des temps de réponse est plus importante que la vitesse de
   mise à jour, l'utilisation de liste d'entrées en attente peut être désactivée
   en désactivant le paramètre de stockage <literal>FASTUPDATE</literal> pour
   un index GIN. Voir <xref linkend="sql-createindex"
   endterm="sql-createindex-title"/> pour plus de détails.
  </para>
 </sect2>

 <sect2 id="gin-partial-match">
  <title>Algorithme de mise en correspondance partielle</title>

  <para>
   GIN peut supporter des requêtes de <quote>correspondances partielles</quote>,
   dans lesquelles la requête ne détermine pas une correspondance parfaite
   pour une ou plusieurs clés, mais que la correspondance tombe à une distance
   suffisamment faible des valeurs de clé (dans l'ordre de tri des clés déterminé
   par la méthode de support <function>compare</function>).
   La méthode <function>extractQuery</function>, au lieu de retourner une valeur
   de clé à mettre en correspondance de façon exacte, retourne une valeur de clé
   qui est la limite inférieure de la plage à rechercher, et retourne l'indicateur
   <literal>pmatch</literal> positionné à true. La plage de clé est alors parcourue
   en utilisant la méthode <function>comparePartial</function>.
   <function>comparePartial</function> doit retourner 0 pour une vraie correspondance,
   une valeur négative pour une non-correspondance qui est toujours dans la plage
   de recherche, et une valeur positive si la clé d'index est sortie de la plage
   qui pourrait correspondre.
  </para>
 </sect2>

</sect1>

<sect1 id="gin-tips">
<title>Conseils et astuces GIN</title>

 <variablelist>
  <varlistentry>
   <term>Création vs insertion</term>
   <listitem>
	<para>
	 L'insertion dans un index <acronym>GIN</acronym> peut être
	 lente du fait de la probabilité d'insertion de nombreuses clés pour
	 chaque valeur. C'est pourquoi, pour les chargements massifs dans une table, il
	 est conseillé de supprimer l'index GIN et de le re-créer après
	 le chargement.
	</para>

    <para>
     À partir de <productname>PostgreSQL</productname> 8.4, ce conseil est moins
     important puisqu'une technique de mise à jour retardée est utilisée (voir
     <xref linkend="gin-fast-update"/> pour plus de détails). Mais pour les
     très grosses mises à jour, il peut toujours être plus efficace de détruire
     et recréer l'index.
    </para>
   </listitem>
  </varlistentry>

<!-- to skimp ? -->
  <varlistentry>
   <term><xref linkend="guc-maintenance-work-mem"/></term>
   <listitem>
    <para>
     Le temps de construction d'un index <acronym>GIN</acronym> dépend
     grandement du paramètre <varname>maintenance_work_mem</varname>&nbsp;;
     il est contre-productif de limiter la mémoire de travail lors de la création d'un index.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><xref linkend="guc-work-mem"/></term>
   <listitem>
    <para>
     Durant une série d'insertions dans un index <acronym>GIN</acronym> existant
     qui a <literal>FASTUPDATE</literal> activé, le système nettoiera la liste
     d'entrées en attente dès qu'elle deviendra plus grosse que
     <varname>work_mem</varname>. Afin d'éviter des fluctuations mesurables
     de temps de réponse, il est souhaitable d'avoir un nettoyage de la liste
     d'attente en arrière-plan (c'est-à-dire via autovacuum). Les opérations
     de nettoyage en avant-plan peuvent être évitées en augmentant
     <varname>work_mem</varname> ou en rendant autovacuum plus aggressif.
     Toutefois, augmenter <varname>work_mem</varname> implique que si un nettoyage
     en avant-plan se produit, il prendra encore plus longtemps.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><xref linkend="guc-gin-fuzzy-search-limit"/></term>
   <listitem>
	<para>
	 La raison principale qui a poussé le développement des index
	 <acronym>GIN</acronym> a été la volonté de supporter les recherches
	 plein texte dans <productname>PostgreSQL</productname> et il arrive
	 fréquemment qu'une recherche renvoie un ensemble volumineux de résultats.
	 Cela arrive d'autant plus fréquemment que la requête contient des mots très
	 fréquents, auquel cas l'ensemble de résultats n'est même pas
	 utile. Puisque la lecture des lignes sur disque et leur tri prend beaucoup de temps,
	 cette situation est inacceptable en production. (La
	 recherche dans l'index est, elle, très rapide.)
	</para>
	<para>
	 Pour faciliter l'exécution contrôlée de telles requêtes,
	 <acronym>GIN</acronym> dispose d'une limite supérieure souple
	 configurable du nombre de lignes renvoyées, le paramètre de configuration
	 <varname>gin_fuzzy_search_limit</varname>. Par défaut, il est
	 positionné à 0 (c'est-à-dire sans limite). Si une limite différente de
	 0 est choisie, alors l'ensemble renvoyé est un sous-ensemble du résultat complet, choisi
	 aléatoirement.
	</para>
	<para>
	 <quote>Souple</quote> signifie
	 que le nombre réel de résultats renvoyés peut différer légèrement
	 de la limite indiquée, en fonction de la requête et de la qualité du
	 générateur de nombres aléatoires du système.
	</para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="gin-limit">
 <title>Limitations</title>

 <para>
  <acronym>GIN</acronym> ne supporte pas les parcours d'index complets.
  La raison est que <function>extractValue</function> est autorisée à retourner
  zéro clés, ce qui pourrait par exemple arriver avec une chaîne vide ou un tableau
  vide. Dans ce cas la valeur indexée ne sera pas présente dans l'index.
  Il est donc impossible à <acronym>GIN</acronym> de garantir que le parcours d'un
  index trouvera tous les enregistrements de la table.
 </para>

 <para>
  En raison de cette limitation, quand <function>extractQuery</function> retourne
  <literal>nkeys = 0</literal> pour indiquer que toutes les valeurs correspondent
  à la requête, <acronym>GIN</acronym> émettra une erreur. (Si il y a plusieurs
  opérateurs indexables liés par des ET logiques, cela n'arrivera que si
  ils retournent tous <literal>nkeys = 0</literal>.)
 </para>

 <para>
  Il est possible pour un opérateur de contourner cette restriction sur les
  scans d'index. Pour cela, <function>extractValue</function> doit conserver
  au moins une (éventuellement factice) clé pour toutes les valeurs indexées, et
  <function>extractQuery</function> doit convertir la recherche sans limitations
  en une requête de correspondance partielle qui parcourera l'ensemble de l'index.
  C'est inefficace, mais peut être nécessaire pour éviter des cas particuliers
  d'échec avec  certains opértateurs comme <literal>LIKE</literal> ou
  l'inclusion de sous-ensemble.
 </para>

 <para>
  <acronym>GIN</acronym> suppose que les opérateurs indexables sont stricts.
  Cela signifie que <function>extractValue</function> ne sera pas appelé du tout
  sur une valeur NULL (et que donc la valeur ne sera pas indexée), et que
  <function>extractQuery</function> ne sera pas appelée sur une valeur de comparaison
  NULL non plus (à la place, la requête est supposée ne pouvant pas correspondre).
 </para>

 <para>
  Une limitation qui peut être plus sérieuse est que <acronym>GIN</acronym> ne
  peut pas pas gérer des clés NULL&nbsp;&mdash; par exemple, un tableau
  contenant une valeur NULL ne peut pas être gérée, excepté en ignorant la
  valeur NULL.
 </para>
</sect1>

<sect1 id="gin-examples">
 <title>Exemples</title>

 <para>
  Les sources de <productname>PostgreSQL</productname> incluent
  des classes d'opérateur <acronym>GIN</acronym> pour <type>tsvector</type> et
  pour les tableaux unidimensionnels de tous
  les types internes. La recherche de préfixe dans <type>tsvector</type> est
  implémentée en utilisant les correspondances partielles de <acronym>GIN</acronym>.
  Les modules <filename>contrib</filename> suivants
  contiennent aussi des classes d'opérateurs <acronym>GIN</acronym>&nbsp;:
 </para>
 
 <variablelist>
  <varlistentry>
   <term>btree-gin</term>
   <listitem>
    <para>Fonctionnalité équivalente à B-Tree pour plusieurs types de données</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>hstore</term>
   <listitem>
    <para>Module pour le stockage des paires (clé, valeur)</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>intarray</term>
   <listitem>
    <para>Support amélioré pour int4[]</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>pg_trgm</term>
   <listitem>
    <para>Similarité de texte par correspondance de trigramme</para>
   </listitem>
  </varlistentry>
 </variablelist>
</sect1>

</chapter>
