<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="GIN">
<title>Index GIN</title>

   <indexterm>
    <primary>index</primary>
    <secondary>GIN</secondary>
   </indexterm>

<sect1 id="gin-intro">
 <title>Introduction</title>

<!-- posting list ? 
     liste postée me semble malheureux. Je mets "liste" en attendant mieux -->
 <para>
   <acronym>GIN</acronym> est l'acronyme de <foreignphrase>Generalized Inverted
   Index</foreignphrase> (ou index générique inverse). C'est une structure
   d'index stockant des ensembles de
   paires (clé, liste de lignes) où le terme <quote>liste de lignes</quote>
   est un ensemble de lignes dans lesquelles la clé est valable. Chaque valeur
   indexée peut contenir plusieurs clés, le même identifiant de ligne
   peut ainsi apparaître dans plusieurs listes.
 </para>

 <para>
   Il est généralisé dans le sens où un index <acronym>GIN</acronym> n'a pas
   à connaître l'opération qu'il accélère. À la place, il utilise
   des stratégies adaptées définies pour des types de données particuliers.
 </para>

 <para>
  Un des avantages de <acronym>GIN</acronym> est la possibilité qu'il offre que
  des types de données personnalisés et les méthodes d'accès appropriées soient
  développés par un expert du domaine du type de données, plutôt que par un
  expert en bases de données. L'utilisation de <acronym>GiST</acronym> offre le
  même avantage.
 </para>

  <para>
   L'implantation de <acronym>GIN</acronym> dans
   <productname>PostgreSQL</productname> est principalement l'oeuvre de
   Teodor Sigaev et Oleg Bartunov. Plus d'informations sur <acronym>GIN</acronym>
   sont disponibles sur leur <ulink
   url="http://www.sai.msu.su/~megera/oddmuse/index.cgi/Gin">site web</ulink>.
  </para>
</sect1>

<sect1 id="gin-extensibility">
 <title>Extensibilité</title>

 <para>
   L'interface <acronym>GIN</acronym> a un haut niveau d'abstraction. De ce
   fait, la personne qui code la méthode d'accès n'a besoin d'implanter que les
   sémantiques du type de données accédé. La couche 
   <acronym>GIN</acronym> prend en charge la gestion de la concurrence, des traces
   et des recherches dans la structure de l'arbre.
 </para>

 <para>
   Pour obtenir une méthode d'accès <acronym>GIN</acronym>
   fonctionnelle, il suffit d'implanter quatre méthodes utilisateur. Celles-ci
   définissent le comportement des clés dans l'arbre
   et les relations entre clés, valeurs indexées et requêtes
   indexables. En résumé, <acronym>GIN</acronym> combine extensibilité,
   généralisation, ré-utilisation du code à une interface
   claire.
 </para>

 <para>
   Les quatre méthodes qu'une classe d'opérateur d'index
   <acronym>GIN</acronym> doit fournir sont&nbsp;:
 </para>

 <variablelist>
    <varlistentry>
     <term>int compare(Datum a, Datum b)</term>
     <listitem>
      <para>
	   Compare les clés (et non les valeurs indexées&nbsp;!) et renvoie un entier
	   négatif, zéro ou un entier positif, qui indique si la
	   première clé est inférieure, égale à ou supérieure à la seconde.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Datum* extractValue(Datum inputValue, int32 *nkeys)</term>
     <listitem>
      <para>
	   Renvoie un tableau de clés à partir d'une valeur à indexer. Le nombre
	   de clés renvoyées doit être stocké dans <literal>*nkeys</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Datum* extractQuery(Datum query, int32 *nkeys,
		StrategyNumber n)</term>
     <listitem>
      <para>
       Renvoie un tableau de clés en fonction de la valeur à requêter&nbsp;; c'est-à-dire
       que <literal>query</literal> est la valeur du côté droit d'un opérateur
       indexable dont le côté gauche est la colonne indexée.
       <literal>n</literal> est le numéro de stratégie de l'opérateur dans la
       classe d'opérateur (voir <xref linkend="xindex-strategies"/>). Souvent,
       <function>extractQuery</function> doit consulter
       <literal>n</literal> pour déterminer le type de données de
       <literal>query</literal> et les valeurs de clés à extraire.
       Le nombre de clés renvoyées doit être stocké dans
       <literal>*nkeys</literal>.
       Si le nombre de clés est égal à zéro, alors <function>extractQuery</function>
       doit enregistrer 0 ou -1 dans <literal>*nkeys</literal>. 0 signifie que
       toutes les lignes répondent à la <literal>requête</literal> et qu'un
       parcours séquentiel doit être lancé. -1 signifie que rien ne satisfait
       la requête (<literal>query</literal>). Le choix de la valeur est basé
       sur la signification sémantique de l'opération correspondant au numéro de
       stratégie indiqué.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>bool consistent(bool check[], StrategyNumber n, Datum query)</term>
     <listitem>
      <para>
       Renvoie TRUE si la valeur indexée satisfait l'opérateur de la requête
       pour le numéro de stratégie <literal>n</literal> (ou peut satisfaire
       si l'opérateur est marqué RECHECK dans la classe d'opérateur).
       Le tableau <literal>check</literal> a la même longueur que le nombre de
       clés précédemment renvoyées par <function>extractQuery</function> pour
       cette requête. Chaque élément du tableau <literal>check</literal> est
       TRUE si la valeur indexée contient la clé correspondante de la requête,
       c'est-à-dire que si (check[i] == TRUE), la i-ème clé du tableau résultant
       d'<function>extractQuery</function> est présente dans la valeur indexée.
       Le datum <literal>query</literal> d'origine (pas le tableau de clés
       extrait&nbsp;!) est passé au cas où la méthode
       <function>consistent</function> a besoin de le consulter.
      </para>
     </listitem>
    </varlistentry>

  </variablelist>

</sect1>

<sect1 id="gin-implementation">
 <title>Implantation</title>

 <para>
  En interne, un index <acronym>GIN</acronym> contient un index B-tree construit
  sur des clés, où chaque clé est un élément de la valeur indexée (un membre d'un
  tableau par exemple) et où chaque ligne d'une page feuille est, soit un pointeur
  vers un B-tree de pointeurs heap (PT, posting tree), soit une liste de
  pointeurs heap (PL, posting list) si la liste est suffisamment petite.
 </para>

</sect1>

<sect1 id="gin-tips">
<title>Conseils et astuces GIN</title>

 <variablelist>
  <varlistentry>
   <term>Création vs insertion</term>
   <listitem>
	<para>
	 Dans la plupart des cas, l'insertion dans un index <acronym>GIN</acronym>
	 est lente du fait de la probabilité d'insertion de nombreuses clés pour
	 chaque valeur. C'est pourquoi, pour les chargements massifs dans une table, il
	 est conseillé de supprimer l'index GIN et de le re-créer après
	 le chargement.
	</para>
   </listitem>
  </varlistentry>

<!-- to skimp ? -->
  <varlistentry>
   <term><xref linkend="guc-maintenance-work-mem"/></term>
   <listitem>
    <para>
     Le temps de construction d'un index <acronym>GIN</acronym> dépend
     grandement du paramètre <varname>maintenance_work_mem</varname>&nbsp;;
     il est contre-productif de limiter la mémoire de travail lors de la création d'un index.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><xref linkend="guc-gin-fuzzy-search-limit"/></term>
   <listitem>
	<para>
	 La raison principale qui a poussé le développement des index
	 <acronym>GIN</acronym> a été la volonté de supporter les recherches
	 plein-texte dans <productname>PostgreSQL</productname> et il arrive
	 fréquemment qu'une recherche renvoie un ensemble volumineux de résultats.
	 Cela arrive d'autant plus fréquemment que la requête contient des mots très
	 fréquents, auquel cas l'ensemble de résultats n'est même pas
	 utile. Puisque la lecture des lignes sur disque et leur tri prend beaucoup de temps,
	 cette situation est inacceptable en production. (La
	 recherche dans l'index est, elle, très rapide.)
	</para>
	<para>
	 Pour faciliter l'exécution contrôlée de telles requêtes,
	 <acronym>GIN</acronym> dispose d'une limite supérieure souple
	 configurable du nombre de lignes renvoyées, le paramètre de configuration
	 <varname>gin_fuzzy_search_limit</varname>. Par défaut, il est
	 positionné à 0 (c'est-à-dire sans limite). Si une limite différente de
	 0 est choisie, alors l'ensemble renvoyé est un sous-ensemble du résultat complet, choisi
	 aléatoirement.
	</para>
	<para>
	 <quote>Souple</quote> signifie
	 que le nombre réel de résultats renvoyés peut différer légèrement
	 de la limite indiquée, en fonction de la requête et de la qualité du
	 générateur de nombres aléatoires du système.
	</para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="gin-limit">
 <title>Limitations</title>

 <para>
  <acronym>GIN</acronym> ne supporte pas les parcours d'index complets&nbsp;:
  comme il y a souvent de nombreuses clés par valeur, chaque pointeur de pile
  serait renvoyé plusieurs fois, or il n'existe pas de moyen simple d'empêcher
  cela.
 </para>

 <para>
  Quand <function>extractQuery</function> ne renvoie aucune clé,
  <acronym>GIN</acronym> émet une erreur. En fonction de l'opérateur, une requête
  vide peut correspondre à toutes, quelques, ou aucune des valeurs indexées (par
  exemple, tout tableau contient le tableau vide mais ne recouvre pas le
  tableau vide). <acronym>GIN</acronym> ne peut alors pas déterminer la bonne
  réponse, pas plus qu'il ne peut fournir un résultat de parcours d'index
  complet en déterminant la justesse de cette opération.
 </para>

 <para>
  Qu'<function>extractValue</function> ne retourne aucune clé n'est pas une
  erreur, mais dans ce cas, la valeur indexée n'est pas représentée dans l'index. C'est une
  autre raison pour laquelle le parcours d'index complet est inutile &mdash;
  il manquerait ce type de lignes.
 </para>

 <para>
  <acronym>GIN</acronym> ne recherche les clés que par égalité. Cela doit être
  amélioré.
 </para>
</sect1>

<sect1 id="gin-examples">
 <title>Exemples</title>

 <para>
  Les sources de <productname>PostgreSQL</productname> incluent
  des classes d'opérateur <acronym>GIN</acronym> pour <type>tsvector</type> et
  pour les tableaux unidimensionnel de tous
  les types internes. Les modules <filename>contrib</filename> suivants
  contiennent aussi des classes d'opérateurs <acronym>GIN</acronym>&nbsp;:
 </para>
 
 <variablelist>
  <varlistentry>
   <term>hstore</term>
   <listitem>
    <para>Module pour le stockage des paires (clé, valeur)</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>intarray</term>
   <listitem>
    <para>Support amélioré pour int4[]</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>pg_trgm</term>
   <listitem>
    <para>Similarité de texte par correspondance de trigramme</para>
   </listitem>
  </varlistentry>
 </variablelist>
</sect1>

</chapter>
