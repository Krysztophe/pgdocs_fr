<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="gist">
<title>Index GiST</title>

   <indexterm>
    <primary>index</primary>
    <secondary>GiST</secondary>
   </indexterm>

<sect1 id="gist-intro">
 <title>Introduction</title>

 <para>
   <acronym>GiST</acronym> est un acronyme de <foreignphrase>Generalized
   Search Tree</foreignphrase>, c'est-à-dire arbre de recherche généralisé.
   C'est une méthode d'accès balancée à structure de type arbre,
   qui agit comme un modèle de base dans lequel il est possible d'implanter
   des schémas d'indexage arbitraires. B-trees, R-trees et de nombreux autres
   schémas d'indexage peuvent être implantés en <acronym>GiST</acronym>.
 </para>

 <para>
  <acronym>GiST</acronym> a pour avantage d'autoriser le développement
  de types de données personnalisés avec les méthodes d'accès appropriées, par
  un expert en types de données, plutôt que par un expert en
  bases de données.
 </para>

  <para>
   Quelques informations disponibles ici sont dérivées du <ulink
   url="http://gist.cs.berkeley.edu/">site web</ulink> du projet d'indexage
   GiST de l'université de Californie à Berkeley et de la <ulink
    url="http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz">thèse
   de Marcel Kornacker, 
   Méthodes d'accès pour les systèmes de bases de données de la prochaine
   génération</ulink>. L'implantation <acronym>GiST</acronym> de
   <productname>PostgreSQL</productname> est principalement maintenu
   par Teodor Sigaev et Oleg Bartunov. Leur <ulink
   url="http://www.sai.msu.su/~megera/postgres/gist/">site web</ulink> fournit
   de plus amples informations.
  </para>

</sect1>

<sect1 id="gist-extensibility">
 <title>Extensibilité</title>

 <para>
  L'implantation d'une nouvelle méthode d'accès à un index
  a toujours été un travail complexe. Il est, en effet, nécessaire de comprendre le
  fonctionnement interne de la base de données, tel que le gestionnaire de
  verrous ou le WAL.
 </para>
 <para>
  L'interface <acronym>GiST</acronym> dispose d'un haut niveau
  d'abstraction, ce qui autorise le codeur de la méthode d'accès à
  ne coder que la sémantique du type de données accédé. La
  couche <acronym>GiST</acronym> se charge elle-même de la gestion des accès concurrents,
  des traces et de la recherche dans la structure en arbre.
 </para>
 
 <para>
   Cette extensibilité n'est pas comparable à celle des
   autres arbres de recherche standard en termes de données gérées. Par
   exemple, <productname>PostgreSQL</productname> supporte les B-trees et les
   index de hachage extensibles. Cela signifie qu'il est possible d'utiliser
   <productname>PostgreSQL</productname> pour construire un B-tree ou un hachage
   sur tout type de données. Mais, les B-trees ne supportent
   que les prédicats d'échelle (<literal>&lt;</literal>,
   <literal>=</literal>, <literal>&gt;</literal>), les index de hachage
   que les requêtes d'égalité.
 </para>
 
 <para>
   Donc, lors de l'indexation d'une collection d'images, par exemple, avec un B-tree
   <productname>PostgreSQL</productname>, seules peuvent être lancées des requêtes de type  
   <quote>est-ce que imagex est égale à imagey</quote>,
   <quote>est-ce que imagex est plus petite que imagey</quote> et <quote>est-ce
   que imagex est plus grande que imagey</quote>. En fonction de la définition
   donnée à <quote>égale à</quote>, <quote>inférieure à</quote> ou
   <quote>supérieure à</quote>, cela peut avoir une utilité.
   Néanmoins, l'utilisation d'un index basé sur <acronym>GiST</acronym> permet
   de créer de nombreuses possibilités de poser des questions spécifiques au domaine,
   telles que <quote>trouver toutes les images de chevaux</quote> ou
   <quote>trouver toutes les images sur-exposées</quote>.
 </para>

 <para>
   Pour obtenir une méthode d'accès
   <acronym>GiST</acronym> fonctionnelle, il suffit de coder sept méthodes
   utilisateur définissant le comportement des clés dans
   l'arbre. Ces méthodes doivent être suffisamment élaborées
   pour supporter des requêtes avancées, mais pour toutes les requêtes standard
   (B-trees, R-trees, etc.) elles sont relativement simples. En bref,
   <acronym>GiST</acronym> combine extensibilité, généralité, 
   ré-utilisation de code et interface claire.
  </para>

</sect1>

<sect1 id="gist-implementation">
 <title>Implantation</title>
 
 <para>
   Une classe d'opérateur d'index <acronym>GiST</acronym> doit fournir sept
   méthodes. Correctness of the index is ensured
   by proper implementation of the <function>same</function>, <function>consistent</function>
   and <function>union</function> methods, while efficiency (size and speed) of the
   index will depend on the <function>penalty</function> and <function>picksplit</function>
   methods.
   The remaining two methods are <function>compress</function> and
   <function>decompress</function>, which allow an index to have internal tree data of
   a different type than the data it indexes. The leaves are to be of the
   indexed data type, while the other tree nodes can be of any C struct (but
   you still have to follow <productname>PostgreSQL</productname> datatype rules here,
   see about <literal>varlena</literal> for variable sized data). If the tree's
   internal data type exists at the SQL level, the <literal>STORAGE</literal> option
   of the <command>CREATE OPERATOR CLASS</command> command can be used.

 </para>

 <variablelist>
    <varlistentry>
     <term><function>consistent</function></term>
     <listitem>
      <para>
       Given an index entry <literal>p</literal> and a query value <literal>q</literal>,
       this function determines whether the index entry is
       <quote>consistent</quote> with the query; that is, could the predicate
       <quote><replaceable>indexed_column</replaceable>
       <replaceable>indexable_operator</replaceable> <literal>q</literal></quote> be true for
       any row represented by the index entry?  For a leaf index entry this is
       equivalent to testing the indexable condition, while for an internal
       tree node this determines whether it is necessary to scan the subtree
       of the index represented by the tree node.  When the result is
       <literal>true</literal>, a <literal>recheck</literal> flag must also be returned.
       This indicates whether the predicate is certainly true or only possibly
       true.  If <literal>recheck</literal> = <literal>false</literal> then the index has
       tested the predicate condition exactly, whereas if <literal>recheck</literal>
       = <literal>true</literal> the row is only a candidate match.  In that case the
       system will automatically evaluate the
       <replaceable>indexable_operator</replaceable> against the actual row value to see
       if it is really a match.  This convention allows
       <acronym>GiST</acronym> to support both lossless and lossy index
       structures.
      </para>

      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
Datum       my_consistent(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_consistent);

Datum
my_consistent(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    bool       *recheck = (bool *) PG_GETARG_POINTER(4);
    data_type  *key = DatumGetDataType(entry-&gt;key);
    bool        retval;

    /*
     * determine return value as a function of strategy, key and query.
     *
     * Use GIST_LEAF(entry) to know where you're called in the index tree,
     * which comes handy when supporting the = operator for example (you could
     * check for non empty union() in non-leaf nodes and equality in leaf
     * nodes).
     */

    *recheck = true;        /* or false if check is exact */

    PG_RETURN_BOOL(retval);
}
</programlisting>

       Here, <varname>key</varname> is an element in the index and <varname>query</varname>
       the value being looked up in the index. The <literal>StrategyNumber</literal>
       parameter indicates which operator of your operator class is being
       applied &mdash; it matches one of the operator numbers in the
       <command>CREATE OPERATOR CLASS</command> command.  Depending on what operators
       you have included in the class, the data type of <varname>query</varname> could
       vary with the operator, but the above skeleton assumes it doesn't.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>union</function></term>
     <listitem>
      <para>
       This method consolidates information in the tree.  Given a set of
       entries, this function generates a new index entry that represents
       all the given entries.
      </para>

      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_union(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
Datum       my_union(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_union);

Datum
my_union(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GISTENTRY  *ent = entryvec-&gt;vector;
    data_type  *out,
               *tmp,
               *old;
    int         numranges,
                i = 0;

    numranges = entryvec-&gt;n;
    tmp = DatumGetDataType(ent[0].key);
    out = tmp;

    if (numranges == 1)
    {
        out = data_type_deep_copy(tmp);

        PG_RETURN_DATA_TYPE_P(out);
    }

    for (i = 1; i &lt; numranges; i++)
    {
        old = out;
        tmp = DatumGetDataType(ent[i].key);
        out = my_union_implementation(out, tmp);
    }

    PG_RETURN_DATA_TYPE_P(out);
}
</programlisting>
      </para>

      <para>
        As you can see, in this skeleton we're dealing with a data type
        where <literal>union(X, Y, Z) = union(union(X, Y), Z)</literal>. It's easy
        enough to support data types where this is not the case, by
        implementing the proper union algorithm in this
        <acronym>GiST</acronym> support method.
      </para>

      <para>
        The <function>union</function> implementation function should return a
        pointer to newly <function>palloc()</function>ed memory. You can't just
        return whatever the input is.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>compress</function></term>
     <listitem>
      <para>
       Convertit l'élément de données dans un format compatible avec
       le stockage physique dans une page d'index.
      </para>

      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_compress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
Datum       my_compress(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *retval;

    if (entry-&gt;leafkey)
    {
        /* replace entry-&gt;key with a compressed version */
        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));

        /* fill *compressed_data from entry-&gt;key ... */

        retval = palloc(sizeof(GISTENTRY));
        gistentryinit(*retval, PointerGetDatum(compressed_data),
                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
    }
    else
    {
        /* typically we needn't do anything with non-leaf entries */
        retval = entry;
    }

    PG_RETURN_POINTER(retval);
}
</programlisting>
      </para>

      <para>
       You have to adapt <replaceable>compressed_data_type</replaceable> to the specific
       type you're converting to in order to compress your leaf nodes, of
       course.
      </para>

      <para>
        Depending on your needs, you could also need to care about
        compressing <literal>NULL</literal> values in there, storing for example
        <literal>(Datum) 0</literal> like <literal>gist_circle_compress</literal> does.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>decompress</function></term>
     <listitem>
      <para>
       L'inverse de la fonction <function>compress</function>. Convertit la
       représentation de l'élément de donnée en un format manipulable par la base
       de données.
      </para>

      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_decompress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
Datum       my_decompress(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_decompress);

Datum
my_decompress(PG_FUNCTION_ARGS)
{
    PG_RETURN_POINTER(PG_GETARG_POINTER(0));
}
</programlisting>

        The above skeleton is suitable for the case where no decompression
        is needed.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>penalty</function></term>
     <listitem>
      <para>
       Renvoie une valeur indiquant le <quote>coût</quote> d'insertion
       d'une nouvelle entrée dans une branche particulière de l'arbre. Les
       éléments seront insérés dans l'ordre des pénalités moindres
       (<function>penalty</function>) de l'arbre.
      </para>

      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;  -- in some cases penalty functions need not be strict
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
Datum       my_penalty(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_penalty);

Datum
my_penalty(PG_FUNCTION_ARGS)
{
    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);
    float      *penalty = (float *) PG_GETARG_POINTER(2);
    data_type  *orig = DatumGetDataType(origentry-&gt;key);
    data_type  *new = DatumGetDataType(newentry-&gt;key);

    *penalty = my_penalty_implementation(orig, new);
    PG_RETURN_POINTER(penalty);
}
</programlisting>
      </para>

      <para>
        The <function>penalty</function> function is crucial to good performance of
        the index. It'll get used at insertion time to determine which branch
        to follow when choosing where to add the new entry in the tree. At
        query time, the more balanced the index, the quicker the lookup.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>picksplit</function></term>
     <listitem>
      <para>
       When an index page split is necessary, this function decides which
       entries on the page are to stay on the old page, and which are to move
       to the new page.
      </para>

      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
Datum       my_picksplit(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_picksplit);

Datum
my_picksplit(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    OffsetNumber maxoff = entryvec-&gt;n - 1;
    GISTENTRY  *ent = entryvec-&gt;vector;
    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
    int         i,
                nbytes;
    OffsetNumber *left,
               *right;
    data_type  *tmp_union;
    data_type  *unionL;
    data_type  *unionR;
    GISTENTRY **raw_entryvec;

    maxoff = entryvec-&gt;n - 1;
    nbytes = (maxoff + 1) * sizeof(OffsetNumber);

    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);
    left = v-&gt;spl_left;
    v-&gt;spl_nleft = 0;

    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);
    right = v-&gt;spl_right;
    v-&gt;spl_nright = 0;

    unionL = NULL;
    unionR = NULL;

    /* Initialize the raw entry vector. */
    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));
    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);

    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
    {
        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;

        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);
        Assert(tmp_union != NULL);

        /*
         * Choose where to put the index entries and update unionL and unionR
         * accordingly. Append the entries to either v_spl_left or
         * v_spl_right, and care about the counters.
         */

        if (my_choice_is_left(unionL, curl, unionR, curr))
        {
            if (unionL == NULL)
                unionL = tmp_union;
            else
                unionL = my_union_implementation(unionL, tmp_union);

            *left = real_index;
            ++left;
            ++(v-&gt;spl_nleft);
        }
        else
        {
            /*
             * Same on the right
             */
        }
    }

    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);
    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);
    PG_RETURN_POINTER(v);
}
</programlisting>
      </para>

      <para>
        Like <function>penalty</function>, the <function>picksplit</function> function
        is crucial to good performance of the index.  Designing suitable
        <function>penalty</function> and <function>picksplit</function> implementations
        is where the challenge of implementing well-performing
        <acronym>GiST</acronym> indexes lies.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>same</function></term>
     <listitem>
      <para>
       Returns true if two index entries are identical, false otherwise.
      </para>

      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_same(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
Datum       my_same(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_same);

Datum
my_same(PG_FUNCTION_ARGS)
{
    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);
    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);
    bool       *result = (bool *) PG_GETARG_POINTER(2);

    *result = my_eq(v1, v2);
    PG_RETURN_POINTER(result);
}
</programlisting>

        For historical reasons, the <function>same</function> function doesn't
        just return a boolean result; instead it has to store the flag
        at the location indicated by the third argument.
      </para>
     </listitem>
    </varlistentry>

  </variablelist>

</sect1>

<sect1 id="gist-examples">
 <title>Exemples</title>

 <para>
  La distribution source de <productname>PostgreSQL</productname> inclut
  plusieurs exemples de méthodes d'indexation implantées selon
  <acronym>GiST</acronym>. Le système principal fournit des fonctionnalités
  de recherche plein texte (indexation des <type>tsvector</type> et
  <type>tsquery</type>) ainsi que des fonctionnalités équivalentes aux R-Tree
  pour certains types de données géométriques
  (voir <filename>src/backend/access/gist/gistproc.c</filename>). Les modules
  <filename>contrib</filename> suivants contiennent aussi des classes d'opérateur
  <acronym>GiST</acronym>&nbsp;:
 </para>
 
 <variablelist>
  <varlistentry>
   <term>btree_gist</term>
   <listitem>
    <para>Fonctionnalités équivalentes aux B-Tree pour plusieurs types de
    données</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>cube</term>
   <listitem>
    <para>Indexation de cubes multi-dimensionnels</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>hstore</term>
   <listitem>
    <para>Module pour le stockage des paires (clé, valeur)</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>intarray</term>
   <listitem>
    <para>RD-Tree pour tableaux uni-dimensionnels de valeurs int4</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>ltree</term>
   <listitem>
    <para>Indexation des structures de type arbre</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>pg_trgm</term>
   <listitem>
    <para>Similarité textuelle par correspondance de trigrammes</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>seg</term>
   <listitem>
    <para>Indexation pour les <quote>nombres
     flottants</quote></para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="gist-recovery">
 <title>Récupération après un arrêt brutal</title>

 <para>
  Il est généralement suffisant de rejouer les traces WAL pour restaurer l'intégrité d'un
  index GiST après un arrêt brutal de la base de données. Néanmoins, il existe
  quelques cas particuliers pour lesquels l'état de l'index n'est pas
  entièrement reconstruit. L'index reste fonctionnellement correct mais
  les performances peuvent se trouver dégradées. Lorsque cela
  arrive, l'index peut être réparé par <command>VACUUM</command> de sa table, ou
  par reconstruction avec <command>REINDEX</command>. Dans certains cas, un simple
  <command>VACUUM</command> ne suffit pas et un <command>VACUUM FULL</command>
  ou un <command>REINDEX</command> est nécessaire. Ce besoin est indiqué par
  la survenue d'un tel message&nbsp;:
<programlisting>LOG:  index NNN/NNN/NNN needs VACUUM or REINDEX to finish crash recovery
</programlisting>
  ou le message suivant lors d'insertions dans l'index&nbsp;:
<programlisting>LOG:  index "FOO" needs VACUUM or REINDEX to finish crash recovery
</programlisting>
  Si un simple <command>VACUUM</command> est incapable de réaliser
  complètement la récupération, l'avertissement suivant est envoyé&nbsp;:
<programlisting>NOTICE:  index "FOO" needs VACUUM FULL or REINDEX to finish crash recovery
</programlisting>
 </para>
</sect1>

</chapter>
