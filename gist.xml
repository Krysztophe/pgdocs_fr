<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="gist">
<title>Index GiST</title>

   <indexterm>
    <primary>index</primary>
    <secondary>GiST</secondary>
   </indexterm>

<sect1 id="gist-intro">
 <title>Introduction</title>

 <para>
   <acronym>GiST</acronym> est un acronyme de <foreignphrase>Generalized
   Search Tree</foreignphrase>, c'est-à-dire arbre de recherche généralisé.
   C'est une méthode d'accès balancée à structure de type arbre,
   qui agit comme un modèle de base dans lequel il est possible d'implanter
   des schémas d'indexage arbitraires. B-trees, R-trees et de nombreux autres
   schémas d'indexage peuvent être implantés en <acronym>GiST</acronym>.
 </para>

 <para>
  <acronym>GiST</acronym> a pour avantage d'autoriser le développement
  de types de données personnalisés avec les méthodes d'accès appropriées, par
  un expert en types de données, plutôt que par un expert en
  bases de données.
 </para>

  <para>
   Quelques informations disponibles ici sont dérivées du <ulink
   url="http://gist.cs.berkeley.edu/">site web</ulink> du projet d'indexage
   GiST de l'université de Californie à Berkeley et de la <ulink
    url="http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz">thèse
   de Marcel Kornacker, 
   Méthodes d'accès pour les systèmes de bases de données de la prochaine
   génération</ulink>. L'implantation <acronym>GiST</acronym> de
   <productname>PostgreSQL</productname> est principalement maintenu
   par Teodor Sigaev et Oleg Bartunov. Leur <ulink
   url="http://www.sai.msu.su/~megera/postgres/gist/">site web</ulink> fournit
   de plus amples informations.
  </para>

</sect1>

<sect1 id="gist-extensibility">
 <title>Extensibilité</title>

 <para>
  L'implantation d'une nouvelle méthode d'accès à un index
  a toujours été un travail complexe. Il est, en effet, nécessaire de comprendre le
  fonctionnement interne de la base de données, tel que le gestionnaire de
  verrous ou le WAL.
 </para>
 
 <para>
  L'interface <acronym>GiST</acronym> dispose d'un haut niveau
  d'abstraction, ce qui autorise le codeur de la méthode d'accès à
  ne coder que la sémantique du type de données accédé. La
  couche <acronym>GiST</acronym> se charge elle-même de la gestion des accès concurrents,
  des traces et de la recherche dans la structure en arbre.
 </para>
 
 <para>
   Cette extensibilité n'est pas comparable à celle des
   autres arbres de recherche standard en termes de données gérées. Par
   exemple, <productname>PostgreSQL</productname> supporte les B-trees et les
   index de hachage extensibles. Cela signifie qu'il est possible d'utiliser
   <productname>PostgreSQL</productname> pour construire un B-tree ou un hachage
   sur tout type de données. Mais, les B-trees ne supportent
   que les prédicats d'échelle (<literal>&lt;</literal>,
   <literal>=</literal>, <literal>&gt;</literal>), les index de hachage
   que les requêtes d'égalité.
 </para>
 
 <para>
   Donc, lors de l'indexation d'une collection d'images, par exemple, avec un B-tree
   <productname>PostgreSQL</productname>, seules peuvent être lancées des requêtes de type  
   <quote>est-ce que imagex est égale à imagey</quote>,
   <quote>est-ce que imagex est plus petite que imagey</quote> et <quote>est-ce
   que imagex est plus grande que imagey</quote>. En fonction de la définition
   donnée à <quote>égale à</quote>, <quote>inférieure à</quote> ou
   <quote>supérieure à</quote>, cela peut avoir une utilité.
   Néanmoins, l'utilisation d'un index basé sur <acronym>GiST</acronym> permet
   de créer de nombreuses possibilités de poser des questions spécifiques au domaine,
   telles que <quote>trouver toutes les images de chevaux</quote> ou
   <quote>trouver toutes les images sur-exposées</quote>.
 </para>

 <para>
   Pour obtenir une méthode d'accès
   <acronym>GiST</acronym> fonctionnelle, il suffit de coder sept méthodes
   utilisateur définissant le comportement des clés dans
   l'arbre. Ces méthodes doivent être suffisamment élaborées
   pour supporter des requêtes avancées, mais pour toutes les requêtes standard
   (B-trees, R-trees, etc.) elles sont relativement simples. En bref,
   <acronym>GiST</acronym> combine extensibilité, généralité, 
   ré-utilisation de code et interface claire.
  </para>

</sect1>

<sect1 id="gist-implementation">
 <title>Implantation</title>
 
 <para>
   Une classe d'opérateur d'index <acronym>GiST</acronym> doit fournir sept
   méthodes. Correctness of the index is ensured
   by proper implementation of the <function>same</function>, <function>consistent</function>
   and <function>union</function> methods, while efficiency (size and speed) of the
   index will depend on the <function>penalty</function> and <function>picksplit</function>
   methods.
   The remaining two methods are <function>compress</function> and
   <function>decompress</function>, which allow an index to have internal tree data of
   a different type than the data it indexes. The leaves are to be of the
   indexed data type, while the other tree nodes can be of any C struct (but
   you still have to follow <productname>PostgreSQL</productname> datatype rules here,
   see about <literal>varlena</literal> for variable sized data). If the tree's
   internal data type exists at the SQL level, the <literal>STORAGE</literal> option
   of the <command>CREATE OPERATOR CLASS</command> command can be used.
 </para>

 <variablelist>
    <varlistentry>
     <term><function>consistent</function></term>
     <listitem>
      <para>
       Given an index entry <literal>p</literal> and a query value <literal>q</literal>,
       this function determines whether the index entry is
       <quote>consistent</quote> with the query; that is, could the predicate
       <quote><replaceable>indexed_column</replaceable>
       <replaceable>indexable_operator</replaceable> <literal>q</literal></quote> be true for
       any row represented by the index entry?  For a leaf index entry this is
       equivalent to testing the indexable condition, while for an internal
       tree node this determines whether it is necessary to scan the subtree
       of the index represented by the tree node.  When the result is
       <literal>true</literal>, a <literal>recheck</literal> flag must also be returned.
       This indicates whether the predicate is certainly true or only possibly
       true.  If <literal>recheck</literal> = <literal>false</literal> then the index has
       tested the predicate condition exactly, whereas if <literal>recheck</literal>
       = <literal>true</literal> the row is only a candidate match.  In that case the
       system will automatically evaluate the
       <replaceable>indexable_operator</replaceable> against the actual row value to see
       if it is really a match.  This convention allows
       <acronym>GiST</acronym> to support both lossless and lossy index
       structures.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_consistent(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_consistent);

Datum
my_consistent(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    bool       *recheck = (bool *) PG_GETARG_POINTER(4);
    data_type  *key = DatumGetDataType(entry-&gt;key);
    bool        retval;

    /*
     * determine return value as a function of strategy, key and query.
     *
     * Use GIST_LEAF(entry) to know where you're called in the index tree,
     * which comes handy when supporting the = operator for example (you could
     * check for non empty union() in non-leaf nodes and equality in leaf
     * nodes).
     */

    *recheck = true;        /* or false if check is exact */

    PG_RETURN_BOOL(retval);
}
</programlisting>

       Ici, <varname>key</varname> est un élément dans l'index et
       <varname>query</varname> la valeur la recherchée dans l'index. Le
       paramètre <literal>StrategyNumber</literal> indique l'opérateur
       appliqué de votre classe d'opérateur. Il correspond à un des nombres
       d'opérateurs dans la commande <command>CREATE OPERATOR CLASS</command>.
       Suivant les opérateurs que vous avez inclus dans la classe, le type de
       données de <varname>query</varname> pourrait varier avec l'opérateur,
       mais le squelette ci-dessus suppose que ce n'est pas le cas.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>union</function></term>
     <listitem>
      <para>
       Cette méthode consolide l'information dans l'arbre. Suivant un ensemble
       d'entrées, cette fonction génère une nouvelle entrée d'index qui
       représente toutes les entrées données.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_union(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_union(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_union);

Datum
my_union(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GISTENTRY  *ent = entryvec-&gt;vector;
    data_type  *out,
               *tmp,
               *old;
    int         numranges,
                i = 0;

    numranges = entryvec-&gt;n;
    tmp = DatumGetDataType(ent[0].key);
    out = tmp;

    if (numranges == 1)
    {
        out = data_type_deep_copy(tmp);

        PG_RETURN_DATA_TYPE_P(out);
    }

    for (i = 1; i &lt; numranges; i++)
    {
        old = out;
        tmp = DatumGetDataType(ent[i].key);
        out = my_union_implementation(out, tmp);
    }

    PG_RETURN_DATA_TYPE_P(out);
}
</programlisting>
      </para>

      <para>
        Comme vous pouvez le voir dans ce quelette, nous gérons un type de
	données où <literal>union(X, Y, Z) = union(union(X, Y), Z)</literal>.
	C'est assez simple pour supporter les types de données où ce n'est pas
	le cas, en implantant un autre algorithme d'union dans cette méthode
	de support <acronym>GiST</acronym>.
      </para>

      <para>
        La fonction d'implantation de <function>union</function> doit renvoyer
	un pointeur vers la mémoire qui vient d'être allouée via la fonction
        <function>palloc()</function>. Vous ne pouvez pas tout simplement
	renvoyer l'entrée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>compress</function></term>
     <listitem>
      <para>
       Convertit l'élément de données dans un format compatible avec
       le stockage physique dans une page d'index.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_compress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_compress(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *retval;

    if (entry-&gt;leafkey)
    {
        /* replace entry-&gt;key with a compressed version */
        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));

        /* fill *compressed_data from entry-&gt;key ... */

        retval = palloc(sizeof(GISTENTRY));
        gistentryinit(*retval, PointerGetDatum(compressed_data),
                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
    }
    else
    {
        /* typically we needn't do anything with non-leaf entries */
        retval = entry;
    }

    PG_RETURN_POINTER(retval);
}
</programlisting>
      </para>

      <para>
       Vous devez adapter <replaceable>compressed_data_type</replaceable> au type
       spécifique que vous essayez d'obtenir pour compresser les n&oelig;uds
       finaux.
      </para>

      <para>
        Vous pourriez aussi avoir besoin de faire attention à la compression des
	valeurs <literal>NULL</literal>, en enregistrant par exemple
        <literal>(Datum) 0</literal> comme le fait <literal>gist_circle_compress</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>decompress</function></term>
     <listitem>
      <para>
       L'inverse de la fonction <function>compress</function>. Convertit la
       représentation de l'élément de donnée en un format manipulable par la base
       de données.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_decompress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_decompress(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_decompress);

Datum
my_decompress(PG_FUNCTION_ARGS)
{
    PG_RETURN_POINTER(PG_GETARG_POINTER(0));
}
</programlisting>

        Le squelette ci-dessus est convenable dans le cas iù aucune
	décompression n'est nécessaire.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>penalty</function></term>
     <listitem>
      <para>
       Renvoie une valeur indiquant le <quote>coût</quote> d'insertion
       d'une nouvelle entrée dans une branche particulière de l'arbre. Les
       éléments seront insérés dans l'ordre des pénalités moindres
       (<function>penalty</function>) de l'arbre.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;  -- in some cases penalty functions need not be strict
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_penalty(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_penalty);

Datum
my_penalty(PG_FUNCTION_ARGS)
{
    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);
    float      *penalty = (float *) PG_GETARG_POINTER(2);
    data_type  *orig = DatumGetDataType(origentry-&gt;key);
    data_type  *new = DatumGetDataType(newentry-&gt;key);

    *penalty = my_penalty_implementation(orig, new);
    PG_RETURN_POINTER(penalty);
}
</programlisting>
      </para>

      <para>
        La fonction <function>penalty</function> est crucial pour de bonnes
	performances de l'index. Elle sera utilisée lors de l'insertion pour
	déterminer la branche à suivre pour savoir où ajoter la nouvelle entrée
	dans l'arbre. Lors de l'exécution de la requête, plus l'arbre sera bien
	balancé, plus l'exécution sera rapide.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>picksplit</function></term>
     <listitem>
      <para>
       Quand une division de page est nécessaire pour un index, cette fonction
       décide des entrées de la page qui resteront sur l'ancienne page et de
       celles qui seront déplacées sur la nouvelle page.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_picksplit(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_picksplit);

Datum
my_picksplit(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    OffsetNumber maxoff = entryvec-&gt;n - 1;
    GISTENTRY  *ent = entryvec-&gt;vector;
    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
    int         i,
                nbytes;
    OffsetNumber *left,
               *right;
    data_type  *tmp_union;
    data_type  *unionL;
    data_type  *unionR;
    GISTENTRY **raw_entryvec;

    maxoff = entryvec-&gt;n - 1;
    nbytes = (maxoff + 1) * sizeof(OffsetNumber);

    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);
    left = v-&gt;spl_left;
    v-&gt;spl_nleft = 0;

    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);
    right = v-&gt;spl_right;
    v-&gt;spl_nright = 0;

    unionL = NULL;
    unionR = NULL;

    /* Initialize the raw entry vector. */
    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));
    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);

    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
    {
        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;

        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);
        Assert(tmp_union != NULL);

        /*
         * Choose where to put the index entries and update unionL and unionR
         * accordingly. Append the entries to either v_spl_left or
         * v_spl_right, and care about the counters.
         */

        if (my_choice_is_left(unionL, curl, unionR, curr))
        {
            if (unionL == NULL)
                unionL = tmp_union;
            else
                unionL = my_union_implementation(unionL, tmp_union);

            *left = real_index;
            ++left;
            ++(v-&gt;spl_nleft);
        }
        else
        {
            /*
             * Same on the right
             */
        }
    }

    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);
    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);
    PG_RETURN_POINTER(v);
}
</programlisting>
      </para>

      <para>
        Comme <function>penalty</function>, la fonction <function>picksplit</function>
	est cruciale pour de bonnes performances de l'index. Concevoir des
	implantations convenables des fonctions <function>penalty</function> et
	<function>picksplit</function> est le challenge d'un index
        <acronym>GiST</acronym> performant.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>same</function></term>
     <listitem>
      <para>
       Renvoit true si les deux entrées de l'index sont identiques, faux sinon.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction ressemble à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_same(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_same(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_same);

Datum
my_same(PG_FUNCTION_ARGS)
{
    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);
    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);
    bool       *result = (bool *) PG_GETARG_POINTER(2);

    *result = my_eq(v1, v2);
    PG_RETURN_POINTER(result);
}
</programlisting>

        Pour des raisons historiques, la fonction <function>same</function> ne
	renvoie pas seulement un résultat booléen&nbsp;; à la place, il doit
	enregistrer le drapeau à l'emplacement indiqué par le troisième argument.
      </para>
     </listitem>
    </varlistentry>

  </variablelist>

</sect1>

<sect1 id="gist-examples">
 <title>Exemples</title>

 <para>
  La distribution source de <productname>PostgreSQL</productname> inclut
  plusieurs exemples de méthodes d'indexation implantées selon
  <acronym>GiST</acronym>. Le système principal fournit des fonctionnalités
  de recherche plein texte (indexation des <type>tsvector</type> et
  <type>tsquery</type>) ainsi que des fonctionnalités équivalentes aux R-Tree
  pour certains types de données géométriques
  (voir <filename>src/backend/access/gist/gistproc.c</filename>). Les modules
  <filename>contrib</filename> suivants contiennent aussi des classes d'opérateur
  <acronym>GiST</acronym>&nbsp;:
 </para>
 
 <variablelist>
  <varlistentry>
   <term>btree_gist</term>
   <listitem>
    <para>Fonctionnalités équivalentes aux B-Tree pour plusieurs types de
    données</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>cube</term>
   <listitem>
    <para>Indexation de cubes multi-dimensionnels</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>hstore</term>
   <listitem>
    <para>Module pour le stockage des paires (clé, valeur)</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>intarray</term>
   <listitem>
    <para>RD-Tree pour tableaux uni-dimensionnels de valeurs int4</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>ltree</term>
   <listitem>
    <para>Indexation des structures de type arbre</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>pg_trgm</term>
   <listitem>
    <para>Similarité textuelle par correspondance de trigrammes</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>seg</term>
   <listitem>
    <para>Indexation pour les <quote>nombres
     flottants</quote></para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="gist-recovery">
 <title>Récupération après un arrêt brutal</title>

 <para>
  Il est généralement suffisant de rejouer les traces WAL pour restaurer l'intégrité d'un
  index GiST après un arrêt brutal de la base de données. Néanmoins, il existe
  quelques cas particuliers pour lesquels l'état de l'index n'est pas
  entièrement reconstruit. L'index reste fonctionnellement correct mais
  les performances peuvent se trouver dégradées. Lorsque cela
  arrive, l'index peut être réparé par <command>VACUUM</command> de sa table, ou
  par reconstruction avec <command>REINDEX</command>. Dans certains cas, un simple
  <command>VACUUM</command> ne suffit pas et un <command>VACUUM FULL</command>
  ou un <command>REINDEX</command> est nécessaire. Ce besoin est indiqué par
  la survenue d'un tel message&nbsp;:
<programlisting>LOG:  index NNN/NNN/NNN needs VACUUM or REINDEX to finish crash recovery
</programlisting>
  ou le message suivant lors d'insertions dans l'index&nbsp;:
<programlisting>LOG:  index "FOO" needs VACUUM or REINDEX to finish crash recovery
</programlisting>
  Si un simple <command>VACUUM</command> est incapable de réaliser
  complètement la récupération, l'avertissement suivant est envoyé&nbsp;:
<programlisting>NOTICE:  index "FOO" needs VACUUM FULL or REINDEX to finish crash recovery
</programlisting>
 </para>
</sect1>

</chapter>
