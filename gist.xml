<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="gist">
<title>Index GiST</title>

   <indexterm>
    <primary>index</primary>
    <secondary>GiST</secondary>
   </indexterm>

<sect1 id="gist-intro">
 <title>Introduction</title>

 <para>
   <acronym>GiST</acronym> est un acronyme de <foreignphrase>Generalized
   Search Tree</foreignphrase>, c'est-à-dire arbre de recherche généralisé.
   C'est une méthode d'accès balancée à structure de type arbre,
   qui agit comme un modèle de base dans lequel il est possible d'implanter
   des schémas d'indexage arbitraires. B-trees, R-trees et de nombreux autres
   schémas d'indexage peuvent être implantés en <acronym>GiST</acronym>.
 </para>

 <para>
  <acronym>GiST</acronym> a pour avantage d'autoriser le développement
  de types de données personnalisés avec les méthodes d'accès appropriées, par
  un expert en types de données, plutôt que par un expert en
  bases de données.
 </para>

  <para>
   Quelques informations disponibles ici sont dérivées du <ulink
   url="http://gist.cs.berkeley.edu/">site web</ulink> du projet d'indexage
   GiST de l'université de Californie à Berkeley et de la <ulink
    url="http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz">thèse
   de Marcel Kornacker, 
   Méthodes d'accès pour les systèmes de bases de données de la prochaine
   génération</ulink>. L'implantation <acronym>GiST</acronym> de
   <productname>PostgreSQL</productname> est principalement maintenu
   par Teodor Sigaev et Oleg Bartunov. Leur <ulink
   url="http://www.sai.msu.su/~megera/postgres/gist/">site web</ulink> fournit
   de plus amples informations.
  </para>

</sect1>

<sect1 id="gist-extensibility">
 <title>Extensibilité</title>

 <para>
  L'implantation d'une nouvelle méthode d'accès à un index
  a toujours été un travail complexe. Il est, en effet, nécessaire de comprendre le
  fonctionnement interne de la base de données, tel que le gestionnaire de
  verrous ou le WAL.
 </para>
 <para>
  L'interface <acronym>GiST</acronym> dispose d'un haut niveau
  d'abstraction, ce qui autorise le codeur de la méthode d'accès à
  ne coder que la sémantique du type de données accédé. La
  couche <acronym>GiST</acronym> se charge elle-même de la gestion des accès concurrents,
  des traces et de la recherche dans la structure en arbre.
 </para>
 
 <para>
   Cette extensibilité n'est pas comparable à celle des
   autres arbres de recherche standard en termes de données gérées. Par
   exemple, <productname>PostgreSQL</productname> supporte les B-trees et les
   index de hachage extensibles. Cela signifie qu'il est possible d'utiliser
   <productname>PostgreSQL</productname> pour construire un B-tree ou un hachage
   sur tout type de données. Mais, les B-trees ne supportent
   que les prédicats d'échelle (<literal>&lt;</literal>,
   <literal>=</literal>, <literal>&gt;</literal>), les index de hachage
   que les requêtes d'égalité.
 </para>
 
 <para>
   Donc, lors de l'indexation d'une collection d'images, par exemple, avec un B-tree
   <productname>PostgreSQL</productname>, seules peuvent être lancées des requêtes de type  
   <quote>est-ce que imagex est égale à imagey</quote>,
   <quote>est-ce que imagex est plus petite que imagey</quote> et <quote>est-ce
   que imagex est plus grande que imagey</quote>. En fonction de la définition
   donnée à <quote>égale à</quote>, <quote>inférieure à</quote> ou
   <quote>supérieure à</quote>, cela peut avoir une utilité.
   Néanmoins, l'utilisation d'un index basé sur <acronym>GiST</acronym> permet
   de créer de nombreuses possibilités de poser des questions spécifiques au domaine,
   telles que <quote>trouver toutes les images de chevaux</quote> ou
   <quote>trouver toutes les images sur-exposées</quote>.
 </para>

 <para>
   Pour obtenir une méthode d'accès
   <acronym>GiST</acronym> fonctionnelle, il suffit de coder sept méthodes
   utilisateur définissant le comportement des clés dans
   l'arbre. Ces méthodes doivent être suffisamment élaborées
   pour supporter des requêtes avancées, mais pour toutes les requêtes standard
   (B-trees, R-trees, etc.) elles sont relativement simples. En bref,
   <acronym>GiST</acronym> combine extensibilité, généralité, 
   ré-utilisation de code et interface claire.
  </para>

</sect1>

<sect1 id="gist-implementation">
 <title>Implantation</title>
 
 <para>
   Une classe d'opérateur d'index <acronym>GiST</acronym> doit fournir sept
   méthodes&nbsp;:
 </para>

 <variablelist>
    <varlistentry>
     <term>consistent</term>
     <listitem>
      <para>
       Pour un prédicat <literal>p</literal> d'une page de l'arbre et une
       requête utilisateur <literal>q</literal> données, cette méthode retourne
       faux si <literal>p</literal> et <literal>q</literal> ne peuvent pas
       être simultanément vrais pour un élément de
       données particulier.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>union</term>
     <listitem>
      <para>
       Cette méthode consolide les informations de l'arbre. Pour une liste
       d'entrées donnée, cette fonction produit un nouveau prédicat vrai pour
       toutes les entrées.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>compress</term>
     <listitem>
      <para>
       Convertit l'élément de données dans un format compatible avec
       le stockage physique dans une page d'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>decompress</term>
     <listitem>
      <para>
       L'inverse de la fonction <function>compress</function>. Convertit la
       représentation de l'élément de donnée en un format manipulable par la base
       de données.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>penalty</term>
     <listitem>
      <para>
       Renvoie une valeur indiquant le <quote>coût</quote> d'insertion
       d'une nouvelle entrée dans une branche particulière de l'arbre. Les
       éléments seront insérés dans l'ordre des pénalités moindres
       (<function>penalty</function>) de l'arbre.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>picksplit</term>
     <listitem>
      <para>
       Quand une coupure de page est nécessaire, cette fonction décide des
       entrées qui restent sur l'ancienne page et de celles
       déplacées sur la nouvelle.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>same</term>
     <listitem>
      <para>
       Renvoie vrai si deux entrées sont identiques, faux autrement.
      </para>
     </listitem>
    </varlistentry>

  </variablelist>

</sect1>

<sect1 id="gist-examples">
 <title>Exemples</title>

 <para>
  La distribution source de <productname>PostgreSQL</productname> inclut
  plusieurs exemples de méthodes d'indexation implantées selon
  <acronym>GiST</acronym>. Le système principal fournit des fonctionnalités
  de recherche plein texte (indexation des <type>tsvector</type> et
  <type>tsquery</type>) ainsi que des fonctionnalités équivalentes aux R-Tree
  pour certains types de données géométriques
  (voir <filename>src/backend/access/gist/gistproc.c</filename>). Les modules
  <filename>contrib</filename> suivants contiennent aussi des classes d'opérateur
  <acronym>GiST</acronym>&nbsp;:
 </para>
 
 <variablelist>
  <varlistentry>
   <term>btree_gist</term>
   <listitem>
    <para>Fonctionnalités équivalentes aux B-Tree pour plusieurs types de
    données</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>cube</term>
   <listitem>
    <para>Indexation de cubes multi-dimensionnels</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>hstore</term>
   <listitem>
    <para>Module pour le stockage des paires (clé, valeur)</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>intarray</term>
   <listitem>
    <para>RD-Tree pour tableaux uni-dimensionnels de valeurs int4</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>ltree</term>
   <listitem>
    <para>Indexation des structures de type arbre</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>pg_trgm</term>
   <listitem>
    <para>Similarité textuelle par correspondance de trigrammes</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>seg</term>
   <listitem>
    <para>Indexation pour les <quote>nombres
     flottants</quote></para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="gist-recovery">
 <title>Récupération après un arrêt brutal</title>

 <para>
  Il est généralement suffisant de rejouer les traces WAL pour restaurer l'intégrité d'un
  index GiST après un arrêt brutal de la base de données. Néanmoins, il existe
  quelques cas particuliers pour lesquels l'état de l'index n'est pas
  entièrement reconstruit. L'index reste fonctionnellement correct mais
  les performances peuvent se trouver dégradées. Lorsque cela
  arrive, l'index peut être réparé par <command>VACUUM</command> de sa table, ou
  par reconstruction avec <command>REINDEX</command>. Dans certains cas, un simple
  <command>VACUUM</command> ne suffit pas et un <command>VACUUM FULL</command>
  ou un <command>REINDEX</command> est nécessaire. Ce besoin est indiqué par
  la survenue d'un tel message&nbsp;:
<programlisting>LOG:  index NNN/NNN/NNN needs VACUUM or REINDEX to finish crash recovery
</programlisting>
  ou le message suivant lors d'insertions dans l'index&nbsp;:
<programlisting>LOG:  index "FOO" needs VACUUM or REINDEX to finish crash recovery
</programlisting>
  Si un simple <command>VACUUM</command> est incapable de réaliser
  complètement la récupération, l'avertissement suivant est envoyé&nbsp;:
<programlisting>NOTICE:  index "FOO" needs VACUUM FULL or REINDEX to finish crash recovery
</programlisting>
 </para>
</sect1>

</chapter>
