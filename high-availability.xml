<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="high-availability">
 <title>Haute disponibilité, répartition de charge et réplication</title>

 <indexterm><primary>haute disponibilité</primary></indexterm>
 <indexterm><primary>failover</primary></indexterm>
 <indexterm><primary>réplication</primary></indexterm>
 <indexterm><primary>répartition de charge</primary></indexterm>
 <indexterm><primary>clustering</primary></indexterm>
 <indexterm><primary>partitionnement de données</primary></indexterm>

<!-- seamlessly ? -->
 <para>
  Des serveurs de bases de données peuvent travailler ensemble pour permettre
  à un serveur secondaire de prendre rapidement la main si le serveur principal
  échoue (haute disponibilité, ou <foreignphrase>high availability</foreignphrase>),
  ou pour permettre à plusieurs serveurs de servir les mêmes données (répartition
  de charge, ou <foreignphrase>load balancing</foreignphrase>). Idéalement, les
  serveurs de bases de données peuvent travailler ensemble sans jointure.
  </para>
  <para>
  Il est aisé de faire coopérer des serveurs web qui traitent des pages web statiques
  en répartissant la charge des requêtes web sur plusieurs
  machines. Dans les faits, les serveurs de bases de données en lecture seule peuvent
  également coopérer facilement. Malheureusement, la plupart des
  serveurs de bases de données traitent des requêtes de lecture/écriture et,
  de ce fait, collaborent plus difficilement. En effet, alors qu'il suffit de
  placer une seule fois les données en lecture seule sur chaque serveur, une
  écriture sur n'importe quel serveur doit, elle, être propagée à tous les
  serveurs afin que les lectures suivantes sur ces serveurs renvoient des résulats
  cohérents.
 </para>

 <para>
  Ce problème de synchronisation représente la difficulté fondamentale à la
  collaboration entre serveurs. Comme la solution au problème de
  synchronisation n'est pas unique pour tous les cas pratiques, plusieurs
  solutions co-existent. Chacune répond de façon différente et minimise
  cet impact au regard d'une charge spécifique.
 </para>

 <para>
  Certaines solutions gèrent la synchronisation en autorisant les modifications
  des données sur un seul serveur. Les serveurs qui peuvent modifier les données
  sont appelés serveurs en lecture/écriture ou serveurs maîtres. Les serveurs qui
  peuvent répondre aux requêtes en lecture seule sont appelés serveurs
  esclaves. Les serveurs qui ne sont pas accessibles tant qu'ils ne se sont pas
  promus en serveurs maîtres sont appelées serveurs en attente
  (<foreignphrase>standby servers</foreignphrase>).
 </para>

 <para>
  Certaines solutions sont synchrones, ce qui signifie qu'une transaction de
  modification de données n'est pas considérée valide tant que tous les
  serveurs n'ont pas validé la transaction. Ceci garantit qu'un
  <foreignphrase>failover</foreignphrase> ne perd pas de données et que tous
  les serveurs en répartition de charge retournent des résultats cohérents, quel
  que soit le serveur interrogé. Au contraire, les solutions asynchrones
  autorisent un délai entre la validation et sa propagation aux
  autres serveurs. Cette solution implique une éventuelle perte de transactions
  lors de la bascule sur un serveur de sauvegarde, ou l'envoi de données
  obsolètes par les serveurs à charge répartie. La communication asynchrone est
  utilisée lorsque la version synchrone est trop lente.
 </para>

 <para>
  Les solutions peuvent aussi être catégorisées par leur granularité. Certaines
  ne gèrent que la totalité d'un serveur de bases alors que
  d'autres autorisent un contrôle par table ou par base.
 </para>

 <para>
  Il importe de considérer les performances dans tout choix. Il y
  a généralement un compromis à trouver entre les fonctionnalités et les
  performances. Par exemple, une solution complètement synchrone sur un réseau
  lent peut diviser les performances par plus de deux, alors qu'une
  solution asynchrone peut n'avoir qu'un impact minimal sur les performances.
 </para>

 <para>
  Le reste de cette section souligne différentes solutions de
  <foreignphrase>failover</foreignphrase>, de réplication et de répartition de
  charge. Un <ulink
  url="http://www.postgres-r.org/documentation/terms">glossaire</ulink> est
  aussi disponible.
 </para>

 <variablelist>

 <varlistentry>
  <term><foreignphrase>Failover</foreignphrase> sur disque partagé</term>
  <listitem>

   <para>
    Le <foreignphrase>failover</foreignphrase> (ou bascule sur incident)
    sur disque partagé élimine la surcharge de synchronisation par
    l'existence d'une seule copie de la base de données. Il utilise un
    seul ensemble de disques partagé par plusieurs serveurs. Si le serveur
    principal échoue, le serveur en attente
    est capable de monter et démarrer la base comme s'il récupérait d'un
    arrêt brutal. Cela permet un <foreignphrase>failover</foreignphrase>
    rapide sans perte de données.
   </para>

<!-- SAS::ICI -->
   <para>
    La fonctionnalité de matériel partagé est commune aux périphériques de
    stockage en réseau. Il est également possible d'utiliser un système de
    fichiers réseau bien qu'il faille porter une grande attention au système de
    fichiers pour s'assurer qu'il a un comportement <acronym>POSIX</acronym>
    complet (voir <xref linkend="creating-cluster-nfs"/>). Une
    limitation significative de cette méthode est que si les disques ont un
    problème ou sont corrompus, les serveurs primaire et en attente sont tous
    les deux non fonctionnels. Un autre problème est que le serveur en attente
    ne devra jamais accéder au stockage partagé tant que le serveur principal
    est en cours d'exécution.
   </para>

   </listitem>
  </varlistentry>

  <varlistentry>
   <term>Réplication de système de fichiers (périphérique bloc)</term>
   <listitem>

   <para>
    Il est aussi possible d'utiliser cette fonctionnalité d'une autre façon
    avec une réplication du système de fichiers, où toutes les modifications
    d'un système de fichiers sont renvoyées sur un système de fichiers situé
    sur un autre ordinateur. La seule restriction est que ce miroir doit être
    construit d'une façon qui assure le fait que le serveur en attente a une
    version cohérente du système de fichiers &mdash; spécifiquement, les
    écritures sur le serveur en attente doivent être réalisées dans le même
    ordre que celles sur le maître. <productname>DRBD</productname> est une
    solution populaire de réplication de systèmes de fichiers pour Linux.
   </para>

<!--
https://forge.continuent.org/pipermail/sequoia/2006-November/004070.html

Oracle RAC is a shared disk approach and just send cache invalidations
to other nodes but not actual data. As the disk is shared, data is
only committed once to disk and there is a distributed locking
protocol to make nodes agree on a serializable transactional order.
-->

  </listitem>
 </varlistentry>

 <varlistentry>
  <term><foreignphrase>Warm Standby</foreignphrase> en utilisant
    <acronym>PITR</acronym></term>
  <listitem>

   <para>
    Un serveur <foreignphrase>warm standby</foreignphrase> (voir <xref
    linkend="warm-standby"/>) peut conserver sa cohérence en lisant un flux
    d'enregistrements de <acronym>WAL</acronym>. Si le serveur principal
    échoue, le serveur
    <foreignphrase>warm standby</foreignphrase> contient pratiquement toutes
    les données du serveur principal et peut rapidement devenir le nouveau
    serveur maître. Ceci est asynchrone et peut seulement se faire pour le
    serveur de bases entier.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term>Réplication maître/esclave</term>
  <listitem>

   <para>
    Une configuration de réplication maître/esclave envoie toutes les requêtes
    de modification de données au serveur maître. Ce serveur envoie les
    modifications de données de façon asynchrone au serveur esclave. L'esclave
    peut répondre aux requêtes en lecture seule alors que le serveur maître
    est en cours d'exécution. Le serveur esclave est idéal pour les requêtes
    vers un entrepôt de données.
   </para>

   <para>
    <productname>Slony-I</productname> est un exemple de ce type de
    réplication, avec une granularité par
    table et un support des esclaves multiple. Comme il met à jour le serveur
    esclave de façon asynchrone (par lots), il existe une possibilité de perte
    de données pendant un <foreignphrase>failover</foreignphrase>.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><foreignphrase>Middleware</foreignphrase> de réplication basés sur les
    instructions</term>
  <listitem>

   <para>
    Avec les <foreignphrase>middleware</foreignphrase> de réplication basés
    sur les instructions, un programme intercepte chaque requête SQL et
    l'envoie à un ou tous les serveurs. Chaque serveur opère indépendamment.
    Les requêtes en lecture/écriture sont envoyées à tous les serveurs alors
    que les requêtes en lecture seule peuvent seulement être envoyées à un seul
    serveur permettant la distribution du vrai travail.
   </para>

   <para>
    Si les requêtes sont envoyées sans modification, les fonctions comme
    <function>random()</function>, <function>CURRENT_TIMESTAMP</function> ainsi
    que les séquences auront des valeurs différentes sur des serveurs
    différents. Ceci est dû au fait que chaque serveur opère indépendamment
    et que les requêtes SQL sont envoyées à tous (et non pas les données
    modifiées). Si ceci est inacceptable, soit le
    <foreignphrase>middleware</foreignphrase> soit l'application doivent
    demander ces valeurs à partir d'un seul serveur, puis les utiliser dans
    des requêtes d'écriture. De plus, une attention doit être portée à ce que
    toutes les transactions soient validées soit annulées sur tous les serveurs
    par exemple en utilisant la validation en deux phases (<xref
    linkend="sql-prepare-transaction"
    endterm="sql-prepare-transaction-title"/> et <xref
    linkend="sql-commit-prepared" endterm="sql-commit-prepared-title"/>.
    <productname>Pgpool-II</productname> et <productname>Sequoia</productname>
    sont un exemple de ce type de réplication.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term>Réplication asynchrone à plusieurs maîtres</term>
  <listitem>

   <para>
    Pour les serveurs qui ne sont pas connectés en permanence, comme les
    portables ou les serveurs distants, garder la cohérence des données
    entre les serveurs est un challenge. En utilisant la réplication asynchrone
    à plusieurs maîtres, chaque serveur fonctionne indépendamment et communique
    périodiquement avec les autres serveurs pour identifier les transactions
    en conflit. Les conflits peuvent être résolus par les utilisateurs ou par
    des règles de résolution.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term>Réplication synchrone multi-maîtres</term>
  <listitem>

<!-- Je corrige l'erreur relevée par tigrou3tac, mais le passage est à
reprendre. Les phrases sont un peu lourdes -->
   <para>
    Dans les réplications synchrones multi-maîtres, chaque serveur peut
    accepter les requêtes en écriture. Les données modifiées sont transmises
    du serveur original à tous les autres serveurs avant validation de chaque
    transaction. Une activité importante en écriture peut être la cause d'un
    verrouillage excessif conduisant à un effondrement des performances. En fait, la
    performance en écriture est souvent pis que celle d'un simple serveur. Les
    requêtes en lecture peuvent être envoyées à tous les serveurs. Certaines
    implantations utilisent les disques partagés pour réduire la surcharge
    de communication. La réplication synchrone multi-maîtres est bien meilleure
    principalement pour de grosses charges de travail en lecture bien que son gros
    avantage est que tout serveur peut accepter des requêtes d'écriture &mdash;
    il n'est pas nécessaire de partitionner les travaux entre les serveurs
    maîtres et esclaves et, comme les modifications de données sont envoyées
    d'un serveur à un autre, il n'y a pas de problème avec les fonctions
    non déterministiques comme <function>random()</function>.
   </para>

   <para>
    <productname>PostgreSQL</productname> n'offre pas ce type de réplication,
    bien que la validation en deux phases de <productname>PostgreSQL</productname>
    (<xref linkend="sql-prepare-transaction"
    endterm="sql-prepare-transaction-title"/> et <xref
    linkend="sql-commit-prepared" endterm="sql-commit-prepared-title"/>) peut
    être utilisée pour implémenter cela dans une application ou un
    <foreignphrase>middleware</foreignphrase>.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term>Solutions commerciales</term>
  <listitem>

   <para>
    Comme <productname>PostgreSQL</productname> est libre et facilement
    extensible, certaines sociétés ont pris <productname>PostgreSQL</productname>
    et créé des solutions propriétaires avec leur propres fonctionnalités de
    <foreignphrase>failover</foreignphrase>, réplication et répartition de
    charges.
   </para>
  </listitem>
 </varlistentry>

 </variablelist>

 <para>
  La <xref linkend="high-availability-matrix"/> résume les
  capacités des différentes solutions listées ci-dessus.
 </para>

 <table id="high-availability-matrix">
  <title>Matrice de fonctionnalités&nbsp;: haute disponibilité, répartition de
    charge et réplication</title>
  <tgroup cols="8">
   <thead>
    <row>
     <entry>Fonctionnalité</entry>
     <entry><foreignphrase>Shared Disk Failover</foreignphrase></entry>
     <entry>Réplication système de fichiers</entry>
     <entry><foreignphrase>Warm Standby</foreignphrase> (en utilisant
       <acronym>PITR</acronym>)</entry>
     <entry>Réplication maître/esclave</entry>
     <entry><foreignphrase>Middleware</foreignphrase> de réplication
       se basant sur les instructions</entry>
     <entry>Réplication asynchrone multi-maître</entry>
     <entry>Réplication synchrone multi-maître</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry>Aucun matériel spécial requis</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>

    <row>
     <entry>Autorise plusieurs serveurs maîtres</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>

    <row>
     <entry>Aucune surcharge dû au serveur maître</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
    </row>

    <row>
     <entry>Aucune attente des différents serveurs</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
    </row>

    <row>
     <entry>Un échec du maître ne perdra aucune donnée</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
    </row>

    <row>
     <entry>Les esclaves acceptent les requêtes en lecture seule</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>

    <row>
     <entry>Granularité par table</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>

    <row>
     <entry>Aucune résolution de conflit nécessaire</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
    </row>

    <row>
     <entry>Méthode de communication</entry>
     <entry align="center">Disque partagé</entry>
     <entry align="center">Blocs disque</entry>
     <entry align="center">WAL</entry>
     <entry align="center">Lignes des tables</entry>
     <entry align="center">SQL</entry>
     <entry align="center">Lignes des tables</entry>
     <entry align="center">Lignes des tables et verrous de ligne</entry>
    </row>

   </tbody>
  </tgroup>
 </table>

 <para>
  Certaines solutions n'entrent pas dans les catégories ci-dessus&nbsp;:
 </para>

 <variablelist>

 <varlistentry>
  <term>Partitionnement de données</term>
  <listitem>

   <para>
    Le partitionnement des données divise les tables en ensemble de données.
    Chaque ensemble peut être modifié par un seul serveur. Par exemple, les
    données peuvent être partitionnées par bureaux, par exemple Londres et
    Paris avec un serveur dans chaque bureau. Si les requêtes combinant les
    données de Londres et de Paris sont nécessaures, une application peut
    envoyer des requêtes sur les deux serveurs ou la réplication maître/esclave
    peut être utilisée pour conserver sur chaque serveur une copie en lecture
    seule des données de l'autre bureau.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term>Exécution de requêtes en parallèle sur plusieurs serveurs</term>
  <listitem>

   <para>
    Un grand nombre des solutions ci-dessus permettent à plusieurs serveurs de
    répondre à plusieurs requêtes mais aucune ne permet à une seule requête
    d'être exécutée sur plusieurs serveurs pour se terminer plus rapidement.
    Cette solution autorise le travail en commun de plusieurs serveurs sur une
    seule requête. Ceci s'accomplit habituellement en divisant les données
    entre les serveurs et en ayant chaque serveur qui exécute une partie de la
    requête pour renvoyer les résultats à un serveur central qui les combinera
    et les renverra à l'utilisateur. <productname>Pgpool-II</productname>
    a cette capacité. De plus, cela peut être implémenté en utilisant les
    outils de <productname>PL/Proxy</productname>.
   </para>
  </listitem>
 </varlistentry>

 </variablelist>

</chapter>
