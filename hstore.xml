<sect1 id="hstore">
 <title>hstore</title>
 
 <indexterm zone="hstore">
  <primary>hstore</primary>
 </indexterm>

 <para>
  Le module <literal>hstore</literal> est utile pour stocker des paires
  (clé,valeur). Ce module a son utilité dans différents scénarios&nbsp;:
  les cas où de nombreux attributs sont rarement recherchés, données
  semi-structurelles ou un administrateur paresseux.
 </para>

 <sect2>
  <title>Opérations</title>
  <itemizedlist>
   <listitem>
    <para>
      <literal>hstore -> text</literal> - obtenir une valeur, analogie Perl
      $h{key} 
    </para>
    <programlisting>
select 'a=>q, b=>g'->'a';
  ?
------
  q
    </programlisting>
    <para>
     Notez l'utilisation de parenthèses dans le SELECT ci-dessous car la
     priorité de 'is' est plus importante que celle de '->'&nbsp;:
    </para>
    <programlisting>
SELECT id FROM entrants WHERE (info->'education_period') IS NOT NULL;
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>hstore || hstore</literal> - concaténation, analogie Perl
     %a=( %b, %c ); 
    </para>
    <programlisting>
regression=# select 'a=>b'::hstore || 'c=>d'::hstore;
      ?column?      
--------------------
 "a"=>"b", "c"=>"d"
(1 row)
    </programlisting>

    <para>
     mais notez que&nbsp;:
    </para>

    <programlisting>
regression=# select 'a=>b'::hstore || 'a=>d'::hstore;
 ?column? 
----------
 "a"=>"d"
(1 row)
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>text => text</literal> - crée un type hstore pour deux chaînes de
     type text
    </para>
    <programlisting>
select 'a'=>'b';
  ?column?
----------
  "a"=>"b"
    </programlisting>
   </listitem>

   <listitem>
    <para>
      <literal>hstore @> hstore</literal> - contient une opération, vérifie
      si l'opérance gauche contient le droit.
    </para>
    <programlisting>
regression=# select 'a=>b, b=>1, c=>NULL'::hstore @> 'a=>c';
 ?column? 
----------
 f
(1 row)

regression=# select 'a=>b, b=>1, c=>NULL'::hstore @> 'b=>1';
 ?column? 
----------
 t
(1 row)
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>hstore &lt;@ hstore</literal> - opération de contenance, vérifie
     si l'opérateur gauche est contenu par le droit
    </para>
    <para>
     (Avant PostgreSQL 8.2, les opérateurs de contenances @&gt; et &lt;@ étaient
     appelés respectivement @ et ~. Ces noms sont toujours disponibles mais sont
     obsolètes et seront supprimés un jour. Notez que les anciens noms sont
     inversés par rapport à la convention suivie par les types de données
     géométriques&nbsp;!)
    </para>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
  <title>Fonctions</title>

  <itemizedlist>
   <listitem>
    <para>
     <literal>akeys(hstore)</literal> - renvoie toutes les clés d'un hstore en
     tant que tableau
    </para>
    <programlisting>
regression=# select akeys('a=>1,b=>2');
 akeys 
-------
 {a,b}
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>skeys(hstore)</literal> - renvoie toutes les clés d'un hstore en
     tant que chaînes
    </para>
    <programlisting>
regression=# select skeys('a=>1,b=>2');
 skeys 
-------
 a
 b
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>avals(hstore)</literal> - renvoie toutes les valeurs d'un hstore
     sous la forme d'un tableau
    </para>
    <programlisting>
regression=# select avals('a=>1,b=>2');
 avals 
-------
 {1,2}
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>svals(hstore)</literal> - renvoie toutes les valeurs d'un hstore
     sous la forme de plusieurs chaînes
    </para>
    <programlisting>
regression=# select svals('a=>1,b=>2');
 svals 
-------
 1
 2
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>delete (hstore,text)</literal> - supprime (clé,valeur) d'un
     hstore si la clé correspond à l'argument.
    </para>
    <programlisting>
regression=# select delete('a=>1,b=>2','b');
  delete  
----------
 "a"=>"1"
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>each(hstore)</literal> - renvoie des paires (clé, valeur)
    </para>
    <programlisting>
regression=# select * from each('a=>1,b=>2');
 key | value 
-----+-------
 a   | 1
 b   | 2
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>exist (hstore,text)</literal>
    </para>
    <para>
     <literal>hstore ? text</literal> - renvoie true si la clé existe dans
     le hstore et false sinon.
    </para>
    <programlisting>
regression=# select exist('a=>1','a'), 'a=>1' ? 'a';
 exist | ?column? 
-------+----------
 t     | t
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>defined (hstore,text)</literal> - renvoie true si la clé existe
     dans le hstore et que sa valeur n'est pas NULL.
    </para>
    <programlisting>
regression=# select defined('a=>NULL','a');
 defined 
---------
 f
    </programlisting>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
  <title>Index</title>
  <para>
   Le module fournit un support des index pour les opérations '@>' et '?'.
  </para>
  <programlisting>
CREATE INDEX hidx ON testhstore USING GIST(h);
CREATE INDEX hidx ON testhstore USING GIN(h);
  </programlisting>
 </sect2>

 <sect2>
  <title>Exemples</title>

  <para>
   Ajouter un clé&nbsp;:
  </para>
  <programlisting>
UPDATE tt SET h=h||'c=>3';
  </programlisting>
  <para>
   Supprimer une clé&nbsp;:
  </para>
  <programlisting>
UPDATE tt SET h=delete(h,'k1');
  </programlisting>
 </sect2>

 <sect2>
  <title>Statistiques</title>
  <para>
   Le type hstore, à cause de sa conception interne, pourrait contenir
   beaucoup de clés différentes. La vérification des clés valides est
   la tâche de l'application. Les exemples ci-dessous démontrent plusieurs
   techniques de vérification des statistiques des clés.
  </para>

  <para>
   Exemple simple&nbsp;:
  </para>
  <programlisting>
SELECT * FROM each('aaa=>bq, b=>NULL, ""=>1 ');
  </programlisting>

  <para>
   En utilisant une table&nbsp;:
  </para>
  <programlisting>
SELECT (each(h)).key, (each(h)).value INTO stat FROM testhstore ;
  </programlisting>

  <para>Statistiques en ligne</para>
  <programlisting>
SELECT key, count(*) FROM (SELECT (each(h)).key FROM testhstore) AS stat GROUP BY key ORDER BY count DESC, key;
    key    | count 
-----------+-------
 line      |   883
 query     |   207
 pos       |   203
 node      |   202
 space     |   197
 status    |   195
 public    |   194
 title     |   190
 org       |   189
...................
  </programlisting>
 </sect2>

 <sect2>
  <title>Auteurs</title>
  <para>
   Oleg Bartunov <email>oleg@sai.msu.su</email>, Moscow, Moscow University, Russia
  </para>
  <para>
   Teodor Sigaev <email>teodor@sigaev.ru</email>, Moscow, Delta-Soft Ltd.,Russia
  </para>
 </sect2>
</sect1>

