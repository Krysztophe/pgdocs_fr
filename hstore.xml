<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="hstore">
 <title>hstore</title>

 <indexterm zone="hstore">
  <primary>hstore</primary>
 </indexterm>

 <para>
  Ce module code le type de données <type>hstore</type> pour stocker des
  ensembles de paires (clé, valeur) à l'intérieur d'un simple champ
  <productname>PostgreSQL</productname>. Cela peut s'avérer utile dans divers
  cas, comme les lignes à attributs multiples rarement examinées ou les données
  semi-structurées.
 </para>

 <sect2>
  <title>Représentation externe de <type>hstore</type></title>

  <para>
   La représentation textuelle d'une valeur <type>hstore</type> inclut
   zéro ou plusieurs paires <replaceable>clé</replaceable>
   <literal>=&gt;</literal> <replaceable>valeur</replaceable> séparées par
   des virgules. Par exemple&nbsp;:

   <programlisting>
    k => v
    foo => bar, baz => whatever
    "1-a" => "anything at all"
   </programlisting>

   L'ordre des éléments n'est pas significatif (et peut ne pas
   être reproduit en sortie). Les espaces entre les éléments ou autour
   du signe <literal>=&gt;</literal> sont ignorées. Des guillemets
   doubles sont nécessaires si une clé ou une valeur inclut espace, virgule,
   <literal>=</literal> ou <literal>&gt;</literal>. Pour inclure un
   guillemet double ou un antislash dans une clé ou une valeur, on le précède
   d'un autre antislash. (En fonction de la configuration
   de <varname>standard_conforming_strings</varname>, il peut s'avérer
   nécessaire de doubler les antislashs dans les chaînes litérales SQL.)
  </para>

  <para>
   Une valeur (mais pas une clé) peut être NULL. Ceci est représenté
   ainsi&nbsp;:

   <programlisting>
    key => NULL
   </programlisting>

   Le mot clé <literal>NULL</literal> est insensible à la casse. Là aussi, on
   utilise les guillemets doubles pour que la chaîne
   <literal>null</literal> soit traitée comme une valeur ordinaire.
  </para>

  <para>
   Actuellement, les guillemets doubles sont utilisés pour entourer les
   chaînes représentant la clé et la valeur en sortie, même si ce n'est pas
   strictement nécessaire.
  </para>

 </sect2>

 <sect2>
  <title>Opérateurs et fonctions <type>hstore</type></title>

  <table id="hstore-op-table">
   <title>Opérateurs<type>hstore</type></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Opérateur</entry>
      <entry>Description</entry>
      <entry>Exemple</entry>
      <entry>Résultat</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><type>hstore</type> <literal>-&gt;</literal> <type>text</type></entry>
      <entry>obtenir la valeur de la clé (NULL si inexistante)</entry>
      <entry><literal>'a=&gt;x, b=&gt;y'::hstore -&gt; 'a'</literal></entry>
      <entry><literal>x</literal></entry>
     </row>

     <row>
      <entry><type>text</type> <literal>=&gt;</literal> <type>text</type></entry>
      <entry>créer un <type>hstore</type> à un seul élément</entry>
      <entry><literal>'a' =&gt; 'b'</literal></entry>
      <entry><literal>"a"=&gt;"b"</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>||</literal> <type>hstore</type></entry>
      <entry>concaténation</entry>
      <entry><literal>'a=&gt;b, c=&gt;d'::hstore || 'c=&gt;x, d=&gt;q'::hstore</literal></entry>
      <entry><literal>"a"=&gt;"b", "c"=&gt;"x", "d"=&gt;"q"</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>?</literal> <type>text</type></entry>
      <entry><type>hstore</type> contient-il une clé donnée&nbsp;?</entry>
      <entry><literal>'a=&gt;1'::hstore ? 'a'</literal></entry>
      <entry><literal>t</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>@&gt;</literal> <type>hstore</type></entry>
      <entry>l'opérande gauche contient-il l'opérande droit&nbsp;?</entry>
      <entry><literal>'a=&gt;b, b=&gt;1, c=&gt;NULL'::hstore @&gt; 'b=&gt;1'</literal></entry>
      <entry><literal>t</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>&lt;@</literal> <type>hstore</type></entry>
      <entry>l'opérande gauche est-il contenu dans l'opérande
      droit&nbsp;?</entry>
      <entry><literal>'a=&gt;c'::hstore &lt;@ 'a=&gt;b, b=&gt;1, c=&gt;NULL'</literal></entry>
      <entry><literal>f</literal></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Avant PostgreSQL 8.2, les opérateurs de contenance @&gt; et &lt;@ étaient
   appelés respectivement @ et ~. Ces noms sont toujours disponibles mais sont
   devenus obsolètes et pourraient éventuellement être supprimés.
   Les anciens noms sont inversés par rapport à la convention suivie par les
   types de données géométriques.
  </para>

  <table id="hstore-func-table">
   <title>Fonctions <type>hstore</type></title>

   <tgroup cols="5">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Type en retour</entry>
      <entry>Description</entry>
      <entry>Exemple</entry>
      <entry>Résultat</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><function>akeys(hstore)</function></entry>
      <entry><type>text[]</type></entry>
      <entry>récupérer les clés du <type>hstore</type> dans un tableau</entry>
      <entry><literal>akeys('a=&gt;1,b=&gt;2')</literal></entry>
      <entry><literal>{a,b}</literal></entry>
     </row>

     <row>
      <entry><function>skeys(hstore)</function></entry>
      <entry><type>setof text</type></entry>
      <entry>récupérer les clés du <type>hstore</type> dans un ensemble</entry>
      <entry><literal>skeys('a=&gt;1,b=&gt;2')</literal></entry>
      <entry>
<programlisting>
a
b
</programlisting></entry>
     </row>

     <row>
      <entry><function>avals(hstore)</function></entry>
      <entry><type>text[]</type></entry>
      <entry>récupérer les valeurs du <type>hstore</type> dans un tableau</entry>
      <entry><literal>avals('a=&gt;1,b=&gt;2')</literal></entry>
      <entry><literal>{1,2}</literal></entry>
     </row>

     <row>
      <entry><function>svals(hstore)</function></entry>
      <entry><type>setof text</type></entry>
      <entry>récupérer les valeurs du <type>hstore</type> dans un
      ensemble</entry>
      <entry><literal>svals('a=&gt;1,b=&gt;2')</literal></entry>
      <entry>
<programlisting>
1
2
</programlisting></entry>
     </row>

     <row>
      <entry><function>each(hstore)</function></entry>
      <entry><type>setof (key text, value text)</type></entry>
      <entry>récupérer les clés et valeurs du <type>hstore</type> dans un
      ensemble</entry>
      <entry><literal>select * from each('a=&gt;1,b=&gt;2')</literal></entry>
      <entry>
<programlisting>
 key | value
-----+-------
 a   | 1
 b   | 2
</programlisting></entry>
     </row>

     <row>
      <entry><function>exist(hstore,text)</function></entry>
      <entry><type>boolean</type></entry>
      <entry>le <type>hstore</type> contient-il une clé donnée&nbsp;?</entry>
      <entry><literal>exist('a=&gt;1','a')</literal></entry>
      <entry><literal>t</literal></entry>
     </row>

     <row>
      <entry><function>defined(hstore,text)</function></entry>
      <entry><type>boolean</type></entry>
      <entry>le <type>hstore</type> contient-il une valeur non NULL pour la
      clé&nbsp;?</entry>
      <entry><literal>defined('a=&gt;NULL','a')</literal></entry>
      <entry><literal>f</literal></entry>
     </row>

     <row>
      <entry><function>delete(hstore,text)</function></entry>
      <entry><type>hstore</type></entry>
      <entry>supprimer tout élément correspondant à une clé donnée</entry>
      <entry><literal>delete('a=&gt;1,b=&gt;2','b')</literal></entry>
      <entry><literal>"a"=>"1"</literal></entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2>
  <title>Index</title>

  <para>
   <type>hstore</type> supporte des index pour les opérateurs
   <literal>@&gt;</literal> et <literal>?</literal>. Les
   types d'index GiST et GIN peuvent être utilisés. Par exemple&nbsp;:
  </para>
  <programlisting>
CREATE INDEX hidx ON testhstore USING GIST(h);

CREATE INDEX hidx ON testhstore USING GIN(h);
  </programlisting>
 </sect2>

 <sect2>
  <title>Exemples</title>

  <para>
   Ajouter une clé, ou mettre à jour une clé existante avec une nouvelle
   valeur&nbsp;:
  </para>
  <programlisting>
UPDATE tab SET h = h || ('c' => '3');
  </programlisting>

  <para>
   Supprimer une clé&nbsp;:
  </para>
  <programlisting>
UPDATE tab SET h = delete(h, 'k1');
  </programlisting>
 </sect2>

 <sect2>
  <title>Statistiques</title>

  <para>
   Le type <type>hstore</type>, du fait de sa libéralité intrinsèque, peut
   contenir beaucoup de clés différentes. C'est à l'application de vérifier
   la validité des clés. Les exemples ci-dessous présentent plusieurs
   techniques pour vérifier les clés et obtenir des statistiques.
  </para>

  <para>
   Exemple simple&nbsp;:
  </para>
  <programlisting>
SELECT * FROM each('aaa=>bq, b=>NULL, ""=>1');
  </programlisting>

  <para>
   En utilisant une table&nbsp;:
  </para>
  <programlisting>
SELECT (each(h)).key, (each(h)).value INTO stat FROM testhstore;
  </programlisting>

  <para>
   Statistiques en ligne&nbsp;:
  </para>
  <programlisting>
SELECT key, count(*) FROM
  (SELECT (each(h)).key FROM testhstore) AS stat
  GROUP BY key
  ORDER BY count DESC, key;
    key    | count
-----------+-------
 line      |   883
 query     |   207
 pos       |   203
 node      |   202
 space     |   197
 status    |   195
 public    |   194
 title     |   190
 org       |   189
...................
  </programlisting>
 </sect2>

 <sect2>
  <title>Auteurs</title>

  <para>
   Oleg Bartunov <email>oleg@sai.msu.su</email>, Moscou, Université de Moscou,
   Russie
  </para>

  <para>
   Teodor Sigaev <email>teodor@sigaev.ru</email>, Moscou, Delta-Soft Ltd.,
   Russie
  </para>
 </sect2>

</sect1>
