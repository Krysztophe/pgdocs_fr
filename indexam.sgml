<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$PostgreSQL: pgsql/doc/src/sgml/indexam.sgml,v 2.7 2005/11/04 23:14:00 petere Exp $
-->

<chapter id="indexam">
 <title>Définition de l'interface des méthodes d'accès aux index</title>

  <para>
   Ce chapitre définit l'interface entre le système
   <productname>PostgreSQL</productname> et les <firstterm>méthodes d'accès
   aux index</firstterm>, qui gére les types d'index individuels. Le système principal
   ne sait rien des index en dehors de ce qui est spécifié ici, donc il est
   possible de développer de nouveaux types d'index en écrivant un code
   supplémentaire.
  </para>

  <para>
   Tous les index de <productname>PostgreSQL</productname> sont connus
   techniquement en tant qu'<firstterm>index secondaires</firstterm>&nbsp;; c'est-à-dire
   que l'index est séparé physiquement de la table qu'il décrit. Chaque index
   est stocké dans sa propre <firstterm>relation</firstterm> physique et est donc décrit
   par une entrée dans le catalogue <structname>pg_class</structname>. Le contenu d'un
   index est entièrement sous le contrôle de la méthode d'accès à l'index. En
   pratique, toutes les méthodes d'accès aux index se divisent en pages de
   taille standard pour qu'elles puissent utiliser le gestionnaire de stockage
   et le gestionnaire de tampon pour accéder au contenu de l'index (de plus,
   toutes les méthodes existantes d'accès aux index utilisent la disposition
   de la page standard décrite dans <xref linkend="storage-page-layout"/>, et
   elles utilisent toutes le même format pour les en-têtes de ligne de
   l'index&nbsp;; mais ces décisions ne sont pas contraintes sur une méthode
   d'index).
  </para>

  <para>
   En fait, un index est une correspondance de valeurs clés de données en
   identifiants de lignes (<firstterm>tuple identifiers</firstterm>, ou <acronym>TIDs</acronym>)
   des versions de lignes dans la table parent de l'index. Un TID consiste en un
   numéro de bloc et un numéro d'élément à l'intérieur de ce bloc (voir <xref
   linkend="storage-page-layout"/>). C'est une information suffisante pour
   récupérer une version de ligne particulière à partir de la table. Les index
   ne sont pas directement conscients que, sous MVCC, il pourrait y avoir
   plusieurs versions de la même ligne logique&nbsp;; pour un index, chaque ligne
   est un objet indépendant qui a besoin de sa propre entrée dans l'index. Du
   coup, une mise à jour d'une ligne crée toujours toutes les nouvelles entrées
   d'index pour la ligne, même si les valeurs de la clé ne changent pas. Les
   entrées d'index pour les lignes mortes sont réclamées (par le VACUUM) lorsque
   les lignes mortes elles-même sont réclamées.
  </para>

 <sect1 id="index-catalog">
  <title>Entrées du catalogue pour les index</title>

  <para>
   Chaque méthode d'accès à l'index est décrite par une ligne dans le catalogue
   système <structname>pg_am</structname> (voir <xref linkend="catalog-pg-am"/>).
   Le contenu principal d'une ligne de <structname>pg_am</structname> est
   constitué de références à des entrées de
   <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>
   indentifiant les fonctions d'accès à l'index fournis par la méthode d'accès.
   Les API pour ces fonctions sont définies plus tard dans ce chapitre. De plus,
   la ligne de <structname>pg_am</structname> spécifie quelques propriétés fixes
   de la méthode d'accès, comme le support des index à plusieurs colonnes. Il
   n'existe pas de support spécial pour la création ou la suppression d'entrées
   dans <structname>pg_am</structname>&nbsp;; toute personne capable d'écrire
   une nouvelle méthode d'accès est supposée assez compétente pour insérer une
   ligne appropriée elle-même.
  </para>

  <para>
   Pour être utile, une méthode d'accès à l'index doit aussi avoir une ou
   plusieurs <firstterm>classes d'opérateur</firstterm> définies dans
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>,
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link> et
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>.
   Ces entrées autorisent le planificateur à déterminer le type de qualification
   des requêtes pouvant être utilisé avec les index de cette méthode d'accès.
   Les classes d'opérateurs sont décrites dans <xref linkend="xindex"/>, qui est
   un élément requis pour comprendre ce chapitre.
  </para>

  <para>
   Un index individuel est défini par une entrée dans
   <link linkend="catalog-pg-class"><structname>pg_class</structname></link>
   le définissant comme une relation physique, et une entrée dans
   <link linkend="catalog-pg-index"><structname>pg_index</structname></link>
   affichant le contenu logique de l'index &mdash; c'est-à-dire des colonnes
   d'index qu'il a et de la sémantique de ces colonnes, de la façon dont elles
   sont récupérées par les classes d'opérateur associées. Les colonnes de
   l'index (valeurs clés) peuvent être soit des colonnes simples de la table
   sous-jacente soit des expressions sur les lignes de la table. Habituellement,
   la méthode d'accès à l'index n'a aucun intérêt dans l'emplacement d'où
   provient les valeurs clés de l'index (ce sont toujours des valeurs clés
   pré-traitées) mais il sera très intéressé dans les informations de la classe
   d'opérateur dans <structname>pg_index</structname>. Ces entrées de catalogue
   peuvent être accédées car elles font partie de la structure de données de
   <structname>Relation</structname> qui est passée dans toutes les opérations de l'index.
  </para>

  <para>
   Certaines des colonnes d'options de <structname>pg_am</structname> ont des
   obligations peu évidentes. Les besoins de <structfield>amcanunique</structfield>
   sont discutés dans  <xref linkend="index-unique-checks"/>, et ceux de
   <structfield>amconcurrent</structfield> dans <xref linkend="index-locking"/>.
   L'option <structfield>amcanmulticol</structfield> assure que la méthode
   d'accès supporte les index multicolonnes alors que 
   <structfield>amoptionalkey</structfield> assure qu'il fera des parcours où
   aucune clause indexable de restriction n'est donnée pour la première colonne
   de l'index. Quand <structfield>amcanmulticol</structfield> est faux,
   <structfield>amoptionalkey</structfield> indique essentiellement si la méthode
   d'accès autorise les parcours complets de l'index sans clause de restriction.
   Les méthodes d'accès qui supportent plusieurs colonnes d'index
   <emphasis>doivent</emphasis> supporter les parcours omettant les restrictions d'une
   ou de toutes les colonnes suivant la première&nbsp;; néanmoins, elles sont
   autorisées à réclamer quelque restrictions pour apparaître  dès la première
   colonne de l'index, et ceci est signalé en initialisant
   <structfield>amoptionalkey</structfield> à faux.
   <structfield>amindexnulls</structfield> assure que les index de l'entrée sont
   créés pour les valeurs clés NULL. Comme la plupart des opérateurs indexables
   sont stricts et, du coup, ne peuvent pas renvoyer TRUE pour des entrées NULL,
   il es à première vue attratif de ne pas stocker les entrées d'index pour les
   valeurs NULL&nbsp;: de toute façon, elles ne peuvent pas être renvoyées par
   un parcours d'index. Néanmoins, cet argument échoue quand un parcours d'index
   n'a pas de clause de restriction pour une colonne d'index donnée. En pratique,
   cela signifie que les index dont <structfield>amoptionalkey</structfield> vaut
   true doivent indexer les valeurs NULL car le planificateur pourrait décider
   d'utiliser un tel index sans clés parcourus. Une restriction relative est
   qu'une méthode d'accès à l'index qui supporte plusieurs colonnes d'index
   <emphasis>doit</emphasis> supporter l'indexage des valeurs NULL dans les colonnes
   suivant la première car le planificateur supposera que l'index peut être
   utilisé pour les requêtes qui ne restreignent pas ces colonnes. Par exemple,
   considérez un index sur (a,b) et une requête avec <literal>WHERE a =
   4</literal>. Le système supposera que l'index peut être utilisé pour les lignes
   avec <literal>a = 4</literal>, ce qui est mauvais si l'index omet les lignes où
   <literal>b</literal> est null. Néanmoins, il est correct d'omettre les lignes où la
   première colonne indexée est NULL (GiST le fait actuellement). Du coup,
   <structfield>amindexnulls</structfield> doit valoir true seulement si la
   méthode d'accès à l'index indexe toutes les lignes, ceci incluant les
   combinaisons arbitraires des valeurs NULL.
  </para>

 </sect1>

 <sect1 id="index-functions">
  <title>Fonctions de la méthode d'accès aux index</title>

  <para>
   Les fonctions de construction et de maintenance d'index que doit fournir
   une méthode d'accès aux index sont&nbsp;:
  </para>

  <para>
<programlisting>
void
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);
</programlisting>
   Construit un nouvel index. La relation de l'index a été créé physiquement
   mais est vide. Elle doit être remplie avec les données fixes dont a besoin
   la méthode d'accès, ainsi que les entrées pour toutes les lignes existant
   déjà dans la table. D'habitude, la fonction <function>ambuild</function> appelera
   <function>IndexBuildHeapScan()</function> pour parcourir la table avec les lignes
   qui existent déjà et pour calculer les clés qui doivent être insérées dans
   l'index.
  </para>

  <para>
<programlisting>
bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          bool check_uniqueness);
</programlisting>
   Insère une nouvelle ligne dans un index existant. Les tableaux
   <literal>values</literal> et <literal>isnull</literal> donnent les valeurs clés à indexer.
   <literal>heap_tid</literal> est le TID à indexer. Si la méthode d'accès supporte les
   index uniques (son drapeau <structname>pg_am</structname>.<structfield>amcanunique</structfield>
   vaut true), alors <literal>check_uniqueness</literal> pourrait aussi valoir true,
   auquel cas la méthode d'accès doit vérifier qu'il n'y a pas de lignes en
   conflit&nbsp;; c'est la seule situation dans laquelle la méthode d'accès a
   habituellement besoin du paramètre <literal>heapRelation</literal>. Voir
   <xref linkend="index-unique-checks"/> pour les détails. Le résultat vaut
   TRUE si une entrée de l'index a été insérée, FALSE sinon (un résultat FALSE
   l'indique par forcément une erreur mais est utilisé dans les cas comme un
   index AM refusant d'indexer une valeur NULL).
  </para>

  <para>
<programlisting>
IndexBulkDeleteResult *
ambulkdelete (Relation indexRelation,
              IndexBulkDeleteCallback callback,
              void *callback_state);
</programlisting>
   Supprime le(s) ligne(s) de l'index. C'est une opération de <quote>suppression
   en flot</quote> qui a pour but d'être implémentée par le parcours complet de
   l'index et par la vérification de chaque entrée pour vérifier si elle
   doit être supprimée. La fonction <literal>callback</literal> passée pourrait être
   appelée, dans le style <literal>callback(<replaceable>TID</replaceable>, callback_state)
   renvoit bool</literal>, pour déterminer si une entrée d'index particulière,
   identifiée par son TID référencé, est à supprimer. Doit renvoyer soit NULL
   soit une structure issue d'un palloc et contenant des statistiques sur les
   effets de l'opération de suppression.
  </para>

  <para>
<programlisting>
IndexBulkDeleteResult *
amvacuumcleanup (Relation indexRelation,
                 IndexVacuumCleanupInfo *info,
                 IndexBulkDeleteResult *stats);
</programlisting>
   Nettoie après une opération <command>VACUUM</command> (un ou plusieurs appels
   à <function>ambulkdelete</function>). Une méthode d'accès à l'index n'a pas besoin de
   fournir cette fonction (si oui, l'entrée dans <structname>pg_am</structname> doit valoir
   zéro). Si elle est fournie, elle est typiquement utilisée pour un nettoyage en
   masse comme pour réclamer des pages d'index vides. <literal>info</literal> fournit
   quelques arguments supplémentaires comme un niveau de message pour des rapports
   statistiques, et <literal>stats</literal> est tout ce que le dernier appel à
   <function>ambulkdelete</function> a pu renvoyer.  <function>amvacuumcleanup</function>
   pourrait remplacer ou modifier cette structure avant de la renvoyer. Si le
   résultat est non NULL, il doit s'agir d'une structure issue d'un palloc. Les
   statistiques qu'elle contient seront rapportées par <command>VACUUM</command> si
   <literal>VERBOSE</literal> est donné.
  </para>

  <para>
   Bien sûr, Le but d'un index est de supporter les parcours de lignes
   correspondant à une condition <literal>WHERE</literal> indexable, souvent appelée
   un <firstterm>qualifieur</firstterm> ou une <firstterm>clé de parcours</firstterm>. La sémantique
   du parcours d'index est décrite plus complètement dans <xref linkend="index-scanning"/>,
   ci-dessous. Les fonctions relatives au parcours qu'une méthode d'accès à
   l'index doit fournir sont&nbsp;:
  </para>

  <para>
<programlisting>
IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             ScanKey key);
</programlisting>
   Débute un nouveau parcours. Le tableau <literal>key</literal> (de longueur
   <literal>nkeys</literal>) décrit les clés de parcours pour le parcours de
   l'index. Le résultat doit être une structure issue de palloc. Pour les
   raisons de l'implémentation, la méthode d'accès à l'index <emphasis>doit</emphasis>
   créer cette structure en appelant <function>RelationGetIndexScan()</function>. Dans
   la plupart des cas, <function>ambeginscan</function> fait peu en dehors de cet
   appel&nbsp;; les parties intéressantes de début du parcours d'index sont
   dans <function>amrescan</function>.
  </para>

  <para>
<programlisting>
boolean
amgettuple (IndexScanDesc scan,
            ScanDirection direction);
</programlisting>
   Récupère la prochaine ligne dans le parcours donné, se déplaçant dans bonne
   direction (en avant ou en arrière dans l'index). Renvoit TRUE si une ligne a
   été obtenue, FALSE s'il ne reste aucune ligne correspondante. Dans le cas
   TRUE, le TID de la ligne est stocké dans la structure <literal>scan</literal>. Notez
   que <quote>success</quote> signifie seulement que l'index contient une entrée
   correspondant aux clés de parcours, pas que la ligne existe toujours dans
   l'en-tête ou réussira le test de l'appelant.
  </para>

  <para>
<programlisting>
boolean
amgetmulti (IndexScanDesc scan,
            ItemPointer tids,
            int32 max_tids,
            int32 *returned_tids);
</programlisting>
   Récupère plusieurs lignes dans le parcours donné. Renvoit TRUE si le parcours
   devait continuer, FALSE si aucune ligne correspondante ne reste.
   <literal>tids</literal> pointe vers un tableau de <literal>max_tids</literal> fourni par
   l'appelant. <structname>ItemPointerData</structname> enregistre, ce que l'appel remplit
   avec les TID des lignes correspondantes. <literal>*returned_tids</literal> est
   initialisé au nombre de TID réellement renvoyé. Ceci peut être moins que
   <literal>max_tids</literal>, voire même zéro, même si la valeur de retour vaut
   TRUE (ceci permet à la méthode d'accès de choisir les points d'arrêt les
   plus efficaces dans son parcours, par exemple les limites de la page d'index).
   <function>amgetmulti</function> et <function>amgettuple</function> ne peuvent pas être utilisés
   dans le même parcours d'index&nbsp;; il y a aussi d'autres restrictions lors de
   l'utilisation de <function>amgetmulti</function>, comme expliqué dans <xref
   linkend="index-scanning"/>.
  </para>

  <para>
<programlisting>
void
amrescan (IndexScanDesc scan,
          ScanKey key);
</programlisting>
   Recommence le parcours donné, si possible avec de nouvelles clés de parcours
   (pour continuer à utiliser les anciennes clés, NULL est passé pour
   <literal>key</literal>). Notez qu'il n'est pas possible de changer le nombre de
   clés. En pratique, la fonctionnalité de relancement est utilisée quand une
   nouvelle ligne externe est sélectionné par une jointure imbriquée en boucle
   et, du coup, la valeur de la comparaison d'une nouvelle clé est nécessaire
   mais la structure de la clé de parcours reste identique. Cette fonction est
   aussi appelée par <function>RelationGetIndexScan()</function>, donc c'est utilisé pour
   une configuration initiale d'un parcours d'index ainsi que pour parcourir de
   nouveau.
  </para>

  <para>
<programlisting>
void
amendscan (IndexScanDesc scan);
</programlisting>
   Termine un parcours et libère les ressources. La structure <literal>scan</literal>
   elle-même ne devrait pas être libérée, mais aucun verrou pris en interne par
   la méthode d'accès doit être libéré.
  </para>

  <para>
<programlisting>
void
ammarkpos (IndexScanDesc scan);
</programlisting>
   Marque la position courante du parcours. La méthode d'accès a seulement
   besoin de supporter le rappel d'une position de parcours par parcours.
  </para>

  <para>
<programlisting>
void
amrestrpos (IndexScanDesc scan);
</programlisting>
   Restaure le parcours à sa plus récente position marquée.
  </para>

  <para>
<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexOptInfo *index,
                List *indexQuals,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);
</programlisting>
   Estime le coût d'un parcours d'index. Cette fonction est décrite complètement
   dans <xref linkend="index-cost-estimation"/>, ci-dessous.
  </para>

  <para>
   Par convention, l'entrée <literal>pg_proc</literal> de toute fonction de
   méthode d'accès aux index devrait afficher le bon nombre d'arguments, mais
   les déclarer comme étant du type <type>internal</type> (car la plupart des
   arguments ont des types qui ne sont pas connus en SQL, et nous ne voulons
   pas que les utilisateurs appelent les fonctions directement). Le type
   renvoyé est déclaré comme <type>void</type>, <type>internal</type> ou <type>boolean</type>
   suivant le cas.
  </para>

 </sect1>

 <sect1 id="index-scanning">
  <title>Parcours d'index</title>

  <para>
   Dans un parcours d'index, la méthode d'accès à l'index est responsable
   de l'ingurgitation des TID de toutes les lignes indiquées comme correspondant
   aux <firstterm>clés de parcours</firstterm>. La méthode d'accès n'est réellement
   impliquée <emphasis>ni</emphasis> dans la récupération de ces lignes à partir de la
   table parent de l'index ni dans la détermination du passage du test de
   qualification ou d'autres conditions.
  </para>

  <para>
   Une clé de parcours est une représentation interne d'une clause <literal>WHERE</literal>
   de la forme <replaceable>clé_index</replaceable> <replaceable>opérateur</replaceable>
   <replaceable>constante</replaceable>, où la clé d'index est une des colonnes de l'index
   et l'opérateur est un des membres de la classe d'opérateur associée avec cette
   colonne d'index. Un parcours d'index a aucune ou plusieurs clés de parcours
   qui sont assemblées implicitement avec des AND &mdash; les lignes renvoyées
   doivent satisfaire toutes les conditions indiquées.
  </para>

  <para>
   La classe d'opérateur peut indiquée que l'index est <firstterm>à perte</firstterm>
   pour un opérateur particulier&nbsp;; ceci implique que le parcours d'index
   renverra toutes les entrées qui correspondent à la clé de parcours, avec
   les entrées supplémentaires qui ne correspondent pas. La machinerie du
   parcours d'index du système principal s'appliquera ensuite cet opérateur
   pour vérifier s'il doit bien être utilisé. Pour les opérateurs sans perte,
   le parcours d'index doit renvoyer exactement l'ensemble d'entrées
   correspondantes cet il n'y aura pas de nouvelle vérification.
  </para>

  <para>
   Notez qu'il est entièrement à la charge de la méthode d'accès de s'assurer
   qu'elle trouve correctement toutes les entrées correspondantes aux clés de
   parcours données, et seulement celles-ci. De plus, le système principal
   donnera toutes les clauses <literal>WHERE</literal> correspondant aux clés d'index
   et aux classes d'opérateurs, sans analyse sémantique déterminant si elles
   sont redondantes ou contradictoires. Comme exemple, étant donné
   <literal>WHERE x &gt; 4 AND x &gt; 14</literal> où <literal>x</literal> est une colonne
   indexée B-tree, elle est passée à la fonction B-tree <function>amrescan</function>
   pour déterminer que la première clé de parcours est redondante et peut être
   annulée. Le supplément de pré-traitement nécessaire lors de
   <function>amrescan</function> dépendra du supplément dont la méthode d'accès à l'index
   a besoin pour réduire les clés de parcours en une forme <quote>normalisée</quote>.
  </para>

  <para>
   La fonction <function>amgettuple</function> dispose d'un argument <literal>direction</literal>,
   qui peut être soit <literal>ForwardScanDirection</literal> (le cas normal) soit
   <literal>BackwardScanDirection</literal>. Si le premier appel après
   <function>amrescan</function> spécifie <literal>BackwardScanDirection</literal>, alors
   l'ensemble d'entrées d'index correspondantes est à parcourir de l'arrière
   vers l'avant plutôt que dans la direction normale, donc
   <function>amgettuple</function> doit renvoyer la dernière ligne correspondante dans
   l'index, plutôt que la première (ceci arrivera seulement pour les méthodes
   d'accès qui indiquent qu'elles supportent les parcours ordonnés en
   initialisant <structname>pg_am</structname>.<structfield>amorderstrategy</structfield> à une
   valeur différente de zéro). Après le premier appel, <function>amgettuple</function>
   doit être préparé pour continuer le parcours dans une direction à partir de
   l'entrée la plus récemment renvoyée.
  </para>

  <para>
   La méthode d'accès doit supporter le <quote>marquage</quote> d'une position dans
   un parcours et le renvoi ultérieur à une position marquée. La même position
   pourrait être restaurée plusieurs fois. Néanmoins, seule une position doit
   être en mémoire par parcours&nbsp;; un nouveau appel à <function>ammarkpos</function>
   surcharge la position marquée précédemment.
  </para>

  <para>
   La position du parcours et du marquage doivent être conservées de façon
   cohérente dans le cas d'insertions et de suppressions concurrentes pendant
   le parcours. Il est considéré correct qu'une entrée tout juste insérée ne
   soit pas renvoyée par un parcours qui aurait trouvé cette entrée si elle
   avait existé au moment où le parcours a commencé, ou que le parcours renvoit
   une telle entrée lors d'un nouveau parcours même si elle n'a pas été renvoyée
   la première fois. De façon similaire, une suppression concurrente pourrait ou
   non être réfléchie dans les résultats d'un parcours. Ce qui est important est
   que les insertions ou suppressions ne causent pas un manque ou un renvoi
   multiple des entrées qui n'ont pas été insérées ou supprimées (pour un type
   d'index qui ne configure pas <structname>pg_am</structname>.<structfield>amconcurrent</structfield>,
   il est suffisant de gérer ces cas pour les insertions et suppressions
   réalisées par le serveur qui effectue le parcours. Mais quand
   <structfield>amconcurrent</structfield> vaut true, les insertions ou suppressions des
   autres serveurs doivent aussi être gérées).
  </para>

  <para>
   Au lieu d'utiliser <function>amgettuple</function>, un parcours d'index peut se faire
   via <function>amgetmulti</function> pour récupérer différentes lignes par appel. Cela
   peut être notablement plus efficace que <function>amgettuple</function> parce que cela
   permet d'éviter les cycles de verrouillage/déverrouillage à l'intérieur de la
   méthode d'accès. En principe, <function>amgetmulti</function> devrait avoir les mêmes
   effets que des appels répétés à <function>amgettuple</function>, mais nous imposons
   plusieurs restrictions pour simplifier la gestion. En premier lieu,
   <function>amgetmulti</function> ne prend pas d'argument <literal>direction</literal>. Du coup,
   il ne supporte ni les parcours inverses ni le changement de direction lors d'un
   parcours. La méthode d'accès n'a pas besoin de supporter le marquage ou la
   restauration des positions de parcours lors d'un parcours
   <function>amgetmulti</function> (ces restrictions ne coûtent rien car il serait difficile
   d'utiliser ces fonctionnalités y compris dans le cas d'un parcours
   <function>amgetmulti</function>&nbsp;: ajuster la liste en tampon des TIDs de l'appelant
   serait complexe). Enfin, <function>amgetmulti</function> ne garantie pas un verrouillage
   des lignes renvoyées, avec les implications précisées dans <xref
   linkend="index-locking"/>.
  </para>

 </sect1>

 <sect1 id="index-locking">
  <title>Considérations pour le verrouillage d'index</title>

  <para>
   Une méthode d'accès aux index peut choisir si elle supporte les mises à jour
   concurrentes de l'index par plusieurs processus. Si le drapeau
   <structname>pg_am</structname>.<structfield>amconcurrent</structfield> de la méthode vaut true,
   alors le système principal <productname>PostgreSQL</productname> obtient
   <literal>AccessShareLock</literal> sur l'index lors d'un parcours d'index et
   <literal>RowExclusiveLock</literal> quand il le met à jour. Comme ces types de
   verrous ne sont pas en conflit, la méthode d'accès est responsable de la
   gestion d'un verrouillage plus précis si nécessaire. Un verrou exclusif sur
   l'index entier sera seulement pris lors de la création, destruction de l'index
   ou dans une opération <literal>REINDEX</literal>. Quand <structfield>amconcurrent</structfield>
   vaut false, <productname>PostgreSQL</productname> obtient toujours
   <literal>AccessShareLock</literal> lors des parcours d'index mais il obtient
   <literal>AccessExclusiveLock</literal> pour une mise à jour. Ceci nous assure que
   les processus mettant à jour ont l'utilisation exclusive de l'index. Notez
   que ceci assume implicitement que les parcours d'index sont en lecture
   seule&nbsp;; une méthode d'accès qui pourrait modifier l'index lors d'un
   parcours devra toujours faire son propre verrouillage pour gérer les cas
   des parcours concurrents.
  </para>

  <para>
   Rappelez-vous que les verrous d'un processus ne sont jamais en conflit&nbsp;;
   du coup, même un type d'index non concurrent doit être préparé à gérer le cas
   où un moteur insère ou supprime des entrées dans un index qui est lui-même en
   train de parcourir (bien sûr, ceci est nécessaire pour supporter un
   <command>UPDATE</command> qui utilise l'index pour trouver les lignes à mettre à
   jour).
  </para>

  <para>
   Construire un type d'index qui supporte les mises à jour concurrentes
   requiert une analyse complète et subtile du comportement requis. Pour les
   types d'index B-tree et hash, vous pouvez lire les décisions du concept dans
   <filename>src/backend/access/nbtree/README</filename> et
   <filename>src/backend/access/hash/README</filename>.
  </para>

  <para>
   En plus des besoins de cohérence interne de l'index, les mises à jour
   concurrentes créent des problèmes de cohérence entre la table parent
   (l'<firstterm>en-tête</firstterm>) et l'index. Comme
   <productname>PostgreSQL</productname> sépare les accès et les mises à
   jour de l'en-tête de ceux de l'index, il existe des possibilités pour que
   l'index ne soit pas à jour par rapport à l'en-tête. Nous gérons ce problème
   avec les règles suivantes&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Une nouvelle entrée dans l'en-tête est effectuée avant sa contrepartie
       dans l'index (du coup, un parcours d'index concurrent pourrait ne pas
       voir l'entrée dans l'en-tête&nbsp;; ceci est bon car le lecteur de
       l'index ne sera pas intéressé par une ligne non validée... voir
       <xref linkend="index-unique-checks"/>).
      </para>
     </listitem>
     <listitem>
      <para>
       Quand une entrée de l'en-tête doit être supprimée (par <command>VACUUM</command>),
       toutes les entrées de l'index doivent d'abord être supprimées.
      </para>
     </listitem>
     <listitem>
      <para>
       Pour des types d'index concurrents, un parcours d'index doit maintenir
       un lien sur la page d'index contenant le dernier élément renvoyé par
       <function>amgettuple</function>, et <function>ambulkdelete</function> ne peut pas
       supprimer les entrées de pages qui sont liées à d'autres processus. Le
       besoin de cette règle est expliqué plus bas.
      </para>
     </listitem>
    </itemizedlist>

   Si un index est concurrent alors il est possible qu'un lecteur d'index voit
   une entrée dans l'index juste avant qu'elle ne soit supprimée par un
   <command>VACUUM</command>, puis d'arriver à l'entrée correspondante de l'en-tête
   après qu'elle soit supprimée par le <command>VACUUM</command> (avec un index non
   concurrent, ceci n'est pas possible à cause des verrous conflictuels au
   niveau index). Ceci ne crée pas de problèmes sérieux si ce numéro d'élément
   est toujours inutilisé quand le lecteur l'atteint car un emplacement d'élément
   vide sera ignoré par <function>heap_fetch()</function>. Mais que se passe-t'il si
   un troisième moteur a déjà ré-utilisé l'emplacement de l'élément pour quelque
   chose d'autre&nbsp;? Lors de l'utilisation d'une image compatible MVCC, il n'y
   a pas de problème car le nouvel occupant de l'emplacement est certain d'être
   trop nouveau pour accepter ou renvoyer une ligne qui, en fait, ne correspond
   pas aux clés de parcours. Nous pouvons nous défendre contre ce scénario en
   réclamant que les clés de parcours soient de nouveau vérifiées avec la ligne
   d'en-tête dans tous les cas mais c'est bien trop coûteux. À la place, nous
   utilisons un lien sur une page d'index comme un proxy, pour indiquer que le
   lecteur pourrait toujours être <quote>en parcours</quote> à partir de l'entrée de
   l'index jusqu'à l'entrée correspondante. Faire bloquer <function>ambulkdelete</function>
   sur un tel lien nous assure qu'un <command>VACUUM</command> ne peut pas supprimer
   l'entrée de l'en-tête avant que le lecteur n'en ait terminé avec lui. Cette
   solution coûte peu en temps d'exécution mais ajoute un délai dans le blocage
   dans de rares cas où il existe réellement un conflit.
  </para>

  <para>
   Cette solution requiert que les parcours d'index soient
   <quote>synchrones</quote>&nbsp;: nous devons récupérer chaque ligne d'en-tête
   immédiatement après avoir parcouru l'entrée d'index correspondante. Ceci
   est coûteux pour plusieurs raisons. Un parcours <quote>asynchrone</quote> dans
   lequel nous récupérons les TID de l'index et dans lequel nous visitons
   seulement les en-têtes de lignes un peu plus tard, requiert moins de temps
   de verrouillage de l'index et pourrait autoriser un modèle d'accès à
   l'en-tête plus efficace. En plus de l'analyse ci-dessus, nous devons
   utiliser l'approche synchronisée pour les images non compatibles avec
   MVCC mais un parcours asynchrone est possible pour une requête utilisant
   une image MVCC.
  </para>

  <para>
   Dans un parcours d'index <function>amgetmulti</function>, la méthode d'accès n'a pas
   besoin de garantir la conservation d'un lien à l'index sur aucune des lignes
   renvoyées, ce qui est impraticable pour toutes sauf la dernière). Du coup, il
   est plus sage d'utiliser plusieurs parcours avec des images compatibles MVCC.
  </para>

 </sect1>

 <sect1 id="index-unique-checks">
  <title>Vérification de l'unicité de l'index</title>

  <para>
   <productname>PostgreSQL</productname> renforce les contraintes SQL d'unicité
   en utilisant les <firstterm>index uniques</firstterm>, qui sont des index qui refusent
   les entrées multiples avec des clés identiques. Une méthode d'accès qui
   supporte cette fonctionnalité initialise
   <structname>pg_am</structname>.<structfield>amcanunique</structfield> à true (à présent, seul
   B-tree le supporte).
  </para>

  <para>
   Grâce à MVCC, il est toujours nécessaire d'autoriser les entrées dupliquées
   à exister physiquement dans un index&nbsp;: mes entrées pourraient faire
   référence à des versions successives d'une même ligne logique. Le comportement
   que nous voulons réellement renforcer est qu'aucune image MVCC n'inclut deux
   lignes avec les mêmes clés d'index. Ceci crée les différents cas suivants
   devant être vérifiés lors de l'insertion d'une nouvelle ligne dans un index
   unique&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Si une ligne valide en conflit a été supprimée par une transaction
       concurrente, tout va bien (en particulier, comme un UPDATE supprime
       outjours l'ancienne version de la ligne avant d'insérer la nouvelle
       version, ceci permettra un UPDATE sur une ligne sans changer la clé).
      </para>
     </listitem>
     <listitem>
      <para>
       If a conflicting row has been inserted by an as-yet-uncommitted
       transaction, the would-be inserter must wait to see if that transaction
       commits.  If it rolls back then there is no conflict.  If it commits
       without deleting the conflicting row again, there is a uniqueness
       violation.  (In practice we just wait for the other transaction to
       end and then redo the visibility check in toto.)
      </para>
     </listitem>
     <listitem>
      <para>
       De façon similaire, si une ligne valide en conflit a été supprimée par
       une transaction encore non validée, l'inserteur doit attendre la
       validation ou l'annulation de cette transaction, puis répère le test.
      </para>
     </listitem>
    </itemizedlist>
  </para>

  <para>
   Nous réclamons que la méthode d'accès à l'index applique ces tests eux-même,
   ce qui signifient qu'ils doivent attendre l'en-tête pour vérifier le
   statu de validation d'une ligne qui est affichée comme une clé dupliquée
   suivant le contenu de l'index. Ceci est sans aucun doute moche et non
   modulaire, mais il permet d'aviter un travail redondant&nbsp;: si nous
   faisons un test séparé, alors la recherche d'index pour une ligne en
   conflit pourrait être essentiellement répétée lors de la découverte d'emplacement
   pour insérer la nouvelle entrée d'index de ligne. De plus, il n'existe
   aucun moyen pour éviter des conditions rares sans que la vérification de
   contrainte ne soit une partie intégrale d'insertion du nouvel entrée d'index.
  </para>

  <para>
   Le principale limitation de ce schéma est qu'il n'existe pas de façon aisée
   de supporter les vérifications d'unicité déferrées.
  </para>

 </sect1>

 <sect1 id="index-cost-estimation">
  <title>Fonctions d'estimation des coûts d'index</title>

  <para>
   La fonction amcostestimate se voit donnée une liste de clauses WHERE qui ont
   été déterminées pour être utilisables avec l'index. Il doit renvoyer une
   estimation du coût de l'accès d'index et de la sélectivité des clauses
   WHERE (c'est-à-dire la fraction des lignes de la table parent qui seront
   récupérées lors du parcours de l'index). Pour les cas simples, pratiquement
   tout le travail de l'estimateur de coût peut être effectué en appelant des
   routines standards dans l'optimiseur&nbsp;; la raison d'avoir une fonction
   amcostestimate est d'autoriser les méthodes d'accès aux index pour fournir
   une connaissance spécifique au type d'index, au cas où il est possible
   d'améliorer les estimations standards.
  </para>

  <para>
   Chaque fonction amcostestimate doit avoir la signature&nbsp;:

<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexOptInfo *index,
                List *indexQuals,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);
</programlisting>

   Les quatre premiers paramètres sont des entrées&nbsp;:

   <variablelist>
    <varlistentry>
     <term>root</term>
     <listitem>
      <para>
       Information du plannificateur sur la requête en cours de traitement.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>index</term>
     <listitem>
      <para>
       Index considéré.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>indexQuals</term>
     <listitem>
      <para>
       Liste des clauses qual d'index (implicitement assemblées avec des AND)&nbsp;;
       une liste NIL indique qu'aucun qualificateur n'est disponible.
       Notez que la liste contient des arbres d'expression, pas ScanKeys.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les quatre derniers paramètres sont passées par leur référence&nbsp;:

   <variablelist>
    <varlistentry>
     <term>*indexStartupCost</term>
     <listitem>
      <para>
       Initialisé au coût du lancement du traitement de l'index
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexTotalCost</term>
     <listitem>
      <para>
       Initialisé au coût du traitement total par l'index
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexSelectivity</term>
     <listitem>
      <para>
       Initialisé à la sélectivité de l'index
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexCorrelation</term>
     <listitem>
      <para>
       Initialisé au coefficient de corrélation entre l'ordre du parcours de
       l'index et l'ordre sous-jacent de la table
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Notez que les fonctions d'estimation de coûts doivent être écrits en C, pas
   en SQL ou dans un autre langage de procédure, parce qu'elles doivent accéder
   aux structures de données internes du plannificateur/optimiseur.
  </para>

  <para>
   Les coûts d'accès aux index doivent être calculés dans les unités utilisés
   par <filename>src/backend/optimizer/path/costsize.c</filename>&nbsp;: la
   récupération d'un bloc disque séquentiel a un coût de 1.0, une récupération
   non séquentielle a un coût de <varname>random_page_cost</varname>, et le coût de
   traitement d'une ligne d'index doit habituellement être considéré comme
   <varname>cpu_index_tuple_cost</varname>. De plus, un multiple approprié de
   <varname>cpu_operator_cost</varname> doit être chargé pour tous les opérateurs
   de comparaison impliqués lors du traitement de l'index (spécialement
   l'évaluation des indexQuals).
  </para>

  <para>
   Les coûts d'accès doivent inclure tous les coûts dûs aux disques et au CPU
   associés au parcours d'index lui-même, mais <emphasis>pas</emphasis> les coûts de
   récupération ou de traitement des lignes de la table parent qui sont
   identifiées par l'index.
  </para>

  <para>
   Le <quote>coût de lancement</quote> est la partie du coût du parcours total
   devant être étendu avant que nous commencions à récupérer la première ligne.
   Pour la plupart des index, cela peut être considéré comme zéro mais un type
   d'index avec un grand coût de lancement pourrait vouloir le configurer à
   une autre valeur que zéro.
  </para>

  <para>
   indexSelectivity devrait être initialisé à la fraction estimée des lignes
   de la table parent qui seront récupérées lors du parcours d'index. Au cas
   où il s'agit d'un index à perte, cela sera typiquement plus haut que la
   fraction des lignes qui réussissent les conditions qual données.
  </para>

  <para>
   The indexCorrelation should be set to the correlation (ranging between
   -1.0 and 1.0) between the index order and the table order.  This is used
   to adjust the estimate for the cost of fetching rows from the parent
   table.
  </para>

  <procedure>
   <title>Estimation du coût</title>
   <para>
    Un estimateur typique de coût exécutera le traitement ainsi&nbsp;:
   </para>

   <step>
    <para>
     Estime et renvoit la fraction des lignes de la table parent qui seront
     visitées suivant les conditions qual données. En l'absence de toute
     connaissance spécifique sur le type de l'index, utilisez la fonction
     de l'optimiseur standard <function>clauselist_selectivity()</function>:

<programlisting>
*indexSelectivity = clauselist_selectivity(root, indexQuals,
                                           index-&gt;rel-&gt;relid, JOIN_INNER);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de lignes d'index qui sera visité lors du parcours. Pour
     de nombreux types d'index, ceci vaut indexSelectivity fois le nombre de
     lignes dans l'index, mais cela pourrait valoir plus (notez que la taille
     de l'index en pages et lignes est disponible à partir de la structure
     IndexOptInfo).
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de pages d'index qui sera récupéré pendant le parcours.
     Ceci pourrait être simplement indexSelectivity fois la taille de l'index
     en pages.
    </para>
   </step>

   <step>
    <para>
     Calcule le coût d'accès à l'index. Un estimateur générique pourrait le
     faire ainsi&nbsp;:

<programlisting>
    /*
     * Our generic assumption is that the index pages will be read
     * sequentially, so they have cost 1.0 each, not random_page_cost.
     * Also, we charge for evaluation of the indexquals at each index row.
     * All the costs are assumed to be paid incrementally during the scan.
     */
    cost_qual_eval(&amp;index_qual_cost, indexQuals);
    *indexStartupCost = index_qual_cost.startup;
    *indexTotalCost = numIndexPages +
        (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;
</programlisting>
    </para>
   </step>

   <step>
    <para>
     Estime la corrélation de l'index. Pour un index ordonné sur un seul champ,
     ceci peut se récupérer de pg_statistic. Si la corrélation est inconnue,
     l'estimation conservative est zéro (pas de corrélation).
    </para>
   </step>
  </procedure>

  <para>
   Des exemples de fonctions d'estimation du coût sont disponibles dans
   <filename>src/backend/utils/adt/selfuncs.c</filename>.
  </para>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
