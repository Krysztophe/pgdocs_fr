<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $PostgreSQL: pgsql/doc/src/sgml/indexam.sgml,v 2.7 2005/11/04 23:14:00 petere Exp $ -->

<chapter id="indexam">
 <title>Définition de l'interface des méthodes d'accès aux index</title>

  <para>
   Ce chapitre définit l'interface entre le système
   <productname>PostgreSQL</productname> et les <firstterm>méthodes d'accès
   aux index</firstterm>, qui gére les types d'index individuels. Le système principal
   ne sait rien des index en dehors de ce qui est spécifié ici, donc il est
   possible de développer de nouveaux types d'index en écrivant un code
   supplémentaire.
  </para>

  <para>
   Tous les index de <productname>PostgreSQL</productname> sont connus
   techniquement en tant qu'<firstterm>index secondaires</firstterm>&nbsp;; c'est-à-dire
   que l'index est séparé physiquement de la table qu'il décrit. Chaque index
   est stocké dans sa propre <firstterm>relation</firstterm> physique et est donc décrit
   par une entrée dans le catalogue <structname>pg_class</structname>. Le contenu d'un
   index est entièrement sous le contrôle de la méthode d'accès à l'index. En
   pratique, toutes les méthodes d'accès aux index se divisent en pages de
   taille standard pour qu'elles puissent utiliser le gestionnaire de stockage
   et le gestionnaire de tampon pour accéder au contenu de l'index (de plus,
   toutes les méthodes existantes d'accès aux index utilisent la disposition
   de la page standard décrite dans <xref linkend="storage-page-layout"/>, et
   elles utilisent toutes le même format pour les en-têtes de ligne de
   l'index&nbsp;; mais ces décisions ne sont pas contraintes sur une méthode
   d'index).
  </para>

  <para>
   En fait, un index est une correspondance de valeurs clés de données en
   identifiants de lignes (<firstterm>tuple identifiers</firstterm>, ou <acronym>TIDs</acronym>)
   des versions de lignes dans la table parent de l'index. Un TID consiste en un
   numéro de bloc et un numéro d'élément à l'intérieur de ce bloc (voir <xref
   linkend="storage-page-layout"/>). C'est une information suffisante pour
   récupérer une version de ligne particulière à partir de la table. Les index
   ne sont pas directement conscients que, sous MVCC, il pourrait y avoir
   plusieurs versions de la même ligne logique&nbsp;; pour un index, chaque ligne
   est un objet indépendant qui a besoin de sa propre entrée dans l'index. Du
   coup, une mise à jour d'une ligne crée toujours toutes les nouvelles entrées
   d'index pour la ligne, même si les valeurs de la clé ne changent pas. Les
   entrées d'index pour les lignes mortes sont réclamées (par le VACUUM) lorsque
   les lignes mortes elles-même sont réclamées.
  </para>

 <sect1 id="index-catalog">
  <title>Entrées du catalogue pour les index</title>

  <para>
   Chaque méthode d'accès à l'index est décrite par une ligne dans le catalogue
   système <structname>pg_am</structname> (voir <xref linkend="catalog-pg-am"/>).
   Le contenu principal d'une ligne de <structname>pg_am</structname> est
   constitué de références à des entrées de
   <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>
   identifiant les fonctions d'accès à l'index fournis par la méthode d'accès.
   Les API pour ces fonctions sont définies plus tard dans ce chapitre. De plus,
   la ligne de <structname>pg_am</structname> spécifie quelques propriétés fixes
   de la méthode d'accès, comme le support des index à plusieurs colonnes. Il
   n'existe pas de support spécial pour la création ou la suppression d'entrées
   dans <structname>pg_am</structname>&nbsp;; toute personne capable d'écrire
   une nouvelle méthode d'accès est supposée assez compétente pour insérer une
   ligne appropriée elle-même.
  </para>

  <para>
   Pour être utile, une méthode d'accès à l'index doit aussi avoir une ou
   plusieurs <firstterm>familles d'opérateur</firstterm> et <firstterm>classes
   d'opérateur</firstterm> définies dans
   <link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>,
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>,
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link> et
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>.
   Ces entrées autorisent le planificateur à déterminer le type de qualification
   des requêtes pouvant être utilisé avec les index de cette méthode d'accès.
   Les familles et classes d'opérateurs sont décrites dans <xref
   linkend="xindex"/>, qui est un élément requis pour comprendre ce chapitre.
  </para>

  <para>
   Un index individuel est défini par une entrée dans
   <link linkend="catalog-pg-class"><structname>pg_class</structname></link>
   le définissant comme une relation physique, et une entrée dans
   <link linkend="catalog-pg-index"><structname>pg_index</structname></link>
   affichant le contenu logique de l'index &mdash; c'est-à-dire des colonnes
   d'index qu'il a et de la sémantique de ces colonnes, de la façon dont elles
   sont récupérées par les classes d'opérateur associées. Les colonnes de
   l'index (valeurs clés) peuvent être soit des colonnes simples de la table
   sous-jacente soit des expressions sur les lignes de la table. Habituellement,
   la méthode d'accès à l'index n'a aucun intérêt dans l'emplacement d'où
   provient les valeurs clés de l'index (ce sont toujours des valeurs clés
   pré-traitées) mais il sera très intéressé dans les informations de la classe
   d'opérateur dans <structname>pg_index</structname>. Ces entrées de catalogue
   peuvent être accédées car elles font partie de la structure de données de
   <structname>Relation</structname> qui est passée dans toutes les opérations de l'index.
  </para>

  <para>
   Certaines des colonnes d'options de <structname>pg_am</structname> ont des
   obligations peu évidentes. Les besoins de <structfield>amcanunique</structfield>
   sont discutés dans  <xref linkend="index-unique-checks"/>.
   L'option <structfield>amcanmulticol</structfield> assure que la méthode
   d'accès supporte les index multicolonnes alors que 
   <structfield>amoptionalkey</structfield> assure qu'il fera des parcours où
   aucune clause indexable de restriction n'est donnée pour la première colonne
   de l'index. Quand <structfield>amcanmulticol</structfield> est faux,
   <structfield>amoptionalkey</structfield> indique essentiellement si la méthode
   d'accès autorise les parcours complets de l'index sans clause de restriction.
   Les méthodes d'accès qui supportent plusieurs colonnes d'index
   <emphasis>doivent</emphasis> supporter les parcours omettant les restrictions d'une
   ou de toutes les colonnes suivant la première&nbsp;; néanmoins, elles sont
   autorisées à réclamer quelque restrictions pour apparaître  dès la première
   colonne de l'index, et ceci est signalé en initialisant
   <structfield>amoptionalkey</structfield> à faux.
   <structfield>amindexnulls</structfield> assure que les index de l'entrée sont
   créés pour les valeurs clés NULL. Comme la plupart des opérateurs indexables
   sont stricts et, du coup, ne peuvent pas renvoyer TRUE pour des entrées NULL,
   il est à première vue attratif de ne pas stocker les entrées d'index pour les
   valeurs NULL&nbsp;: de toute façon, elles ne peuvent pas être renvoyées par
   un parcours d'index. Néanmoins, cet argument échoue quand un parcours d'index
   n'a pas de clause de restriction pour une colonne d'index donnée. En pratique,
   cela signifie que les index dont <structfield>amoptionalkey</structfield> vaut
   true doivent indexer les valeurs NULL car le planificateur pourrait décider
   d'utiliser un tel index sans clés parcourus. Une restriction relative est
   qu'une méthode d'accès à l'index qui supporte plusieurs colonnes d'index
   <emphasis>doit</emphasis> supporter l'indexage des valeurs NULL dans les colonnes
   suivant la première car le planificateur supposera que l'index peut être
   utilisé pour les requêtes qui ne restreignent pas ces colonnes. Par exemple,
   considérez un index sur (a,b) et une requête avec <literal>WHERE a =
   4</literal>. Le système supposera que l'index peut être utilisé pour les lignes
   avec <literal>a = 4</literal>, ce qui est mauvais si l'index omet les lignes où
   <literal>b</literal> est null. Néanmoins, il est correct d'omettre les lignes où la
   première colonne indexée est NULL. Du coup,
   <structfield>amindexnulls</structfield> doit valoir true seulement si la
   méthode d'accès à l'index indexe toutes les lignes, ceci incluant les
   combinaisons arbitraires des valeurs NULL. Une méthode d'accès d'index qui
   initialise <structfield>amindexnulls</structfield> peut aussi initialiser
   <structfield>amsearchnulls</structfield>, indiquant ainsi qu'il supporte
   les clauses <literal>IS NULL</literal> dans les conditions de recherche.
  </para>

 </sect1>

 <sect1 id="index-functions">
  <title>Fonctions de la méthode d'accès aux index</title>

  <para>
   Les fonctions de construction et de maintenance d'index que doit fournir
   une méthode d'accès aux index sont&nbsp;:
  </para>

  <para>
<programlisting>IndexBuildResult *
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);
</programlisting>
   Construit un nouvel index. La relation de l'index a été créée physiquement
   mais elle est vide. Elle doit être remplie avec les données fixes dont a besoin
   la méthode d'accès, ainsi que les entrées pour toutes les lignes existant
   déjà dans la table. D'habitude, la fonction <function>ambuild</function> appellera
   <function>IndexBuildHeapScan()</function> pour parcourir la table avec les lignes
   qui existent déjà et pour calculer les clés qui doivent être insérées dans
   l'index. La fonction doit renvoyer une structure allouée par palloc contenant
   les statistiques sur le nouvel index.
  </para>

  <para>
<programlisting>bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          bool check_uniqueness);
</programlisting>
   Insère une nouvelle ligne dans un index existant. Les tableaux
   <literal>values</literal> et <literal>isnull</literal> donnent les valeurs clés à indexer.
   <literal>heap_tid</literal> est le TID à indexer. Si la méthode d'accès supporte les
   index uniques (son drapeau <structname>pg_am</structname>.<structfield>amcanunique</structfield>
   vaut true), alors <literal>check_uniqueness</literal> pourrait aussi valoir true,
   auquel cas la méthode d'accès doit vérifier qu'il n'y a pas de lignes en
   conflit&nbsp;; c'est la seule situation dans laquelle la méthode d'accès a
   habituellement besoin du paramètre <literal>heapRelation</literal>. Voir
   <xref linkend="index-unique-checks"/> pour les détails. Le résultat vaut
   TRUE si une entrée de l'index a été insérée, FALSE sinon (un résultat FALSE
   l'indique par forcément une erreur mais est utilisé dans les cas comme un
   index AM refusant d'indexer une valeur NULL).
  </para>

  <para>
<programlisting>IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
              IndexBulkDeleteResult *stats,
              IndexBulkDeleteCallback callback,
              void *callback_state);
</programlisting>
   Supprime le(s) ligne(s) de l'index. C'est une opération de <quote>suppression
   en flot</quote> qui a pour but d'être implémentée par le parcours complet de
   l'index et par la vérification de chaque entrée pour vérifier si elle
   doit être supprimée. La fonction <literal>callback</literal> passée doit être
   appelée, dans le style <literal>callback(<replaceable>TID</replaceable>, callback_state)
   renvoie bool</literal>, pour déterminer si une entrée d'index particulière,
   identifiée par son TID référencé, est à supprimer. Doit renvoyer soit NULL
   soit une structure issue d'un palloc et contenant des statistiques sur les
   effets de l'opération de suppression.
   Il est bien de renvoyer NULL s'il n'est pas nécessaire de renvoyer des
   informations à <function>amvacuumcleanup</function>.
  </para>

  <para>
   À cause d'un <varname>maintenance_work_mem</varname> limité,
   <function>ambulkdelete</function> pourrait nécessiter d'être appelé plus
   d'une fois lorsque plusieurs lignes sont supprimées. L'argument
   <literal>stats</literal> est le résultat du dernier appel pour cet index
   (il est NULL pour le premier appel à l'intérieur d'une opération
   <command>VACUUM</command>). Ceci permet à l'AM d'accumuler les statistiques
   sur une même opération. Typiquement, <function>ambulkdelete</function>
   modifiera et renverra la même structure si le <literal>stats</literal> fourni
   n'est pas NULL.
  </para>

  <para>
<programlisting>IndexBulkDeleteResult *
amvacuumcleanup (IndexVacuumInfo *info,
                 IndexBulkDeleteResult *stats);
</programlisting>
   Nettoie après une opération <command>VACUUM</command> (zéro ou plus d'appels
   à <function>ambulkdelete</function>). Ceci n'a rien à voir avec autre chose
   que le renvoi des statistiques des index, mais il peut réaliser un nettoyage
   en masse, comme réclamer les pages d'index vides. <literal>stats</literal>
   est ce que renvoie l'appel à <function>ambulkdelete</function>, ou NULL si
   <function>ambulkdelete</function> n'a pas été appelé car aucune ligne n'avait
   besoin d'être supprimée. Si le résultat n'est pas NULL, il est une structure
   allouée avec palloc. Les statistiques qu'elle contient seront utilisées pour
   mettre à jour <structname>pg_class</structname>, et seront rapportées par
   <command>VACUUM</command> si <literal>VERBOSE</literal> est indiqué. Il est
   bien de renvoyer NULL si l'index n'a pas changé du tout lors de l'opération
   de <command>VACUUM</command> mais, sinon, des statistiques correctes devront
   être renvoyées.
  </para>

  <para>
<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexOptInfo *index,
                List *indexQuals,
                RelOptInfo *outer_rel,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);
</programlisting>
   Estime les coûts d'un parcours d'index. Cette fonction est décrite complètement
   dans <xref linkend="index-cost-estimation"/>, ci-dessous.
  </para>

  <para>
<programlisting>
bytea *
amoptions (ArrayType *reloptions,
           bool validate);
</programlisting>
   Analyse et valide le tableau reloptions pour un index. C'est appelé seulement
   quand un tableau reloptions non NULL existe pour l'index.
   <parameter>reloptions</parameter> est un tableau de type <type>text</type>
   contenant des entrées de la forme
   <replaceable>nom</replaceable><literal>=</literal><replaceable>valeur</replaceable>.
   La fonction devrait construire une valeur de type <type>bytea</type> qui sera
   copiée dans le champ <structfield>rd_options</structfield> de l'entrée relcache
   de l'index. Les données contenues dans la valeur <type>bytea</type> dépendent
   de la méthode d'accès mais les méthodes d'accès standards utilisent actuellement
   tous la structure <structname>StdRdOptions</structname>.
   Quand <parameter>validate</parameter> est true, la fonction devrait rapporter
   un message d'erreur convenable si aucune des option n'est pas reconnue ou a des
   valeurs invalides&nbsp;; quand <parameter>validate</parameter> est false, les
   entrées invalides devraient être ignorées silencieusement.
   (<parameter>validate</parameter> est faux lors du chargement des options déjà
   stockées dans <structname>pg_catalog</structname>&nbsp;; une entrée invalide
   pourrait seulement être trouvée si la méthode d'accès a modifié ses règles pour
   les options et, dans ce cas, ignorer les entrées obsolètes est approprié.)
   Il est aussi bon de renvoyer NULL si le comportement par défaut est voulu.
  </para>

  <para>
   Bien sûr, Le but d'un index est de supporter les parcours de lignes
   correspondant à une condition <literal>WHERE</literal> indexable, souvent appelée
   un <firstterm>qualifieur</firstterm> ou une <firstterm>clé de parcours</firstterm>. La sémantique
   du parcours d'index est décrite plus complètement dans <xref linkend="index-scanning"/>,
   ci-dessous. Les fonctions relatives au parcours qu'une méthode d'accès à
   l'index doit fournir sont&nbsp;:
  </para>

  <para>
<programlisting>IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             ScanKey key);
</programlisting>
   Débute un nouveau parcours. Le tableau <literal>key</literal> (de longueur
   <literal>nkeys</literal>) décrit les clés de parcours pour le parcours de
   l'index. Le résultat doit être une structure issue de palloc. Pour les
   raisons de l'implémentation, la méthode d'accès à l'index <emphasis>doit</emphasis>
   créer cette structure en appelant <function>RelationGetIndexScan()</function>. Dans
   la plupart des cas, <function>ambeginscan</function> fait peu en dehors de cet
   appel&nbsp;; les parties intéressantes de début du parcours d'index sont
   dans <function>amrescan</function>.
  </para>

  <para>
<programlisting>boolean
amgettuple (IndexScanDesc scan,
            ScanDirection direction);
</programlisting>
   Récupère la prochaine ligne dans le parcours donné, se déplaçant dans bonne
   direction (en avant ou en arrière dans l'index). Renvoie TRUE si une ligne a
   été obtenue, FALSE s'il ne reste aucune ligne correspondante. Dans le cas
   TRUE, le TID de la ligne est stocké dans la structure <literal>scan</literal>. Notez
   que <quote>success</quote> signifie seulement que l'index contient une entrée
   correspondant aux clés de parcours, pas que la ligne existe toujours dans
   l'en-tête ou réussira le test de l'appelant.
  </para>

  <para>
<programlisting>boolean
amgetmulti (IndexScanDesc scan,
            ItemPointer tids,
            int32 max_tids,
            int32 *returned_tids);
</programlisting>
   Récupère plusieurs lignes dans le parcours donné. Renvoie TRUE si le parcours
   devait continuer, FALSE si aucune ligne correspondante ne reste.
   <literal>tids</literal> pointe vers un tableau de <literal>max_tids</literal> fourni par
   l'appelant. <structname>ItemPointerData</structname> enregistre, ce que l'appel remplit
   avec les TID des lignes correspondantes. <literal>*returned_tids</literal> est
   initialisé au nombre de TID réellement renvoyé. Ceci peut être moins que
   <literal>max_tids</literal>, voire même zéro, même si la valeur de retour vaut
   TRUE (ceci permet à la méthode d'accès de choisir les points d'arrêt les
   plus efficaces dans son parcours, par exemple les limites de la page d'index).
   <function>amgetmulti</function> et <function>amgettuple</function> ne peuvent pas être utilisés
   dans le même parcours d'index&nbsp;; il y a aussi d'autres restrictions lors de
   l'utilisation de <function>amgetmulti</function>, comme expliqué dans <xref
   linkend="index-scanning"/>.
  </para>

  <para>
<programlisting>void
amrescan (IndexScanDesc scan,
          ScanKey key);
</programlisting>
   Recommence le parcours donné, si possible avec de nouvelles clés de parcours
   (pour continuer à utiliser les anciennes clés, NULL est passé pour
   <literal>key</literal>). Notez qu'il n'est pas possible de changer le nombre de
   clés. En pratique, la fonctionnalité de relancement est utilisée quand une
   nouvelle ligne externe est sélectionné par une jointure imbriquée en boucle
   et, du coup, la valeur de la comparaison d'une nouvelle clé est nécessaire
   mais la structure de la clé de parcours reste identique. Cette fonction est
   aussi appelée par <function>RelationGetIndexScan()</function>, donc c'est utilisé pour
   une configuration initiale d'un parcours d'index ainsi que pour parcourir de
   nouveau.
  </para>

  <para>
<programlisting>void
amendscan (IndexScanDesc scan);
</programlisting>
   Termine un parcours et libère les ressources. La structure <literal>scan</literal>
   elle-même ne devrait pas être libérée, mais aucun verrou pris en interne par
   la méthode d'accès doit être libéré.
  </para>

  <para>
<programlisting>void
ammarkpos (IndexScanDesc scan);
</programlisting>
   Marque la position courante du parcours. La méthode d'accès a seulement
   besoin de supporter le rappel d'une position de parcours par parcours.
  </para>

  <para>
<programlisting>void
amrestrpos (IndexScanDesc scan);
</programlisting>
   Restaure le parcours à sa plus récente position marquée.
  </para>

  <para>
   Par convention, l'entrée <literal>pg_proc</literal> de toute fonction de
   méthode d'accès aux index devrait afficher le bon nombre d'arguments, mais
   les déclarer comme étant du type <type>internal</type> (car la plupart des
   arguments ont des types qui ne sont pas connus en SQL, et nous ne voulons
   pas que les utilisateurs appelent les fonctions directement). Le type
   renvoyé est déclaré comme <type>void</type>, <type>internal</type> ou <type>boolean</type>
   suivant le cas.
   La seule exception est <function>amoptions</function>, qui devrait être
   correctement déclarée comme prenant <type>text[]</type> et <type>bool</type>
   et renvoyer <type>bytea</type>. Cette provision autorise le code du client à
   exécuter <function>amoptions</function> pour tester la validité des paramètres.
  </para>

 </sect1>

 <sect1 id="index-scanning">
  <title>Parcours d'index</title>

  <para>
   Dans un parcours d'index, la méthode d'accès à l'index est responsable
   de l'ingurgitation des TID de toutes les lignes indiquées comme correspondant
   aux <firstterm>clés de parcours</firstterm>. La méthode d'accès n'est réellement
   impliquée <emphasis>ni</emphasis> dans la récupération de ces lignes à partir de la
   table parent de l'index ni dans la détermination du passage du test de
   qualification ou d'autres conditions.
  </para>

  <para>
   Une clé de parcours est une représentation interne d'une clause 
   <literal>WHERE</literal> de la forme <replaceable>clé_index</replaceable>
   <replaceable>opérateur</replaceable> <replaceable>constante</replaceable>,
   où la clé d'index est une des colonnes de l'index et l'opérateur est un des
   membres de la famille d'opérateur associée avec cette colonne d'index. Un
   parcours d'index a aucune ou plusieurs clés de parcours qui sont assemblées
   implicitement avec des AND &mdash; les lignes renvoyées doivent satisfaire
   toutes les conditions indiquées.
  </para>

  <para>
   La famille d'opérateur peut indiquer que l'index est <firstterm>à perte</firstterm>
   pour un opérateur particulier&nbsp;; ceci implique que le parcours d'index
   renverra toutes les entrées qui correspondent à la clé de parcours, avec
   les entrées supplémentaires qui ne correspondent pas. La machinerie du
   parcours d'index du système principal s'appliquera ensuite cet opérateur
   pour vérifier s'il doit bien être utilisé. Pour les opérateurs sans perte,
   le parcours d'index doit renvoyer exactement l'ensemble d'entrées
   correspondantes cet il n'y aura pas de nouvelle vérification.
  </para>

  <para>
   Notez qu'il est entièrement à la charge de la méthode d'accès de s'assurer
   qu'elle trouve correctement toutes les entrées correspondantes aux clés de
   parcours données, et seulement celles-ci. De plus, le système principal
   donnera toutes les clauses <literal>WHERE</literal> correspondant aux clés d'index
   et aux familles d'opérateurs, sans analyse sémantique déterminant si elles
   sont redondantes ou contradictoires. Comme exemple, étant donné
   <literal>WHERE x &gt; 4 AND x &gt; 14</literal> où <literal>x</literal> est une colonne
   indexée B-tree, elle est passée à la fonction B-tree <function>amrescan</function>
   pour déterminer que la première clé de parcours est redondante et peut être
   annulée. Le supplément de pré-traitement nécessaire lors de
   <function>amrescan</function> dépendra du supplément dont la méthode d'accès à l'index
   a besoin pour réduire les clés de parcours en une forme <quote>normalisée</quote>.
  </para>

  <para>
   Certaines méthodes d'accès renvoient des entrées d'index dans un ordre bien
   défini, d'autres non. Si les entrées sont renvoyées triées, la méthode
   d'accès doit initialiser
   <structname>pg_am</structname>.<structfield>amcanorder</structfield> à
   true pour indiquer qu'il supporte les parcours triés. Toutes les méthodes
   d'accès doivent utiliser les numéros de stratégie compatibles btree pour les
   opérateurs d'égalité et d'ordre.
  </para>

  <para>
   La fonction <function>amgettuple</function> dispose d'un argument <literal>direction</literal>,
   qui peut être soit <literal>ForwardScanDirection</literal> (le cas normal) soit
   <literal>BackwardScanDirection</literal>. Si le premier appel après
   <function>amrescan</function> spécifie <literal>BackwardScanDirection</literal>, alors
   l'ensemble d'entrées d'index correspondantes est à parcourir de l'arrière
   vers l'avant plutôt que dans la direction normale, donc
   <function>amgettuple</function> doit renvoyer la dernière ligne correspondante dans
   l'index, plutôt que la première (ceci arrivera seulement pour les méthodes
   d'accès qui indiquent qu'elles supportent les parcours ordonnés). Après le premier appel, <function>amgettuple</function>
   doit être préparé pour continuer le parcours dans une direction à partir de
   l'entrée la plus récemment renvoyée.
  </para>

  <para>
   La méthode d'accès doit supporter le <quote>marquage</quote> d'une position dans
   un parcours et le renvoi ultérieur à une position marquée. La même position
   pourrait être restaurée plusieurs fois. Néanmoins, seule une position doit
   être en mémoire par parcours&nbsp;; un nouveau appel à <function>ammarkpos</function>
   surcharge la position marquée précédemment.
  </para>

  <para>
   La position du parcours et du marquage doivent être conservées de façon
   cohérente dans le cas d'insertions et de suppressions concurrentes pendant
   le parcours. Il est considéré correct qu'une entrée tout juste insérée ne
   soit pas renvoyée par un parcours qui aurait trouvé cette entrée si elle
   avait existé au moment où le parcours a commencé, ou que le parcours renvoie
   une telle entrée lors d'un nouveau parcours même si elle n'a pas été renvoyée
   la première fois. De façon similaire, une suppression concurrente pourrait ou
   non être réfléchie dans les résultats d'un parcours. Ce qui est important est
   que les insertions ou suppressions ne causent pas un manque ou un renvoi
   multiple des entrées qui n'ont pas été insérées ou supprimées.
  </para>

  <para>
   Au lieu d'utiliser <function>amgettuple</function>, un parcours d'index peut se faire
   via <function>amgetmulti</function> pour récupérer différentes lignes par appel. Cela
   peut être notablement plus efficace que <function>amgettuple</function> parce que cela
   permet d'éviter les cycles de verrouillage/déverrouillage à l'intérieur de la
   méthode d'accès. En principe, <function>amgetmulti</function> devrait avoir les mêmes
   effets que des appels répétés à <function>amgettuple</function>, mais nous imposons
   plusieurs restrictions pour simplifier la gestion. En premier lieu,
   <function>amgetmulti</function> ne prend pas d'argument <literal>direction</literal>. Du coup,
   il ne supporte ni les parcours inverses ni le changement de direction lors d'un
   parcours. La méthode d'accès n'a pas besoin de supporter le marquage ou la
   restauration des positions de parcours lors d'un parcours
   <function>amgetmulti</function> (ces restrictions ne coûtent rien car il serait difficile
   d'utiliser ces fonctionnalités y compris dans le cas d'un parcours
   <function>amgetmulti</function>&nbsp;: ajuster la liste en tampon des TIDs de l'appelant
   serait complexe). Enfin, <function>amgetmulti</function> ne garantie pas un verrouillage
   des lignes renvoyées, avec les implications précisées dans <xref
   linkend="index-locking"/>.
  </para>

 </sect1>

 <sect1 id="index-locking">
  <title>Considérations pour le verrouillage d'index</title>

  <para>
   Les méthodes d'accès aux index doivent gérer des mises à jour
   concurrentes de l'index par plusieurs processus.
   Le système principal <productname>PostgreSQL</productname> obtient
   <literal>AccessShareLock</literal> sur l'index lors d'un parcours d'index et
   <literal>RowExclusiveLock</literal> quand il le met à jour (ceci incluant le
   <command>VACUUM</command> simple). Comme ces types de
   verrous ne sont pas en conflit, la méthode d'accès est responsable de la
   gestion d'un verrouillage plus précis si nécessaire. Un verrou exclusif sur
   l'index entier sera seulement pris lors de la création, destruction de l'index,
   dans une opération <literal>REINDEX</literal> ou lors d'un <command>VACUUM
   FULL</command>.
  </para>

  <para>
   Construire un type d'index qui supporte les mises à jour concurrentes
   requiert une analyse complète et subtile du comportement requis. Pour les
   types d'index B-tree et hash, vous pouvez lire les décisions du concept dans
   <filename>src/backend/access/nbtree/README</filename> et
   <filename>src/backend/access/hash/README</filename>.
  </para>

  <para>
   En plus des besoins de cohérence interne de l'index, les mises à jour
   concurrentes créent des problèmes de cohérence entre la table parent
   (l'<firstterm>en-tête</firstterm>) et l'index. Comme
   <productname>PostgreSQL</productname> sépare les accès et les mises à
   jour de l'en-tête de ceux de l'index, il existe des possibilités pour que
   l'index ne soit pas à jour par rapport à l'en-tête. Nous gérons ce problème
   avec les règles suivantes&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Une nouvelle entrée dans l'en-tête est effectuée avant sa contrepartie
       dans l'index (du coup, un parcours d'index concurrent pourrait ne pas
       voir l'entrée dans l'en-tête&nbsp;; ceci est bon car le lecteur de
       l'index ne sera pas intéressé par une ligne non validée... voir
       <xref linkend="index-unique-checks"/>).
      </para>
     </listitem>
     <listitem>
      <para>
       Quand une entrée de l'en-tête doit être supprimée (par <command>VACUUM</command>),
       toutes les entrées de l'index doivent d'abord être supprimées.
      </para>
     </listitem>
     <listitem>
      <para>
       Un parcours d'index doit maintenir
       un lien sur la page d'index contenant le dernier élément renvoyé par
       <function>amgettuple</function>, et <function>ambulkdelete</function> ne peut pas
       supprimer les entrées de pages qui sont liées à d'autres processus. Le
       besoin de cette règle est expliqué plus bas.
      </para>
     </listitem>
    </itemizedlist>

   Sans la troisième règle, il est possible qu'un lecteur d'index voit
   une entrée dans l'index juste avant qu'elle ne soit supprimée par un
   <command>VACUUM</command>, puis d'arriver à l'entrée correspondante de
   l'en-tête après qu'elle soit supprimée par le <command>VACUUM</command>.
   Ceci ne crée pas de problèmes sérieux si ce numéro d'élément
   est toujours inutilisé quand le lecteur l'atteint car un emplacement d'élément
   vide sera ignoré par <function>heap_fetch()</function>. Mais que se passe-t'il si
   un troisième moteur a déjà ré-utilisé l'emplacement de l'élément pour quelque
   chose d'autre&nbsp;? Lors de l'utilisation d'une image compatible MVCC, il n'y
   a pas de problème car le nouvel occupant de l'emplacement est certain d'être
   trop nouveau pour accepter ou renvoyer une ligne qui, en fait, ne correspond
   pas aux clés de parcours. Nous pouvons nous défendre contre ce scénario en
   réclamant que les clés de parcours soient de nouveau vérifiées avec la ligne
   d'en-tête dans tous les cas mais c'est bien trop coûteux. À la place, nous
   utilisons un lien sur une page d'index comme un proxy, pour indiquer que le
   lecteur pourrait toujours être <quote>en parcours</quote> à partir de l'entrée de
   l'index jusqu'à l'entrée correspondante. Faire bloquer <function>ambulkdelete</function>
   sur un tel lien nous assure qu'un <command>VACUUM</command> ne peut pas supprimer
   l'entrée de l'en-tête avant que le lecteur n'en ait terminé avec lui. Cette
   solution coûte peu en temps d'exécution mais ajoute un délai dans le blocage
   dans de rares cas où il existe réellement un conflit.
  </para>

  <para>
   Cette solution requiert que les parcours d'index soient
   <quote>synchrones</quote>&nbsp;: nous devons récupérer chaque ligne d'en-tête
   immédiatement après avoir parcouru l'entrée d'index correspondante. Ceci
   est coûteux pour plusieurs raisons. Un parcours <quote>asynchrone</quote> dans
   lequel nous récupérons les TID de l'index et dans lequel nous visitons
   seulement les en-têtes de lignes un peu plus tard, requiert moins de temps
   de verrouillage de l'index et pourrait autoriser un modèle d'accès à
   l'en-tête plus efficace. En plus de l'analyse ci-dessus, nous devons
   utiliser l'approche synchronisée pour les images non compatibles avec
   MVCC mais un parcours asynchrone est possible pour une requête utilisant
   une image MVCC.
  </para>

  <para>
   Dans un parcours d'index <function>amgetmulti</function>, la méthode d'accès n'a pas
   besoin de garantir la conservation d'un lien à l'index sur aucune des lignes
   renvoyées, ce qui est impraticable pour toutes sauf la dernière). Du coup, il
   est plus sage d'utiliser plusieurs parcours avec des images compatibles MVCC.
  </para>

 </sect1>

 <sect1 id="index-unique-checks">
  <title>Vérification de l'unicité de l'index</title>

  <para>
   <productname>PostgreSQL</productname> renforce les contraintes SQL d'unicité
   en utilisant les <firstterm>index uniques</firstterm>, qui sont des index qui refusent
   les entrées multiples avec des clés identiques. Une méthode d'accès qui
   supporte cette fonctionnalité initialise
   <structname>pg_am</structname>.<structfield>amcanunique</structfield> à true (à présent, seul
   B-tree le supporte).
  </para>

  <para>
   Grâce à MVCC, il est toujours nécessaire d'autoriser les entrées dupliquées
   à exister physiquement dans un index&nbsp;: mes entrées pourraient faire
   référence à des versions successives d'une même ligne logique. Le comportement
   que nous voulons réellement renforcer est qu'aucune image MVCC n'inclut deux
   lignes avec les mêmes clés d'index. Ceci crée les différents cas suivants
   devant être vérifiés lors de l'insertion d'une nouvelle ligne dans un index
   unique&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Si une ligne valide en conflit a été supprimée par une transaction
       concurrente, tout va bien (en particulier, comme un UPDATE supprime
       toujours l'ancienne version de la ligne avant d'insérer la nouvelle
       version, ceci permettra un UPDATE sur une ligne sans changer la clé).
      </para>
     </listitem>
     <listitem>
      <para>
	Si une ligne en conflit a été insérée par une transaction encore non
	validée, le soi-disant inséreur doit attendre de voir si la transaction
	est validée. Si la transaction est annulée, alors il n'y a pas de conflit.
	Si la transaction est validée sans que la ligne en conflit ait été
	supprimée, il y a une violation de la contrainte d'unicité (en pratique,
	nous attendons juste que l'autre transaction finisse et puis nous
	refaisons le contrôle de visibilité dans toto).
      </para>
     </listitem>
     <listitem>
      <para>
       De façon similaire, si une ligne valide en conflit a été supprimée par
       une transaction encore non validée, l'inserteur doit attendre la
       validation ou l'annulation de cette transaction, puis recommence le test.
      </para>
     </listitem>
    </itemizedlist>
  </para>

  <para>
   De plus, immédiatement avant de lever une violation d'unicité
   suivant les règles ci-dessus, la méthode d'accès doit de
   nouveau vérifier l'état de la ligne en cours d'insertion. Si elle
   est validée tout en étant morte, alors aucune erreur ne devrait
   survenir. (Ce cas ne peut pas survenir lors du scénario ordinaire
   d'insertion d'une ligne qui a été tout juste créée par la
   transaction en cours. Cela peut néanmoins arriver pendant
   <command>CREATE UNIQUE INDEX CONCURRENTLY</command>.)
  </para>

  <para>
   Nous réclamons que la méthode d'accès à l'index applique ces tests eux-même,
   ce qui signifient qu'ils doivent attendre l'en-tête pour vérifier le
   statut de validation d'une ligne qui est affichée comme une clé dupliquée
   suivant le contenu de l'index. Ceci est sans aucun doute moche et non
   modulaire, mais il permet d'éviter un travail redondant&nbsp;: si nous
   faisons un test séparé, alors la recherche d'index pour une ligne en
   conflit pourrait être essentiellement répétée lors de la découverte d'emplacement
   pour insérer la nouvelle entrée d'index de ligne. De plus, il n'existe
   aucun moyen pour éviter des conditions rares sans que la vérification de
   contrainte ne soit une partie intégrale d'insertion du nouvel entrée d'index.
  </para>

  <para>
   Le principale limitation de ce schéma est qu'il n'existe pas de façon aisée
   de supporter les vérifications d'unicité déferrées.
  </para>

 </sect1>

 <sect1 id="index-cost-estimation">
  <title>Fonctions d'estimation des coûts d'index</title>

  <para>
   La fonction amcostestimate se voit donner une liste de clauses WHERE qui ont
   été déterminées pour être utilisables avec l'index. Il doit renvoyer une
   estimation du coût de l'accès d'index et de la sélectivité des clauses
   WHERE (c'est-à-dire la fraction des lignes de la table parent qui seront
   récupérées lors du parcours de l'index). Pour les cas simples, pratiquement
   tout le travail de l'estimateur de coût peut être effectué en appelant des
   routines standards dans l'optimiseur&nbsp;; la raison d'avoir une fonction
   amcostestimate est d'autoriser les méthodes d'accès aux index pour fournir
   une connaissance spécifique au type d'index, au cas où il est possible
   d'améliorer les estimations standards.
  </para>

  <para>
   Chaque fonction amcostestimate doit avoir la signature&nbsp;:

<programlisting>void
amcostestimate (PlannerInfo *root,
                IndexOptInfo *index,
                List *indexQuals,
		RelOptInfo *outer_rel,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);
</programlisting>

   Les quatre premiers paramètres sont des entrées&nbsp;:

   <variablelist>
    <varlistentry>
     <term>root</term>
     <listitem>
      <para>
       Information du planificateur sur la requête en cours de traitement.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>index</term>
     <listitem>
      <para>
       Index considéré.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>indexQuals</term>
     <listitem>
      <para>
       Liste des clauses qual d'index (implicitement assemblées avec des AND)&nbsp;;
       une liste NIL indique qu'aucun qualificateur n'est disponible.
       Notez que la liste contient des arbres d'expression, pas ScanKeys.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>outer_rel</term>
     <listitem>
      <para>
       Si l'utilisation de l'index est considérée dans un parcours d'index pour
       une jointure interne, le planificateur dispose des informations sur le
       côté externe de la jointure. Sinon NULL. Quand non NULL, certaines des
       clauses qual seront des clauses de jointure avec cette relation plutôt
       que de simples clauses de restriction. De plus, le processus d'estimation
       du coût devrait s'attendre à ce que le parcours d'index soit répété pour
       chaque ligne de la relation externe.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les quatre derniers paramètres sont passés par leur référence&nbsp;:

   <variablelist>
    <varlistentry>
     <term>*indexStartupCost</term>
     <listitem>
      <para>
       Initialisé au coût du lancement du traitement de l'index
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexTotalCost</term>
     <listitem>
      <para>
       Initialisé au coût du traitement total par l'index
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexSelectivity</term>
     <listitem>
      <para>
       Initialisé à la sélectivité de l'index
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexCorrelation</term>
     <listitem>
      <para>
       Initialisé au coefficient de corrélation entre l'ordre du parcours de
       l'index et l'ordre sous-jacent de la table
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Notez que les fonctions d'estimation de coûts doivent être écrits en C, pas
   en SQL ou dans un autre langage de procédure, parce qu'elles doivent accéder
   aux structures de données internes du planificateur/optimiseur.
  </para>

  <para>
   Les coûts d'accès aux index doivent être calculés en utilisant les paramètres
   utilisés par <filename>src/backend/optimizer/path/costsize.c</filename>&nbsp;: la
   récupération d'un bloc disque séquentiel a un coût de <varname>seq_page_cost</varname>,
   une récupération non séquentielle a un coût de <varname>random_page_cost</varname>, et le coût de
   traitement d'une ligne d'index doit habituellement être considéré comme
   <varname>cpu_index_tuple_cost</varname>. De plus, un multiple approprié de
   <varname>cpu_operator_cost</varname> doit être chargé pour tous les opérateurs
   de comparaison impliqués lors du traitement de l'index (spécialement
   l'évaluation des indexQuals).
  </para>

  <para>
   Les coûts d'accès doivent inclure tous les coûts dûs aux disques et aux CPU
   associés au parcours d'index lui-même, mais <emphasis>pas</emphasis> les coûts de
   récupération ou de traitement des lignes de la table parent qui sont
   identifiées par l'index.
  </para>

  <para>
   Le <quote>coût de lancement</quote> est la partie du coût du parcours total
   devant être étendu avant que nous commencions à récupérer la première ligne.
   Pour la plupart des index, cela peut être considéré comme zéro mais un type
   d'index avec un grand coût de lancement pourrait vouloir le configurer à
   une autre valeur que zéro.
  </para>

  <para>
   indexSelectivity devrait être initialisé à la fraction estimée des lignes
   de la table parent qui seront récupérées lors du parcours d'index. Au cas
   où il s'agit d'un index à perte, cela sera typiquement plus haut que la
   fraction des lignes qui réussissent les conditions qual données.
  </para>

  <para>
   indexCorrelation devrait être initialisé à la corrélation (valeur entre
   -1,0 et 1,0) entre l'ordre de l'index et celui de la table. Cela permet
   d'ajuster l'estimation pour le coût de récupération des lignes de la table
   parent.
  </para>

  <para>
   Dans le cas de la jointure, les nombres renvoyés devraient être des moyennes
   attendues pour tout parcours de l'index.
  </para>

  <procedure>
   <title>Estimation du coût</title>
   <para>
    Un estimateur typique de coût exécutera le traitement ainsi&nbsp;:
   </para>

   <step>
    <para>
     Estime et renvoie la fraction des lignes de la table parent qui seront
     visitées suivant les conditions qual données. En l'absence de toute
     connaissance spécifique sur le type de l'index, utilisez la fonction
     de l'optimiseur standard <function>clauselist_selectivity()</function>:

<programlisting>*indexSelectivity = clauselist_selectivity(root, indexQuals,
                                           index-&gt;rel-&gt;relid, JOIN_INNER);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de lignes d'index qui seront visitées lors du parcours. Pour
     de nombreux types d'index, ceci vaut indexSelectivity fois le nombre de
     lignes dans l'index, mais cela pourrait valoir plus (notez que la taille
     de l'index en pages et lignes est disponible à partir de la structure
     IndexOptInfo).
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de pages d'index qui seront récupérées pendant le parcours.
     Ceci pourrait être simplement indexSelectivity fois la taille de l'index
     en pages.
    </para>
   </step>

   <step>
    <para>
     Calcule le coût d'accès à l'index. Un estimateur générique pourrait le
     faire ainsi&nbsp;:

<programlisting>    /*
     * Our generic assumption is that the index pages will be read
     * sequentially, so they have cost seq_page_cost each, not random_page_cost.
     * Also, we charge for evaluation of the indexquals at each index row.
     * All the costs are assumed to be paid incrementally during the scan.
     */
    cost_qual_eval(&amp;index_qual_cost, indexQuals, root);
    *indexStartupCost = index_qual_cost.startup;
    *indexTotalCost = seq_page_cost * numIndexPages +
        (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;
</programlisting>

     Néanmoins, l'exemple ci-dessus ne prend pas en compte l'amortissement des
     lectures des index via les parcours répétés d'index dans le cas de la
     jointure.
    </para>
   </step>

   <step>
    <para>
     Estime la corrélation de l'index. Pour un index ordonné sur un seul champ,
     ceci peut se récupérer de pg_statistic. Si la corrélation est inconnue,
     l'estimation conservative est zéro (pas de corrélation).
    </para>
   </step>
  </procedure>

  <para>
   Des exemples de fonctions d'estimation du coût sont disponibles dans
   <filename>src/backend/utils/adt/selfuncs.c</filename>.
  </para>
 </sect1>
</chapter>
