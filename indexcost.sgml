<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/indexcost.sgml,v 1.6 2005/03/14 06:03:49 guillaume Exp $
-->

 <chapter id="indexcost">
  <title>Fonctions d'estimation du coût des index</title>

  <note>
   <title>Auteur</title>

   <para>
    Écrit par Tom Lane (<email>tgl@sss.pgh.pa.us</email>) le 24 janvier 2000.
   </para>
  </note>

   <note>
    <para>
     Ceci pourra faire partie d'un futur chapitre plus étoffé sur l'écriture
     de nouvelles méthodes d'accès aux index.
    </para>
   </note>

  <para>
   Chaque méthode d'accès aux index doit fournir une fonction d'estimation de
   son coût qui sera utilisée par l'optimiseur de requêtes. L'OID de procédure
   de cette fonction est donné dans le champ <literal>amcostestimate</literal>
   dans la table <literal>pg_am</literal>.

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 7.0, l'enregistrement des
     fonctions utilisait un mécanisme différent.
    </para>
   </note>
  </para>

  <para>
   Une liste de clauses WHERE utilisables par l'index est passée
   à la fonction amcostestimate. Celle-ci retourne une estimation du coût
   d'accès à l'index et de la sélectivité des clauses WHERE, c'est-à-dire la
   fraction des colonnes de la table principale qui sera récupérée lors
   du parcours de l'index.
  </para>
  <para>
   Dans certains cas simples, l'optimiseur peut réaliser l'essentiel du calcul 
   de coût à l'aide de routines standard&nbsp;;la fonction amcostestimate 
   permet aux méthodes d'accès de fournir une information spécifique aux index,
   pour le cas où l'estimation standard serait améliorable.
  </para>

  <para>
   Chaque fonction amcostestimate doit avoir la signature suivante&nbsp;:

   <programlisting>
void
amcostestimate (Query *root,
                RelOptInfo *rel,
                IndexOptInfo *index,
                List *indexQuals,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);
   </programlisting>

   Les quatre premiers paramètres sont des entrées&nbsp;:

   <variablelist>
    <varlistentry>
     <term>root</term>
     <listitem>
      <para>
       la requête traitée&nbsp;;
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>rel</term>
     <listitem>
      <para>
       la relation sur laquelle porte l'index&nbsp;;
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>index</term>
     <listitem>
      <para>
       l'index lui même&nbsp;;
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>indexQuals</term>
     <listitem>
      <para>
       la liste des clauses qualifiées pour l'index (implicitement
       liées par des ET logiques)&nbsp;; une liste NIL indique qu'aucune
       clause n'est qualifiée&nbsp;; la liste contient des arbres d'expression
       et non des ScanKeys.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les quatre derniers paramètres sont des sorties passées par référence&nbsp;:

   <variablelist>
    <varlistentry>
     <term>*indexStartupCost</term>
     <listitem>
      <para>
       coût du démarrage du traitement de l'index&nbsp;;
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexTotalCost</term>
     <listitem>
      <para>
       coût total de traitement de l'index&nbsp;;
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexSelectivity</term>
     <listitem>
      <para>
       sélectivité de l'index&nbsp;;
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexCorrelation</term>
     <listitem>
      <para>
       coefficient de corrélation entre l'ordre de parcours de l'index
       et l'ordre de la table sous-jacente.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   les fonctions d'estimation de coût sont écrites en C. Elles ne peuvent l'être
   en SQL ou en langage procédural,
   car elles accèdent aux structures de données internes de 
   l'optimiseur/planificateur.
  </para>

  <para>
   Le coût d'accès aux index est calculé dans les unités utilisées par
   <filename>src/backend/optimizer/path/costsize.c</filename>&nbsp;: la lecture 
   séquentielle d'un bloc a un coût de 1,0, une lecture non séquentielle coûte
   <variable>random_page_cost</variable> et le traitement d'une ligne d'index
   coûte
   généralement <variable>cpu_index_tuple_cost<variable> (qui est un paramètre
   utilisateur).
   De plus, un multiple approprié de <variable>cpu_operator_cost</variable>
   doit être ajouté pour
   chaque opérateur de comparaison appelé lors du traitement de l'index,
   particulièrement lors de l'évaluation des indexQuals.
  </para>

  <para>
   Les coûts d'accès incluent les coûts disque et CPU associés au parcours
   de l'index lui même, mais <emph>PAS</emph> les coûts associés à la
   recherche ou au 
   traitement des lignes de la table principale identifiées par
   l'index.
  </para>

  <para>
   Le <quote>coût de départ</quote> est la fraction du coût total de parcours
   dépensée avant de pouvoir retrouver la première ligne. Pour la
   plupart des index, il peut être nul, mais un type d'index de coût de 
   départ élevé lui donnera une valeur non nulle.
  </para>

  <para>
   La sélectivité de l'index (indexSelectivity) indique la fraction estimée de
   la table principale récupérée par le parcours de l'index.
   Dans le cas d'un index peu intéressant, cette fraction est
   supérieure à celle des lignes qui passent réellement les conditions
   de qualification.
  </para>

  <para>
   indexCorrelation précise la corrélation (comprise entre -1,0 et 1,0) entre
   l'ordre
   de l'index et l'ordre de la table. Ce paramètre est utilisé pour ajuster le
   coût de lecture des lignes de la table principale.
  </para>

  <procedure>
   <title>Estimation de coût</title>
   <para>
    Une estimation de coût classique se fait comme suit&nbsp;:
   </para>

   <step>
    <para>
     Estime et retourne la fraction de lignes visitées de la table principale,
     en fonction des conditions de qualification. En l'absence de connaissance
     spécifique au type d'index, utilise la fonction standard de l'optimiseur,
     <function>clauselist_selectivity()</function>&nbsp;:

     <programlisting>
*indexSelectivity = clauselist_selectivity(root, indexQuals,
                                           rel-&nbsp;relid, JOIN_INNER);
     </programlisting>
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de lignes d'index parcourues. Pour de nombreux types
     d'index, cette valeur vaut
     indexSelectivity multipliée par le nombre de lignes de l'index,
     mais elle peut valoir plus. (La taille de l'index en pages et en lignes
     est disponible
     à partir de la structure IndexOptInfo.)
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de pages d'index recupérées lors de son 
     parcours.
     Peut valoir indexSelectivity multipliée par la taille de l'index en
     pages.
    </para>
   </step>

   <step>
    <para>
     Calcule le coût d'accès à l'index. Un estimateur générique pourrait
     procéder comme suit&nbsp;:

     <programlisting>
    /*
     * Il est supposé que les pages d'index vont être lues
     * séquentiellement, si bien qu'elles ont un coût de 1,0 chacune, et
     * non pas de random_page_cost.
     * De plus, on ajoute le coût de l'évaluation des conditions pour chaque
     * ligne d'index. Tous les coûts sont supposés payés incrémentalement
     * lors du parcours de l'index.
     */
    cost_qual_eval(&amp;index_qual_cost, indexQuals);
    *indexStartupCost = index_qual_cost.startup;
    *indexTotalCost = numIndexPages +
        (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;
     </programlisting>
    </para>
   </step>

   <step>
    <para>
     Estime la corrélation d'index. Pour un index simple ordonné sur un
     seul champ, la valeur peut être obtenue à partir de pg_statistic. 
     Si la corrélation n'est pas connue, vaut zéro (pas de corrélation).
    </para>
   </step>
  </procedure>

  <para>
   Des exemples de fonctions d'estimation se trouvent dans 
   <filename>src/backend/utils/adt/selfuncs.c</filename>.
  </para>

  <para>
   Par convention, l'entrée dans <literal>pg_proc</literal> pour une
   fonction <literal>amcostestimate</literal> comprend huit arguments tous
   déclarés de type <type>internal</type> (car aucun n'est d'un type reconnu
   par SQL), le type
   retourné est <type>void</type>.
  </para>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->

