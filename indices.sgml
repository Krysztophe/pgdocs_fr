<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/indices.sgml,v 1.13 2005/09/22 18:34:41 guillaume Exp $ -->

<chapter id="indexes">
 <title id="indexes-title">Index</title>

 <indexterm zone="indexes">
  <primary>index</primary>
 </indexterm>

 <para>
  Les index sont une méthode courante pour augmenter les performances
  d'une base de données. Un index permet au serveur de bases de données de
  retrouver une ligne spécifique bien plus rapidement que sans index.
  Mais les index ajoutent aussi une surcharge au système de base de données
  dans son ensemble, si bien qu'ils doivent être utilisés avec discernement.
 </para>


 <sect1 id="index-intro">
  <title>Introduction</title>

  <para>
   Supposons que nous ayons une table comme celle-ci:
<programlisting>
CREATE TABLE test1 (
    id integer,
    contenu varchar
);
</programlisting>
   et que l'application utilise beaucoup de requêtes de la forme
<programlisting>
SELECT contenu FROM test1 WHERE id = <replaceable>constante</replaceable>;
</programlisting>
   Sans préparation supplémentaire, le système devrait lire la table
   <structname>test1</structname> en entier, ligne par ligne, pour trouver
   toutes les lignes qui correspondent. S'il y a beaucoup de lignes dans
   <structname>test1</structname>, et que seulement quelques lignes 
   correspondent à la requête (peut-être même zéro ou une seule), alors,
   clairement, la méthode n'est pas efficace.
   Mais si on a indiqué au système de maintenir un index sur la colonne
   <structfield>id</structfield>, alors il peut utiliser une manière
   beaucoup plus efficace pour trouver les lignes recherchées. Par exemple,
   il pourrait n'avoir à parcourir que quelques niveaux d'un arbre de 
   recherche.
  </para>

  <para>
   Une approche similaire est utilisée dans la plupart des livres autres
   que ceux de fiction&nbsp;: les termes et concepts qui sont fréquemment
   recherchés par les lecteurs sont listés par ordre alphabétique à la
   fin du livre. Le lecteur qui recherche un mot particulier peut
   facilement parcourir l'index, puis aller directement à la page 
   ou aux pages indiquée(s). De la même façon que l'auteur doit anticiper
   les sujets que les lecteurs risquent de rechercher, il est de la
   responsabilité du programmeur de prévoir quels index sont avantageux.
  </para>

  <para>
   La commande suivante permet de créer un index sur la colonne
   <structfield>id</structfield> dont nous parlons&nbsp;:
<programlisting>
CREATE INDEX test1_id_index ON test1 (id);
</programlisting>
   Le nom <structname>test1_id_index</structname> peut être choisi
   librement mais il est conseillé de choisir un nom qui rappelle le but
   de l'index.
  </para>

  <para>
   Pour supprimer l'index, utilisez la commande <command>DROP INDEX</command>.
   Les index peuvent être ajoutés et retirés des tables à tout moment.
  </para>

  <para>
   Une fois un index créé, aucune intervention supplémentaire n'est
   nécessaire&nbsp;:
   le système met à jour l'index lorsque la table est modifiée et utilise
   l'index dans les requêtes lorsqu'il pense que c'est plus efficace qu'une
   lecture complète de la table. Il faut néanmoins lancer la commande
   <command>ANALYZE</command> régulièrement pour permettre à l'optimiseur
   de requêtes de prendre les bonnes décisions.
   Voir le <xref linkend="performance-tips"/> pour comprendre quand et
   pourquoi l'optimiseur décide d'utiliser ou de ne
   <emphasis>pas</emphasis> utiliser un index.
  </para>

  <para>
   Les index peuvent aussi bénéficier aux commandes
   <command>UPDATE</command> et <command>DELETE</command> qui ont des
   conditions de recherche. De plus, les index peuvent être utilisés dans les
   jointures. Ainsi, un index défini sur une colonne qui fait partie d'une
   condition de jointure peut accélérer significativement les requêtes avec
   jointures.
  </para>

  <para>
   Après la création d'un index, le système doit le maintenir synchronisé avec
   la table. Cela rend plus lourdes les opérations de manipulation de 
   données. C'est pourquoi les index qui sont peu, voire jamais, utilisés
   doivent être supprimés.
  </para>
 </sect1>


 <sect1 id="indexes-types">
  <title>Types d'index</title>

  <para>
   <productname>PostgreSQL</productname> propose plusieurs types d'index&nbsp;:
   B-tree, R-tree, Hash et GiST. Chaque type d'index utilise un algorithme
   différent qui convient à un type particulier de requêtes. Par défaut, la
   commande <command>CREATE INDEX</command> créera un index B-tree, ce qui
   convient dans la plupart des situations.
   <indexterm>
    <primary>index</primary>
    <secondary>B-tree</secondary>
   </indexterm>
   <indexterm>
    <primary>B-tree</primary>
    <see>index</see>
   </indexterm>
   Les index B-tree savent traiter les égalités et les recherches sur des
   tranches de valeurs des données qui peuvent être triées. En particulier,
   l'optimiseur de requêtes de <productname>PostgreSQL</productname>
   essaie d'utiliser un index B-tree lorsque une colonne indexée est
   utilisée dans une comparaison qui utilise un de ces opérateurs&nbsp;:

   <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist>

   Les constructions équivalentes à des combinaisons de ces opérateurs, comme
   <literal>BETWEEN</literal> et <literal>IN</literal>, peuvent aussi être implémentées avec
   une recherche par index B-tree (mais notez que <literal>IS NULL</literal> n'est pas
   équivalent à <literal>=</literal> et n'est pas indexable).
  </para>

  <para>
   L'optimiseur peut aussi utiliser un index B-tree pour des requêtes
   qui utilisent les opérateurs de recherche de motif <literal>LIKE</literal>
   et <literal>~</literal> <emphasis>si</emphasis> le motif est une constante et
   se trouve au début de la chaîne à rechercher &mdash; par exemple,
   <literal>col LIKE 'foo%'</literal> ou <literal>col ~ '^foo'</literal>, mais
   pas <literal>col LIKE '%bar'</literal>. Néanmoins, si votre serveur
   n'utilise pas la locale C, il vous faudra créer l'index avec
   une classe d'opérateur spéciale pour supporter l'indexage à correspondance
   de modèles. Voir la <xref linkend="indexes-opclass"/> ci-dessous. Il est
   aussi possible d'utiliser des index B-tree pour <literal>ILIKE</literal> et
   <literal>~*</literal> mais seulement si le modèle commence avec des caractères
   non alphabétiques, c'est-à-dire des caractères non affectés par les
   conversions majuscules/minuscules.
  </para>

  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>R-tree</secondary>
   </indexterm>
   <indexterm>
    <primary>R-tree</primary>
    <see>index</see>
   </indexterm>
   Les index R-tree sont adaptés aux requêtes sur des données spatiales à deux
   dimensions. Pour créer un index R-tree, utilisez une commande de la
   forme&nbsp;:
<synopsis>
CREATE INDEX <replaceable>nom</replaceable> ON <replaceable>table</replaceable> USING RTREE (<replaceable>colonne</replaceable>);
</synopsis>
   L'optimiseur de requêtes de <productname>PostgreSQL</productname>
   envisagera d'utiliser un index R-tree lorsqu'une colonne indexée fait
   partie d'une comparaison utilisant l'un de ces opérateurs&nbsp;:

   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&amp;&lt;</literal></member>
    <member><literal>&amp;&gt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>&lt;&lt;|</literal></member>
    <member><literal>&amp;&lt;|</literal></member>
    <member><literal>|&amp;&gt;</literal></member>
    <member><literal>|&gt;&gt;</literal></member>
    <member><literal>~</literal></member>
    <member><literal>@</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

   Voir la <xref linkend="functions-geometry"/> pour connaître la
   signification de ces opérateurs.
  </para>

  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>hash</secondary>
   </indexterm>
   <indexterm>
    <primary>hash</primary>
    <see>index</see>
   </indexterm>
   Les index hachés ne supportent que les simples comparaisons d'égalité.
   L'optimiseur de requêtes envisagera d'utiliser un index haché lorsqu'une
   colonne indexée fait partie d'une comparaison utilisant l'opérateur 
   <literal>=</literal>. La commande suivante est utilisée pour créer un index
   haché:
<synopsis>
CREATE INDEX <replaceable>nom</replaceable> ON <replaceable>table</replaceable> USING HASH (<replaceable>colonne</replaceable>);
</synopsis>
  </para>

  <para>
   Les index GiST ne sont pas un seul genre d'index mais plutôt une
   infrastructure à l'intérieur de laquelle plusieurs stratégies d'indexage
   peuvent être implémentées. En accord, les opérateurs particuliers avec
   lesquels un index GiST peut être utilisé varient suivant sur la stratégie
   d'indexage (la <firstterm>classe d'opérateur</firstterm>). La distribution standard 
   de <productname>PostgreSQL</productname> inclut des classes d'opérateur GiST
   équivalentes à celles de l'opérateur R-tree, et un grand nombre d'autres
   classes d'opérateurs GiST sont disponibles dans la collection
   <literal>contrib</literal> ou via des projets séparés. Pour plus d'informations,
   voir le <xref linkend="GiST"/>.
  </para>

  <note>
   <para>
    Les tests ont montré que les index de hachage de
    <productname>PostgreSQL</productname> ne sont pas plus performants que les
    index B-tree, alors que la taille de ces index et que leur temps de
    construction est bien pire. De plus, les opérations sur les index hachés
    ne sont pas encore tracées dans les WAL, donc les index de hachage
    pourraient avoir besoin d'être reconstruits avec <command>REINDEX</command>
    après un arrêt brutal de la base de données. Pour ces raisons,
    l'utilisation des index de hachage est actuellement déconseillée.
   </para>

   <para>
    De façon similaire, les index R-tree ne semblent pas avoir un avantage
    en terme de performance comparé aux opérations équivalentes sur les index
    GiST. Comme les index de hachages, ils ne sont pas tracés sur les WAL et
    pourraient nécessiter un <command>REINDEX</command> après un arrêt brutal de la
    base de données.
   </para>

   <para>
    Bien que les problèmes des index de hachage pourraient être corrigés
    ultérieurement, il est probable que le type d'index R-tree soit supprimé
    dans une prochaine version. Les utilisateurs sont encouragés à migrer les
    applications qui utilisent les index R-tree pour qu'elles utilisent des
    index GiST.
   </para>
  </note>  

 </sect1>


 <sect1 id="indexes-multicolumn">
  <title>Index multicolonnes</title>

  <indexterm zone="indexes-multicolumn">
   <primary>index</primary>
   <secondary>multi colonne</secondary>
  </indexterm>

  <para>
   Un index peut porter sur plus d'une colonne d'une table. Par exemple, si vous avez 
   une table de cette forme&nbsp;:
<programlisting>
CREATE TABLE test2 (
  majeur int,
  mineur int,
  nom varchar
);
</programlisting>
   (par exemple, si vous gardez votre répertoire
   <filename class="directory">/dev</filename> dans une base de données...)
   et que vous faites fréquemment des requêtes comme&nbsp;:
<programlisting>
SELECT nom FROM test2 WHERE majeur = <replaceable>constante</replaceable> AND mineur = <replaceable>constante</replaceable>;
</programlisting>
   alors il est sans doute souhaitable de définir un index sur les colonnes
   <structfield>majeur</structfield> et
   <structfield>mineur</structfield> ensemble, par exemple avec:,
<programlisting>
CREATE INDEX test2_mm_idx ON test2 (majeur, mineur);
</programlisting>
  </para>

  <para>
   Actuellement, seuls les types d'index B-trees et GiST supportent les
   index multicolonnes. Un maximum de 32 colonnes peut être indexé.
   Cette limite peut être modifiée à la compilation de
   <productname>PostgreSQL</productname>. Voyez le fichier 
   <filename>pg_config_manual.h</filename>.
  </para>

  <para>
   Un index B-tree multicolonnes peut être utilisé avec des conditions de
   requêtes qui impliquent tout sous-ensemble des colonnes de l'index mais
   ce dernier est le plus efficace quant il s'agit des contraintes des
   premières colonnes (celles de gauche). La règle exacte est que les
   contraintes d'égalité sur les premières colonnes, plus toute contrainte
   de différence sur la première colonne qui n'a pas une contrainte d'égalité
   seront utilisées pour limiter la partie parcourue de l'index. Les contraintes
   sur les colonnes à droite de ces colonnes sont vérifiées dans l'index, donc
   elles évitent des visites de la table mais elles ne réduisent pas la partie
   de l'index à parcourir. Par exemple, avec un index sur
   <literal>(a, b, c)</literal> et une condition de requête <literal>WHERE a =
   5 AND b &gt;= 42 AND c &lt; 77</literal>, l'index devrait être parcouru à partir de
   la première entrée avec <literal>a</literal> = 5 et <literal>b</literal> = 42 jusqu'à la
   dernière entrée de <literal>a</literal> = 5. Les entrées de l'index avec
   <literal>c</literal> &gt;= 77 seront passées mais elles devront toujours être
   parcourues. En principe, cet index pourrait être utilisé pour les requêtes
   qui ont des contraintes sur <literal>b</literal> et/ou <literal>c</literal> sans contrainte
   sur <literal>a</literal> &mdash; mais l'index entier devra être parcouru, donc, dans
   la plupart des cas, le planificateur préférera un parcours séquentiel de la
   table plutôt que d'utiliser l'index.
  </para>

  <para>
   Un index GiST multicolonne peut seulement être utilisé quand il existe une
   condition de requête sur sa colonne de tête. Les conditions sur les
   colonnes supplémentaires restreignent les entrées renvoyées par l'index mais
   la condition sur la première colonne est la plus importante pour déterminer
   à quel point l'index devra être parcouru. Un index GiSTsera relativement
   inefficace si sa première colonne a seulement quelques valeurs distinctes
   même s'il y a plein de valeurs distinctes dans les colonnes supplémentaires.
  </para>

  <para>
   Bien sûr, chaque colonne doit être utilisée avec les opérateurs appropriés
   au type de l'index&nbsp;; les clauses qui impliquent d'autres opérateurs ne
   seront pas pris en compte.
  </para>

  <para>
   Les index multicolonnes devraient être utilisés avec parcimonie. Dans la
   plupart des cas, un index sur une seule colonne est suffisant et sauvegarde
   de l'espace et du temps. Les index avec plus de trois colonnes ont un gros
   risque d'être inefficace sauf si l'utilisation de cette table est extrêmement
   stylisée. Voir aussi la <xref linkend="indexes-bitmap-scans"/> pour des
   discussions sur les mérites des différentes configurations d'index.
  </para>
 </sect1>


 <sect1 id="indexes-bitmap-scans">
  <title>Combiner des index multiples</title>

  <indexterm zone="indexes-bitmap-scans">
   <primary>index</primary>
   <secondary>combiner des index multiples</secondary>
  </indexterm>

  <indexterm zone="indexes-bitmap-scans">
   <primary>parcours de bitmap</primary>
  </indexterm>

  <para>
   Un parcours d'index simple utilise les clauses de la requête qui utilisent
   les colonnes de l'index avec les opérateurs de sa classe d'opérateur et qui
   sont joint avec <literal>AND</literal>. Par exemple, étant donné un index sur
   <literal>(a, b)</literal>, une condition de requête <literal>WHERE a = 5
   AND b = 6</literal> pourrait utiliser l'index mais une requête comme
   <literal>WHERE a = 5 OR b = 6</literal> ne pourrait pas utiliser directement
   l'index.
  </para>

  <para>
   À partir de la version 8.1, <productname>PostgreSQL</productname> peut combiner
   plusieurs index (y compris plusieurs utilisations du même index) pour gérer
   les cas qui ne peuvent pas être implémentés avec des parcours d'index
   simples. Le système peut former des conditions <literal>AND</literal>
   et <literal>OR</literal> au travers de plusieurs parcours d'index. Par exemple,
   une requête comme <literal>WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</literal>
   pourrait être divisée en quatre parcours séparés d'un index sur
   <literal>x</literal>, chaque parcours utilisant une des clauses de la requête. Les
   résultats de ces parcours sont alors assemblés avec un OR pour produire le
   résultat. Un autre exemple est que, si nous avons des index séparés sur
   <literal>x</literal> et <literal>y</literal>, une implémentation possible d'une requête
   comme <literal>WHERE x = 5 AND y = 6</literal> est d'utiliser chaque index avec la
   clause de la requête appropriée et d'assembler les différents résultats
   avec un AND pour identifier les lignes résultantes.
  </para>

  <para>
   Pour combiner plusieurs index, le système parcourt chaque index nécessaire
   et prépare un <firstterm>bitmap</firstterm> en mémoire en donnant l'emplacement des
   lignes de table qui sont rapportées comme correspondant aux conditions de
   l'index. Les bitmaps sont ensuite assemblés avec des opérateurs AND ou OR
   suivant les besoins de la requête. Enfin, les lignes réelles de la table
   sont visitées et renvoyées. Elles sont visitées dans l'ordre physique parce
   c'est ainsi que le bitmap est créé&nbsp;; cela signifie que tout ordre
   des index originaux est perdu et que, du coup, une étape de tri séparée sera
   nécessaire si la requête comprend une clause <literal>ORDER BY</literal>. Pour
   cette raison, et parce que chaque parcours d'index supplémentaire ajoute
   un temps additionnel, le planificateur choisira quelque fois d'utiliser un
   parcours d'index simple même si des index supplémentaires sont disponibles
   et auraient aussi pû être utilisés.
  </para>

  <para>
   Dans toutes les applications un peu compliquées, il existe différentes
   combinaisons d'index qui pourraient être utiles. Le développeur de la base
   de données doit faire des concessions pour décider des index à fournir.
   Quelque fois, des index à colonnes multiples sont préférables mais quelque
   fois, il est mieux de créer des index séparés et de dépendre de la
   fonctionnalité des index combinés. Par exemple, si votre temps de travail
   inclut un mixe des requêtes qui impliquent parfois seulement la colonne
   <literal>x</literal>, quelque fois seulement la colonne <literal>y</literal> et quelque
   fois les deux colonnes, vous pourriez choisir deux index séparés sur
   <literal>x</literal> et <literal>y</literal>, en vous reposant sur la combinaison d'index
   pour traiter les requêtes qui utilisent les deux colonnes. Vous pouvez aussi
   créer un index multicolonne sur <literal>(x, y)</literal>. Cet index serait
   typiquement plus efficace que la combinaison d'index pour les requêtes
   impliquant les deux colonnes mais, comme discuté dans la <xref
   linkend="indexes-multicolumn"/>, il serait pratiquement inutile pour les
   requêtes impliquant seulement <literal>y</literal>, donc il ne peut pas être le
   seul index. Une combinaison de l'index multicolonnes et d'un index séparé
   sur <literal>y</literal> serviraient raisonnablement. Pour les requêtes impliquant
   seulement <literal>x</literal>, l'index multicolonne pourrait être utilisé bien
   qu'il soit plus large et donc plus lent qu'un index sur <literal>x</literal> seul.
   La dernière alternative est de créer les trois index mais ceci est
   probablement seulement raisonnable si la table est parcourue bien plus
   fréquemment qu'elle n'est mise à jour et les trois types de requête sont
   communs. Si un des types de requête est bien moins courant que les autres,
   vous devriez probablement en rester à la création des deux seuls index qui
   correspondront le mieux aux types communs.
  </para>

 </sect1>


 <sect1 id="indexes-unique">
  <title>Index uniques</title>

  <indexterm zone="indexes-unique">
   <primary>index</primary>
   <secondary>unique</secondary>
  </indexterm>

  <para>
   Les index peuvent aussi être utilisés pour garantir l'unicité des
   valeurs d'une colonne, ou l'unicité des valeurs combinées de plusieurs 
   colonnes.
<synopsis>
CREATE UNIQUE INDEX <replaceable>nom</replaceable> ON <replaceable>table</replaceable> (<replaceable>colonne</replaceable> <optional>, ...</optional>);
</synopsis>
   À ce jour, seuls les index B-trees peuvent être déclarés uniques.
  </para>

  <para>
   Lorsqu'un index est déclaré unique, des lignes différentes d'une table ne 
   pourront avoir une valeur égale. Les valeurs NULL ne sont pas
   considérées comme égales. Un index unique multicolonnes ne rejette que les
   cas où toutes les colonnes indexées sont égales dans deux lignes.
  </para>

  <para>
   <productname>PostgreSQL</productname> crée automatiquement un index
   unique quand une contrainte unique ou une clé primaire sont définies
   sur une table. L'index porte sur les colonnes qui composent la clé primaire
   ou la contrainte d'unicité (il s'agit d'un index multicolonnes, si c'est
   approprié). Cet index EST le mécanisme qui vérifie la contrainte.
  </para>

  <note>
   <para>
    La méthode la plus appropriée pour ajouter une contrainte à une table
    est <literal>ALTER TABLE ... ADD CONSTRAINT</literal>. L'utilisation des
    index pour vérifier les contraintes uniques doit être considérée comme
    un détail d'implémentation qui ne doit pas être utilisé directement.
    Il faut par contre savoir qu'il n'est pas nécessaire de créer manuellement
    un index sur les colonnes uniques. Cela dupliquerait l'index créé
    automatiquement.
   </para>
  </note>
 </sect1>


 <sect1 id="indexes-expressional">
  <title>Index sur des expressions</title>

  <indexterm zone="indexes-expressional">
   <primary>index</primary>
   <secondary sortas="expressions">sur des expressions</secondary>
  </indexterm>

  <para>
   Une colonne d'index ne correspond pas nécessairement exactement à une 
   colonne de la table associée, mais peut être une fonction ou une expression
   scalaire calculée à partir d'une ou plusieurs colonnes de la table.
   Cette fonctionnalité est utile pour obtenir un accès rapide aux tables
   en se basant sur les résultat des calculs.
  </para>

  <para>
   Par exemple, une façon classique de faire des comparaisons indépendantes
   de la casse est d'utiliser la fonction <function>lower</function>&nbsp;:
<programlisting>
SELECT * FROM test1 WHERE lower(col1) = 'valeur';
</programlisting>
   Si un index a été défini sur le résultat de <literal>lower(col1)</literal>,
   cette requête peut l'utiliser.
   Cet index est créé avec la commande&nbsp;:
<programlisting>
CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));
</programlisting>
  </para>

  <para>
   Si nous avions déclaré cet index <literal>UNIQUE</literal>, il empêcherait
   la création de lignes dont la valeur de la colonne <literal>col1</literal> ne
   diffère que par la casse.
   Ainsi, les index sur les expressions peuvent être utilisés pour
   vérifier des contraintes qui ne peuvent être définies avec une simple
   contrainte.
  </para>

  <para>
   Un autre exemple, si vous faites souvent des requêtes comme celle-ci&nbsp;:
<programlisting>
SELECT * FROM personnes WHERE (prenom || ' ' || nom) = 'Jean Dupont';
</programlisting>
   alors il peut être utile de créer un index comme celui-ci&nbsp;:
<programlisting>
	CREATE INDEX personnes_noms ON personnes ((prenom || ' ' || nom));
</programlisting>
  </para>

  <para>
   La syntaxe de la commande <command>CREATE INDEX</command> nécessite normalement
   de mettre des parenthèses autour de l'expression indexés, comme dans
   l'exemple précédent. Les parenthèses peuvent être omises quand l'expression
   est un simple appel de fonction, comme dans le premier exemple.
  </para>

  <para>
   Les expressions d'index sont relativement coûteuses à calculer car
   l'expression doit être recalculée à chaque insertion ou mise à jour de
   chaque ligne. Néanmoins, les expressions d'index ne sont
   <emphasis>pas</emphasis> recalculés lors d'une recherche par index car ils sont
   déjà stockés dans l'index. Dans les deux exemples ci-dessus, le système
   voit la requête comme un <literal>WHERE colonne_indexée = 'constante'</literal>
   et, du coup, la rapidité de la recherche est équivalente à une autre simple
   recherche d'index. Du coup, les index avec des expressions sont utiles
   quand la rapidité de la recherche est plus importante que la rapidité de
   l'insertion et de la mise à jour.
  </para>
 </sect1>


 <sect1 id="indexes-partial">
  <title>Index partiels</title>

  <indexterm zone="indexes-partial">
   <primary>index</primary>
   <secondary>partiel</secondary>
  </indexterm>

  <para>
   Un <firstterm>index partiel</firstterm> est un index construit sur un
   sous-ensemble d'une table&nbsp;; le sous-ensemble est défini par une expression
   conditionnelle (appelée le <firstterm>prédicat</firstterm> de l'index
   partiel). L'index ne contient des entrées que pour les lignes de la
   table qui satisfont au prédicat. Les index partiels sont une fonctionnalité
   spécialisée mais il existe plusieurs situations où ils sont utiles.
  </para>

  <para>
   Une raison majeure pour l'usage principal des index partiels est d'éviter
   d'indexer les valeurs trop courantes. Comme une requête qui fait des
   recherches sur une valeur trop courante (qui correspond à plus de quelques
   pour-cent des lignes) n'utilisera pas cet index de toute façon, il ne sert
   à rien de garder  ces lignes dans l'index. Cela réduit la taille de l'index,
   ce qui accélère les requêtes qui l'utilisent. Cela accélère aussi beaucoup
   d'opérations de mise à jour de la table car l'index n'a pas besoin d'être
   mis à jour à chaque fois. L'<xref linkend="indexes-partial-ex1"/> montre une
   application possible de cette idée.
  </para>

  <example id="indexes-partial-ex1">
   <title>Mettre en place un index partiel pour exclure les valeurs courantes</title>

   <para>
    Supposons que vous enregistrez un journal d'accès à un serveur web dans une 
    base de données.
    La plupart des accès proviennent de classes d'adresses IP internes à votre
    organisation, mais certaines viennent d'ailleurs (disons des employés connectés
    par modem).
    Si vos recherches sur des adresses IP concernent essentiellement les accès
    extérieurs, vous n'avez probablement pas besoin d'indexer les classes
    d'adresses IP qui correspondent au sous-réseau de votre organisation.

   </para>

   <para>
    Supposons que la table soit comme ceci&nbsp;:
<programlisting>
CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);
</programlisting>
   </para>

   <para>
    Pour créer un index partiel qui corresponde à notre exemple, il faut utiliser 
    une commande comme celle-ci&nbsp;:
<programlisting>
CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
    WHERE NOT (client_ip &gt; inet '192.168.100.0' AND client_ip &lt; inet '192.168.100.255');
</programlisting>
   </para>

   <para>
    Une requête typique pouvant utiliser cet index est&nbsp;:
<programlisting>
SELECT * FROM access_log WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';
</programlisting>
    Une requête qui ne peut pas l'utiliser est&nbsp;:
<programlisting>
SELECT * FROM access_log WHERE client_ip = inet '192.168.100.23';
</programlisting>
   </para>

   <para>
    Observez que ce type d'index partiel nécessite que les valeurs courantes
    soient prédéterminées. Si la distribution des valeurs est inhérente
    (du fait de la nature de l'application) et statique (ne changeant pas dans 
    le temps), ce n'est pas trop difficile mais, si les valeurs courantes sont
    simplement dues au hasard, cela peut demander beaucoup de travail de
    maintenance pour modifier la définition de l'index de temps en temps.
   </para>
  </example>

  <para>
   Une autre utilisation possible d'un index partiel revient à exclure des
   valeurs de l'index qui ne correspondent pas aux requêtes courantes&nbsp;;
   ceci est montré dans l'<xref linkend="indexes-partial-ex2"/>. Cette méthode
   donne les mêmes avantages que la précédente mais empêche l'accès aux valeurs
   <quote>sans intérêt</quote>. Évidemment, mettre en place des index partiels
   pour ce genre de scénario nécessite beaucoup de soin et d'expérimentation.
  </para>

  <example id="indexes-partial-ex2">
   <title>Mettre en place un index partiel pour exclure les valeurs inintéressantes</title>

   <para>
    Si vous avez une table qui contient des commandes facturées et des
    commandes non facturées, que les commandes non facturées ne prennent
    qu'une petite fraction de l'espace dans la table, et que ces commandes
    non facturées sont les plus utilisées, alors vous pouvez améliorer les 
    performances en créant un index limité aux lignes non facturées.
    La commande pour créer l'index ressemblerait à ceci&nbsp;:
<programlisting>
CREATE INDEX index_commandes_nonfacturees ON commandes (no_commande)
    WHERE facturee is not true;
</programlisting>
   </para>

   <para>
    La requête suivante utilise probablement cet index&nbsp;:
<programlisting>
SELECT * FROM commandes WHERE facturee is not true AND no_commande &lt; 10000;
</programlisting>
    Néanmoins, l'index peut aussi être utilisé dans des requêtes qui
    n'utilisent pas <structfield>no_commande</structfield>, comme&nbsp;:
<programlisting>
SELECT * FROM commandes WHERE facturee is not true AND montant &gt; 5000.00;
</programlisting>
    Ceci n'est pas aussi efficace qu'un index partiel sur la colonne
    <structfield>montant</structfield> car le système doit lire l'index en entier.
    Néanmoins, s'il y a assez peu de commandes non facturées, l'utilisation
    de cet index partiel pour trouver les commandes non facturées peut être
    efficace.
   </para>

   <para>
    Notez que cette requête ne peut pas utiliser cet index&nbsp;:
<programlisting>
SELECT * FROM commandes WHERE no_commande = 3501;
</programlisting>
    La commande 3501 peut faire partie des commandes facturées ou
    bien des commandes non facturées.
   </para>
  </example>

  <para>
   L'<xref linkend="indexes-partial-ex2"/> illustre aussi le fait que la colonne
   indexée et la colonne utilisée dans le prédicat ne sont pas nécessairement
   les mêmes. <productname>PostgreSQL</productname> supporte tous les
   prédicats sur les index partiels, tant que ceux-ci ne portent que sur des
   champs de la table indexée. Néanmoins, il faut se rappeler que le prédicat doit
   correspondre aux conditions utilisées dans les requêtes qui sont supposées
   profiter de l'index. Pour être précis, un index partiel ne peut être utilisé
   pour une requête que si le système peut reconnaître que la clause 
   <literal>WHERE</literal> de la requête implique mathématiquement le prédicat de
   l'index.
   <productname>PostgreSQL</productname> n'a pas de méthode sophistiquée de
   démonstration de théorème pour reconnaître que des expressions apparemment
   différentes sont mathématiquement équivalentes (non seulement une telle
   méthode générale de démonstration serait extrêmement complexe à créer
   mais, en plus, elle serait probablement trop lente pour être d'une quelconque
   utilité).
   Le système peut reconnaître des implications d'inégalités simples, par
   exemple <quote>x &lt; 1</quote> implique <quote>x &lt; 2</quote>&nbsp;; sinon,
   la condition du prédicat doit correspondre exactement à une partie de la
   clause <literal>WHERE</literal> de la requête, sans quoi l'index ne sera pas
   considéré comme utilisable.
  </para>

  <para>
   Le troisième usage possible des index partiels ne nécessite pas que
   l'index soit utilisé dans des requêtes. L'idée ici est de créer un index
   unique sur un sous-ensemble de la table, comme dans l'<xref
   linkend="indexes-partial-ex3"/>. Ceci permet de mettre en place une unicité
   parmi le sous-ensemble des lignes de la table qui satisfont au prédicat,
   sans contraindre les lignes qui n'y satisfont pas.
  </para>

  <example id="indexes-partial-ex3">
   <title>Mettre en place un index unique partiel</title>

   <para>
    Supposons que nous ayons une table qui décrive des résultats de tests.
    Nous voulons nous assurer qu'il n'y a qu'une seule entrée 
    <quote>succès</quote> (succes) pour chaque combinaison de sujet et de
    résultat, mais il peut y avoir un nombre quelconque d'entrées
    <quote>echec</quote>. Voici une façon de le faire.
<programlisting>
CREATE TABLE tests (
    sujet text,
    resultat text,
    succes boolean,
    ...
);

CREATE UNIQUE INDEX contrainte_tests_reussis ON tests (sujet, resultat)
    WHERE succes;
</programlisting>
    C'est une méthode très efficace pour le faire quand il y a peu de tests
    réussis et beaucoup de tests en échec.
   </para>
  </example>

  <para>
   Enfin, un index partiel peut aussi être utilisé pour passer outre les
   choix de plan d'exécution de requête du système.
   Il peut arriver avec certains jeux de données particuliers que le
   système utilise un index alors qu'il ne devrait vraiment pas le faire.
   Dans ce cas, on peut mettre en place l'index de telle façon qu'il ne soit 
   pas utilisé pour la requête qui pose problème.
   Normalement, <productname>PostgreSQL</productname> fait des choix d'usage d'index
   raisonnables. Par exemple, il les évite pour rechercher les valeurs communes,
   si bien que l'exemple précédent n'économise que la taille de l'index, il
   n'est en fait pas nécessaire pour éviter l'usage de l'index.
   En fait, les choix de plan d'exécution grossièrement incorrects doivent
   être traités comme des bogues, et être transmis à l'équipe de développement.
  </para>

  <para>
   Gardez à l'esprit que mettre en place un index partiel indique que vous
   connaissez vos données au moins aussi bien que l'analyseur de requêtes
   et, en particulier, que vous savez quand un index peut être profitable.
   Une telle connaissance nécessite de l'expérience et une bonne
   compréhension du fonctionnement des index de <productname>PostgreSQL</productname>.
   Dans la plupart des cas, les index partiels ne représentent pas un
   gros gain par rapport aux index classiques.
  </para>

  <para>
   Vous trouverez plus d'informations sur les index partiels
   en lisant <xref linkend="STON89b"/>, <xref linkend="OLSON93"/>
   et <xref linkend="SESHADRI95"/>.
  </para>
 </sect1>

 <sect1 id="indexes-opclass">
  <title>Classes d'opérateurs</title>

  <indexterm zone="indexes-opclass">
   <primary>classe d'opérateurs</primary>
  </indexterm>

  <para>
   Une définition d'index peut indiquer une <firstterm>classe 
   d'opérateurs</firstterm> pour chaque colonne de l'index.
<synopsis>
CREATE INDEX <replaceable>nom</replaceable> ON <replaceable>table</replaceable> (<replaceable>colonne</replaceable> <replaceable>classe_operateur</replaceable> <optional>, ...</optional>);
</synopsis>
   La classe d'opérateurs identifie les opérateurs que l'index doit utiliser 
   sur cette colonne. Par exemple, un index B-tree sur une colonne de type
   <type>int4</type> utiliserait la classe <literal>int4_ops</literal>.
   Cette classe d'opérateurs comprend des fonctions de comparaison pour les
   valeurs de type <type>int4</type>.
   En pratique, la classe d'opérateurs par défaut pour le type de données de la
   colonne est généralement suffisant. Les classes d'opérateurs sont utiles pour
   certains types de données, pour lesquels il pourrait y avoir plus d'un
   comportement utile de l'index.
   Par exemple, nous pourrions vouloir trier une donnée de type nombre complexe
   soit par sa valeur absolue, soit par sa partie entière.
   Nous pourrions le faire en définissant deux classes d'opérateurs pour ce 
   type de données et en sélectionnant la bonne classe en créant l'index.
  </para>

  <para>
   Il y a quelques classes d'opérateurs en plus des classes par défaut:

   <itemizedlist>
    <listitem>
     <para>
      Les classes d'opérateurs <literal>text_pattern_ops</literal>,
      <literal>varchar_pattern_ops</literal>,
      <literal>bpchar_pattern_ops</literal>, et
      <literal>name_pattern_ops</literal> supportent les index B-tree sur
      les types <type>text</type>, <type>varchar</type>,
<type>char</type>, et <type>name</type>, respectivement.
      La différence avec les classes d'opérateurs par défaut est que
      les valeurs sont comparées strictement caractère par caractère plutôt 
      que suivant les règles de tri spécifiques à la localisation.
      Cela rend ces index utilisables pour des requêtes qui utilisent des
      recherches sur des motifs (<literal>LIKE</literal> ou des expressions 
      régulières POSIX) quand le serveur n'utilise pas la localisation standard
      <quote>C</quote>.
      Par exemple, on pourrait indexer une colonne <type>varchar</type>
      comme ceci:
<programlisting>
CREATE INDEX test_index ON test_table (col varchar_pattern_ops);
</programlisting>
      Notez qu'il faut créer un index avec la classe d'opérateurs par
      défaut si vous voulez que les requêtes qui utilisent une comparaison
      ordinaire utilisent un index. De telles requêtes ne peuvent pas utiliser
      les classes d'opérateurs 
      <literal><replaceable>xxx</replaceable>_pattern_ops</literal>.
      Il est possible de créer plusieurs index sur la même colonne
      avec différentes classes d'opérateurs.
      Si vous utilisez la locale C, vous n'avez pas besoin des classes
      d'opérateur <literal><replaceable>xxx</replaceable>_pattern_ops</literal>
      car un index avec une classe d'opérateur par défaut est utilisable pour
      les requêtes de correspondance de modèles dans la locale C.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
    Les requêtes suivantes montrent toutes les classes d'opérateurs prédéfinies:

<programlisting>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name
    FROM pg_am am, pg_opclass opc
    WHERE opc.opcamid = am.oid
    ORDER BY index_method, opclass_name;
</programlisting>

    Elle peut être étendue pour montrer tous les opérateurs inclus dans chaque classe:
    
<programlisting>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opr.oid::regoperator AS opclass_operator
    FROM pg_am am, pg_opclass opc, pg_amop amop, pg_operator opr
    WHERE opc.opcamid = am.oid AND
          amop.amopclaid = opc.oid AND
          amop.amopopr = opr.oid
    ORDER BY index_method, opclass_name, opclass_operator;
</programlisting>
  </para>
 </sect1>


 <sect1 id="indexes-examine">
  <title>Examiner l'usage des index</title>

  <indexterm zone="indexes-examine">
   <primary>index</primary>
   <secondary>examiner l'usage</secondary>
  </indexterm>

  <para>
   Bien que les index de <productname>PostgreSQL</productname> n'aient pas besoin
   de maintenance ni d'optimisation, il est important de s'assurer que les
   index sont effectivement utilisés sur un système en production.
   On vérifie l'utilisation d'un index pour une requête particulière avec
   la commande <xref linkend="sql-explain" endterm="sql-explain-title"/>.
   Son utilisation dans notre cas est expliquée dans la
   <xref linkend="using-explain"/>.
   Il est aussi possible de rassembler des statistiques globales
   sur l'utilisation des index sur un serveur en cours de fonctionnement,
   comme décrit dans la <xref linkend="monitoring-stats"/>.
  </para>

  <para>
   Il est difficile de donner une procédure générale pour déterminer
   quels index doivent être créés. Plusieurs cas typiques ont été
   cités dans les exemples précédents.
   Une bonne dose d'expérimentation sera nécessaire dans de nombreux cas.
   Le reste de cette section donne quelques pistes.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     La première chose à faire est de lancer 
     <xref linkend="sql-analyze" endterm="sql-analyze-title"/>.
     Cette commande collecte les informations sur la distribution des
     valeurs dans la table. Cette information est nécessaire pour essayer de
     deviner le nombre lignes retournées par une requête. L'optimiseur
     de requêtes en a besoin pour donner des coûts réalistes aux différents
     plans de requêtes possibles. En l'absence de statistiques réelles,
     le système utilise quelques valeurs par défaut, qui ont toutes les chances
     d'être inadaptées. Examiner l'utilisation des index par une application
     sans avoir lancé <command>ANALYZE</command> préalablement est du coup
     une cause perdue.
    </para>
   </listitem>

   <listitem>
    <para>
     Utilisez des données réelles pour l'expérimentation. Utiliser des
     données de test pour mettre en place des index vous permettra
     de trouver les index dont vous avez besoin pour vos données de test,
     mais c'est tout.
    </para>

    <para>
     Il est particulièrement néfaste d'utiliser des jeux de données 
     très réduits.
     Alors qu'une requête sélectionnant 1000 lignes parmi 100000 pourrait
     utiliser un index, il est peu probable qu'une requête sélectionnant 1 ligne
     dans une table de 100 lignes le fasse, parce que les 100 lignes
     tiennent probablement dans une seule page sur le disque, et qu'il n'y a
     aucun plan d'exécution qui puisse aller plus vite que la lecture 
     d'une seule page.
    </para>

    <para>
     Soyez aussi vigilant en créant des données de test, ce qui est souvent
     inévitable quand l'application n'est pas encore en production.
     Les valeurs qui sont très similaires, complètement aléatoire, ou
     insérées déjà triées peuvent modifier la distribution des données et
     fausser les statistiques.
    </para>
   </listitem>

   <listitem>
    <para>
     Quand les index ne sont pas utilisés, il peut être utile pour
     les tests de forcer leur utilisation. Certains paramètres d'exécution
     du serveur peuvent interdire certains types de plans (voir
     la <xref linkend="runtime-config-query-enable"/>).
     Par exemple, en interdisant les lectures séquentielles de tables 
     <varname>enable_seqscan</varname>) et les jointures à boucles imbriquées
     (<varname>enable_nestloop</varname>), qui sont les deux plans les plus
     basiques, on forcera le système à utiliser un plan différent.
     Si le système continue néanmoins à choisir une lecture séquentielle
     ou une jointure à boucles imbriquées, alors il y a probablement
     une raison plus fondamentale qui empêche l'utilisation de l'index&nbsp;;
     par exemple que la condition ne correspond pas à l'index.
     (Les sections précédentes expliquent quelles sortes de requêtes peuvent
     utiliser quelles sortes d'index.)
    </para>
   </listitem>

   <listitem>
    <para>
     Si l'index est effectivement utilisé en forçant son utilisation,
     alors il y a deux possibilités: Soit le système a raison et 
     l'utilisation de l'index est effectivement inappropriée, soit les
     coûts estimés des plans de requêtes ne reflètent pas la réalité.
     Il faut alors comparer la durée de la requête avec et sans
     index. La commande <command>EXPLAIN ANALYZE</command> peut être
     utile pour cela.
    </para>
   </listitem>

   <listitem>
    <para>
     S'il apparaît que les estimations de coûts sont fausses, il y a
     de nouveau deux possibilités. Le coût total est calculé à partir du
     coût par ligne de chaque n&oelig;ud du plan, multiplié par l'estimation de
     sélectivité du n&oelig;ud de plan.
     Le coût estimé des n&oelig;uds de plan peut être ajusté avec
     des paramètres d'exécution (décrits dans la <xref
     linkend="runtime-config-query-constants"/>).
     Une estimation de sélectivité inadaptée est due à des statistiques 
     insuffisantes. Il est peut être possible de les améliorer en 
     optimisant les paramètres de collecte de statistiques.
     Voir <xref linkend="sql-altertable" endterm="sql-altertable-title"/>.
    </para>

    <para>
     Si vous n'arrivez pas à ajuster les coûts pour qu'ils représentent
     mieux la réalité, alors vous devrez forcer l'utilisation de l'index
     explicitement.
     Si vous le voulez, Vous pouvez aussi contacter les développeurs de
     <productname>PostgreSQL</productname> afin qu'ils examinent le problème.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
