<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="information-schema">
 <title>Schéma d'information</title>

 <indexterm zone="information-schema">
  <primary>schéma d'information</primary>
 </indexterm>

 <para>
  Le schéma d'information consiste en un ensemble de vues contenant des
  informations sur les objets définis dans la base de données courante. Le
  schéma d'information est défini dans le standard SQL et, donc
  supposé portable et stable &mdash; contrairement aux catalogues système qui
  sont spécifiques à <productname>PostgreSQL</productname> et modelés suivant
  l'implantation. Néanmoins, les vues du schéma d'information ne contiennent
  pas d'informations sur les fonctionnalités spécifiques à
  <productname>PostgreSQL</productname>&nbsp;; pour cela, on utilise
  catalogues système et autres vues spécifiques à
  <productname>PostgreSQL</productname>.
 </para>

 <sect1 id="infoschema-schema">
  <title>Le schéma</title>

  <para>
   Le schéma d'information est lui-même un schéma nommé 
   <literal>information_schema</literal>. Ce schéma existe automatiquement dans
   toutes les bases de données. Le propriétaire de ce schéma est l'utilisateur
   initial du cluster. Il a naturellement
   tous les droits sur ce schéma, dont la possibilité de le supprimer
   (mais l'espace gagné ainsi sera minuscule).
  </para>

  <para>
   Par défaut, le schéma d'information n'est pas dans le chemin de recherche
   des schémas. Il est donc nécessaire d'accéder à tous les objets qu'il contient
   via des noms qualifiés. Comme les noms de certains objets du schéma
   d'information sont des noms génériques pouvant survenir dans les applications
   utilisateur, il convient d'être prudent avant de placer le schéma
   d'information dans le chemin.
  </para>
 </sect1>

 <sect1 id="infoschema-datatypes">
  <title>Types de données</title>

  <para>
   Les colonnes des vues du schéma d'information utilisent des types de 
   données spéciaux, définis dans le schéma d'information. Ils sont définis
   comme des domaines simples sur des types internes. Vous  normal, il est
   préférable de ne pas utiliser ces types en dehors du schéma d'information, 
   mais les applications doivent pouvoir les utiliser si des sélections sont
   faites dans le schéma d'information.
  </para>

  <para>
   Ces types sont&nbsp;:

   <variablelist>
    <varlistentry>
     <term><type>cardinal_number</type></term>
     <listitem>
      <para>
       Un entier non négatif.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>character_data</type></term>
     <listitem>
      <para>
       Une chaîne de caractères (sans longueur maximale indiquée).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>sql_identifier</type></term>
     <listitem>
      <para>
       Une chaîne de caractères. Elle est utilisée pour les identifiants SQL,
       le type de données <type>character_data</type> est utilisé pour tout
       autre type de données texte.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>time_stamp</type></term>
     <listitem>
      <para>
       Un domaine au-dessus du type <type>timestamp with time zone</type>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Chaque colonne du schéma d'information est de l'un des ces quatre types.
  </para>

  <para>
   Les données booléennes (true/false) sont représentées dans le schéma
   d'informations par une colonne de type <type>character_data</type> contenant
   soit <literal>YES</literal> soit <literal>NO</literal>. (Le schéma
   d'information a été inventé avant que le type <type>boolean</type> ne soit
   ajouté au standard SQL. Cette convention est ainsi nécessaire pour conserver
   la rétro-compatibilité du schéma d'informations).
  </para>
 </sect1>

 <sect1 id="infoschema-information-schema-catalog-name">
  <title><literal>information_schema_catalog_name</literal></title>

  <para>
   <literal>information_schema_catalog_name</literal> est une table qui
   contient en permanence une ligne et une colonne contenant le nom de la base
   de données courante (catalogue courant dans la terminologie SQL).
  </para>

  <table>
   <title>Colonnes de <literal>information_schema_catalog_name</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant ce schéma
        d'informations</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-administrable-role-authorizations">
  <title><literal>administrable_role_authorizations</literal></title>

  <para>
   La vue <literal>administrable_role_authorizations</literal>
   identifie tous les rôles pour lesquelles l'utilisateur courant possède l'option
   ADMIN.
  </para>

  <table>
   <title>Colonnes de <literal>administrable_role_authorizations</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du rôle pour lequel cette appartenance de rôle a été donnée
       (peut être l'utilisateur courant ou un rôle différent dans le cas
       d'appartenances de rôles imbriquées).
      </entry>
     </row>

     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'un rôle</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>YES</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-applicable-roles">
  <title><literal>applicable_roles</literal></title>

  <para>
   La vue <literal>applicable_roles</literal> identifie tous les rôles dont
   l'utilisateur courant peut utiliser les droits. Cela signifie qu'il y a
   certaines chaînes de donnation des droits de l'utilisateur courant au
   rôle en question. L'utilisateur lui-même est un rôle applicable.
   L'ensemble de rôles applicables est habituellement utilisé pour la
   vérification des droits.
   <indexterm><primary>applicable role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>applicable</secondary></indexterm>
  </para>

  <table>
   <title>Colonnes de <literal>applicable_roles</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.4*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du rôle à qui cette appartenance a été donnée (peut être
       l'utilisateur courant ou un rôle différent dans le cas d'appartenances
       de rôles imbriquées)
      </entry>
     </row>

     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'un rôle</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si le bénéficiaire a l'option ADMIN sur le rôle,
       <literal>NO</literal> dans le cas contraire
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-attributes">
  <title><literal>attributes</literal></title>

  <para>
   La vue <literal>attributes</literal> contient des informations sur les
   attributs des types de données composites définis dans la base.
   (La vue ne donne pas d'informations sur les colonnes de table,
   qui sont quelque fois appelées attributs dans le contexte de PostgreSQL.)
  </para>

  <table>
   <title>Colonnes de <literal>attributes</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base contenant le type de données (toujours la base
       courante)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le type de données</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type de données</entry>
     </row>

     <row>
      <entry><literal>attribute_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'attribut</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Position de l'attribut dans le type de données (le décompte commence
       à 1)</entry>
     </row>

     <row>
      <entry><literal>attribute_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Expression par défaut de l'attribut</entry>
     </row>

     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si l'attribut peut être NULL,
       <literal>NO</literal> dans le cas contraire.
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données de l'attribut s'il s'agit d'un type interne ou
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir
       la vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié
       dans <literal>attribute_udt_name</literal> et les colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un caractère ou une chaîne
       de bits, la longueur maximale déclarée&nbsp;; NULL pour tous les autres
       types de données ou si aucune longueur maximale n'a été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type caractère,
       la longueur maximale en octets (bytes) d'un datum (ne
       concerne pas les utilisateurs de
       <productname>PostgreSQL</productname>)&nbsp;; NULL pour tous les autres
       types.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette colonne
       contient la précision (déclarée ou implicite) du type pour cet attribut.
       La précision indique le nombre de chiffres significatifs. Elle peut être
       exprimée en décimal (base 10) ou en binaire (base 2) comme le précise la
       colonne <literal>numeric_precision_radix</literal>. Pour tous les autres
       types de données, cette colonne vaut NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette colonne
       indique la base d'expression des colonnes <literal>numeric_precision</literal>
       et <literal>numeric_scale</literal>. La valeur est soit 2 soit 10. Pour
       tous les autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique exact,
       cette colonne contient l'échelle (déclarée ou implicite) du type pour cet
       attribut. L'échelle indique le nombre de chiffres significatifs à droite
       du point décimal. Elle peut être exprimée en décimal (base 10) ou en
       binaire (base 2) comme le précise la colonne
       <literal>numeric_precision_radix</literal>. Pour tous les autres types
       de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie une date, une heure, un
       horodatage ou un interval, cette colonne contient la précision en
       secondes (déclarée ou implicite) pour cet attribut, c'est-à-dire le
       nombre de chiffres décimaux suivant le point décimal de la valeur
       en secondes. Pour tous les autres types de données, cette colonne
       est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>attribute_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base dans laquelle le type de données de l'attribut est défini (toujours
       la base courante)
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma dans lequel le type de données de l'attribut est défini
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données de l'attribut
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux ont toujours une cardinalité maximale
       dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur du type de données de la colonne, unique
       parmi les descripteurs de types de données de la table. Ceci est
       principalement utile pour des jointures avec d'autres instances de tels
       identifiants. (Le format spécifique de l'identifiant n'est pas défini
       et il n'est pas garanti qu'il reste identique dans les versions futures.)
      </entry>
     </row>

     <row>
      <entry><literal>is_derived_reference_attribute</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Voir aussi dans <xref linkend="infoschema-columns"/>, une vue structurée de
   façon similaire, pour plus d'informations sur certaines colonnes.
  </para>
 </sect1>

 <sect1 id="infoschema-check-constraint-routine-usage">
  <title><literal>check_constraint_routine_usage</literal></title>

  <para>
   La vue <literal>check_constraint_routine_usage</literal> identifie les
   routines (fonctions et procédures) utilisées par une contrainte de
   vérification. Seules sont présentées les routines qui appartiennent à un rôle
   couramment actif.
  </para>

  <table>
   <title>Colonnes de <literal>check_constraint_routine_usage</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base contenant la contrainte (toujours la base courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base contenant la fonction (toujours la base courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraints">
  <title><literal>check_constraints</literal></title>

  <para>
   La vue <literal>check_constraints</literal> contient toutes les contraintes
   de vérification définies sur une table ou un domaine, possédées
   par un rôle couramment actif (le propriétaire d'une table ou d'un domaine est
   le propriétaire de la contrainte).
  </para>

  <table>
   <title>Colonnes de <literal>check_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la base
        de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>check_clause</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>L'expression de vérification de la contrainte</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-domain-usage">
  <title><literal>column_domain_usage</literal></title>

  <para>
   La vue <literal>column_domain_usage</literal> identifie toutes les colonnes
   (d'une table ou d'une vue) utilisant un domaine défini dans la base de
   données courante et possédé par un rôle couramment actif.
  </para>

  <table>
   <title>Colonnes de <literal>column_domain_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours la base de
        données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
        données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-privileges">
  <title><literal>column_privileges</literal></title>

  <para>
   La vue <literal>column_privileges</literal> identifie tous les droits
   octroyés sur les colonnes à un rôle couramment actif ou par un rôle
   couramment actif. Il existe une ligne pour chaque combinaison colonne,
   donneur (<foreignphrase>grantor</foreignphrase>) et receveur
   (<foreignphrase>grantee</foreignphrase>).
  </para>

  <para>
   Si un droit a été donné sur une table entière, il s'affichera dans cette vue
   comme un droit sur chaque colonne, mais seulement pour les types de droits
   où la granularité par colonne est possible&nbsp;:
   <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal>, <literal>REFERENCES</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>column_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle ayant accordé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle receveur</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table qui contient la
      colonne (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table qui contient la colonne</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table qui contient la colonne</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de privilège&nbsp;: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal> ou
       <literal>REFERENCES</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être accordé,
<literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-column-udt-usage">
  <title><literal>column_udt_usage</literal></title>

  <para>
   La vue <literal>column_udt_usage</literal> identifie toutes les colonnes
   qui utilisent les types de données possédés par un rôle actif.
   Avec <productname>PostgreSQL</productname>, les types de données
   internes se comportent comme des types utilisateur, ils apparaissent
   aussi ici. Voir aussi la <xref linkend="infoschema-columns"/>
   pour plus de détails.
  </para>

  <table>
   <title>Colonnes de <literal>column_udt_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données dans laquelle le type de donnée de la colonne (le type
       sous-jacent du domaine, si applicable) est défini (toujours la base de
       données courante).
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma dans lequel le type de donnée de la colonne (le type
       sous-jacent du domaine, si applicable) est défini.
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données de la colonne (le type sous-jacent du domaine,
       si applicable).
      </entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
       données courante).</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table.</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table.</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-columns">
  <title><literal>columns</literal></title>

  <para>
   La vue <literal>columns</literal> contient des informations sur toutes les
   colonnes de table (et colonnes de vue) de la base. Les colonnes
   système (<literal>oid</literal>, etc.) ne sont pas incluses. Seules les colonnes
   auxquelles l'utilisateur a accès (par propriété ou par
   privilèges) sont affichées.
  </para>

  <table>
   <title>Colonnes de <literal>columns</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Position de la colonne dans la table (la numérotation commençant à
       1)</entry>
     </row>

     <row>
      <entry><literal>column_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Expression par défaut de la colonne</entry>
     </row>

     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si la colonne est
       <foreignphrase>NULLable</foreignphrase> (elle admet une absence de
       valeur),
       <literal>NO</literal> dans le cas contraire. La contrainte NOT NULL n'est
       pas la seule façon de définir qu'une colonne n'est pas
       <foreignphrase>NULLable</foreignphrase>.
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type de données de la colonne, s'il s'agit d'un type interne ou
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas,
       voir la vue <literal>element_types</literal>),
       <literal>USER-DEFINED</literal> dans les autres cas (le type est alors identifié
       dans <literal>udt_name</literal> et colonnes associées). Si la
       colonne est fondée sur un domaine, cette colonne est une référence au type
       sous-jacent du domaine (et le domaine est identifié dans
       <literal>domain_name</literal> et colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type chaîne de caractères 
       ou chaîne de bits, la longueur maximale déclarée&nbsp;; NULL pour tous les
       autres types de données ou si aucune longueur maximale n'a été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type caractère, la longueur
       maximale en octets (bytes) d'un datum (ne concerne pas les
       utilisateurs de <productname>PostgreSQL</productname>)&nbsp;; NULL pour les
       autres types de données.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette
       colonne contient la précision (déclarée ou implicite) du type pour ce
       domaine. La précision indique le nombre de chiffres significatifs.
       Elle peut être exprimée en décimal (base 10) ou en binaire (base 2)
       comme indiqué dans la colonne
       <literal>numeric_precision_radix</literal>. Pour tous les autres types de
       données, la colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette
       colonne indique dans quelle base les valeurs des colonnes
       <literal>numeric_precision</literal> et      
       <literal>numeric_scale</literal> sont exprimées. La valeur est 2
       ou 10. Pour tous les autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numeric exact,
       cette colonne contient l'échelle (déclarée ou implicite) du type pour ce
       domaine. L'échelle indique le nombre de chiffres significatifs à la
       droite du point décimal. Elle peut être exprimée en décimal (base 10)
       ou en binaire (base 2), comme indiqué dans la colonne
       <literal>numeric_precision_radix</literal>. Pour tous les autres types de
       données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie une date, une heure, un
       horodatage ou un interval, cette colonne contient la précision en
       secondes (déclarée ou implicite) pour cet attribut, c'est-à-dire le
       nombre de chiffres décimaux suivant le point décimal de la valeur
       en secondes. Pour tous les autres types de données, cette colonne
       est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Si la colonne a un type domaine, le nom de la base de données où le type
       est défini (toujours la base de données courante), sinon NULL.
      </entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Si la colonne a un type domaine, le nom du schéma où le domaine est
       défini, sinon NULL.
      </entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Si la colonne a un type de domaine, le nom du domaine, sinon
       NULL.</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données où le type de données de la colonne (le type
       sous-jacent du domaine, si applicable) est défini (toujours la base de
       données courante).
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma où le type de données de la colonne (le type sous-jacent
       du domaine, si applicable) est défini.
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données de la colonne (le type sous-jacent du domaine,
       si applicable).
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux ont toujours une cardinalité 
       maximale illimitée avec <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur du type de données de la colonne, unique
       parmi les descripteurs de type de données contenus dans la table. Ceci 
       est principalement utile pour joindre d'autres instances de ces
       identifiants. (Le format spécifique de l'identifiant n'est pas défini et
       rien ne permet d'assurer qu'il restera inchangé dans les versions
       futures.)
      </entry>
     </row>

     <row>
      <entry><literal>is_self_referencing</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_identity</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_start</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_increment</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_maximum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_minimum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>identity_cycle</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_generated</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>generation_expression</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
      <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si la colonne est actualisable,
       <literal>NO</literal> dans le cas contraire (les colonnes des tables
       sont toujours modifiables, les colonnes des vues ne le sont pas
       nécessairement).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Puisqu'en SQL les possibilités de définir les types de données sont
   nombreuses, et que <productname>PostgreSQL</productname> offre des
   possibilités supplémentaires, leur représentation dans le schéma
   d'information peut s'avérer complexe. 
  </para>

  <para>
   La colonne <literal>data_type</literal> est supposée identifier le type de
   données interne sous-jacent de la colonne. Avec
   <productname>PostgreSQL</productname>, cela signifie que le type est défini
   dans le schéma du catalogue système <literal>pg_catalog</literal>. Cette
   colonne est utile si l'application sait gérer les
   types internes (par exemple, formater les types numériques différemment
   ou utiliser les données dans les colonnes de précision). Les colonnes
   <literal>udt_name</literal>, <literal>udt_schema</literal> et
   <literal>udt_catalog</literal> identifient toujours le type de données
   sous-jacent de la colonne même si la colonne est basée sur un domaine.
  </para>

  <para>
   Puisque <productname>PostgreSQL</productname> traite les types internes comme des
   types utilisateur, les types internes apparaissent aussi ici.
   Il s'agit d'une extension du standard SQL.
  </para>
  
  <para>
   Toute application conçue pour traiter les données en fonction du type peut
   utiliser ces colonnes, car, dans ce cas, il importe peu de savoir si la
   colonne est effectivement fondée sur un domaine.
   Si la colonne est fondée sur un domaine, l'identité du domaine est
   stockée dans les colonnes <literal>domain_name</literal>,
   <literal>domain_schema</literal> et <literal>domain_catalog</literal>. Pour
   assembler les colonnes avec leurs types de données associés et
   traiter les domaines comme des types séparés, on peut écrire
   <literal>coalesce(domain_name, udt_name)</literal>, etc.
  </para>
 </sect1>

 <sect1 id="infoschema-constraint-column-usage">
  <title><literal>constraint_column_usage</literal></title>

  <para>
   La vue <literal>constraint_column_usage</literal> identifie toutes les
   colonnes de la base de données courante utilisées par des contraintes.
   Seules sont affichées les colonnes contenues dans une table possédée par
   un rôle connecté. Pour une contrainte de vérification, cette vue
   identifie les colonnes utilisées dans l'expression de la vérification. Pour
   une contrainte de clé étrangère, cette vue identifie les colonnes que la clé
   étrangère référence. Pour une contrainte d'unicité ou de clé primaire, cette vue
   identifie les colonnes contraintes.
  </para>

  <table>
   <title>Colonnes de <literal>constraint_column_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la table contenant la colonne
       utilisée par certaines contraintes (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant la table contenant la colonne utilisée par
       certaines contraintes
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table contenant la colonne utilisée par certaines contraintes
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la colonne utilisée par certaines contraintes
      </entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-constraint-table-usage">
  <title><literal>constraint_table_usage</literal></title>

  <para>
   La vue <literal>constraint_table_usage</literal> identifie toutes les
   tables de la base de données courante utilisées par des contraintes et
   possédées par un rôle actuellement activé. (Cela diffère de la vue
   <literal>table_constraints</literal> qui identifie toutes les contraintes
   et la table où elles sont définies.) Pour une contrainte de clé étrangère,
   cette vue identifie la table que la clé étrangère référence. Pour une
   contrainte d'unicité ou de clé primaire, cette vue identifie simplement la table
   à laquelle appartient la contrainte. Les contraintes de vérification et les
   contraintes de non nullité (NOT NULL) ne sont pas incluses dans cette vue.
  </para>

  <table>
   <title>Colonnes de <literal>constraint_table_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la table utilisée par quelques
       contraintes (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant la table utilisée par quelque contrainte
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table utilisée par quelque contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-data-type-privileges">
  <title><literal>data_type_privileges</literal></title>

  <para>
   La vue <literal>data_type_privileges</literal> identifie tous les
   descripteurs de type de données auxquels l'utilisateur a accès, parce qu'il en
   est le propriétaire ou parce qu'il dispose de quelque droit sur le
   descripteur. Un descripteur de type de données est créé lorsqu'un type de
   données est utilisé dans la définition d'une colonne de table, d'un domaine ou
   d'une fonction (en tant que paramètre ou code de retour). Il stocke alors quelques
   informations sur l'utilisation du type de données (par exemple la
   longueur maximale déclarée, si applicable). Chaque descripteur de type de
   données se voit affecter un identifiant unique parmi les descripteurs de type de
   données affectés à un objet (table, domaine, fonction). Cette vue n'est
   probablement pas utile pour les applications, mais elle est utilisée pour définir
   d'autres vues dans le schéma d'information.
  </para>

  <table>
   <title>Colonnes de <literal>data_type_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant l'objet décrit (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant l'objet décrit</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'objet décrit</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type d'objet décrit&nbsp;: fait partie de
       <literal>TABLE</literal> (le descripteur de type de données concerne une
       colonne de cette table), <literal>DOMAIN</literal> (le descripteur
       concerne ce domaine), <literal>ROUTINE</literal> (le descripteur est lié
       à un type de paramètre ou de code de retour de cette fonction).
      </entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       L'identifiant du descripteur de type de données, unique parmi les
       descripteurs de type de données pour le même objet.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-constraints">
  <title><literal>domain_constraints</literal></title>

  <para>
   La vue <literal>domain_constraints</literal> contient toutes les contraintes
   appartenant aux domaines définis dans la base courante.
  </para>

  <table>
   <title>Colonnes de <literal>domain_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si la vérification de la contrainte
      peut être différée,
       <literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si la vérification de la contrainte, qui peut
      être différée, est initialement différée, <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-udt-usage">
  <title><literal>domain_udt_usage</literal></title>

  <para>
   La vue <literal>domain_udt_usage</literal> identifie tous les domaines
   utilisant les types de données possédés par un rôle actif. 
   Sous <productname>PostgreSQL</productname>, les types de données internes
   se comportent comme des types utilisateur. Ils sont donc inclus ici.
  </para>

  <table>
   <title>Colonnes de <literal>domain_udt_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données de définition du type de données domaine
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma de définition du type de données domaine</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type de données domaine</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domains">
  <title><literal>domains</literal></title>

  <para>
   La vue <literal>domains</literal> contient tous les domaines définis dans la
   base de données courante.
  </para>

  <table>
   <title>Colonnes de <literal>domains</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données du domaine s'il s'agit d'un type interne, ou
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
       vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est
       identifié dans <literal>udt_name</literal> et comprend des colonnes
       associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type caractère ou chaîne de bits, la longueur
       maximale déclarée&nbsp;; NULL pour tous les autres types de données ou
       si aucune longueur maximale n'a été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type caractère, la longueur maximale en octets (bytes)
       d'un datum (ne concerne normalement pas les utilisateurs de
       <productname>PostgreSQL</productname>)&nbsp;; NULL pour tous les autres
       types.
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type numérique, cette colonne contient la précision
       (déclarée ou implicite) du type de cette colonne. Cette précision
       indique le nombre de chiffres significatifs. Elle peut être exprimée en
       décimal (base 10) ou en binaire (base 2), comme indiqué dans la colonne
       <literal>numeric_precision_radix</literal>. Pour les autres types de
       données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type numérique, cette colonne indique la base des
       valeurs des colonnes <literal>numeric_precision</literal> et
       <literal>numeric_scale</literal>. La valeur est soit 2 soit 10. Pour tous
       les autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine contient un type numeric, cette colonne contient l'échelle
       (déclarée ou implicite) du type pour cette colonne. L'échelle indique le
       nombre de chiffres significatifs à droite du point décimal. Elle peut
       être exprimée en décimal (base 10) ou en binaire (base 2), comme indiqué
       dans la colonne <literal>numeric_precision_radix</literal>. Pour tous les
       autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine contient un type date, heure ou intervalle, la précision
       déclarée&nbsp;; NULL pour les autres types de données ou si la précision
       n'a pas été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Expression par défaut du domaine</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle est défini le type de
       données domaine (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma où le type de données domaine est défini</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type de données domaine</entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux n'ont pas de limite maximale de cardinalité 
       dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur de type de données du domaine, unique
       parmi les descripteurs de type de données restant dans le domaine (ce qui
       est trivial car un domaine contient seulement un descripteur de type de
       données). Ceci est principalement utile pour joindre d'autres instances
       de tels identifiants (le format spécifique de l'identifiant n'est pas
       défini et il n'est pas garanti qu'il restera identique dans les versions
       futures).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-element-types">
  <title><literal>element_types</literal></title>

  <para>
   La vue <literal>element_types</literal> contient les descripteurs de type 
   de données des éléments de tableaux. Lorsqu'une colonne de table, domaine,
   paramètre de fonction ou code de retour de fonction est définie comme un
   type tableau, la vue respective du schéma d'information contient seulement
   <literal>ARRAY</literal> dans la colonne <literal>data_type</literal>. Pour
   obtenir des informations sur le type d'élément du tableau, il est possible
   de joindre la vue respective avec cette vue. Par exemple, pour afficher les
   colonnes d'une table avec les types de données et les types d'élément de
   tableau, si applicable, on peut écrire&nbsp;:
<programlisting>SELECT c.column_name, c.data_type, e.data_type AS element_type
FROM information_schema.columns c LEFT JOIN information_schema.element_types e
     ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE',
c.dtd_identifier)
       = (e.object_catalog, e.object_schema, e.object_name, e.object_type,
e.dtd_identifier))
WHERE c.table_schema = '...' AND c.table_name = '...'
ORDER BY c.ordinal_position;
</programlisting>
   Cette vue n'inclut que les objets auxquels l'utilisateur courant a
   accès, parce que propriétaire ou disposant de quelque privilège.
  </para>

  <table>
   <title>Colonnes de <literal>element_types</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant l'objet qui utilise le tableau
       décrit (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant l'objet utilisant le tableau décrit
      </entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de l'objet utilisant le tableau décrit
      </entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type de l'objet utilisant le tableau décrit&nbsp;:
       il fait partie de <literal>TABLE</literal> (le tableau est utilisé par
       une colonne de cette table), <literal>DOMAIN</literal> (le tableau est
       utilisé par ce domaine), <literal>ROUTINE</literal> (le tableau est
       utilisé par un paramètre ou le type du code de retour de cette fonction).
      </entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       L'identifiant du descripteur de type de données du tableau décrit.
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type de données des éléments du tableau s'il s'agit d'un type
       interne, sinon <literal>USER-DEFINED</literal> (dans ce cas, le type est
       identifié comme <literal>udt_name</literal> et dispose de colonnes
       associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données pour lequel le type de données est défini
       (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma dans lequel est défini le type de données des éléments
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données des éléments
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux n'ont pas de limite maximale de
       cardinalité dans <productname>PostgreSQL</productname></entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-enabled-roles">
  <title><literal>enabled_roles</literal></title>

  <para>
   La vue <literal>enabled_roles</literal> identifie les <quote>rôles
   actuellement actifs</quote>. Les rôles actifs sont définis
   récursivement comme l'utilisateur courant avec tous les rôles qui ont été
   donnés aux rôles activés avec l'héritage automatique. En d'autres termes,
   ce sont les rôles dont l'utilisateur courant est automatiquement membre,
   par héritage direct ou indirect.
   <indexterm><primary>enabled role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>enabled</secondary></indexterm>
  </para>

  <para>
   Pour la vérification des permissions, l'ensemble des <quote>rôles applicables</quote>
   est appliqué, ce qui peut être plus large que l'ensemble des rôles
   actifs. Il est, de ce fait, généralement préférable d'utiliser la vue
   <literal>applicable_roles</literal> à la place de celle-ci&nbsp;; voir aussi
   là.
  </para>

  <table>
   <title>Colonnes de <literal>enabled_roles</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'un rôle</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrapper-options">
  <title><literal>foreign_data_wrapper_options</literal></title>

  <para>
   La vue <literal>foreign_data_wrapper_options</literal> contient toutes
   les options définies par les wrappers de données distantes dans la base de
   données en cours. Seuls les wrappers accessibles par l'utilisateur connecté
   sont affichés (qu'il soit propriétaire ou qu'il ait des droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>foreign_data_wrapper_options</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle est défini le wrapper
       de données distantes (toujours la base de connexion)</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du wrapper</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'une option</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Valeur de l'option</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrappers">
  <title><literal>foreign_data_wrappers</literal></title>

  <para>
   La vue <literal>foreign_data_wrappers</literal> contient tous les wrappers
   de données distantes définis dans le base de données en cours. Seuls sont
   affichés les wrappers pour lesquels l'utilisateur connecté a accès
   (qu'il soit propriétaire ou qu'il ait des droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>foreign_data_wrappers</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le wrapper de données
       distantes (toujours la base de données en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du wrapper</entry>
     </row>

     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du propriétaire du serveur distant</entry>
     </row>

     <row>
      <entry><literal>library_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom du fichier de la bibliothèque implémentant ce wrapper</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Langage utilisé pour implémenter ce wrapper</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-server-options">
  <title><literal>foreign_server_options</literal></title>

  <para>
   La vue <literal>foreign_server_options</literal> contient toutes les options
   définies pour les serveurs distants de la base de données en cours. Ne sont
   affichés que les serveurs distants pour lesquels l'utilisateur connecté a
   des droits (qu'il soit propriétaire ou qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>foreign_server_options</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le serveur
       distant (toujours la base de données en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du serveur distant</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'une option</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Valeur de l'option</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-servers">
  <title><literal>foreign_servers</literal></title>

  <para>
   La vue <literal>foreign_servers</literal> contient tous les serveurs
   distants définis dans la base en cours. Ne sont
   affichés que les serveurs distants pour lesquels l'utilisateur connecté a
   des droits (qu'il soit propriétaire ou qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>foreign_servers</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle ce serveur distant est
       défini (toujours la base de données en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du serveur distant</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient le wrapper de données
       distantes utilisé par le serveur distant (toujours la base de données
       en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du wrapper de données distantes utilisé par le serveur
       distant</entry>
     </row>

     <row>
      <entry><literal>foreign_server_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Information sur le type de serveur distant, si indiqué lors de la
       création</entry>
     </row>

     <row>
      <entry><literal>foreign_server_version</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Information sur la version de serveur distant, si indiqué lors de
       la création</entry>
     </row>

     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du propriétaire du serveur distant</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-key-column-usage">
  <title><literal>key_column_usage</literal></title>

  <para>
   La vue <literal>key_column_usage</literal> identifie toutes les colonnes de
   la base de données courante restreintes par une contrainte unique, clé primaire
   ou clé étrangère. Les contraintes de vérification ne sont pas incluses dans
   cette vue. Seules sont affichées les colonnes auxquelles l'utilisateur a accès,
   parce qu'il est le propriétaire de la table ou qu'il dispose de
   quelque privilège.
  </para>

  <table>
   <title>Colonnes de <literal>key_column_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la table contenant la colonne
       contrainte (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant la table contenant la colonne contrainte
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table contenant la colonne contrainte
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la colonne contrainte
      </entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Position ordinale de la colonne dans la clé de contrainte (la numérotation
       commence à 1)
      </entry>
     </row>

     <row>
      <entry><literal>position_in_unique_constraint</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Pour une contrainte de type clé étrangère, la position ordinale de la
       colonne référencée dans sa contrainte d'unicité (la numérotation commence à
       1)&nbsp;; sinon null
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-parameters">
  <title><literal>parameters</literal></title>

  <para>
   La vue <literal>parameters</literal> contient des informations sur les
   paramètres (arguments) de toutes les fonctions de la base de données
   courante. Seules sont affichées les fonctions auxquelles l'utilisateur
   courant a accès, parce qu'il en est le propriétaire ou qu'il
   dispose de quelque privilège.
  </para>

  <table>
   <title>Colonnes de <literal>parameters</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la fonction (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Position ordinale du paramètre dans la liste des arguments de la fonction
       (la numérotation commence à 1)
      </entry>
     </row>

     <row>
      <entry><literal>parameter_mode</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>IN</literal> pour les paramètres en entrée,
       <literal>OUT</literal> pour les paramètres en sortie ou
       <literal>INOUT</literal> pour les paramètres en entrée/sortie.
      </entry>
     </row>

     <row>
      <entry><literal>is_result</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>parameter_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du paramètre ou NULL si le paramètre n'a pas de nom</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données du paramètre s'il s'agit d'un type interne, ou
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
       vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié dans
       <literal>udt_name</literal> et dispose de colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données sur laquelle est défini le paramètre (toujours la base
       de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma dans lequel est défini le type de données du paramètre
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données du paramètre
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur de type de données du paramètre, unique
       parmi les descripteurs de type de données restant dans la fonction. Ceci
       est principalement utile pour réaliser une jointure avec les autres
       instances de tels identifiants (le format spécifique de l'identifiant
       n'est pas défini et il n'est pas garanti qu'il reste identique dans les
       prochaines versions).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-referential-constraints">
  <title><literal>referential_constraints</literal></title>

  <para>
   La vue <literal>referential_constraints</literal> contient toutes les
   contraintes référentielles (clés étrangères) au sein de la base de données
   courante.
   Seuls sont affichés les contraintes pour lesquelles l'utilisateur connecté
   a accès en écriture sur la table référençante (parce qu'il est le
   propriétaire ou qu'il a d'autres droits que SELECT).
  </para>

  <table>
   <title>Colonnes de <literal>referential_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base de données contenant la contrainte
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>unique_constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Nom de la base de données contenant la contrainte d'unicité ou de clé
       primaire que la contrainte de clé étrangère référence (toujours la base
       de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Nom du schéma contenant la contrainte d'unicité ou de clé primaire que
       la contrainte de clé étrangère référence
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Nom de la contrainte d'unicité ou de clé primaire que la contrainte de clé
       étrangère référence
      </entry>
     </row>

     <row>
      <entry><literal>match_option</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Correspondances de la contrainte de clé étrangère&nbsp;:
       <literal>FULL</literal>, <literal>PARTIAL</literal> ou
       <literal>NONE</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>update_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Règle de mise à jour associée à la contrainte de clé étrangère&nbsp;:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal> ou
       <literal>NO ACTION</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>delete_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Règle de suppression associée à la contrainte de clé étrangère&nbsp;:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal> ou
       <literal>NO ACTION</literal>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-column-grants">
  <title><literal>role_column_grants</literal></title>

  <para>
   La vue <literal>role_column_grants</literal> identifie tous les privilèges
   de colonne octroyés pour lesquels le donneur ou le
   bénéficiaire est un rôle actuellement actif. Plus d'informations sous
   <literal>column_privileges</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>role_column_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a octroyé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table qui contient la
       colonne (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table qui contient la colonne</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table qui contient la colonne</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de privilège&nbsp;: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal> ou <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
       <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-routine-grants">
  <title><literal>role_routine_grants</literal></title>

  <para>
   La vue <literal>role_routine_grants</literal> identifie tous les privilèges
   de routine octriyés lorsque le donneur ou le bénéficiaire est un rôle actif.
   Plus d'informations sous <literal>routine_privileges</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>role_routine_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a octroyé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la fonction (peut être dupliqué en cas de
       surcharge)</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>EXECUTE</literal> (seul type de privilège sur
       les fonctions)</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
       <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-table-grants">
  <title><literal>role_table_grants</literal></title>

  <para>
   La vue <literal>role_table_grants</literal> identifie tous les privilèges de
   tables octroyés lorsque le donneur ou le bénéficiaire est un rôle actif.
   Plus d'informations sous <literal>table_privileges</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>role_table_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a octroyé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type du privilège&nbsp;: <literal>SELECT</literal>,
       <literal>DELETE</literal>, <literal>INSERT</literal>,
       <literal>UPDATE</literal>, <literal>REFERENCES</literal>
       ou <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
<literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-usage-grants">
  <title><literal>role_usage_grants</literal></title>

  <para>
   La vue <literal>role_usage_grants</literal> identifie
   les privilèges d'<literal>USAGE</literal> sur différents types d'objets
   où le donneur ou le receveur des droits est un rôle actuellement activé.
   Plus d'informations sous <literal>usage_privileges</literal>.
   Dans le futur, cette vue pourrait contenir des informations plus utiles.
  </para>

  <table>
   <title>Colonnes de <literal>role_usage_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a octroyé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient l'objet (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient l'objet, if applicable,
       sinon une chaîne vide</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'objet</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>DOMAIN</literal>, <literal>FOREIGN DATA WRAPPER</literal>
       ou <literal>FOREIGN SERVER</literal></entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
       <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-privileges">
  <title><literal>routine_privileges</literal></title>

  <para>
   La vue <literal>routine_privileges</literal> identifie tous les droits
   sur les fontions à un rôle actuellement activé ou par un rôle actuellement
   activé.
   Il existe une ligne pour chaque combinaison fonction, donneur, bénéficiaire.
  </para>

  <table>
   <title>Colonnes de <literal>routine_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a accordé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la fonction (peut être dupliqué en cas de
       surcharge)</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>EXECUTE</literal> (seul priilège de fonctions)</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
       <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-routines">
  <title><literal>routines</literal></title>

  <para>
   La vue <literal>routines</literal> contient toutes les fonctions de la base
   de données courante. Seules sont affichées les fonctions auxquelles
   l'utilisateur courant a accès (qu'il en soit le propriétaire ou dispose de
   de privilèges).
  </para>

  <table>
   <title>Colonnes de <literal>routines</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Ce nom identifie de
       façon unique la fonction dans le schéma, même si le nom réel de la
       fonction est surchargé. Le format du nom spécifique n'est pas défini, il
       ne devrait être utilisé que dans un but de comparaison avec d'autres instances de
       noms spécifiques de routines.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la fonction (peut être dupliqué en cas de
       surcharge)</entry>
     </row>

     <row>
      <entry><literal>routine_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours <literal>FUNCTION</literal> (dans le futur, il pourrait y avoir
       d'autres types de routines)
      </entry>
     </row>

     <row>
      <entry><literal>module_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>module_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>module_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données de retour de la fonction s'il est interne,
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
       vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié
       dans <literal>type_udt_name</literal> et dispose de colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées sous <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données dans laquelle est défini le type de données de retour
       de la fonction (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma dans lequel est défini le type de données de retour
       de la fonction
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données de retour de la fonction
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car il n'y a pas de limite maximale à la
      cardinalité des tableaux dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur de type de données du type de données
       retour, unique parmi les descripteurs de type de données de la
       fonction. Ceci est principalement utile pour la jointure avec d'autres
       instances de tels identifiants (le format spécifique de l'identifiant
       n'est pas défini et il n'est pas certain qu'il restera identique dans les
       versions futures).
      </entry>
     </row>

     <row>
      <entry><literal>routine_body</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction est une fonction SQL, alors
       <literal>SQL</literal>, sinon <literal>EXTERNAL</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>routine_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le texte source de la fonction (NULL si la fonction n'appartient pas à
       un rôle actif). (Le standard SQL précise que cette colonne n'est 
       applicable que si <literal>routine_body</literal> est
       <literal>SQL</literal>, mais sous <productname>PostgreSQL</productname>
       ce champ contient tout texte source précisé à la création de la
       fonction.)
      </entry>
     </row>

     <row>
      <entry><literal>external_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction est une fonction C, le nom externe (link
       symbol) de la fonction&nbsp;; sinon NULL. (Il s'agit de la 
       même valeur que celle affichée dans
       <literal>routine_definition</literal>).
      </entry>
     </row>

     <row>
      <entry><literal>external_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Le langage d'écriture de la fonction</entry>
     </row>

     <row>
      <entry><literal>parameter_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours <literal>GENERAL</literal> (le standard SQL définit d'autres
       styles de paramètres qui ne sont pas disponibles avec
       <productname>PostgreSQL</productname>).
      </entry>
     </row>

     <row>
      <entry><literal>is_deterministic</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction est déclarée immuable (déterministe dans le
       standard SQL), alors <literal>YES</literal>, sinon
       <literal>NO</literal>. (Les autres
       niveaux de volatilité disponibles dans
       <productname>PostgreSQL</productname> ne peuvent être récupérés via le schéma
       d'informations).
      </entry>
     </row>

     <row>
      <entry><literal>sql_data_access</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours <literal>MODIFIES</literal>, ce qui signifie que la fonction peut
       modifier les données SQL. Cette information n'est pas utile sous
       <productname>PostgreSQL</productname>.
      </entry>
     </row>

     <row>
      <entry><literal>is_null_call</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction renvoie automatiquement NULL si un de ces arguments est
       NULL, alors <literal>YES</literal>, sinon <literal>NO</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>schema_level_routine</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours <literal>YES</literal>. (L'opposé serait une méthode d'un type
       utilisateur, fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>).
      </entry>
     </row>

     <row>
      <entry><literal>max_dynamic_result_sets</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_user_defined_cast</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_implicitly_invocable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>security_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction est exécutée avec les droits de l'utilisateur courant,
       alors <literal>INVOKER</literal>. Si la fonction est exécutée avec les
       droits de l'utilisateur l'ayant définie, alors <literal>DEFINER</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>last_altered</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>new_savepoint_level</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>is_udt_dependent</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_from_data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_as_locator</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_max_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_octet_length</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_datetime_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-schemata">
  <title><literal>schemata</literal></title>

  <para>
   La vue <literal>schemata</literal> contient tous les schémas de la base de
   données courante dont un rôle actif est propriétaire.
  </para>

  <table>
   <title>Colonnes de <literal>schemata</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle se trouve le schéma (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>schema_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma</entry>
     </row>

     <row>
      <entry><literal>schema_owner</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du propriétaire du schéma</entry>
     </row>

     <row>
      <entry><literal>default_character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>default_character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>default_character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sequences">
  <title><literal>sequences</literal></title>

  <para>
   La vue <literal>sequences</literal> contient toutes les séquences définies
   dans la base courante. Seules sont affichées les séquences auxquelles
   l'utilisateur courant a accès (qu'il en soit le propriétaire ou dispose de
   privilèges).
  </para>

  <table>
   <title>Colonnes de <literal>sequences</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sequence_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base qui contient la séquence (toujours la base en cours)</entry>
     </row>

     <row>
      <entry><literal>sequence_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la séquence</entry>
     </row>

     <row>
      <entry><literal>sequence_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la séquence</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données de la séquence. Dans
       <productname>PostgreSQL</productname>, c'est toujours
       <literal>bigint</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Cette colonne contient la précision (déclarée ou implicite) du type de
       données de la séquence (voir ci-dessus). La précision indique le
       nombre de chiffres significatifs. Elle peut être exprimée en décimal
       (base 10) ou en binaire (base 2), suivant ce qui est indiqué dans la
       colonne <literal>numeric_precision_radix</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Cette colonne indique dans quelle base les valeurs de la colonne
       <literal>numeric_precision</literal> et <literal>numeric_scale</literal>
       sont exprimées, 2 ou 10.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Cette colonne contient l'échelle (déclarée ou implicite) du type de
       données de la séquence (voir ci-dessus). L'échelle indique le nombre
       de chiffres significatifs à droite du point décimale. Elle peut être
       exprimée en décimal (base 10) ou en binaire (base 2), suivant ce qui
       est indiqué dans la
       colonne <literal>numeric_precision_radix</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>maximum_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>minimum_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>increment</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>cycle_option</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implanté</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-features">
  <title><literal>sql_features</literal></title>

  <para>
   La table <literal>sql_features</literal> contient des informations sur les
   fonctionnalités officielles définies dans le standard SQL et supportées par
   <productname>PostgreSQL</productname>. Ce sont les mêmes informations que
   celles présentées dans l'<xref linkend="features"/>. D'autres informations 
   de fond y sont disponibles.
  </para>

  <table>
   <title>Colonnes de <literal>sql_features</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant la fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de la fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>sub_feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant la sous-fonctionnalité ou chaîne de
       longueur NULL s'il ne s'agit pas d'une sous-fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>sub_feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de la sous-fonctionnalité ou chaîne de
       longueur NULL s'il ne s'agit pas d'une sous-fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si la fonctionnalité est complètement supportée
       par la version actuelle de <productname>PostgreSQL</productname>, <literal>NO</literal> sinon
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours NULL car le groupe de développement <productname>PostgreSQL</productname> ne réalise pas
       de tests formels sur la conformité des fonctionnalités
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un commentaire éventuel sur le statut du support de la
       fonctionnalité</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-implementation-info">
  <title><literal>sql_implementation_info</literal></title>

  <para>
   La table <literal>sql_inplementation_info</literal> contient des
   informations sur différents aspects que le standard SQL laisse à la
   discrétion de l'implantation. Ces informations n'ont de réel intérêt que dans
   le contexte de l'interface ODBC&nbsp;; les utilisateurs
   des autres interfaces leur trouveront certainement peu d'utilité.
   Pour cette raison, les éléments décrivant l'implantation
   ne sont pas décrits ici&nbsp;; ils se trouvent dans la
   description de l'interface ODBC.
  </para>

  <table>
   <title>Colonnes de <literal>sql_implementation_info</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>implementation_info_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant l'élément d'information
       d'implantation</entry>
     </row>

     <row>
      <entry><literal>implementation_info_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de l'élément d'information
       d'implantation</entry>
     </row>

     <row>
      <entry><literal>integer_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Valeur de l'élément d'information d'implantation, ou NULL si la valeur
       est contenue dans la colonne <literal>character_value</literal>
      </entry>
     </row>

     <row>
      <entry><literal>character_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Valeur de l'élément d'information d'implantation, ou NULL si la valeur
       est contenue dans la colonne
       <literal>integer_value</literal>
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un commentaire éventuel de l'élément d'information
       d'implantation</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-languages">
  <title><literal>sql_languages</literal></title>

  <para>
   La table <literal>sql_languages</literal> contient une ligne par
   langage lié au SQL supporté par <productname>PostgreSQL</productname>.
   <productname>PostgreSQL</productname> supporte le SQL direct et le SQL
   intégré dans le C&nbsp;; cette table ne contient pas d'autre information.
  </para>

  <table>
   <title>Colonnes de <literal>sql_languages</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.4*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sql_language_source</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le nom de la source de définition du langage&nbsp;; toujours
       <literal>ISO 9075</literal>, c'est-à-dire le standard SQL
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_year</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       L'année de l'approbation du standard dans
       <literal>sql_language_source</literal>&nbsp;; actuellement
       <literal>2003</literal>
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_conformance</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le niveau de conformité au standard pour le langage. Pour ISO 9075:2003,
       c'est toujours <literal>CORE</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_integrity</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL (cette valeur n'a d'intérêt que pour les versions
       précédentes du standard SQL).</entry>
     </row>

     <row>
      <entry><literal>sql_language_implementation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL</entry>
     </row>

     <row>
      <entry><literal>sql_language_binding_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le style de lien du langage, soit <literal>DIRECT</literal> soit
       <literal>EMBEDDED</literal>
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_programming_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le langage de programmation si le style de lien est
       <literal>EMBEDDED</literal>, sinon NULL.
       <productname>PostgreSQL</productname> ne supporte que
       le langage C.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-packages">
  <title><literal>sql_packages</literal></title>

  <para>
   La table <literal>sql_packages</literal> contient des informations sur les
   paquets de fonctionnalités définis dans le standard SQL supportés par
   <productname>PostgreSQL</productname>. On se référera à l'<xref
   linkend="features"/> pour des informations de base sur les paquets de
   fonctionnalités.
  </para>

  <table>
   <title>Colonnes de <literal>sql_packages</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant le paquet</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif du paquet</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si le paquet est complètement supporté par la
       version actuelle, <literal>NO</literal> sinon
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours NULL car le groupe de développement de <productname>PostgreSQL</productname> ne réalise
       pas de tests formels pour la conformité des fonctionnalités
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un commentaire éventuel sur l'état de support du paquet</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-parts">
  <title><literal>sql_parts</literal></title>

  <para>
   La table <literal>sql_parts</literal> contient des informations sur les
   parties du standard SQL supportées par <productname>PostgreSQL</productname>.
  </para>

  <table>
   <title>Colonnes de <literal>sql_parts</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Une chaîne d'identification contenant le numéro de la partie</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de la partie</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si cette partie est complètement supportée par la
       version actuelle de <productname>PostgreSQL</productname>,
       <literal>NO</literal> dans le cas contraire
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours NULL, car les développeurs <productname>PostgreSQL</productname>
       ne testent pas officiellement la conformité des fonctionnalités
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Commentaires sur le statut du support de la partie</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing">
  <title><literal>sql_sizing</literal></title>

  <para>
   La table <literal>sql_sizing</literal> contient des informations sur les
   différentes limites de tailles et valeurs maximales dans
   <productname>PostgreSQL</productname>. Ces informations ont pour contexte
   principal l'interface ODBC&nbsp;; les utilisateurs
   des autres interfaces leur trouveront probablement peu d'utilité.
   Pour cette raison, les éléments de taille individuels ne sont
   pas décrits ici&nbsp;; ils se trouvent dans la description de l'interface
   ODBC.
  </para>

  <table>
   <title>Colonnes de <literal>sql_sizing</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Identifiant de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>supported_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Valeur de l'élément de taille, ou 0 si la taille est illimitée ou ne
       peut pas être déterminée, ou NULL si les fonctionnalités pour lesquelles
       l'élément de taille est applicable ne sont pas supportées
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un commentaire éventuel de l'élément de taille</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing-profiles">
  <title><literal>sql_sizing_profiles</literal></title>

  <para>
   La table <literal>sql_sizing_profiles</literal> contient des informations
   sur les valeurs <literal>sql_sizing</literal> requises par différents profils
   du standard SQL. <productname>PostgreSQL</productname> ne garde pas trace des profils SQL, donc la
   table est vide.
  </para>

  <table>
   <title>Colonnes de <literal>sql_sizing_profiles</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Identifiant de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>profile_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant un profil</entry>
     </row>

     <row>
      <entry><literal>required_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       La valeur requise par le profil SQL pour l'élément de taille, ou 0 si
       le profil ne place aucune limite sur l'élément de taille, ou NULL si le
       profil ne requiert aucune fonctionnalité pour laquelle l'élément de
       style est applicable
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un commentaire éventuel sur l'élément de taille 
       au sein du profil</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-constraints">
  <title><literal>table_constraints</literal></title>

  <para>
   La vue <literal>table_constraints</literal> contient toutes les contraintes
   appartenant aux tables possédées par l'utilisateur courant ou pour lesquelles
   l'utilisateur courant dispose de certains droits différents de SELECT.
  </para>

  <table>
   <title>Colonnes de <literal>table_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la contrainte (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>constraint_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de contrainte&nbsp;: <literal>CHECK</literal>,
       <literal>FOREIGN KEY</literal>, <literal>PRIMARY KEY</literal>
       ou <literal>UNIQUE</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si la contrainte peut être différée,
       <literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si la contrainte, qui peut être différée,
       est initialement différée, <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-privileges">
  <title><literal>table_privileges</literal></title>

  <para>
   La vue <literal>table_privileges</literal> identifie tous les privilèges
   accordés, à un rôle actif ou par une rôle actif, sur des tables ou vues.
   Il y a une ligne par combinaison table, donneur, bénéficiaire.
  </para>

  <table>
   <title>Colonnes de <literal>table_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a accordé le privilège</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle bénéficiaire</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de privilège&nbsp;: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal> ou <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être transmis,
       <literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-tables">
  <title><literal>tables</literal></title>

  <para>
   La vue <literal>tables</literal> contient toutes les tables et vues définies
   dans la base de données courantes. Seules sont affichées les tables et vues
   auxquelles l'utilisateur courant a accès (parce qu'il en est le
   propriétaire ou qu'il possède certains privilèges).
  </para>

  <table>
   <title>Colonnes de <literal>tables</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>table_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de table&nbsp;: <literal>BASE TABLE</literal> pour une table de
       base persistante (le type de table normal), <literal>VIEW</literal> pour
       une vue ou <literal>LOCAL TEMPORARY</literal> pour une table temporaire
      </entry>
     </row>

     <row>
      <entry><literal>self_referencing_column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>reference_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> s'il est possible d'insérer des données dans la
       table, <literal>NO</literal> dans le cas contraire. (Il est toujours
       possible d'insérer des données dans une table de base, pas forcément
       dans les vues.)
      </entry>
     </row>

     <row>
      <entry><literal>is_typed</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>commit_action</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la table est temporaire, alors <literal>PRESERVE</literal>, sinon NULL.
       (Le standard SQL définit d'autres actions de validation pour les tables
       temporaires, actions qui ne sont pas supportées par
       <productname>PostgreSQL</productname>.)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggers">
  <title><literal>triggers</literal></title>

  <para>
   La vue <literal>triggers</literal> contient tous les déclencheurs définis
   dans la base de données courante qu'un rôle actif possède ou pour lesquels
   il dispose de privilèges différents de SELECT.
  </para>

  <table>
   <title>Colonnes de <literal>triggers</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient le déclencheur (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient le déclencheur</entry>
     </row>

     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du déclencheur</entry>
     </row>

     <row>
      <entry><literal>event_manipulation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Événement qui a lancé le déclencheur (<literal>INSERT</literal>,
       <literal>UPDATE</literal> ou <literal>DELETE</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données qui contient la table sur laquelle est défini le déclencheur
       (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la table sur laquelle est défini le
       déclencheur</entry>
     </row>

     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table sur laquelle est défini le déclencheur</entry>
     </row>

     <row>
      <entry><literal>action_order</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Pas encore implanté</entry>
     </row>

     <row>
      <entry><literal>action_condition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>action_statement</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Instruction exécutée par le déclencheur (actuellement toujours
       <literal>EXECUTE PROCEDURE
       <replaceable>function</replaceable>(...)</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>action_orientation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Indique si le déclencheur est exécuté une fois par ligne
       traitée ou une fois par instruction (<literal>ROW</literal> ou
       <literal>STATEMENT</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>condition_timing</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Moment de l'exécution du déclencheur (<literal>BEFORE</literal> ou
       <literal>AFTER</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>condition_reference_old_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>condition_reference_new_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>condition_reference_old_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>condition_reference_new_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les déclencheurs dans <productname>PostgreSQL</productname> ont deux
   incompatibilités avec le standard SQL qui affectent leur représentation dans le
   schéma d'information.
  </para>
  
  <para>
   Premièrement, les noms des déclencheurs sont locaux à la
   table sous <productname>PostgreSQL</productname>, et ne sont pas des objets
   du schéma indépendants. De ce fait, il peut exister des déclencheurs de même
   noms au sein d'un schéma, pour peu qu'ils s'occupent de tables différentes.
   (<literal>trigger_catalog</literal> et <literal>trigger_schema</literal> sont
   les champs qui décrivent effectivement la table sur laquelle est défini le
   déclencheur.)
  </para>
  
  <para>
   Deuxièmement, les déclencheurs peuvent être définis pour
   s'exécuter sur plusieurs événements sous
   <productname>PostgreSQL</productname> (c'est-à-dire <literal>ON INSERT OR
   UPDATE</literal>) alors que le standard SQL n'en autorise qu'un. Si un
   déclencheur est défini pour s'exécuter sur plusieurs événements, il est
   représenté sur plusieurs lignes dans le schéma d'information, une pour chaque
   type d'événement.
  </para>
  
  <para>
   En conséquence, la clé primaire de la vue <literal>triggers</literal> est en fait
   <literal>(trigger_catalog, trigger_schema, trigger_name, event_object_table,
   event_manipulation)</literal> et non <literal>(trigger_catalog,
   trigger_schema, trigger_name)</literal> comme le spécifie le standard SQL.
   Néanmoins, si les déclencheurs sont définis de manière conforme au
   standard SQL (des noms de déclencheurs uniques dans le schéma et un seul
   type d'événement par déclencheur), il n'y a pas lieu de se préoccuper de ces
   deux incompatibilités.
  </para>
 </sect1>

 <sect1 id="infoschema-usage-privileges">
  <title><literal>usage_privileges</literal></title>

  <para>
   La vue <literal>usage_privileges</literal> identifie les
   privilèges d'<literal>USAGE</literal> accordés sur différents objets à un rôle
   actif ou par un rôle actif. Sous <productname>PostgreSQL</productname>,
   cela s'applique aux domaines. Puisqu'il n'y a pas de réels
   privilèges sur les domaines sous <productname>PostgreSQL</productname>,
   cette vue est affiche les privilèges <literal>USAGE</literal> implicitement
   octroyés à <literal>PUBLIC</literal> pour tous les domaines, wrappers de
   données distantes et serveurs distants. Il y a une ligne pour chaque
   combinaison d'objet, de donneur et de receveur.
  </para>

  <para>
   Comme les domaines n'ont pas de vrais droits dans
   <productname>PostgreSQL</productname>, cette vue affiche des droits
   <literal>USAGE</literal> implicites, non donnables à d'autres, et
   donnés par le propriétaire à <literal>PUBLIC</literal> pour tous les
   domaines. Les autres types d'objets affichent néanmoins de vrais droits.
  </para>

  <table>
   <title>Colonnes de <literal>usage_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a donné ce droit</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that the privilege was granted to</entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient l'objet (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient l'objet, if applicable,
       sinon une chaîne vide</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'objet</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>DOMAIN</literal>, <literal>FOREIGN DATA WRAPPER</literal>
       ou <literal>FOREIGN SERVER</literal></entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être donné,
       <literal>NO</literal> dans le cas contraire</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 
 <sect1 id="infoschema-user-mapping-options">
  <title><literal>user_mapping_options</literal></title>

  <para>
   La vue <literal>user_mapping_options</literal> contient toutes les options
   définies pour les correspondances d'utilisateur définies dans la base de
   données en cours. Seules sont affichées les correspondances pour lesquelles
   le serveur distant correspondant peut être accédé par l'utilisateur
   connecté (qu'il en soit le propriétaire ou qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>user_mapping_options</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'utilisateur,
       ou <literal>PUBLIC</literal> si la correspondance est publique</entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle est défini le serveur
        distant correspondant (toujours la base de données en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du serveur distant utilisé par cette correspondance</entry>
     </row>

     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'une option</entry>
     </row>

     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Valeur de l'option. Cette colonne s'affichera comme NULL sauf si
      l'utilisateur connecté est l'utilisateur en cours de correspondance ou
      si la correspondance est pour <literal>PUBLIC</literal> et que l'utilisateur
      connecté est le propriétaire de la base de données ou un superutilisateur.
      Le but est de protéger les informations de mot de passe stockées comme
      option.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mappings">
  <title><literal>user_mappings</literal></title>

  <para>
   La vue <literal>user_mappings</literal> contient toutes les correspondances
   utilisateurs définies dans la base de données en cours. Seules sont affichées
   les correspondances pour lesquelles le serveur distant correspondant peut
   être accédé par l'utilisateur connecté (qu'il en soit le propriétaire ou
   qu'il ait quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>user_mappings</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'utilisateur en cours de correspondance ou
       <literal>PUBLIC</literal> si la correspondance est publique</entry>
     </row>

     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle est défini le serveur
        distant correspondant (toujours la base de données en cours)</entry>
     </row>

     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du serveur distant utilisé par cette correspondance</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-column-usage">
  <title><literal>view_column_usage</literal></title>

  <para>
   La vue <literal>view_column_usage</literal> identifie toutes les colonnes
   utilisées dans l'expression de la requête d'une vue (l'instruction
   <command>SELECT</command> définissant la vue). Une colonne n'est incluse que
   si la table contenant la colonne appartient à un rôle actif.
  </para>

  <note>
   <para>
    Les colonnes des tables système ne sont pas incluses. Cela sera
    probablement corrigé un jour.
   </para>
  </note>

  <table>
   <title>Colonnes de <literal>view_column_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la vue (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la vue</entry>
     </row>

     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données qui contient la table qui contient la colonne
       utilisée par la vue (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma qui contient la table qui contient la colonne utilisée par la vue
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table qui contient la colonne utilisée par la vue
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne utilisée par la vue</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-routine-usage">
  <title><literal>view_routine_usage</literal></title>

  <para>
   La vue <literal>view_routine_usage</literal> identifie toutes les
   routines (fonctions et procédures) utilisées dans la requête d'une
   vue (l'instruction <command>SELECT</command> qui définit la vue). Une routine
   n'est incluse que si la routine appartient à un rôle actif.
  </para>

  <table>
   <title>Colonnes de <literal>view_routine_usage</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base qui contient la vue (toujours la base en cours)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma qui contient la vue</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base qui contient la fonction (toujours la base en cours)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma qui contient la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-table-usage">
  <title><literal>view_table_usage</literal></title>

  <para>
   La vue <literal>view_table_usage</literal> identifie toutes les tables
   utilisées dans l'expression de la requête d'une vue (l'instruction
   <command>SELECT</command> définissant la vue). Une table n'est incluse que
   son propriétaire est un rôle actif.
  </para>

  <note>
   <para>
    Les tables système ne sont pas incluses. Cela sera probablement corrigé un
    jour.
   </para>
  </note>

  <table>
   <title>Colonnes de <literal>view_table_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la vue (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la vue</entry>
     </row>

     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données qui contient la table utilisée par la vue
       (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma qui contient la table utilisée par la vue
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table utilisée par la vue
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-views">
  <title><literal>views</literal></title>

  <para>
   La vue <literal>views</literal> contient toutes les vues définies dans la
   base de données courantes. Seules sont affichées les vues auxquelles
   l'utilisateur a accès (parce qu'il en est le propriétaire ou qu'il dispose
   de privilèges).
  </para>

  <table>
   <title>Colonnes de <literal>views</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données qui contient la vue (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma qui contient la vue</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>view definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Expression de la requête définissant la vue (NULL si la vue n'appartient
       pas à un rôle actif)
      </entry>
     </row>

     <row>
      <entry><literal>check_option</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si la vue est actualisable (autorise
       <command>UPDATE</command> et <command>DELETE</command>),
       <literal>NO</literal> dans le cas contraire
      </entry>
     </row>

     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> s'il est possible d'insérer des données dans la
       vue (autorise <command>INSERT</command>), <literal>NO</literal> dans le
       cas contraire
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

</chapter>
