<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="intagg">
 <title>intagg</title>
 
 <indexterm zone="intagg">
  <primary>intagg</primary>
 </indexterm>

 <para>
  Le module <filename>intagg</filename> fournit une
  agrégation pour entier et un énumérateur.
 </para>

 <sect2>
  <title>Fonctions</title>

 <para>
  L'agrégateur est une fonction d'agrégat
  <function>int_array_aggregate(integer)</function> qui produit un tableau
  d'entiers contenant exactement les entiers en arguments&nbsp;:
 </para>

 <programlisting>
test=# select int_array_aggregate(i) from
test-#   generate_series(1,10,2) i;
 int_array_aggregate
---------------------
 {1,3,5,7,9}
(1 row)
 </programlisting>

 <para>
  L'énumérateur est une fonction
  <function>int_array_enum(integer[])</function> qui renvoie
  <type>setof integer</type>. C'est essentiellement une opération reverse de
  l'agrégateur&nbsp;: avec un tableau d'entiers, l'étendre en un ensemble de
  lignes. Par exemple,
 </para>

 <programlisting>
test=# select * from int_array_enum(array[1,3,5,7,9]);
 int_array_enum
----------------
              1
              3
              5
              7
              9
(5 rows)
 </programlisting>

 </sect2>

 <sect2>
  <title>Exemples d'utilisation</title>

  <para>
   Un grand nombre de bases de données ont la notion de <quote>une vers
   plusieurs tables</quote>. Ce type de table se trouve habituellement entre
   deux tables indexés, par exemple&nbsp;:
  </para>

 <programlisting>
CREATE TABLE left (id INT PRIMARY KEY, ...);
CREATE TABLE right (id INT PRIMARY KEY, ...);
CREATE TABLE one_to_many(left INT REFERENCES left, right INT REFERENCES right);
 </programlisting>

 <para>
  Il est typiquement utilisé de cette façon&nbsp;:
 </para>

 <programlisting>
  SELECT right.* from right JOIN one_to_many ON (right.id = one_to_many.right)
    WHERE one_to_many.left = <replaceable>item</replaceable>;
 </programlisting>

 <para>
  Ceci renverra tous les éléments de la table de droite pour un enregistrement
  de la table de gauche. Il s'agit d'une construction assez commune en SQL.
 </para>

 <para>
  Cette méthode devient complexe avec plusieurs tables. Souvent, une jointure
  de ce type pourrait résulter
  en un parcours d'index et une récupération de chaque enregistrement de
  la table de droite pour chaque entrée particulière de la table de gauche.
  Si vous avez un système dynamique, vous ne pourrez pas faire grand chose pour
  aller contre ça. Néanmoins, si certaines de vos données sont statiques, vous
  pouvez créer une table résumé avec l'agrégation.
 </para>

 <programlisting>
CREATE TABLE summary as
  SELECT left, int_array_aggregate(right) AS right
  FROM one_to_many
  GROUP BY left;
 </programlisting>

 <para>
  Ceci crée une table avec une ligne par élément gauche et un tableau d'éléments
  droits. Ceci est réellement inutilisable sans un moyen pour utiliser le
  tableau, et c'est là que l'énumérateur entre en service. You can do
 </para>
 <programlisting>
SELECT left, int_array_enum(right) FROM summary WHERE left = <replaceable>item</replaceable>;
 </programlisting>

 <para>
  La requête ci-dessus utilisant <function>int_array_enum</function> produit les mêmes résultats
  que celle-ci&nbsp;:
 </para>
 <programlisting>
SELECT left, right FROM one_to_many WHERE left = <replaceable>item</replaceable>;
 </programlisting>
 
 <para>
  La différence tient dans le fait que la requête utilisant la table résumé
  doit seulement récupérer une ligne de la table alors que l'ancienne requête
  doit faire un parcours d'index et récupérer une ligne par enregistrement.
 </para>
 <para>
  Sur un système, un <command>EXPLAIN</command> a montré qu'une requête avec
  un coût de 8488 a été réduite à une requête d'un coût de 329. La requête
  originale était une jointure impliquant la table
  <structname>one_to_many</structname>, which was replaced by:
 </para>
 <programlisting>
SELECT right, count(right) FROM
  ( SELECT left, int_array_enum(right) AS right
    FROM summary JOIN (SELECT left FROM left_table WHERE left = <replaceable>item</replaceable>) AS lefts
         ON (summary.left = lefts.left)
  ) AS list
  GROUP BY right
  ORDER BY count DESC;
 </programlisting>

 </sect2>

</sect1>

