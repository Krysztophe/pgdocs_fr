
<sect1 id="intagg">
 <title>intagg</title>
 
 <indexterm zone="intagg">
  <primary>intagg</primary>
 </indexterm>

 <para>
  Cette section décrit le module <literal>intagg</literal> qui fournit une
  agrégation pour entier et un énumérateur.
 </para>
 <para>
  Beaucoup de systèmes de bases de données ont la notion d'une table de lien
  vers plusieurs autres tables. Ce type de table se trouve habituellement
  entre deux tables indexées, de cette façon:&nbsp;
 </para>
 <programlisting>
CREATE TABLE one_to_many(left INT, right INT) ;
 </programlisting>

 <para>
  Elle est utilisée ainsi&nbsp;:
 </para>

 <programlisting>
  SELECT right.* from right JOIN one_to_many ON (right.id = one_to_many.right) 
        WHERE  one_to_many.left = item;
 </programlisting>

 <para>
  Ceci renverra tous les éléments de la table de droite pour un enregistrement
  de la table de gauche. Il s'agit d'une construction assez commune en SQL.
 </para>

 <para>
  Cette méthode devient complexe avec plusieurs tables. Suivant l'ordre dans
  lequel les données sont saisies, une jointure de ce type pourrait résulter
  en un parcours d'index et une récupération de chaque enregistrement de
  la table de droite pour chaque entrée particulière de la table de gauche.
  Si vous avez un système dynamique, vous ne pourrez pas faire grand chose pour
  aller contre ça. Néanmoins, si certaines de vos données sont statiques, vous
  pouvez créer une table résumé avec l'agrégation.
 </para>

 <programlisting>
CREATE TABLE summary as SELECT left, int_array_aggregate(right) 
        AS right FROM one_to_many GROUP BY left;
 </programlisting>

 <para>
  Ceci crée une table avec une ligne par élément gauche et un tableau d'éléments
  droits. Ceci est réellement inutilisable sans un moyen pour utiliser le
  tableau, et c'est là que l'énumérateur entre en service.
 </para>
 <programlisting>
SELECT left, int_array_enum(right) FROM summary WHERE left = item;
 </programlisting>

 <para>
  La requête ci-dessus utilisant int_array_enum produit les mêmes résultats
  que celle-ci&nbsp;:
 </para>
 <programlisting>
SELECT left, right FROM one_to_many WHERE left = item;
 </programlisting>
 
 <para>
  La différence tient dans le fait que la requête utilisant la table résumé
  doit seulement récupérer une ligne de la table alors que l'ancienne requête
  doit faire un parcours d'index et récupérer une ligne par enregistrement.
 </para>
 <para>
  Sur notre système, un EXPLAIN montre qu'une requête avec un coût de 8488
  est réduite à une requête d'un coût de 329. La requête est une jointure entre
  la table one_to_many,
 </para>
 <programlisting>
SELECT right, count(right) FROM 
(
        SELECT left, int_array_enum(right) AS right FROM summary JOIN
                (SELECT left FROM left_table WHERE left = item) AS lefts
                 ON (summary.left = lefts.left ) 
) AS list GROUP BY right ORDER BY count DESC ;
 </programlisting>
</sect1>

