
<sect1 id="intagg">
 <title>intagg</title>
 
 <indexterm zone="intagg">
  <primary>intagg</primary>
 </indexterm>

 <para>
  Le module <filename>intagg</filename> fournit une
  agrégation pour entier et un énumérateur.
 </para>

 <sect2>
  <title>Functions</title>

 <para>
  The aggregator is an aggregate function
  <function>int_array_aggregate(integer)</function>
  that produces an integer array
  containing exactly the integers it is fed.
  Here is a not-tremendously-useful example:
 </para>

 <programlisting>
test=# select int_array_aggregate(i) from
test-#   generate_series(1,10,2) i;
 int_array_aggregate
---------------------
 {1,3,5,7,9}
(1 row)
 </programlisting>

 <para>
  The enumerator is a function
  <function>int_array_enum(integer[])</function>
  that returns <type>setof integer</type>.  It is essentially the reverse
  operation of the aggregator: given an array of integers, expand it
  into a set of rows.  For example,
 </para>

 <programlisting>
test=# select * from int_array_enum(array[1,3,5,7,9]);
 int_array_enum
----------------
              1
              3
              5
              7
              9
(5 rows)
 </programlisting>

 </sect2>

 <sect2>
  <title>Sample Uses</title>

  <para>
   Many database systems have the notion of a one to many table. Such a table
   usually sits between two indexed tables, for example:
  </para>

 <programlisting>
CREATE TABLE left (id INT PRIMARY KEY, ...);
CREATE TABLE right (id INT PRIMARY KEY, ...);
CREATE TABLE one_to_many(left INT REFERENCES left, right INT REFERENCES right);
 </programlisting>

 <para>
  It is typically used like this:
 </para>

 <programlisting>
  SELECT right.* from right JOIN one_to_many ON (right.id = one_to_many.right)
    WHERE one_to_many.left = <replaceable>item</replaceable>;
 </programlisting>

 <para>
  Ceci renverra tous les éléments de la table de droite pour un enregistrement
  de la table de gauche. Il s'agit d'une construction assez commune en SQL.
 </para>

 <para>
  Cette méthode devient complexe avec plusieurs tables. Souvent, une jointure
  de ce type pourrait résulter
  en un parcours d'index et une récupération de chaque enregistrement de
  la table de droite pour chaque entrée particulière de la table de gauche.
  Si vous avez un système dynamique, vous ne pourrez pas faire grand chose pour
  aller contre ça. Néanmoins, si certaines de vos données sont statiques, vous
  pouvez créer une table résumé avec l'agrégation.
 </para>

 <programlisting>
CREATE TABLE summary as
  SELECT left, int_array_aggregate(right) AS right
  FROM one_to_many
  GROUP BY left;
 </programlisting>

 <para>
  Ceci crée une table avec une ligne par élément gauche et un tableau d'éléments
  droits. Ceci est réellement inutilisable sans un moyen pour utiliser le
  tableau, et c'est là que l'énumérateur entre en service. You can do
 </para>
 <programlisting>
SELECT left, int_array_enum(right) FROM summary WHERE left = <replaceable>item</replaceable>;
 </programlisting>

 <para>
  La requête ci-dessus utilisant <function>int_array_enum</function> produit les mêmes résultats
  que celle-ci&nbsp;:
 </para>
 <programlisting>
SELECT left, right FROM one_to_many WHERE left = <replaceable>item</replaceable>;
 </programlisting>
 
 <para>
  La différence tient dans le fait que la requête utilisant la table résumé
  doit seulement récupérer une ligne de la table alors que l'ancienne requête
  doit faire un parcours d'index et récupérer une ligne par enregistrement.
 </para>
 <para>
  Sur un système, un <command>EXPLAIN</command> a montré qu'une requête avec
  un coût de 8488 a été réduite à une requête d'un coût de 329. La requête
  originale était une jointure impliquant la table
  <structname>one_to_many</structname>, which was replaced by:
 </para>
 <programlisting>
SELECT right, count(right) FROM
  ( SELECT left, int_array_enum(right) AS right
    FROM summary JOIN (SELECT left FROM left_table WHERE left = <replaceable>item</replaceable>) AS lefts
         ON (summary.left = lefts.left)
  ) AS list
  GROUP BY right
  ORDER BY count DESC;
 </programlisting>

 </sect2>

</sect1>

