<sect1 id="intarray">
 <title>intarray</title>
 
 <indexterm zone="intarray">
  <primary>intarray</primary>
 </indexterm>

 <para>
  Ceci est une implémentation d'une structure de données RD-tree utilisant
  l'interface GiST de PostgreSQL. Elle contient une compression interne
  sans perte.
 </para>

 <para>
  L'implémentation en cours fournit un support des index pour les tableaux à
  une dimension contenant des données de type int4, gist__int_ops
  intéressant pour des tableaux de petites et moyennes tailles (utilisés par
  défaut), et gist__intbig_ops pour indexer de gros tableaux (nous avons
  utilisé des signatures d'une longueur de 4096 bits pour représenter des
  ensembles).
 </para>

 <sect2>
  <title>Fonctions</title>

  <itemizedlist>

   <listitem>
    <para>
     <literal>int   icount(int[])</literal> - le nombre des éléments dans
       intarray
    </para>
    <programlisting>
test=# select icount('{1,2,3}'::int[]);  
 icount
--------
      3
(1 row)
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>int[] sort(int[], 'asc' | 'desc')</literal> - tri de intarray
    </para>
    <programlisting>
test=# select sort('{1,2,3}'::int[],'desc');
  sort  
---------
 {3,2,1}
(1 row)
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>int[] sort(int[])</literal> - tri en ordre ascendant
    </para>
   </listitem>

   <listitem>
    <para>
     <literal>int[] sort_asc(int[]),sort_desc(int[])</literal> - raccourcis pour
     le tri
    </para>
   </listitem>

   <listitem>
    <para>
     <literal>int[] uniq(int[])</literal> - renvoie les éléments uniques
    </para>
    <programlisting>
test=# select uniq(sort('{1,2,3,2,1}'::int[]));
  uniq  
---------
 {1,2,3}
(1 row)
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>int   idx(int[], int item)</literal> - renvoie l'index du premier
      élément de l'intarray correspondant à cet élément ('0' si aucun trouvé).
    </para>
    <programlisting>
test=# select idx('{1,2,3,2,1}'::int[],2);
 idx
-----
   2
(1 row)
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>int[] subarray(int[],int START [, int LEN])</literal> - renvoie
      un sous-tableau de l'intarray qui commence à l'élément numéro START (en
      commençant à 1) et de longueur LEN.
    </para>
    <programlisting>
test=# select subarray('{1,2,3,2,1}'::int[],2,3);
 subarray
----------
 {2,3,2}
(1 row)
    </programlisting>
   </listitem>

   <listitem>
    <para>
     <literal>int[] intset(int4)</literal> - convertie un int4 en int[]
    </para>
    <programlisting>
test=# select intset(1);
 intset
--------
 {1}
(1 row)
    </programlisting>
   </listitem>

  </itemizedlist>
 </sect2>

 <sect2>
  <title>Opérations</title>
  <table>
   <title>Opérations</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Opérateur</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal><![CDATA[int[] && int[]]]></literal></entry>
      <entry>overlap - renvoie TRUE si les tableaux ont au moins un élément en
       commun</entry>
     </row>
     <row>
      <entry><literal><![CDATA[int[] @> int[]]]></literal></entry>
      <entry>contains - renvoie TRUE si le tableau gauche contient le tableau
       droit</entry>
     </row>
     <row>
      <entry><literal><![CDATA[int[] <@ int[]]]></literal></entry>
      <entry>contained - renvoie TRUE si le tableau gauche est contenu dans le
       le tableau droit</entry>
     </row>
     <row>
      <entry><literal># int[]</literal></entry>
      <entry>renvoie le nombre d'éléments contenu dans le tableau</entry>
     </row>
     <row>
      <entry><literal>int[] + int</literal></entry>
      <entry>place l'élément à la fin du tableau</entry>
     </row>
     <row>
      <entry><literal>int[] + int[]  </literal></entry>
      <entry>assemble les tableaux (celui de droite est ajouté à la fin de celui
       de gauche)</entry>
     </row>
     <row>
      <entry><literal>int[] - int</literal></entry>
      <entry>supprime les éléments du tableau correspondant à l'argument droit
       </entry>
     </row>
     <row>
      <entry><literal>int[] - int[]</literal></entry>
      <entry>supprime le tableau droit du tableau gauche</entry>
     </row>
     <row>
      <entry><literal>int[] | int</literal></entry>
      <entry>renvoie intarray - l'union des arguments</entry>
     </row>
     <row>
      <entry><literal>int[] | int[]</literal></entry>
      <entry>renvoie intarray comme union des deux tableaux</entry>
     </row>

     <row>
      <entry><literal><![CDATA[int[] & int[]]]></literal></entry>
      <entry>renvoie l'intersection des tableaux</entry>
     </row>

     <row>
      <entry><literal>int[] @@ query_int</literal></entry>
      <entry>
       renvoie TRUE si le tableau satisfait la requête (comme
       <literal>'1&amp;(2|3)'</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>query_int ~~ int[]</literal></entry>
      <entry>renvoie TRUE si le tableau satisfait la requête (commutateur de
       @@)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   (Avant PostgreSQL 8.2, les opérateurs de contenance @&gt; et &lt;@ étaient
   respectivement appelés @ et ~. Ces noms sont toujours disponibles, mais sont
   obsolètes et seront un jour supprimés complètement. Notez que les anciens
   noms correspondent à l'inverse de la convention suivie par les types de
   données de géométrie&nbsp;!)
  </para>
 </sect2>

 <sect2>
  <title>Exemple</title>

  <programlisting><![CDATA[
CREATE TABLE message (mid INT NOT NULL,sections INT[]);
CREATE TABLE message_section_map (mid INT NOT NULL,sid INT NOT NULL);

-- création des index
CREATE unique index message_key ON message ( mid );
CREATE unique index message_section_map_key2 ON message_section_map (sid, mid );
CREATE INDEX message_rdtree_idx ON message USING GIST ( sections gist__int_ops);

-- sélectionne les messages dont sections contient 1 ou 2 - opérateur OVERLAP
SELECT message.mid FROM message WHERE message.sections && '{1,2}'; 

-- sélectionne les messages dont sections contient 1 et 2 - opérateur CONTAINS
SELECT message.mid FROM message WHERE message.sections @> '{1,2}';
-- de même, opérateur CONTAINED
SELECT message.mid FROM message WHERE '{1,2}' <@ message.sections;
  ]]></programlisting>
 </sect2>

 <sect2>
  <title>Benchmark</title>
  <para>
  Le sous répertoire bench contient une suite de tests des performances.
  </para>
  <programlisting><![CDATA[
  cd ./bench
  1. createdb TEST
  2. psql TEST < ../_int.sql
  3. ./create_test.pl | psql TEST
  4. ./bench.pl - perl script to benchmark queries, supports OR, AND queries
                  with/without RD-Tree. Run script without arguments to
                  see availbale options.

     a)test without RD-Tree (OR)
       ./bench.pl -d TEST -c -s 1,2 -v
     b)test with RD-Tree
       ./bench.pl -d TEST -c -s 1,2 -v -r

     BENCHMARKS:
    
     Size of table &lt;message>: 200000
     Size of table &lt;message_section_map>: 269133
    
     Distribution of messages by sections:
    
     section 0: 74377 messages
     section 1: 16284 messages
     section 50: 1229 messages
     section 99: 683 messages
    
     old - without RD-Tree support,
     new - with RD-Tree
    
     +----------+---------------+----------------+
     |Search set|OR, time in sec|AND, time in sec|
     |          +-------+-------+--------+-------+
     |          |  old  |  new  |   old  |  new  |
     +----------+-------+-------+--------+-------+
     |         1|  0.625|  0.101|       -|      -|
     +----------+-------+-------+--------+-------+
     |        99|  0.018|  0.017|       -|      -|
     +----------+-------+-------+--------+-------+
     |       1,2|  0.766|  0.133|   0.628|  0.045|
     +----------+-------+-------+--------+-------+
     | 1,2,50,65|  0.794|  0.141|   0.030|  0.006|
     +----------+-------+-------+--------+-------+
  ]]></programlisting>
 </sect2>

 <sect2>
  <title>Auteurs</title>
  <para>
   Ce travail a été réalisé par Teodor Sigaev (<email>teodor@stack.net</email>)
   et Oleg Bartunov (<email>oleg@sai.msu.su</email>). Voir le
   <ulink url="http://www.sai.msu.su/~megera/postgres/gist">site de
   GiST</ulink> pour des informations supplémentaires. Andrey Oktyabrski a fait
   un gros travail en ajoutant des nouvelles fonctions et opérateurs.
  </para>
 </sect2>

</sect1>

