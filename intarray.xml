<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="intarray">
 <title>intarray</title>
 
 <indexterm zone="intarray">
  <primary>intarray</primary>
 </indexterm>

 <para>
  Le module <filename>intarray</filename> fournit un certain nombre de
  fonctions et d'opérateurs utiles pour manipuler des tableaux d'entiers sur
  une dimension. Il y a aussi un support pour les recherches par index en
  utilisant certains des opérateurs.
 </para>

 <sect2>
  <title>Fonctions et opérateurs d'<filename>intarray</filename></title>

  <table id="intarray-func-table">
   <title>Fonctions <filename>intarray</filename></title>

   <tgroup cols="5">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Type en retour</entry>
      <entry>Description</entry>
      <entry>Exemple</entry>
      <entry>Résultat</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><function>icount(int[])</function></entry>
      <entry><type>int</type></entry>
      <entry>nombre d'éléments dans un tableau</entry>
      <entry><literal>icount('{1,2,3}'::int[])</literal></entry>
      <entry><literal>3</literal></entry>
     </row>

     <row>
      <entry><function>sort(int[], text dir)</function></entry>
      <entry><type>int[]</type></entry>
      <entry>tri du tableau &mdash; <parameter>dir</parameter> doit valoir <literal>asc</literal> ou <literal>desc</literal></entry>
      <entry><literal>sort('{1,2,3}'::int[], 'desc')</literal></entry>
      <entry><literal>{3,2,1}</literal></entry>
     </row>

     <row>
      <entry><function>sort(int[])</function></entry>
      <entry><type>int[]</type></entry>
      <entry>tri en ordre ascendant</entry>
      <entry><literal>sort(array[11,77,44])</literal></entry>
      <entry><literal>{11,44,77}</literal></entry>
     </row>

     <row>
      <entry><function>sort_asc(int[])</function></entry>
      <entry><type>int[]</type></entry>
      <entry>tri en ordre descendant</entry>
      <entry><literal></literal></entry>
      <entry><literal></literal></entry>
     </row>

     <row>
      <entry><function>sort_desc(int[])</function></entry>
      <entry><type>int[]</type></entry>
      <entry>tri en ordre descendant</entry>
      <entry><literal></literal></entry>
      <entry><literal></literal></entry>
     </row>

     <row>
      <entry><function>uniq(int[])</function></entry>
      <entry><type>int[]</type></entry>
      <entry>supprime les duplicats adjacents</entry>
      <entry><literal>uniq(sort('{1,2,3,2,1}'::int[]))</literal></entry>
      <entry><literal>{1,2,3}</literal></entry>
     </row>

     <row>
      <entry><function>idx(int[], int item)</function></entry>
      <entry><type>int</type></entry>
      <entry>index du premier élément correspondant à
      <parameter>item</parameter> (0 si aucune correspondance)</entry>
      <entry><literal>idx(array[11,22,33,22,11], 22)</literal></entry>
      <entry><literal>2</literal></entry>
     </row>

     <row>
      <entry><function>subarray(int[], int start, int len)</function></entry>
      <entry><type>int[]</type></entry>
      <entry>portion du tableau commençant à la position <parameter>start</parameter>, de longueur <parameter>elements</parameter></entry>
      <entry><literal>subarray('{1,2,3,2,1}'::int[], 2, 3)</literal></entry>
      <entry><literal>{2,3,2}</literal></entry>
     </row>

     <row>
      <entry><function>subarray(int[], int start)</function></entry>
      <entry><type>int[]</type></entry>
      <entry>portion du tableau commençant à la position <parameter>start</parameter></entry>
      <entry><literal>subarray('{1,2,3,2,1}'::int[], 2)</literal></entry>
      <entry><literal>{2,3,2,1}</literal></entry>
     </row>

     <row>
      <entry><function>intset(int)</function></entry>
      <entry><type>int[]</type></entry>
      <entry>crée un tableau à un élément</entry>
      <entry><literal>intset(42)</literal></entry>
      <entry><literal>{42}</literal></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <table id="intarray-op-table">
   <title>Opérateurs d'<filename>intarray</filename></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Opérateur</entry>
      <entry>Renvoie</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>int[] &amp;&amp; int[]</literal></entry>
      <entry><type>boolean</type></entry>
      <entry>surcharge &mdash; <literal>true</literal> si les tableaux ont
      au moins un élément en commun</entry>
     </row>
     <row>
      <entry><literal>int[] @ int[]</literal></entry>
      <entry><type>boolean</type></entry>
      <entry>contient &mdash; <literal>true</literal> si le tableau gauche
      contient le tableau droit</entry>
     </row>
     <row>
      <entry><literal>int[] ~ int[]</literal></entry>
      <entry><type>boolean</type></entry>
      <entry>est contenu &mdash; <literal>true</literal> si le tableau gauche
      est contenu dans le tableau droit</entry>
     </row>
     <row>
      <entry><literal># int[]</literal></entry>
      <entry><type>int</type></entry>
      <entry>nombre d'éléments dans le tableau</entry>
     </row>
     <row>
      <entry><literal>int[] # int</literal></entry>
      <entry><type>int</type></entry>
      <entry>index (identique à la fonction <function>idx</function>)</entry>
     </row>
     <row>
      <entry><literal>int[] + int</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>pousse l'élément dans le tableau (l'ajoute à la fin du
      tableau)</entry>
     </row>
     <row>
      <entry><literal>int[] + int[]  </literal></entry>
      <entry><type>int[]</type></entry>
      <entry>concaténation de tableau (le tableau à droite est ajouté à la
      fin du tableau à gauche)</entry>
     </row>
     <row>
      <entry><literal>int[] - int</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>supprime les entrée correspondant à l'argument droit du
      tableau</entry>
     </row>
     <row>
      <entry><literal>int[] - int[]</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>supprime les éléments du tableau droit à partir de la
      gauche</entry>
     </row>
     <row>
      <entry><literal>int[] | int</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>union des arguments</entry>
     </row>
     <row>
      <entry><literal>int[] | int[]</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>union des tableaux</entry>
     </row>
     <row>
      <entry><literal>int[] &amp; int[]</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>intersection des tableaux</entry>
     </row>
     <row>
      <entry><literal>int[] @@ query_int</literal></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>true</literal> si le tableau satisfait la requête (voir
      ci-dessous)</entry>
     </row>
     <row>
      <entry><literal>query_int ~~ int[]</literal></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>true</literal> si le tableau satisfait la requête
      (commutateur de <literal>@@</literal>)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The containment operators <literal>@</literal> and <literal>~</literal> are functionally
   equivalent to <productname>PostgreSQL</productname>'s built-in operators
   <literal>@&gt;</literal> and <literal>&lt;@</literal>, respectively, except that
   <literal>@</literal> and <literal>~</literal> work only on integer arrays.  These
   operator names are deprecated and will eventually be retired.  (Notice that
   these names are reversed from the convention formerly followed by the core
   geometric datatypes!)
  </para>

  <para>
   Les opérateurs <literal>@@</literal> et <literal>~~</literal> testent si
   un tableau satisfait une <firstterm>requête</firstterm>, qui est exprimée
   comme une valeur d'un type de données spécialisé <type>query_int</type>. Une
   <firstterm>requête</firstterm> consiste en des valeurs de type integer qui
   sont vérifiées avec les éléments du tableau, parfois combinées en utilisant
   les opérateurs <literal>&amp;</literal> (AND), <literal>|</literal> (OR)
   et <literal>!</literal> (NOT). Les parenthèses peuvent être utilisées si
   nécessaire. Par exemple, la requête <literal>1&amp;(2|3)</literal> établit
   une correspondance avec les tableaux qui contiennent 1 et aussi soit 2 soit
   3.
  </para>
 </sect2>

 <sect2>
  <title>Support des index</title>

  <para>
   <filename>intarray</filename> fournit un support des index pour les
   opérateurs <literal>&amp;&amp;</literal>, <literal>@</literal>,
   <literal>~</literal> et <literal>@@</literal>, ainsi qu'une égalité
   des tableaux standards
   and the built-in <literal>@&gt;</literal> and <literal>&lt;@</literal> operators
   (when used on integer arrays).
  </para>

  <para>
   Deux classes d'opérateur pour index GiST sont fournies&nbsp;:
   <literal>gist__int_ops</literal> (utilisé par défaut) convient pour des
   tableaux d'ensembles de données de petites et moyennes tailles alors que
   <literal>gist__intbig_ops</literal> utilise une signature plus importante
   et est donc plus intéressant pour indexer des gros ensembles de données.
   (i.e., columns containing a large number of distinct array values).
   The implementation uses an RD-tree data structure with
   built-in lossy compression.
  </para>

  <para>
   Il y a aussi une classe d'opérateur GIN,<literal>gin__int_ops</literal>
   supporting the same operators, qui n'est pas disponible par défaut.
  </para>

  <para>
   Le choix d'un indexage GiST ou IN dépend des caractéristiques relatives
   de performance qui sont discutées ailleurs. Comme règle de base, un index
   GIN est plus rapide pour la recherche qu'un index GiST mais plus lent
   pour la construction et la mise à jour&nbsp;; donc GIN est préférable pour
   des données statiques et GiST pour des données souvent mises à jour.
  </para>
 </sect2>

 <sect2>
  <title>Exemple</title>

  <programlisting>
-- un message peut être dans un ou plusieurs <quote>sections</quote>
CREATE TABLE message (mid INT PRIMARY KEY, sections INT[], ...);

-- crée un index spécialisé
CREATE INDEX message_rdtree_idx ON message USING GIST (sections gist__int_ops);

-- sélectionne les messages dans la section 1 ou 2 - opérateur OVERLAP
SELECT message.mid FROM message WHERE message.sections &amp;&amp; '{1,2}';

-- sélectionne les messages dans sections 1 et 2 - opérateur CONTAINS
SELECT message.mid FROM message WHERE message.sections @&gt; '{1,2}';

-- idem, en utilisant l'opérateur QUERY
SELECT message.mid FROM message WHERE message.sections @@ '1&amp;2'::query_int;
  </programlisting>
 </sect2>

 <sect2>
  <title>Tests de performance</title>

  <para>
   Le répertoire des sources (<filename>contrib/intarray/bench</filename>)
   contient une suite de tests de performance. Pour l'exécuter&nbsp;:
  </para>

  <programlisting>
   cd .../bench
   createdb TEST
   psql TEST &lt; ../_int.sql
   ./create_test.pl | psql TEST
   ./bench.pl
  </programlisting>

  <para>
   Le script <filename>bench.pl</filename> contient un grand nombre d'options.
   Elles sont affichées quand il est exécuté sans arguments.
  </para>
 </sect2>


 <sect2>
  <title>Auteurs</title>
  <para>
   Ce travail a été réalisé par Teodor Sigaev (<email>teodor@sigaev.ru</email>)
   et Oleg Bartunov (<email>oleg@sai.msu.su</email>). Voir le
   <ulink url="http://www.sai.msu.su/~megera/postgres/gist">site de
   GiST</ulink> pour des informations supplémentaires. Andrey Oktyabrski a fait
   un gros travail en ajoutant des nouvelles fonctions et opérateurs.
  </para>
 </sect2>

</sect1>

