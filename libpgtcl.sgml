<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/libpgtcl.sgml,v 1.5 2005/07/15 06:14:24 guillaume Exp $
-->

<chapter id="pgtcl">
 <title><application>pgtcl</application> - Bibliothèque de liens pour
Tcl</title>

 <indexterm zone="pgtcl">
  <primary>libpgtcl</primary>
 </indexterm>

 <indexterm zone="pgtcl">
  <primary>pgtcl</primary>
 </indexterm>

 <indexterm zone="pgtcl">
  <primary>Tcl</primary>
 </indexterm>

  <para>
   <application>pgtcl</application> est un paquet Tcl pour que les programmes
   client s'interfacent avec les serveurs
   <ProductName>PostgreSQL</ProductName>. Il rend disponible la plupart des
   fonctionnalités de <application>libpq</application> pour les scripts Tcl.
  </para>

 <sect1 id="pgtcl-overview">
  <title>Survol</title>

  <para>
   <xref linkend="pgtcl-commands-table"> donne un aperçu des commandes
   disponibles dans <application>pgtcl</application>. Ces commandes sont
   décrites en détail dans les pages suivantes.
  </para>


<table id="pgtcl-commands-table">
<title>Commandes <application>pgtcl</application></title>
<tgroup cols="2">
<thead>
  <row>
    <entry>Commande</entry>
    <entry>Description</entry>
  </row>
</thead>

<tbody>
  <row>
    <entry><function>pg_connect</function></entry>
    <entry>ouvre une connexion au serveur</entry>
  </row>
  <row>
    <entry><function>pg_disconnect</function></entry>
    <entry>ferme une connexion au serveur</entry>
  </row>
  <row>
    <entry><function>pg_conndefaults</function></entry>
    <entry>récupère les options de connexion et leurs valeurs par défaut</entry>
  </row>
  <row>
    <entry><function>pg_exec</function></entry>
    <entry>envoie une commande au serveur</entry>
  </row>
  <row>
    <entry><function>pg_result</function></entry>
    <entry>obtient des informations sur le résultat d'une commande</entry>
  </row>
  <row>
    <entry><function>pg_select</function></entry>
    <entry>fait une boucle dans le résultat d'une requête</entry>
  </row>
  <row>
    <entry><function>pg_execute</function></entry>
    <entry>envoie une requête et boucle, optionnellement, dans les
      résultats</entry>
  </row>
  <row>
    <entry><function>pg_listen</function></entry>
    <entry>initialise ou modifie un appel pour les messages de notification
      asynchrones</entry>
  </row>
  <row>
    <entry><function>pg_on_connection_loss</function></entry>
    <entry>initialise ou modifier un appel en cas de perte inattendue de
      connexion</entry>
  </row>

  <row>
    <entry><function>pg_lo_creat</function></entry>
    <entry>crée un objet large</entry>
  </row>
  <row>
    <entry><function>pg_lo_open</function></entry>
    <entry>ouvre un objet large</entry>
  </row>
  <row>
    <entry><function>pg_lo_close</function></entry>
    <entry>ferme un objet large</entry>
  </row>
  <row>
    <entry><function>pg_lo_read</function></entry>
    <entry>lit à partir d'un objet large</entry>
  </row>
  <row>
    <entry><function>pg_lo_write</function></entry>
    <entry>écrit dans un objet large</entry>
  </row>
  <row>
    <entry><function>pg_lo_lseek</function></entry>
    <entry>recherche une position dans un objet large</entry>
  </row>
  <row>
    <entry><function>pg_lo_tell</function></entry>
    <entry>renvoie la position courante d'un objet large</entry>
  </row>
  <row>
    <entry><function>pg_lo_unlink</function></entry>
    <entry>supprime un objet large</entry>
  </row>
  <row>
    <entry><function>pg_lo_import</function></entry>
    <entry>importe un objet large à partir d'un fichier</entry>
  </row>
  <row>
    <entry><function>pg_lo_export</function></entry>
    <entry>exporte un objet large vers un fichier</entry>
  </row>
</tbody>
</tgroup>
</table>

  <para>
   Les commandes <function>pg_lo_*</function> sont des interfaces vers les
   fonctionnalités des objets larges de
   <ProductName>PostgreSQL</ProductName>.<indexterm><primary>objet
   large</><secondary>en pgctl</></> Les fonctions sont conçues pour imiter les
   fonctions analogues du système de fichier dans l'interface standard des
   systèmes de fichiers Unix. Les commandes <function>pg_lo_*</function>
   devraient être utiliser à l'intérieur d'un bloc de transaction
   <command>BEGIN</command>/<command>COMMIT</command> car le descripteur
   renvoyé par <function>pg_lo_open</function> n'est valide que pour la
   transaction en cours. <function>pg_lo_import</function> et
   <function>pg_lo_export</function> <emphasis>doivent</emphasis> être
   utilisées dans un bloc de transaction
   <command>BEGIN</command>/<command>COMMIT</command>.
  </para>

 </sect1>

<sect1 id="libpgtcl-loading">
<title>Charger <application>pgtcl</application> dans une application</title>

   <para>
    Avant d'utiliser les commandes <application>pgtcl</application>, vous devez
    charger la bibliothèque <filename>libpgtcl</> dans votre application Tcl.
    Ceci se fait normalement avec la commande <literal>load</> command. Voici un
    exemple :

<programlisting>
load libpgtcl[info sharedlibextension]
</programlisting>

    L'utilisation de <literal>info sharedlibextension</> est recommandé au
    codage en dur du <literal>.so</> ou du <literal>.sl</> dans le programme.
   </para>

   <para>
    La commande <literal>load</> échouera sauf si le chargeur dynamique du
    système sait où trouver le fichier de la bibliothèque partagée
    <filename>libpgtcl</> shared. Vous pourriez avoir besoin de travailler avec
    <command>ldconfig</> ou d'initialiser la variable d'environnement
    <envar>LD_LIBRARY_PATH</> ou encore utiliser une fonctionnalité équivalente
    pour votre plateforme. Référez-vous aux instructions d'installation de
    <productname>PostgreSQL</> pour plus d'informations.
   </para>

   <para>
    <filename>libpgtcl</> dépend de <filename>libpq</>, donc le chargeur
    dynamique doit être capable de trouver la bibliothèque partagée
    <filename>libpq</>. En pratique, ceci est rarement un problème car les deux
    bibliothèques sont normalement placées dans le même répertoire mais cela
    peut devenir un cas bloquant pour certaines configurations.
   </para>

   <para>
    Si vous utilisez un exécutable personnalisé pour votre application, vous
    pourriez choisir de lier <filename>libpgtcl</> statiquement dans
    l'exécutable et, du coup, éviter la commande <literal>load</> et les
    problèmes potentiels de chargement dynamique. Voir le code source de
    <application>pgtclsh</> pour un exemple.
   </para>

</sect1>

<sect1 id="libpgtcl-ref">
<title>Référence des commandes de <application>pgtcl</application></title>

<refentry ID="PGTCL-PGCONNECT">
 <refmeta>
  <refentrytitle>pg_connect</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_connect</refname>
  <refpurpose>ouvre une connexion au serveur</refpurpose>
  <indexterm ID="IX-PGTCL-PGCONNECT-2"><primary>pg_connect</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_connect -conninfo <parameter>optionsConnexion</parameter>
pg_connect <parameter>dbName</parameter> <optional role="tcl">-host
<parameter>nomHote</parameter></optional> <optional role="tcl">-port
<parameter>numeroPort</parameter></optional> <optional role="tcl">-tty
<parameter>tty</parameter</optional> <optional role="tcl">-options
<parameter>optionsServeur</parameter></optional>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_connect</function> ouvre une connexion vers le serveur
   <ProductName>PostgreSQL</ProductName>.
  </para>

  <para>
   Deux syntaxes sont disponibles. Dans l'ancienne forme, chaque option possible
   a un commutateur d'option séparé à partir de la commande
   <command>pg_connect</command>. Dans la nouvelle forme, une seule chaîne
   d'options est fournie, pouvant contenir plusieurs valeurs d'options.
   <function>pg_conndefaults</function> est utilisable pour récupérer des
   informations sur les options disponibles avec la nouvelle syntaxe.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <title>Nouveau style</title>

   <varlistentry>
    <term><parameter>optionsConnexion</parameter></term>
    <listitem>
     <para>
      Une chaîne d'options de connexion, chacune écrite de la forme
      <literal>motclé = valeur</>. Une liste des options valides est disponible
      dans la description de la fonction <function>PQconnectdb</>
      de <application>libpq</>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <variablelist>
   <title>Ancien style</title>

   <varlistentry>
    <term><parameter>nomDB</parameter></term>
    <listitem>
     <para>
      Le nom de la base de données où se connecter.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><option>-host <parameter>nomHote</parameter></option></term>
    <listitem>
     <para>
      Le nom de l'hôte où se trouve le serveur de bases de données.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><option>-port <parameter>numeroPort</parameter></option></term>
    <listitem>
     <para>
      Le numéro de port TCP pour se connecter au serveur des bases de données.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><option>-tty <parameter>tty</parameter></option></term>
    <listitem>
     <para>
      Un fichier ou un <acronym>TTY</acronym> pour une sortie de débogage
      optionnelle du serveur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><option>-options <parameter>optionsServeur</parameter></option></term>
    <listitem>
     <para>
      Des options supplémentaires de configuration à passer au serveur.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   En cas de succès, une poignée vers une connexion est renvoyée. Celle-ci
   commence avec le préfixe <literal>pgsql</literal>.
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGDISCONNECT">
 <refmeta>
  <refentrytitle>pg_disconnect</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_disconnect</refname>
  <refpurpose>ferme une connexion au serveur</refpurpose>
  <indexterm
ID="IX-PGTCL-PGDISCONNECT-2"><primary>pg_disconnect</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_disconnect <parameter>conn</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_disconnect</function> ferme une connexion au serveur
   <productname>PostgreSQL</productname>.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de la connexion à fermer.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Aucun
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGCONNDEFAULTS">
 <refmeta>
  <refentrytitle>pg_conndefaults</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_conndefaults</refname>
  <refpurpose>Obtient des options de connexion et leur valeurs par
    défaut</refpurpose>
  <indexterm
ID="IX-PGTCL-PGCONNDEFAULTS-2"><primary>pg_conndefaults</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_conndefaults
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_conndefaults</function> renvoie des informations sur les
   options de connexion disponibles dans
   <function>pg_connect-conninfo</function> et la valeur courante par défaut de
   chaque option.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <para>
   Aucun
  </para>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Le résultat est une liste décrivant les options possibles de connexion 
   et leur valeur courante par défaut. Chaque entrée de la liste est une
   sous-liste dans le format :
<synopsis>
{optname label dispchar dispsize value}
</synopsis>
   où <replaceable>optname</> est utilisable comme option avec
   <function>pg_connect -conninfo</function>.
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGEXEC">
 <refmeta>
  <refentrytitle>pg_exec</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_exec</refname>
  <refpurpose>envoie une commande au serveur</refpurpose>
  <indexterm ID="IX-PGTCL-PGEXEC-2"><primary>pg_exec</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_exec <parameter>conn</parameter> <parameter>chaineCommande</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_exec</function> soumet une commande au serveur
   <productname>PostgreSQL</productname> et récupère un résultat. La poignée du
   résultat de la commande commence avec la poignée de la connexion, et ajoute
   un point et un numéro de résultat.
  </para>

  <para>
   Notez que le manque d'erreur Tcl n'est pas la preuve que la commande a
   réussi ! Un message d'erreur renvoyé par le serveur sera traité comme un
   résultat de commande avec un statut d'échec, sans générer d'erreur Tcl dans
   <function>pg_exec</function>.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de la connexion où exécuter la commande.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>chaineCommande</parameter></term>
    <listitem>
     <para>
      La commande SQL à exécuter.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Une poignée résultat. Une erreur Tcl sera renvoyée si
   <application>pgtcl</application> a été incapable d'obtenir une réponse du
   serveur. Sinon, l'objet résultat de la commande est créé et une poignée sur
   celui-ci est renvoyée. Cette poignée peut être passée à
   <function>pg_result</function> pour obtenir les résultats de la commande.
  </para>
 </refsect1
</refentry>


<refentry ID="PGTCL-PGRESULT">
 <refmeta>
  <refentrytitle>pg_result</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_result</refname>
  <refpurpose>obtenir des informations sur le résultat d'une
    commande</refpurpose>
  <indexterm ID="IX-PGTCL-PGRESULT-2"><primary>pg_result</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_result <parameter>poigneeResultat</parameter>
<parameter>optionResultat</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_result</function> renvoie des informations sur un résultat de
   commande créé suite à un appel précédent à <function>pg_exec</function>.
  </para>

  <para>
   Vous pouvez garder un résultat de commande aussi longtemps que vous en
   avez besoin, mais une fois terminé, assurez-vous de le libérer en
   exécutant <function>pg_result -clear</function>. Sinon, vous aurez des pertes
   de mémoire et <application>pgtcl</> commencera éventuellement à se plaindre
   que vous avez créé trop d'objets de résultats de commandes.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>poigneeResultat</parameter></term>
    <listitem>
     <para>
      La poignée du résultat de la commande.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>optionResultat</parameter></term>
    <listitem>
     <para>
      Une des options suivantes, spécifiant quelle pièce d'informations de
      résultat renvoyer :

      <variablelist>
       <varlistentry>
        <term><option>-status</option></term>
        <listitem>
         <para>
          Le statut du résultat.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-error</option></term>
        <listitem>
         <para>
          Le message d'erreur si le statut indique une erreur, sinon une chaîne
          vide.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-conn</option></term>
        <listitem>
         <para>
          La connexion qui a produit ce résultat.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-oid</option></term>
        <listitem>
         <para>
          Si la commande était un <command>INSERT</command>, l'OID de la ligne
          insérée, sinon 0.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-numTuples</option></term>
        <listitem>
         <para>
          Le nombre de lignes (tuples) renvoyées par la requête.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-cmdTuples</option></term>
        <listitem>
         <para>
          Le nombre de lignes (tuples) affectées par la commande.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-numAttrs</option></term>
        <listitem>
         <para>
          Le nombre de colonnes (attributs) pour chaque ligne.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-assign <parameter>arrayName</parameter></option></term>
        <listitem>
         <para>
          Affecte les résultats dans un tableau en utilisant des indices de la
          forme <literal>(numeroLigne, nomColonne)</literal>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-assignbyidx <parameter>nomTableau</> <optional
          role="tcl"><parameter>appendstr</></optional></option></term>
        <listitem>
         <para>
          Affecte les résultats dans un tableau en utilisant les valeurs de la
          première colonne et les noms des colonnes restantes comme clés. Si
          <parameter>appendstr</> est donné, alors il est ajouté à chaque clé.
          En bref, tout sauf la première colonne de chaque ligne est stocké dans
          le tableau en utilisant des indices de la forme
          <literal>(valeurPremiereColonne, chaineAjouteeAuNomColonne)</literal>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-getTuple
          <parameter>numeroLigne</parameter></option></term>
        <listitem>
         <para>
          Renvoie les colonnes de la ligne indiquée dans une liste. Les numéros
          de lignes commencent à zéro.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-tupleArray <parameter>numeroLigne</>
          <parameter>nomTableau</></option></term>
        <listitem>
         <para>
          Stocke les colonnes de la ligne dans le tableau
          <parameter>nomTableau</parameter>, indexé par les noms de colonnes.
          Les numéros de lignes commencent à zéro.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-attributes</option></term>
        <listitem>
         <para>
          Renvoie une liste des noms des colonnes dans le résultat.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-lAttributes</option></term>
        <listitem>
         <para>
          Renvoie une liste de sous-listes, <literal>{name typeOid
          typeSize}</literal> pour chaque colonne.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><option>-clear</option></term>
        <listitem>
         <para>
          Efface l'objet résultat de la commande.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Le résultat dépend de l'option sélectionnée comme décrit ci-dessus.
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGSELECT">
 <refmeta>
  <refentrytitle>pg_select</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_select</refname>
  <refpurpose>boucle avec le résultat d'une requête</refpurpose>
  <indexterm ID="IX-PGTCL-PGSELECT-2"><primary>pg_select</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_select <parameter>conn</parameter> <parameter>chaineCommande</parameter>
<parameter>tableauVar</parameter> <parameter>procedure</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_select</function> soumet une requête (instruction
   (<command>SELECT</command>) au serveur <productname>PostgreSQL</productname>
   et exécute un bout de code pour chaque ligne du résultat.
   <parameter>chaineCommande</parameter> doit être une instruction
   <command>SELECT</command> ; tout autre instruction renvoie une erreur.
   La variable <parameter>tableauVar</parameter> est un nom de tableau utilisé
   dans la boucle. Pour chaque ligne, <parameter>tableauVar</parameter> est
   rempli avec les valeurs de la ligne en utilisant les noms de colonnes comme
   indices du tableau. Puis, la <parameter>procedure</parameter> est exécutée.
  </para>

  <para>
   En plus des valeurs des colonnes, les entrées spéciales suivantes sont
   ajoutées dans le tableau :

   <variablelist>
    <varlistentry>
     <term><literal>.headers</></term>
     <listitem>
      <para>
       Une liste des noms de colonnes renvoyés par la requête.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>.numcols</></term>
     <listitem>
      <para>
       Le nombre de colonnes renvoyées par la requête.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>.tupno</></term>
     <listitem>
      <para>
       Le numéro de ligne courant, commençant à zéro et incrémenté à chaque
       itération du corps de la boucle.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de la connexion où exécuter la requête.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>commandString</parameter></term>
    <listitem>
     <para>
      La requête SQL à exécuter.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>tableauVar</parameter></term>
    <listitem>
     <para>
      Une variable de type tableau pour les lignes renvoyées.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>procedure</parameter></term>
    <listitem>
     <para>
      La procédure à exécuter pour chaque ligne renvoyée.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>
  <para>
   Aucun
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Cet exemple assume que la table <classname>table1</> dispose des colonnes
   <structfield>control</> et <structfield>name</> (et peut-être
   d'autres) :
<programlisting>
pg_select $pgconn "SELECT * FROM table1;" array {
    puts [format "%5d %s" $array(control) $array(name)]
}
</programlisting>
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGEXECUTE">
 <refmeta>
  <refentrytitle>pg_execute</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_execute</refname>
  <refpurpose>envoie une requête et boucle de façon optionnelle sur les
    résultats</refpurpose>
  <indexterm ID="IX-PGTCL-PGEXECUTE-2"><primary>pg_execute</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_execute <optional role="tcl">-array
<parameter>tableauVar</parameter></optional> <optional role="tcl">-oid
<parameter>oidVar</parameter></optional> <parameter>conn</parameter>
<parameter>chaineCommande</parameter> <optional
role="tcl"><parameter>procedure</parameter></optional>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_execute</function> soumet une commande au serveur
   <productname>PostgreSQL</>.
  </para>

  <para>
   Si la commande n'est pas une instruction <command>SELECT</command>, le
   nombre de lignes affectées par la commande est renvoyé. Si la commande est
   une instruction <command>INSERT</command> et qu'une simple ligne est insérée,
   l'OID de la ligne insérée est stocké dans la variable <parameter>oidVar</> si
   l'argument optionnel <parameter>-oid</parameter> est fourni.
  </para>

  <para>
   Si la commande est une instruction <command>SELECT</command>, alors, pour
   chaque ligne du résultat, les valeurs de la ligne sont stockées dans la
   variable <parameter>tableauVar</parameter>, si celle-ci est fournie, en
   utilisant les noms de colonnes comme indices de tableau, sinon elles sont
   stockées dans les variables nommées suivant les noms de colonne. Enfin, la
   <parameter>procedure</parameter> optionnelle est exécutée si fournie.
   (Oublier <parameter>procedure</parameter> n'a probablement de sens que si la
   requête ne renvoie qu'une ligne.) Le nombre de lignes sélectionnées est
   renvoyé.
  </para>

  <para>
   La <parameter>procedure</parameter> peut utiliser les commandes Tcl
   <literal>break</literal>, <literal>continue</literal> et
   <literal>return</literal> avec le comportement attendu. Notez que si la
   <parameter>procedure</parameter> exécute <literal>return</literal>, alors
   <function>pg_execute</function> ne renvoie pas le nombre de lignes affectées.
  </para>

  <para>
   <function>pg_execute</function> est une fonction plus récente qui
   fournit un super-ensemble des fonctionnalités de
   <function>pg_select</function> et peut remplacer <function>pg_exec</function>
   dans de nombreux cas où l'accès à la poignée résultat n'est pas nécessaire.
  </para>

  <para>
   Pour les erreurs gérées par le serveur, <function>pg_execute</function>
   lancera une erreur Tcl et renverra une liste à deux éléments. Le premier
   élément est un code d'erreur tel que <literal>PGRES_FATAL_ERROR</literal> et
   le second élément est le texte d'erreur du serveur. Pour des erreurs plus
   sérieuses, tel qu'un échec dans la communication avec le serveur,
   <function>pg_execute</function> lancera une erreur Tcl et renverra juste le
   texte du message d'erreur.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><option>-array <parameter>tableauVar</parameter></option></term>
    <listitem>
     <para>
      Spécifie le nom de la variable tableau où les lignes de résultat sont
      stockées, indexées par les noms de colonnes. Ceci est ignoré si
      <parameter>chaineCommande</> n'est pas une instruction <command>SELECT</>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><option>-oid <parameter>oidVar</parameter></option></term>
    <listitem>
     <para>
      Spécifie le nom d'une variable dans lequel l'OID d'une instruction
      <command>INSERT</command> sera stocké.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de la connexion où exécuter la commande.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>commandString</parameter></term>
    <listitem>
     <para>
      La commande SQL à exécuter.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>procedure</parameter></term>
    <listitem>
     <para>
      Le procédure optionnelle à exécuter pour chaque ligne d'une
      instruction <command>SELECT</command>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Le nombre de lignes affectées ou renvoyées par la commande.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Dans les exemples suivants, la vérification d'erreur avec
   <literal>catch</literal> a été omise pour des raisons de clarté.
  </para>

  <para>
   Insérez une ligne et conservez l'OID dans <varname>result_oid</> :
<programlisting>
pg_execute -oid result_oid $pgconn "INSERT INTO matable VALUES (1);"
</programlisting>
  </para>

  <para>
   Affichez les colonnes <literal>element</> et <literal>valeur</> pour chaque
   ligne :
<programlisting>
pg_execute -array d $pgconn "SELECT element, valeur FROM matable;" {
    puts "Item=$d(element) Value=$d(valeur)"
}
</programlisting>
  </para>

  <para>
   Trouvez les valeurs maximum et minimum et les stockez dans
   <literal>$s(max)</> and <literal>$s(min)</>:
<programlisting>
pg_execute -array s $pgconn "SELECT max(valeur) AS max, min(valeur) AS min FROM
matable;"
</programlisting>
  </para>

  <para>
   Trouvez les valeurs maximum et minimum et les stockez dans
   <literal>$max</> and <literal>$min</>:
<programlisting>
pg_execute $pgconn "SELECT max(valeur) AS max, min(valeur) AS min FROM ma_table;"
</programlisting>
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGLISTEN">
 <refmeta>
  <refentrytitle>pg_listen</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_listen</refname>
  <refpurpose>initialise ou modifier un appel pour les messages asynchrones de
    notification</refpurpose>
  <indexterm ID="IX-PGTCL-PGLISTEN-2"><primary>pg_listen</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_listen <parameter>conn</parameter> <parameter>nomNotification</parameter>
<optional role="tcl"><parameter>commande</parameter></optional>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_listen</function> crée, modifie ou annule les rqupetes d'écoute
   de messages asynchrones de notification à partir du serveur
   <productname>PostgreSQL</productname>. Avec un paramètre
   <parameter>commande</>, la requête est établie ou la chaîne d'une requête
   déjà existante est remplacée. Sans paramètre <parameter>callbackCommand</>,
   une précédente requête est annulée.
  </para>

  <para>
   Après qu'une requête <function>pg_listen</function> ne soit établie, la
   chaîne de commande spécifiée est exécutée à chaque fois qu'un message de
   notification portant le même nom arrive du serveur. Ceci arrive lorsqu'un
   application client <productname>PostgreSQL</productname> lance une commande
   <command>NOTIFY</command><indexterm><primary>NOTIFY</><secondary
   sortas="pgtcl">en pgtcl</></> référençant ce nom. La chaîne de la commande
   est exécutée à partir de la boucle d'attente Tcl. C'est l'état normal d'une
   application écrite en Tk. Avec les shells Tcl non-Tk, vous pouvez exécuter
   <function>update</function> ou <function>vwait</function> pour entrer dans la
   boucle d'attente.
  </para>

  <para>
   Vous ne devriez pas appeler les instructions SQL <command>LISTEN</command>
   ou <command>UNLISTEN</command> directement en utilisant
   <function>pg_listen</function>. <application>pgtcl</application> prend en
charge l'appel de ces instructions pour vous. Mais si vous voulez envoyer un
message de notification vous-même, appelez l'instruction SQL
<command>NOTIFY</command> en utilisant <function>pg_exec</function>.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de la connexion sur laquelle écouter les notifications.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>nomNotification</parameter></term>
    <listitem>
     <para>
      Le nom de la condition de la notification pour commencer ou arrêter
      l'écoute.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>commande</parameter></term>
    <listitem>
     <para>
      Si présent, fournit la chaîne de commande à exécuter lorsqu'une
      notification correspondante arrive.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Aucun
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGON-CONNECTION-LOSS">
 <refmeta>
  <refentrytitle>pg_on_connection_loss</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_on_connection_loss</refname>
  <refpurpose>initialise ou modifie un appel pour les pertes inattendues de
    connexion</refpurpose>
  <indexterm ID="IX-PGTCL-PGON-CONNECTION-LOSS-2">
<primary>pg_on_connection_loss</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_on_connection_loss <parameter>conn</parameter> <optional
role="tcl"><parameter>commande</parameter></optional>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_on_connection_loss</function> crée, modifie ou annule une
   requête pour exécuter une commande si une perte inattendue de connexion à la
   base de données arrive. Avec un paramètre <parameter>commande</>, la requête
   est établie ou la chaîne de commande d'une requête existante est
   remplacée. Sans paramètre <parameter>commande</>, une précédente requête est
   annulée.
  </para>

  <para>
   La chaîne de commande est exécutée à partir de la boucle d'attente Tcl. Ceci
   est l'état normal d'attente d'une application écrite avec Tk. Dans les shells
   Tcl non-Tk, vous pouvez exécuté <function>update</function> ou
   <function>vwait</function> pour entrer dans la boucle d'attente.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée où surveiller une perte de connexion.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>commande</parameter></term>
    <listitem>
     <para>
      Si présent, fournit la chaîne de commande à exécuter lorsqu'une perte de
      connexion est détectée.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Aucun
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGLOCREAT">
 <refmeta>
  <refentrytitle>pg_lo_creat</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_lo_creat</refname>
  <refpurpose>crée un objet large</refpurpose>
  <indexterm
ID="IX-PGTCL-PGLOCREAT-2"><primary>pg_lo_creat</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_lo_creat <parameter>conn</parameter> <parameter>mode</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_lo_creat</function> crée un objet large.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de connexion à une base de données où créer l'objet large.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>mode</parameter></term>
    <listitem>
     <para>
      Le mode d'accès pour l'objet large. Il fait partie de, ou est une
      combinaison de <literal>INV_READ</> et <literal>INV_WRITE</>. L'opérateur
      <quote>ou</quote> est <literal>|</literal>. Par exemple :
<programlisting>
[pg_lo_creat $conn "INV_READ|INV_WRITE"]
</programlisting>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   OID de l'objet large créé.
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGLOOPEN">
 <refmeta>
  <refentrytitle>pg_lo_open</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_lo_open</refname>
  <refpurpose>ouvre un objet large</refpurpose>
  <indexterm ID="IX-PGTCL-PGLOOPEN-2"><primary>pg_lo_open</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_lo_open <parameter>conn</parameter> <parameter>loid</parameter>
<parameter>mode</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_lo_open</function> ouvre un objet large.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>

    <listitem>
     <para>
      La poignée de connexion d'une base de données où l'objet large existe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>loid</parameter></term>
    <listitem>
     <para>
      OID de l'objet large.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>mode</parameter></term>
    <listitem>
     <para>
      Spécifie le mode d'accès pour l'objet large. Le mode peut être soit
      <literal>r</> soit <literal>w</> soit <literal>rw</>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Un descripteur à utiliser avec les prochaines commandes pour objets larges.
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGLOCLOSE">
 <refmeta>
  <refentrytitle>pg_lo_close</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_lo_close</refname>
  <refpurpose>ferme un objet large</refpurpose>
  <indexterm
ID="IX-PGTCL-PGLOCLOSE-2"><primary>pg_lo_close</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_lo_close <parameter>conn</parameter> <parameter>descripteur</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_lo_close</function> ferme un objet large.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de connexion d'une base de données où l'objet large existe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>descripteur</parameter></term>
    <listitem>
     <para>
      Un descripteur de l'objet large disponible depuis
      <function>pg_lo_open</function>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Aucun
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGLOREAD">
 <refmeta>
  <refentrytitle>pg_lo_read</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_lo_read</refname>
  <refpurpose>lit à partir d'un objet large</refpurpose>
  <indexterm ID="IX-PGTCL-PGLOREAD-2"><primary>pg_lo_read</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_lo_read <parameter>conn</parameter> <parameter>descripteur</parameter>
<parameter>varTampon</parameter> <parameter>longueur</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_lo_read</function> lit au plus
   <parameter>longueur</parameter> octets depuis un objet large et les place
   dans une variable nommée <parameter>varTampon</parameter>.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de connexion d'une base de données où l'objet large existe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>descripteur</parameter></term>
    <listitem>
     <para>
      Un descripteur de l'objet large provenant de
      <function>pg_lo_open</function>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>varTampon</parameter></term>
    <listitem>
     <para>
      Le nom d'une variable tampon qui contiendra le segment de l'objet large.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>longueur</parameter></term>
    <listitem>
     <para>
      Le nombre maximum d'octets à lire.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Le nombre d'octets réellement lu est renvoyé ; cela pourrait être moins
   que le nombre demandé si la fin de l'objet large est atteint avant. Dans
   le cas d'une erreur, le code de retour est négatif.
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGLOWRITE">
 <refmeta>
  <refentrytitle>pg_lo_write</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_lo_write</refname>
  <refpurpose>écrit dans un objet large</refpurpose>
  <indexterm ID="IX-PGTCL-PGLOWRITE-2"><primary>pg_lo_write</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_lo_write <parameter>conn</parameter> <parameter>descripteur</parameter>
<parameter>tampon</parameter> <parameter>longueur</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_lo_write</function> écrit au plus
   <parameter>longueur</parameter> octets depuis la variable
   <parameter>tampon</parameter> dans un objet large.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de connexion d'une base de données où l'objet large existe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>descriptor</parameter></term>
    <listitem>
     <para>
      Un descripteur d'un objet large récupéré avec
      <function>pg_lo_open</function>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>tampon</parameter></term>
    <listitem>
     <para>
      La chaîne à écrire dans l'objet large (non pas le nom de la variable, mais
      la valeur elle-même).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>longueur</parameter></term>
    <listitem>
     <para>
      Le nombre maximum d'octets à écrire. Le nombre écrit sera le plus petit
      nombre entre cette valeur et la longueur de la chaîne.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Le nombre d'octets réellement écrit est renvoyé ; ceci sera normalement
   identique au nombre renvoyé. Dans le cas d'une erreur, le code de retour est
   négatif.
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGLOLSEEK">
 <refmeta>
  <refentrytitle>pg_lo_lseek</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_lo_lseek</refname>
  <refpurpose>recherche une position d'un objet large</refpurpose>
  <indexterm ID="IX-PGTCL-PGLOLSEEK-2"><primary>pg_lo_lseek</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_lo_lseek <parameter>conn</parameter> <parameter>descripteur</parameter>
<parameter>décalage</parameter> <parameter>position</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_lo_lseek</function> déplace la position de lecture/écriture
   de <parameter>décalage</parameter> octets depuis la position spécifiée par
   <parameter>position</parameter>.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de connexion d'une base de données où l'objet large existe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>descripteur</parameter></term>
    <listitem>
     <para>
      Un descripteur de l'objet large récupéré avec
      <function>pg_lo_open</function>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>décalage</parameter></term>
    <listitem>
     <para>
      La nouvelle position en octets.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>position</parameter></term>
    <listitem>
     <para>
      Spécifie à partir d'où calculer la nouvelle position :
      <literal>SEEK_CUR</> (à partir de la position actuelle),
      <literal>SEEK_END</> (à partir de la fin) ou <literal>SEEK_SET</> (à
      partir du début).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Aucun
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGLOTELL">
 <refmeta>
  <refentrytitle>pg_lo_tell</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_lo_tell</refname>
  <refpurpose>Renvoie la position actuelle à l'intérieur d'un objet
    large</refpurpose>
  <indexterm ID="IX-PGTCL-PGLOTELL-2"><primary>pg_lo_tell</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_lo_tell <parameter>conn</parameter> <parameter>descripteur</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_lo_tell</function> renvoie la position actuelle de
   lecture/écriture en octets depuis le début de l'objet large.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>

    <listitem>
     <para>
      La poignée de connexion d'une base de données où l'objet large existe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>descripteur</parameter></term>
    <listitem>
     <para>
      Un descripteur de l'objet large récupéré avec
      <function>pg_lo_open</function>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Un décalage, commençant à zéro, en octets et pouvant être utilisé avec
   <function>pg_lo_lseek</function>.
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGLOUNLINK">
 <refmeta>
  <refentrytitle>pg_lo_unlink</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_lo_unlink</refname>
  <refpurpose>supprime un objet large</refpurpose>
  <indexterm ID="IX-PGTCL-PGLOUNLINK-2"><primary>pg_lo_unlink</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_lo_unlink <parameter>conn</parameter> <parameter>loid</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_lo_unlink</function> supprime l'objet large spécifié.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de connexion d'une base de données où l'objet large existe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>loid</parameter></term>
    <listitem>
     <para>
      OID de l'objet large.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   Aucun
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGLOIMPORT">
 <refmeta>
  <refentrytitle>pg_lo_import</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_lo_import</refname>
  <refpurpose>importe un objet large à partir d'un fichier</refpurpose>
  <indexterm
ID="IX-PGTCL-PGLOIMPORT-2"><primary>pg_lo_import</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_lo_import <parameter>conn</parameter> <parameter>nom_fichier</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_lo_import</function> lit le fichier spécifié et place son
   contenu dans un nouvel objet large.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de connexion d'une base de données où l'objet large existe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>nom_fichier</parameter></term>
    <listitem>
     <para>
      Spécifie le fichier à partir duquel importer les données.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>

  <para>
   OID de l'objet large créé.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   <function>pg_lo_import</function> doit être appelé à partir d'un bloc de
   transaction <command>BEGIN</>/<command>COMMIT</>.
  </para>
 </refsect1>
</refentry>


<refentry ID="PGTCL-PGLOEXPORT">
 <refmeta>
  <refentrytitle>pg_lo_export</refentrytitle>
 </refmeta>

 <refnamediv>
  <refname>pg_lo_export</refname>
  <refpurpose>exporte un objet large dans un fichier</refpurpose>
  <indexterm
ID="IX-PGTCL-PGLOEXPORT-2"><primary>pg_lo_export</primary></indexterm>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
pg_lo_export <parameter>conn</parameter> <parameter>loid</parameter>
<parameter>nom_fichier</parameter>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <function>pg_lo_export</function> écrit l'objet large spécifié dans 
   un fichier.
  </para>
 </refsect1>

 <refsect1>
  <title>Arguments</title>

  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <para>
      La poignée de connexion d'une base de données où l'objet large existe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>loid</parameter></term>
    <listitem>
     <para>
      OID d'un objet large.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><parameter>nom_fichier</parameter></term>
    <listitem>
     <para>
      Spécifie le fichier dans lequel exporter les données.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Code de retour</title>
  <para>
   Aucun
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   <function>pg_lo_export</function> doit être appelé dans un bloc de
   transaction <command>BEGIN</>/<command>COMMIT</>.
  </para>
 </refsect1>
</refentry>

</sect1>


<sect1 id="pgtcl-examplesect">
 <title>Programme exemple</title>

 <para>
  <xref linkend="pgtcl-example"> affiche un petit exemple de l'utilisation de
  commandes <application>pgtcl</application>.
 </para>

 <example id="pgtcl-example">
  <title>Programme exemple avec <application>pgtcl</application></title>

<programlisting>
# getDBs :
#   récupère les noms de toutes les bases de données d'un hôte et d'un port
#   donnés, les valeurs par défaut étant localhost et 5432
#   les renvoie dans l'ordre alphabétique
proc getDBs { {host "localhost"} {port "5432"} } {
    # datnames est la liste résultante
    set conn [pg_connect template1 -host $host -port $port]
    set res [pg_exec $conn "SELECT datname FROM pg_database ORDER BY datname;"]
    set ntups [pg_result $res -numTuples]
    for {set i 0} {$i < $ntups} {incr i} {
	lappend datnames [pg_result $res -getTuple $i]
    }
    pg_result $res -clear
    pg_disconnect $conn
    return $datnames
}
</programlisting>
  </example>
 </sect1>

</chapter>
