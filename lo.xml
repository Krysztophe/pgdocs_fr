
<sect1 id="lo">
 <title>lo</title>

 <indexterm zone="lo">
  <primary>lo</primary>
 </indexterm>

 <para>
  Extension PostgreSQL pour la gestion des <quote>Large Objects</quote>.
 </para>

 <sect2>
  <title>Aperçu</title>
  <para>
   Un des problèmes avec le pilote JDBC (mais cela affecte aussi le pilote
   ODBC) est que la spécification suppose que les références aux BLOB (Binary
   Large OBject) sont stockées dans une table et que, si une entrée est
   modifiée, le BLOB associé est supprimé de cette base.
  </para>
  <para>
   Au niveau de PostgreSQL, ceci n'arrive pas. Les <quote>Large Objects</quote>
   sont traités comme des objets propres&nbsp;; une entrée de table peut
   référencer un <quote>Large Object</quote> par son OID, mais plusieurs
   tables peuvent référencer le même OID. Donc, le système ne peut pas
   supprimer un <quote>Large Object</quote> simplement parce que vous
   avez modifié ou supprimé une entrée contenant son OID.
  </para>
  <para>
   Ceci n'est pas un problème pour les nouvelles applications spécifiques
   à PostgreSQL mais celles qui existent déjà, qui utilisent JDBC ou ODBC,
   ne suppriment pas les objets, ceci aboutissant à des <quote>Large
   Objects</quote> orphelins - des objets qui ne sont référencés par
   personne et occupant donc un espace disque précieux sans raison.
  </para>
 </sect2>

 <sect2>
  <title>La correction</title>
  <para>
   J'ai corrigé ceci en créant un nouveau type de données,
   <literal>lo</literal>, quelques fonctions de support et un trigger qui
   gère le problème des <quote>Large Objects</quote> orphelins. Le trigger
   exécute essentiellement un <command>lo_unlink</command> à chaque fois
   que vous voulez supprimer ou modifier une valeur référencer un
   <quote>Large Object</quote>. Quand vous utilisez ce trigger, vous supposez
   qu'il n'existe qu'une référence à ce <quote>Large Object</quote> dans
   toute la base de données&nbsp;!
  </para>
  <para>
   Le type <literal>lo</literal> a été créé car nous avons besoin de
   différencier les OID normaux des OID de <quote>Large Object</quote>.
   Actuellement, le pilote JDBC gère ce dilemne facilement mais, après
   en avoir discuté avec Byron, le pilote ODBC a besoin d'un type unique.
   Ils avaient créé un type <literal>lo</literal> mais sans solution pour
   les orphelins.
  </para>
  <para>
   Vous n'avez pas à utiliser le type <literal>lo</literal> pour utiliser
   le trigger mais c'est plus agréable de l'utiliser car ça vous permet
   de bien visualiser les colonnes de votre base qui contiennent des
   <quote>Large Objects</quote> et que vous gérez avec le trigger.
  </para>
 </sect2>

 <sect2>
  <title>Comment l'utiliser</title>
  <para>
   Voici la façon la plus simple&nbsp;:
  </para>
  <programlisting>
   CREATE TABLE image (title TEXT, raster lo);
   CREATE TRIGGER t_raster BEFORE UPDATE OR DELETE ON image
     FOR EACH ROW EXECUTE PROCEDURE lo_manage(raster);
  </programlisting>
  <para>
   Crée un trigger pour chaque colonne contenant un type <literal>lo</literal>
   et donne le nom de la colonne en argument de la procédure trigger. Vous
   pouvez avoir plus d'un trigger sur une table si cette dernière contient
   plusieurs colonnes de type <literal>lo</literal> mais n'oubliez pas de
   donner un nom différent à chaque trigger.
  </para>
 </sect2>

 <sect2>
  <title>Problèmes</title>

  <itemizedlist>
   <listitem>
    <para>
     Supprimer une table laissera toujours un grand nombre d'orphelins car
     il n'existe pas de trigger pour cette opération.
    </para>
    <para>
     Éviter ceci en exécutant avant le <literal>DROP TABLE</literal> un
     <literal>DELETE FROM</literal>.
    </para>
    <para>
     Si vous avez déjà, ou suspecté avoir, des <quote>Large Objects</quote>
     orphelins, jetez un ½il au module contrib vacuumlo pour vous aider à
     faire le nettoyage. Exécuter vacuumlo de temps en temps est une bonne
     idée.
    </para>
   </listitem>
   <listitem>
    <para>
     Certaines interfaces pourraient créer leur propres tables, sans associer
     le(s) trigger(s) associé(s). De plus, le sutilisateurs pourraient ne
     plus se rappeler (ou savoir) d'avoir à créer les triggers.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Comme le pilote ODBC a besoin d'un type <literal>lo</literal> permanent
   (&amp; JDBC pourrait être optimisé pour l'utiliser si son OID est fixe)
   et comme les problèmes ci-dessus peuvent seulement être corrigés par
   des modifications internes, je pense qu'il devrait être un type interne.
  </para>
 </sect2>

 <sect2>
  <title>Auteur</title>
  <para>
   Peter Mount <email>peter@retep.org.uk</email> June 13 1998
  </para>
 </sect2>
</sect1>

