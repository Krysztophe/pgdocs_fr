
<sect1 id="ltree">
 <title>ltree</title>
 
 <indexterm zone="ltree">
  <primary>ltree</primary>
 </indexterm>

 <para>
  <literal>ltree</literal> est un module PostgreSQL qui contient l'implémentation 
  de types de données, de méthode d'accès pour les index et de requêtes pour
  organiser les données en tant que structures de type arbre.
 </para>

 <sect2>
  <title>Définitions</title>
  <para>
   Un <emphasis>label</emphasis> d'un n½ud est une séquence de un ou plusieurs
   mots séparés par un espace blanc '_' et contenant des lettres ou des
   chiffres (par exemple [a-zA-Z0-9] pour la locale C). La longueur d'un label
   est limité par 256 octets.
  </para>
  <para>
   Exémple&nbsp;: 'Countries', 'Personal_Services'
  </para>
  <para>
   Le <emphasis>chemin de label</emphasis> d'un n½ud est une séquence de un
   ou plusieurs labels séparés par des points l1.l2...ln, ce qui
   représente le chemin de la racine jusqu'au n½ud. La longueur d'un chemin
   est limité à 65&nbsp;Ko, mais une longueur inférieure ou égale à 2&nbsp;Ko
   est préférable. Nous considérons qu'il ne s'agit pas d'une limitation
   stricte (taille maximum d'un chemin de label pour un catalogue DMOZ -
   <ulink url="http://www.dmoz.org"></ulink> fait environ 240 octets&nbsp;!)
  </para>
  <para>
   Exemple&nbsp;: <literal>'Top.Countries.Europe.Russia'</literal>
  </para>
  <para>
   Nous ajoutons quelques types de données&nbsp;:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     <literal>ltree</literal> - est un type pour les chemins de label.
    </para>
   </listitem> 
   <listitem>
    <para>
     <literal>ltree[]</literal> - est un type pour les tableaux de ltree.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>lquery</literal>
     - est une expression de chemin qui contient des expressions rationnelles
     dans le chemin de label et qui est utilisé pour la correspondance de
     ltree. Le caractère joker * est utilisé pour spécifier tout nombre de
     labels (niveaux) et peut être utilisé en début ou en fin de lquery,
     par exemple '*.Europe.*'.
    </para>
    <para>
     Les caractères suivants sont aussi considérés comme des caractères
     joker (comme en Perl)&nbsp;:
    </para>
    <itemizedlist>
     <listitem>
      <para>{n}    Correspond exactement à n niveaux</para>
     </listitem>
     <listitem>
      <para>{n,}   Correspond à au moins n niveaux</para>
     </listitem>
     <listitem>
      <para>{n,m}  Correspond à au moins à n niveaux mais à pas plus de m</para>
     </listitem>
     <listitem>
      <para>{,m}   Correspond à au plus m niveaux (équivalent à {0,m})</para>
     </listitem>
    </itemizedlist>
    <para>
     Il est possible d'utiliser plusieurs modificateurs à la fin d'un
     label&nbsp;:
    </para>
    <itemizedlist>
     <listitem>
      <para>@     Correspondance sans vérification de casse</para>
     </listitem>
     <listitem>
      <para>*     Correspondance d'un préfixe pour un label</para>
     </listitem>
     <listitem>
      <para>%     Ne prend pas en compte les séparateurs de mots '_' dans la
                  correspondance de label, autrement dit 'Russian%' établirait
		  une correspondance avec 'Russian_nations', mais pas
		  avec 'Russian'
      </para>
     </listitem>
    </itemizedlist>
   
    <para>
     <literal>lquery</literal> peut contenir des opérateurs NON logiques '!'
     au début d'un label ainsi que des OU logiques pour spécifier des
     alternatives possibles pour la correspondance de labels.
    </para>
    <para> 
     Exemple de <literal>lquery</literal>&nbsp;:
    </para>
    <programlisting> 
     Top.*{0,2}.sport*@.!football|tennis.Russ*|Spain
     a)  b)     c)      d)               e)
    </programlisting>
    <para>
    Ce chemin de labels devra
    </para>
    <orderedlist numeration='loweralpha'>
     <listitem>
      <para>
       commencer avec un n½ud dont le label est 'Top'
      </para>
     </listitem>
     <listitem>
      <para>
       et suivre avec zéro ou deux labels jusqu'à
      </para>
     </listitem>
     <listitem>
      <para>
       un n½ud dont le label commence avec le préfixe 'sport' quelque soit la
       casse
      </para>
     </listitem>
     <listitem>
      <para>
       suivi par un n½ud dont le label ne correspond ni à 'football' ni à
       'tennis'
      </para>
     </listitem>
     <listitem>
      <para>
       et se termine enfin avec un label commençant par 'Russ' ou correspond
       strictement à 'Spain'.
      </para>
     </listitem>
    </orderedlist>

   </listitem>

   <listitem>
    <para><literal>ltxtquery</literal>
    - est un type de données pour la recherche de labels (comme le type
    'query' pour la recherche plein texte, voir le module contrib tsearch). Il
    est possible d'utiliser les modificateurs @, %, * à la fin d'un mot. La
    signification des modificateurs est identique que pour lquery.
    </para>
    <para>
     Exemple&nbsp;: <literal><![CDATA['Europe & Russia*@ & !Transportation']]></literal>
    </para>
    <para>
     Les chemins de recherche contiennent les mots 'Europe' et 'Russia*'
     (insensible à la casse) et pas 'Transportation'. Notez que l'ordre des mots
     dans le chemin du label n'est pas important&nbsp;!
    </para>
   </listitem>

  </itemizedlist>
 </sect2>

 <sect2>
  <title>Opérations</title>
  <para>
   Les opérations suivantes sont définies pour le type ltree&nbsp;:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     <literal><![CDATA[<,>,<=,>=,=, <>]]></literal>
     - Ont leur signification habituelle. La comparaison est faire dans l'ordre
     direct de traverser de l'arbre, les enfants d'un n½ud sont triés
     lexicographiquement.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal><![CDATA[ltree @> ltree]]></literal>
      - renvoie TRUE si l'argument à gauche est un ancêtre de l'argument à
      droite (ou identique).
    </para>
   </listitem>
   <listitem>
    <para>
     <literal><![CDATA[ltree <@ ltree]]></literal>
     - renvoie TRUE si l'argument à gauche est un descendant de l'argument à
      droite (ou identique).
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ltree ~ lquery, lquery ~ ltree</literal>
     - renvoie TRUE si le n½ud représenté par ltree satisfait lquery.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ltree ? lquery[], lquery ? ltree[]</literal>
     - renvoie TRUE si le n½ud représenté par ltree satisfait au moins une
       lquery du tableau.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ltree @ ltxtquery, ltxtquery @ ltree</literal>
     - renvoie TRUE si le n½ud représenté par ltree satisfait ltxtquery.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ltree || ltree, ltree || text, text || ltree</literal>
     - renvoie un ltree concaténé.
    </para>
   </listitem>
  </itemizedlist>
  
  <para>
   Opérations sur des tableaux de ltree (<literal>ltree[]</literal>):
  </para>
  <itemizedlist>
   <listitem>
    <para>
     <literal><![CDATA[ltree[] @> ltree, ltree <@ ltree[]]]></literal>
     - renvoie TRUE si un tableau ltree[] contient un ancêtre de ltree.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal><![CDATA[ltree @> ltree[], ltree[] <@ ltree]]></literal>
     - renvoie TRUE si un tableau ltree[] contient un descendant de ltree.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ltree[] ~ lquery, lquery ~ ltree[]</literal>
     - renvoie TRUE si un tableau ltree[] contient des chemins de label qui
       correspondent au lquery.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ltree[] ? lquery[], lquery[] ? ltree[]</literal>
     - renvoie TRUE si un tableau ltree[] contient des chemins de label qui
       correspondent à au moins un lquery du tableau.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ltree[] @ ltxtquery, ltxtquery @ ltree[]</literal>
     - renvoie TRUE si un tableau ltree[] contient des chemins de label qui
       correspondent au ltxtquery (recherche plein texte).
    </para>
   </listitem>
   <listitem>
    <para>
     <literal><![CDATA[ltree[] ?@> ltree, ltree ?<@ ltree[], ltree[] ?~ lquery, ltree[] ?@ ltxtquery]]></literal>

     - renvoie le premier élément du tableau ltree[] qui correspond à la
       condition et, vice-versa, à NULL
    </para>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
  <title>Remarque</title>

  <para>
   Les opérations <literal>&lt;@</literal>, <literal>@&gt;</literal>,
   <literal>@</literal> et <literal>~</literal> ont des versions analogues
   - <literal>^&lt;@, ^@&gt;, ^@, ^~,</literal> - qui n'utilisent pas les
   index&nbsp;!
  </para>
 </sect2>

 <sect2>
  <title>Index</title>
  <para>
   Plusieurs index peuvent être créés pour accélérer l'exécution des
   opérations&nbsp;:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Index B-tree sur un ltree&nbsp;: <literal>&lt;, &lt;=, =, &gt;=,
     &gt;</literal>
    </para>
   </listitem>
   <listitem>
    <para>
     Index GiST sur un ltree: <literal>&lt;, &lt;=, =, &gt;=, &gt;, @&gt;,
     &lt;@, @, ~, ?</literal>
    </para>
    <para>
     Exemple&nbsp;:
    </para>
    <programlisting>
     CREATE INDEX path_gist_idx ON test USING GIST (path);
    </programlisting>
   </listitem>
   <listitem>
    <para>Index GiST sur un ltree[]&nbsp;:
     <literal><![CDATA[ltree[]<@ ltree, ltree @> ltree[], @, ~, ?.]]></literal>
    </para>
    <para>
     Exemple&nbsp;:
    </para>
    <programlisting>
    CREATE INDEX path_gist_idx ON test USING GIST (array_path);
    </programlisting>
    <para>
     Notez que cet index est à perte.
    </para>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
  <title>Fonctions</title>
  
  <itemizedlist>
   <listitem>
    <para>
     <literal>ltree subltree(ltree, start, end)</literal>
      renvoie le sous-chemin d'un ltree depuis start (inclus) jusqu'à end.
    </para>
    <programlisting>
        # select subltree('Top.Child1.Child2',1,2);
        subltree
        --------
        Child1
    </programlisting>
   </listitem>
   <listitem>
    <para>
     <literal>ltree subpath(ltree, OFFSET,LEN)</literal> et
     <literal>ltree subpath(ltree, OFFSET)</literal>
      renvoie un sous-chemin de ltree à partir de OFFSET (inclus) et d'une
      longueur LEN.
      Si OFFSET est négatif, renvoie un sous-chemin qui commence à la fin.
      Si LENGTH est omis, renvoie tout jusqu'à la fin du chemin. Si LENGTH est
      négatif, laisse ce nombre de label à partir de la fin du chemin.
    </para>
    <programlisting>
        # select subpath('Top.Child1.Child2',1,2);
        subpath
        -------
        Child1.Child2
    
        # select subpath('Top.Child1.Child2',-2,1);
        subpath 
        ---------
        Child1
    </programlisting>
   </listitem>
   <listitem>
    <para>
     <literal>int4 nlevel(ltree)</literal> - renvoie le niveau du n½ud.
    </para>
    <programlisting>
        # select nlevel('Top.Child1.Child2');
        nlevel 
        --------
          3
    </programlisting>
    <para>
     Notez que les arguments start, end, OFFSET, LEN ont connaissance du
     niveau du n½ud&nbsp;!
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>int4 index(ltree,ltree)</literal> et
     <literal>int4 index(ltree,ltree,OFFSET)</literal>
     renvoie le nombre de niveau à partir de la première occurence du second
     argument dans le premier argument en commençant à OFFSET. Si OFFSET est
     négatif, alors la recherche commence à partir de OFFSET niveaux (en
     commençant le décompte à partir de la fin du chemin).
    </para>
    <programlisting>
     SELECT index('0.1.2.3.5.4.5.6.8.5.6.8','5.6',3);
      index
     -------
          6
     SELECT index('0.1.2.3.5.4.5.6.8.5.6.8','5.6',-4);
      index  
     -------
          9
    </programlisting>
   </listitem>
   <listitem>
    <para>
     <literal>ltree text2ltree(text)</literal> et
     <literal>text ltree2text(text)</literal>, fonctions de conversion pour
     ltree et text.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ltree lca(ltree,ltree,...) (jusqu'à huit arguments)</literal> et
     <literal>ltree lca(ltree[])</literal> renvoie le premier ancêtre commun
     (<acronym>LCA</acronym>, acronyme de <foreignphrase>Lowest Common
     Ancestor</foreignphrase>).
    </para>
    <programlisting>
        # select lca('1.2.2.3','1.2.3.4.5.6');
        lca 
        -----
         1.2
        # select lca('{la.2.3,1.2.3.4.5.6}') is null;
        ?column? 
        ----------
           f
    </programlisting>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
  <title>Installation</title>
  <programlisting>
  cd contrib/ltree
  make
  make install
  make installcheck
  </programlisting>
 </sect2>

 <sect2>
  <title>Exemple</title>
  <programlisting><![CDATA[
 createdb ltreetest
 psql ltreetest < /usr/local/pgsql/share/contrib/ltree.sql
 psql ltreetest < ltreetest.sql
  ]]></programlisting>

  <para>
   Maintenant, nous avons une base de données ltreetest comprenant des données
   décrivant la hiérarchie présentée ci-dessous&nbsp;:
  </para>

  <programlisting>

 
                            TOP
                         /   |  \     
                 Science Hobbies Collections  
                     /       |              \
            Astronomy   Amateurs_Astronomy Pictures
               /  \                            |
    Astrophysics  Cosmology                Astronomy
                                            /  |    \
                                     Galaxies Stars Astronauts
  </programlisting>
  <para>
   Héritage&nbsp;:
  </para>

  <programlisting><![CDATA[
ltreetest=# select path from test where path <@ 'Top.Science';
                path                
------------------------------------
 Top.Science
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(4 rows)
  ]]></programlisting>
  <para>
   Correspondance&nbsp;:
  </para>
  <programlisting>
ltreetest=# select path from test where path ~ '*.Astronomy.*';
                     path                      
-----------------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Collections.Pictures.Astronomy
 Top.Collections.Pictures.Astronomy.Stars
 Top.Collections.Pictures.Astronomy.Galaxies
 Top.Collections.Pictures.Astronomy.Astronauts
(7 rows)
ltreetest=# select path from test where path ~ '*.!pictures@.*.Astronomy.*';
                path                
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
  </programlisting>
  <para>
   Recherche plein texte&nbsp;:
  </para>
  <programlisting><![CDATA[
ltreetest=# select path from test where path @ 'Astro*% & !pictures@';
                path                
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Hobbies.Amateurs_Astronomy
(4 rows)

ltreetest=# select path from test where path @ 'Astro* & !pictures@';
                path                
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
  ]]></programlisting>
  <para>
   En utilisant les fonctions&nbsp;:
  </para>
  <programlisting><![CDATA[
ltreetest=# select subpath(path,0,2)||'Space'||subpath(path,2) from test where path <@ 'Top.Science.Astronomy';
                 ?column?                 
------------------------------------------
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)]]></programlisting>
 <para>
  Nous pouvons créer la fonction SQL&nbsp;:
</para>
  <programlisting><![CDATA[
CREATE FUNCTION ins_label(ltree, int4, text) RETURNS ltree 
AS 'select subpath($1,0,$2) || $3 || subpath($1,$2);'
LANGUAGE SQL IMMUTABLE;
  ]]></programlisting>
  <para>
   et le SELECT précédent peut être ré-écrit avec&nbsp;:
  </para>

  <programlisting><![CDATA[
ltreetest=# select ins_label(path,2,'Space') from test where path <@ 'Top.Science.Astronomy';
                ins_label                 
------------------------------------------
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
  ]]></programlisting>

  <para>
   Ou avec d'autres arguments&nbsp;:
  </para>

  <programlisting><![CDATA[
CREATE FUNCTION ins_label(ltree, ltree, text) RETURNS ltree
AS 'select subpath($1,0,nlevel($2)) || $3 || subpath($1,nlevel($2));'
LANGUAGE SQL IMMUTABLE;

ltreetest=# select ins_label(path,'Top.Science'::ltree,'Space') from test where path <@ 'Top.Science.Astronomy';
                ins_label                 
------------------------------------------
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
  ]]></programlisting>
 </sect2>

 <sect2>
  <title>Données supplémentaires</title>
  <para>
   Pour mieux appréhender le module ltree, vous pouvez télécharger le fichier
   dmozltree-eng.sql.gz (une archive tar.gz d'environ 3&nbsp;Mo et contenant
   300274 n½uds), disponible à partir de <ulink
   url="http://www.sai.msu.su/~megera/postgres/gist/ltree/">dmozltree-eng.sql.gz</ulink>,
   qui est un catalogue DMOZ, préparé pour une utilisation avec ltree.
   Configurez votre base de données test (dmoz), chargez le module ltree et
   lancez la commande&nbsp;:
  </para>
  <programlisting>
   zcat dmozltree-eng.sql.gz| psql dmoz
  </programlisting>
  <para>
   Les données seront chargées dans la base de données dmoz et tous les idnex
   seront créés.
  </para>
 </sect2>

 <sect2>
  <title>Tests de performance</title>
  <para>
   Tous les tests sont réalisés sur mon IBM ThinkPad T21 (256&nbsp;Mo de RAM,
   750&nbsp;Mhz) en utilisant les données DMOZ contenant 300274 n½uds (voir
   ci-dessus pour un lien de téléchargement). Nous avons utilisé des requêtes
   basiques typiques pour traverser notre catalogue.
  </para>

  <sect3>
   <title>Requêtes</title>
   <itemizedlist>
    <listitem>
     <para>
      Q0&nbsp;: Compte toutes les lignes (en quelque sorte un test de base pour
      la comparaison)
     </para>
     <programlisting>
     select count(*) from dmoz;
      count  
     --------
      300274
     (1 row)
     </programlisting>
    </listitem>
    <listitem>
     <para>
      Q1&nbsp;: Récupère les enfants directs (sans héritage)
     </para>
     <programlisting>
     select path from dmoz where path ~ 'Top.Adult.Arts.Animation.*{1}';
                    path                
     -----------------------------------
      Top.Adult.Arts.Animation.Cartoons
      Top.Adult.Arts.Animation.Anime
     (2 rows)
     </programlisting>
    </listitem>
    <listitem>
     <para>
      Q2&nbsp;: Identique à Q1 mais avec un décompte des descendants
     </para>
     <programlisting><![CDATA[
     select path as parentpath , (select count(*)-1 from dmoz where path <@
     p.path) as count from dmoz p where path ~ 'Top.Adult.Arts.Animation.*{1}';
                 parentpath             | count 
     -----------------------------------+-------
      Top.Adult.Arts.Animation.Cartoons |     2
      Top.Adult.Arts.Animation.Anime    |    61
     (2 rows)
     ]]></programlisting>
    </listitem>
    <listitem>
     <para>
      Q3&nbsp;: Récupère tous les parents
     </para>
     <programlisting><![CDATA[
     select path from dmoz where path @> 'Top.Adult.Arts.Animation' order by
     path asc;
                path           
     --------------------------
      Top
      Top.Adult
      Top.Adult.Arts
      Top.Adult.Arts.Animation
     (4 rows)
     ]]></programlisting>
    </listitem>
    <listitem>
     <para>
      Q4&nbsp;: Récupère tous les parents avec un décompte des enfants
     </para>
     <programlisting><![CDATA[
     select path, (select count(*)-1 from dmoz where path <@ p.path) as count
     from dmoz p where path @> 'Top.Adult.Arts.Animation' order by path asc;
                path           | count  
     --------------------------+--------
      Top                      | 300273
      Top.Adult                |   4913
      Top.Adult.Arts           |    339
      Top.Adult.Arts.Animation |     65
     (4 rows)
     ]]></programlisting>
    </listitem>
    <listitem>
     <para>
      Q5&nbsp;: Récupère tous les enfants avec des niveaux
     </para>
     <programlisting>
     select path, nlevel(path) - nlevel('Top.Adult.Arts.Animation') as level
     from dmoz where path ~ 'Top.Adult.Arts.Animation.*{1,2}' order by path asc;
                           path                      | level 
     ------------------------------------------------+-------
      Top.Adult.Arts.Animation.Anime                 |     1
      Top.Adult.Arts.Animation.Anime.Fan_Works       |     2
      Top.Adult.Arts.Animation.Anime.Games           |     2
      Top.Adult.Arts.Animation.Anime.Genres          |     2
      Top.Adult.Arts.Animation.Anime.Image_Galleries |     2
      Top.Adult.Arts.Animation.Anime.Multimedia      |     2
      Top.Adult.Arts.Animation.Anime.Resources       |     2
      Top.Adult.Arts.Animation.Anime.Titles          |     2
      Top.Adult.Arts.Animation.Cartoons              |     1
      Top.Adult.Arts.Animation.Cartoons.AVS          |     2
      Top.Adult.Arts.Animation.Cartoons.Members      |     2
     (11 rows)
     </programlisting>
    </listitem>
   </itemizedlist>
  </sect3>

  <sect3>
   <title>Chronométrage</title>
   <programlisting>
+-------------------------------------------------+
|Requ.|Lig.|Temps (ms) index|Temps (ms) sans index|
|-----+----+----------------+----------------------|
|   Q0|   1|              NA|               1453.44|
|-----+----+----------------+----------------------|
|   Q1|   2|            0.49|               1001.54|
|-----+----+----------------+----------------------|
|   Q2|   2|            1.48|               3009.39|
|-----+----+----------------+----------------------|
|   Q3|   4|            0.55|                906.98|
|-----+----+----------------+----------------------|
|   Q4|   4|        24385.07|               4951.91|
|-----+----+----------------+----------------------|
|   Q5|  11|            0.85|               1003.23|
+--------------------------------------------------+
   </programlisting>
   <para>
    Les chronométrage sans les index ont été obtenus en utilisant les fonctions
    qui n'utilisent pas les index (voir ci-dessus).
   </para>
  </sect3>

  <sect3>
   <title>Remarques</title>
   <para>
    Nous n'avons pas exécuter des tests à grande échelle, nous n'avons pas non
    plus présenter (encore) des données pour les opérations sur les tableaux
    de ltree (ltree[]) et sur la recherche plein texte. Nous apprécions vos
    idées à ce sujet. Jusqu'à maintenant, voici quelques résultats (plutôt
    évidents)&nbsp;:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Les index aident lors de l'exécution des requêtes
     </para>
    </listitem>
    <listitem>
     <para>
      Q4 a de mauvaises performances car il est nécessaire de lire pratiquement
      toutes les données du disque.
     </para>
    </listitem>
   </itemizedlist>
  </sect3>
 </sect2>
 <sect2>
  <title>Contexte</title>
  <para>
   L'approche que nous utilisons pour ltree ressemble à celle que nous avons
   utilisé pour nos autres modules contrib basés sur GiST (intarray, tsearch,
   tree, btree_gist, rtree_gist). Le contexte théorique est disponible dans
   les documents référencés dans notre
   <ulink url="http://www.sai.msu.su/~megera/postgres/gist">page de
   développement sur GiST</ulink>.
  </para>
  <para>
   Une structure de données hiérarchique (tree) est un ensemble de n½uds.
   Chaque n½ud a une signature (LPS) de taille fixe, qui est un chemin de
   labels haché de ce n½ud. Pour parcourir un arbre, nous pourrions
   certainement ignorés des branches si
  </para>
  <programlisting>
   LQS (bitwise AND) LPS != LQS
  </programlisting>
  <para>
   où LQS est une signature de lquery ou ltxtquery, obtenu de la même façon
   que LPS.
  </para>
  <programlisting>
   ltree[]&nbsp;:
  </programlisting>
  <para>
   Pour les tableaux de ltree, LPS est une signature réalisée par des OU
   logiques bit à bit de *tous* les enfants atteignables à partir de ce
   n½ud. Les signatures sont stockées dans un RD-tree, implementé en utilisant
   GiST, qui fournit des accès indexés.
  </para>
  <programlisting>
   ltree&nbsp;:
  </programlisting>
  <para>
   Pour ltree, nous stockons LPS dans un B-tree, implémenté en utilisant GiST.
   Chaque entrée de n½ud est représentée par (limite_gauche, signature,
   limite_droite), pour accélérer les opérations <literal><![CDATA[<, <=, =,
   >=, >]]></literal> en utilisant limite_gauche, limite_droite et les branches
   ignorées d'un arbre utilisant la signature.
  </para>
 </sect2>
 <sect2>
  <title>Auteurs</title>
  <para>
   Tout ce travail a été réalisé par Teodor Sigaev
   (<email>teodor@stack.net</email>) et Oleg Bartunov
   (<email>oleg@sai.msu.su</email>). Voir la
   <ulink url="http://www.sai.msu.su/~megera/postgres/gist">page sur GiST</ulink>
   pour plus d'informations. Les auteurs veulent remercier Eugeny Rodichev pour
   son aide. Les commentaires et rapports de bogue sont les bienvenus.
  </para>
 </sect2>
</sect1>

