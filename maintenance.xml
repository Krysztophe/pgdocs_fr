<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="maintenance">
 <title>Planifier les tâches de maintenance</title>

 <indexterm zone="maintenance">
  <primary>maintenance</primary>
 </indexterm>

 <indexterm zone="maintenance">
  <primary>routine maintenance</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname>, comme tout SGBD, requiert que certains
   tâches soient réalisées de façon régulière pour atteindre les performances
   optimales. Ces tâches, discutées maintenant, sont <emphasis>requises</emphasis>
   mais elles sont répétitives par nature et peuvent être facilement automatisées
   en utilisant des outils standards comme les scripts
   <application>cron</application> ou le <application>Task Scheduler</application>
   de Windows. La responsabilité de la mise en place de ces
   scripts et du contrôle de leur bon fonctionnement relève de l'administrateur
   de la base.
  </para>

  <para>
   Une opération de maintenance évidente est la sauvegarde régulière des
   données. Sans une sauvegarde récente il est impossible de restaurer après
   un dommage grave (perte d'un disque, incendie, table supprimée par erreur,
   etc.). Les mécanismes de sauvegarde et restauration disponibles dans
   <productname>PostgreSQL</productname> sont détaillés dans le <xref
   linkend="backup"/>.
  </para>

  <para>
   L'autre tâche primordiale est de réaliser périodiquement un <quote>vacuum</quote>,
   c'est à dire <quote>faire le vide</quote> dans la base de données.
   Cette opération est détaillée dans la <xref linkend="routine-vacuuming"/>.
   La mise à jour des statistiques qui seront utilisées par le planificateur de
   requêtes sera discutée dans <xref linkend="vacuum-for-statistics"/>.
  </para>

  <para>
   La gestion du fichier de traces mérite aussi une attention régulière.
   Cela est détaillé dans la <xref linkend="logfile-maintenance"/>.
  </para>

  <para>
   <ulink
   url="http://bucardo.org/check_postgres/"><application>check_postgres.pl</></ulink>
   is available for monitoring database health and reporting unusual
   conditions.  <application>check_postgres.pl</> integrates with
   Nagios and MRTG, but can be run standalone too.
  </para>

  <para>
   <productname>PostgreSQL</productname> demande peu de maintenance par rapport
   à d'autres SGBD. Néanmoins, un suivi vigilant de ces tâches participera
   beaucoup à rendre le système productif et agréable à utiliser.
  </para>

 <sect1 id="routine-vacuuming">
  <title>Nettoyages réguliers</title>

  <indexterm zone="routine-vacuuming">
   <primary>vacuum</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> databases require periodic
   maintenance known as <firstterm>vacuuming</>.  For many installations, it
   is sufficient to let vacuuming be performed by the <firstterm>autovacuum
   daemon</>, which is described in <xref linkend="autovacuum">.  You might
   need to adjust the autovacuuming parameters described there to obtain best
   results for your situation.  Some database administrators will want to
   supplement or replace the daemon's activities with manually-managed
   <command>VACUUM</> commands, which typically are executed according to a
   schedule by <application>cron</application> or <application>Task
   Scheduler</> scripts.  To set up manually-managed vacuuming properly,
   it is essential to understand the issues discussed in the next few
   subsections.  Administrators who rely on autovacuuming may still wish
   to skim this material to help them understand and adjust autovacuuming.
  </para>

  <sect2 id="vacuum-basics">
   <title>Vacuuming Basics</title>

  <para>
   La commande <xref linkend="sql-vacuum" endterm="sql-vacuum-title"/> de
   <productname>PostgreSQL</productname> doit traiter chaque table régulièrement
   pour plusieurs raisons&nbsp;:

    <orderedlist>
     <listitem>
      <simpara>pour récupérer ou ré-utiliser l'espace disque occupé par les lignes supprimées
      ou mises à jour&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour mettre à jour les statistiques utilisées par l'optimiseur de
      <productname>PostgreSQL</productname>&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour prévenir la perte des données les plus anciennes à cause
      d'un <firstterm>cycle de l'identifiant de transaction (XID)</firstterm>.</simpara>
     </listitem>
    </orderedlist>
  </para>

    Each of these reasons dictates performing <command>VACUUM</> operations
    of varying frequency and scope, as explained in the following subsections.
   </para>

   <para>
    There are two variants of <command>VACUUM</>: standard <command>VACUUM</>
    and <command>VACUUM FULL</>.  <command>VACUUM FULL</> can reclaim more
    disk space but runs much more slowly.  Also,
    the standard form of <command>VACUUM</> can run in parallel with production
    database operations.  (Commands such as <command>SELECT</command>,
    <command>INSERT</command>, <command>UPDATE</command>, and
    <command>DELETE</command> will continue to function as normal, though you
    will not be able to modify the definition of a table with commands such as
    <command>ALTER TABLE</command> while it is being vacuumed.)
    <command>VACUUM FULL</> requires exclusive lock on the table it is
    working on, and therefore cannot be done in parallel with other use
    of the table.  Another disadvantage of <command>VACUUM FULL</> is that
    while it reduces table size, it does not reduce index size proportionally;
    in fact it can make indexes <emphasis>larger</>.  Generally, therefore,
    administrators should strive to use standard <command>VACUUM</> and
    avoid <command>VACUUM FULL</>.
   </para>

   <para>
    <command>VACUUM</command> creates a substantial amount of I/O
    traffic, which can cause poor performance for other active sessions.
    There are configuration parameters that can be adjusted to reduce the
    performance impact of background vacuuming &mdash; see
    <xref linkend="runtime-config-resource-vacuum-cost">.
   </para>
  </sect2>

  <sect2 id="vacuum-for-space-recovery">
   <title>Récupérer l'espace disque</title>

   <indexterm zone="vacuum-for-space-recovery">
    <primary>espace disque</primary>
   </indexterm>

   <para>
    Avec <productname>PostgreSQL</productname>, les versions périmées des
    lignes ne sont pas immédiatement supprimées après une commande
    <command>UPDATE</command> ou <command>DELETE</command>.  Cette approche est
    nécessaire pour la consistance des accès
    concurrents (voir le <xref linkend="mvcc"/>)&nbsp;: la version de la ligne ne
    doit pas être supprimée tant qu'elle est susceptible d'être lue par une
    autre transaction. Mais finalement, une ligne qui est plus vieille que
    toutes les transactions en cours n'est plus utile du tout. La place qu'elle
    utilise doit être rendu pour être réutilisée par d'autres lignes afin
    d'éviter un accroissement constant du volume occupé sur le disque. Cela est
    réalisé en exécutant <command>VACUUM</command>.
   </para>

   <para>
    The standard form of <command>VACUUM</command> removes dead row
    versions in tables and indexes and marks the space available for
    future reuse.  However, it will not return the space to the operating
    system, except in the special case where one or more pages at the
    end of a table become entirely free and an exclusive table lock can be
    easily obtained.  In contrast, <command>VACUUM FULL</> actively compacts
    tables by moving row versions to earlier pages.  It is thus able to
    force pages at the end of the table to become entirely free, whereupon
    it will return them to the operating system.  However, if many rows
    must be moved, this can take a long time.  Also, moving a row requires
    transiently making duplicate index entries for it (the entry pointing
    to its new location must be made before the old entry can be removed);
    so moving a lot of rows this way causes severe index bloat.
   </para>

   <para>
    The usual goal of routine vacuuming is to do standard <command>VACUUM</>s
    often enough to avoid needing <command>VACUUM FULL</>.  The
    autovacuum daemon attempts to work this way, and in fact will
    never issue <command>VACUUM FULL</>.  In this approach, the idea
    is not to keep tables at their minimum size, but to maintain steady-state
    usage of disk space: each table occupies space equivalent to its
    minimum size plus however much space gets used up between vacuumings.
    Although <command>VACUUM FULL</> can be used to shrink a table back
    to its minimum size and return the disk space to the operating system,
    there is not much point in this if the table will just grow again in the
    future.  Thus, moderately-frequent standard <command>VACUUM</> runs are a
    better approach than infrequent <command>VACUUM FULL</> runs for
    maintaining heavily-updated tables.
   </para>

   <para>
    Some administrators prefer to schedule vacuuming themselves, for example
    doing all the work at night when load is low.
    The difficulty with doing vacuuming according to a fixed schedule
    is that if a table has an unexpected spike in update activity, it may
    get bloated to the point that <command>VACUUM FULL</> is really necessary
    to reclaim space.  Using the autovacuum daemon alleviates this problem,
    since the daemon schedules vacuuming dynamically in response to update
    activity.  It is unwise to disable the daemon completely unless you
    have an extremely predictable workload.  One possible compromise is
    to set the daemon's parameters so that it will only react to unusually
    heavy update activity, thus keeping things from getting out of hand,
    while scheduled <command>VACUUM</>s are expected to do the bulk of the
    work when the load is typical.
   </para>
   
   <para>
    Pour ceux qui n'utilisent pas autovacuum, une approche typique alternative est de
    planifier un <command>VACUUM</command> sur la base complète une fois
    par jour lorsque l'utilisation n'est pas grande, avec en plus des
    opérations de <command>VACUUM</command> plus fréquentes pour les tables
    très impactées par des mises à jour, de la façon adéquate.
    (Certaines installations avec énormément de mises à jour peuvent exécuter
    des VACUUM toutes les quelques minutes.) Si vous avez plusieurs bases dans
    un cluster, n'oubliez pas d'exécuter un <command>VACUUM</command> sur
    chacune d'elles&nbsp;; le programme <xref
    linkend="app-vacuumdb" endterm="app-vacuumdb-title"/> pourrait être utile.
   </para>

   <tip>
   <para>
    Neither form of <command>VACUUM</> is entirely satisfactory when
    a table contains large numbers of dead row versions as a result of
    massive update or delete activity.  If you have such a table and
    you need to reclaim the excess disk space it occupies, the best
    way is to use <xref linkend="sql-cluster" endterm="sql-cluster-title">
    or one of the table-rewriting variants of
    <xref linkend="sql-altertable" endterm="sql-altertable-title">.
    These commands rewrite an entire new copy of the table and build
    new indexes for it.  Like <command>VACUUM FULL</>, they require
    exclusive lock.  Note that they also temporarily use extra disk
    space, since the old copies of the table and indexes can't be
    released until the new ones are complete.  In the worst case where
    your disk is nearly full, <command>VACUUM FULL</> may be the only
    workable alternative.
   </para>
   </tip>

   <tip>
   <para>
    Si vous avez une table dont le contenu entier est supprimé sur une base périodique,
    considérez de le faire avec <xref linkend="sql-truncate" endterm="sql-truncate-title"> plutôt qu'avec
    <command>DELETE</command> suivi par un <command>VACUUM</command>.
    <command>TRUNCATE</command> supprime le contenu entier de la table
    immédiatement sans nécessiter un <command>VACUUM</command> ou
    <command>VACUUM FULL</command> pour réclamer l'espace disque maintenant
    inutilisé.
    The disadvantage is that strict MVCC semantics are violated.
   </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-statistics">
   <title>Maintenir les statistiques du planificateur</title>

   <indexterm zone="vacuum-for-statistics">
    <primary>statistiques</primary>
    <secondary>du planificateur</secondary>
   </indexterm>

   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>

   <para>
    L'optimiseur de requêtes de <productname>PostgreSQL</productname> s'appuie
    sur des informations statistiques sur le contenu des tables dans l'optique
    de générer des plans d'exécutions efficaces pour les requêtes. Ces
    statistiques sont collectées par la commande <xref linkend="sql-analyze"
    endterm="sql-analyze-title"/>, qui peut
    être invoquée seule ou comme une option de <command>VACUUM</command>. Il est
    important d'avoir des statistiques relativement à jour sans quoi des mauvais
    choix dans les plans d'exécution pourraient pénaliser la performance de la
    base.
   </para>

   <para>
    The autovacuum daemon, if enabled, will automatically issue
    <command>ANALYZE</> commands whenever the content of a table has
    changed sufficiently.  However, administrators might prefer to rely
    on manually-scheduled <command>ANALYZE</> operations, particularly
    if it is known that update activity on a table will not affect the
    statistics of <quote>interesting</> columns.  The daemon schedules
    <command>ANALYZE</> strictly as a function of the number of rows
    inserted or updated; it has no knowledge of whether that will lead
    to meaningful statistical changes.
   </para>

   <para>
    À l'instar du nettoyage pour récupérer l'espace, les statistiques doivent
    être plus souvent collectées pour les tables intensément modifiées que pour
    celles qui le sont moins. Mais même si la table est très modifiée, il se
    peut que ces collectes soient inutiles si la distribution probabiliste des
    données évolue peu. Une règle simple pour décider est de voir comment
    évoluent les valeurs minimum et maximum des données. Par exemple, une
    colonne de type <type>timestamp</type> qui contient la date de mise à jour
    de la ligne aura une valeur maximum en continuelle croissance au fur et à
    mesure des modifications&nbsp;; une telle colonne nécessitera plus de
    collectes statistiques qu'une colonne qui contient par exemple les URL des
    pages accédées sur un site web. La colonne qui contient les URL peut très
    bien être aussi souvent modifiée mais la distribution probabiliste des
    données changera certainement moins rapidement.
   </para>

   <para>
    Il est possible d'exécuter <command>ANALYZE</command> sur des tables spécifiques,
    voire des colonnes spécifiques&nbsp;; il a donc toute flexibilité pour
    mettre à jour certaines statistiques plus souvent que les autres en
    fonction des besoins de l'application. Quoi qu'il en soit, dans la pratique,
    il est généralement mieux de simplement analyser la base entière car il s'agit
    d'une opération rapide. <command>ANALYZE</> utilise un système d'échantillonage des lignes d'une
    table, ce qui lui évite de lire chaque ligne.
   </para>

   <tip>
    <para>
     Même si il n'est pas très productif de règler précisément la fréquence de
     <command>ANALYZE</command> pour chaque colonne, il peut être intéressant d'ajuster
     le niveau de détail des statistiques collectées pour chaque colonne. Les
     colonnes très utilisées dans les clauses <literal>WHERE</literal> et dont la
     distribution n'est pas uniforme requièrent des histogrammes plus précis
     que les autres colonnes. Voir <command>ALTER TABLE SET STATISTICS</command>,
     or change the database-wide default using the <xref
     linkend="guc-default-statistics-target"> configuration parameter.
    </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-wraparound">
   <title>Éviter les cycles des identifiants de transactions</title>

   <indexterm zone="vacuum-for-wraparound">
    <primary>identifiant de transaction</primary>
    <secondary>cycle</secondary>
   </indexterm>

   <para>
    Le mécanisme de contrôle de concurrence multiversion (<acronym>MVCC</acronym>) de
    <productname>PostgreSQL</productname> s'appuie sur la possibilité de
    comparer des identifiants de transactions (<acronym>XID</acronym>)&nbsp;; c'est un
    nombre croissant&nbsp;: la version d'une ligne dont le XID d'insertion est
    supérieur au XID de la transaction en cours est <quote>dans le futur</quote> et
    ne doit pas être visible de la transaction courante. Comme les identifiants
    ont une taille limitée (32 bits à ce jour), un groupe qui est en activité
    depuis longtemps (plus de 4 milliards de transactions) pourrait connaître un
    cycle des identifiants de transaction&nbsp;: le XID reviendra à 0 et
    soudainement les transactions du passé sembleront appartenir au futur - ce
    qui signifie qu'elles deviennent invisibles. En bref, perte de données
    totale. (En réalité, les données sont toujours là mais c'est un piètre
    réconfort puisqu'elles resteront inaccessibles.) Pour éviter ceci, il est
    nécessaire d'exécuter un VACUUM sur chaque table de chaque base au moins
    au moins une fois à chaque milliard de transactions.
   </para>

   <para>
    La raison pour laquelle un VACUUM périodique résout le problème est que
    <productname>PostgreSQL</productname> distingue un ID de transaction spécial,
    <literal>FrozenXID</literal>. Ce XID est toujours considéré comme plus âgé
    que les XID normaux. Les XID normaux sont comparés sur une base
    modulo-2<superscript>31</superscript>. Cela signifie
    que pour chaque XID normal, il y en a deux milliards qui sont plus vieux et
    deux milliards qui sont plus récents. Une autre manière de le dire est que
    l'ensemble de définition des XID est circulaire et sans limite. De plus,
    une ligne créée avec un XID normal donné, la version de la ligne apparaîtra
    comme appartenant au passé pour les deux milliards de transactions qui
    suivront quelque soit le XID. Si la ligne existe encore après deux milliards
    de transactions, elle apparaîtra soudainement comme appartenant au futur.
    Pour éviter la disparition des données, les versions trop anciennes doivent
    se voir affecter le XID <literal>FrozenXID</literal> avant d'atteindre le seuil
    fatidique des deux milliards de transactions. Une fois qu'elles ont ce XID
    spécifique, elles appartiendront au passé pour toutes les transactions même
    en cas de cycle. Cette affectation des anciens XID est réalisée par
    <command>VACUUM</command>.
   </para>

   <para>
    Le comportement du <command>VACUUM</command> est contrôlé par deux paramètres
    de configuration&nbsp;: <xref linkend="guc-vacuum-freeze-min-age"/> and
    <xref linkend="guc-vacuum-freeze-table-age">. .
    <varname>vacuum_freeze_table_age</> controls when <command>VACUUM</>
    performs a full sweep of the table, in order to replace old XID values 
    with <literal>FrozenXID</>.  <varname>vacuum_freeze_min_age</> 
    controls how old an XID value has to be before it's replaced with
    <literal>FrozenXID</>. Les valeurs plus importantes de ces deux paramètres
    préservent l'information
    transactionnelles plus longtemps alors que les valeurs plus petites
    augmentent le nombre de transactions qui peuvent survenir avant un nouveau
    VACUUM de la table.
   </para>

   <para>
    Le temps maximum où une table peut rester sans VACUUM est de deux millions
    de transactions moins <varname>vacuum_freeze_min_age</varname> quand
    <command>VACUUM</> last scanned the whole table. Si elle devait rester sans
    VACUUM après
    cela, des pertes de données pourraient survenir. Pour s'assurer que cela
    n'arrive pas, autovacuum est appelé sur chaque table qui pourrait
    contenir des XID plus âgés que ne l'indique le paramètre de configuration
    <xref linkend="guc-autovacuum-freeze-max-age"/>. (Ceci arrivera même si
    autovacuum est désactivé.)
   </para>

   <para>
    Ceci implique que, si aucune opération de VACUUM n'est demandée sur une
    table, l'autovacuum sera automatiquement déclenché une fois toutes les
    <varname>autovacuum_freeze_max_age</varname> moins
    <varname>vacuum_freeze_min_age</varname> transactions. Pour les tables qui
    ont régulièrement l'opération de VACUUM pour réclamer l'espace perdu, ceci
    a peu d'importance. Néanmoins, pour les tables statiques (ceci incluant les
    tables qui ont des INSERT mais pas d'UPDATE ou de DELETE), il n'est pas
    nécessaire d'exécuter un VACUUM pour récupérer de la placer et donc il
    peut être utile d'essayer de maximiser l'interval entre les autovacuums
    forcés sur de très grosses tables statiques. Évidemment, vous pouvez le
    faire soit en augmentant <varname>autovacuum_freeze_max_age</varname> soit
    en diminuant <varname>vacuum_freeze_min_age</varname>.
   </para>

   <para>
    Le seul inconvénient à augmenter <varname>vacuum_freeze_table_age</> et
    <varname>autovacuum_freeze_max_age</varname>
    est que le sous-répertoire <filename>pg_clog</filename> du cluster prendre
    plus de place car il doit stocker le statut du COMMIT pour toutes les
    transactions depuis <varname>autovacuum_freeze_max_age</varname>. L'état de
    COMMIT utilise deux bits par transaction, donc si
    <varname>autovacuum_freeze_max_age</varname> et
    <varname>vacuum_freeze_table_age</> ont une valeur maximum permise
    d'un peu moins que deux billion, <filename>pg_clog</filename> peut grossir
    jusqu'à la moitié d'un Go. Si c'est rien comparé à votre taille de base
    totale, configurer <varname>autovacuum_freeze_max_age</varname> à son
    maximum permis est recommandé. Sinon, le configurer suivant ce que vous
    voulez comme stockage maximum dans <filename>pg_clog</filename>.
    (La valeur par défaut, 200 millions de transactions, se traduit en à peu près
    50&nbsp;Mo de stockage dans <filename>pg_clog</filename>.)
   </para>

   <para>
    Un inconvénient causé par la diminution de
    <varname>vacuum_freeze_min_age</varname> est que cela pourrait faire que
    <command>VACUUM</command> travaille sans raison&nbsp;: modifier le XID de
    la ligne d'une table à <literal>FrozenXID</literal> est une perte de temps
    si la ligne est modifiée rapidement après (ce qui fait qu'elle obtiendra
    un nouveau XID). Donc ce paramètre doit être suffisamment important pour
    que les lignes ne soient pas gelées jusqu'à ce qu'il soit pratiquement
    certain qu'elles ne seront plus modifiées. Un autre inconvénient en
    diminuant ce paramètre est que les détails sur la transaction exacte
    qui a inséré ou modifié une ligne seront perdus plus tôt. Cette information
    est quelque fois utile, particulièrement lors d'une analyse de ce qui s'est
    mal passé sur une base après un problème. Pour ces deux raisons, baisser
    ce paramètre n'est pas recommandé sauf pour les tables entièrement statiques.
   </para>

   <para>
    Pour tracer l'âge des plus anciens XID de la base, <command>VACUUM</command>
    stocke les statistiques sur XID dans les tables systèmes
    <structname>pg_class</structname> et <structname>pg_database</structname>.
    En particulier, la colonne <structfield>relfrozenxid</structfield> de la
    ligne <structname>pg_class</structname> d'une table contient le XID final
    du gel qui a été utilisé par le dernier <command>VACUUM</command> pour cette
    table. Il est garanti que tous les XID plus anciens que ce XID ont été
    remplacés par <literal>FrozenXID</literal> pour cette table. De façon
    similaire, la colonne <structfield>datfrozenxid</structfield> de la ligne
    <structname>pg_database</structname> de la base est une limite inférieure des
    XID normaux apparaissant dans cette base &mdash; c'est tout simplement le
    minimum des valeurs <structfield>relfrozenxid</structfield> par table dans
    cette base. Pour examiner cette information, le plus simple est d'exécuter
    des requêtes comme&nbsp;:

<programlisting>SELECT relname, age(relfrozenxid) FROM pg_class WHERE relkind = 'r';
SELECT datname, age(datfrozenxid) FROM pg_database;</programlisting>

    La colonne <literal>age</literal> mesure le nombre de transactions à partir
    du XID final vers le XID de transaction en cours. When <command>VACUUM</>
    scans the whole table, after it's finished <literal>age(relfrozenxid)</>
    should be a little more than the <varname>vacuum_freeze_min_age</> setting
    that was used (more by the number of transactions started since the
    <command>VACUUM</> started).
   </para>

   <para>
    <command>VACUUM</> normally only scans pages that have been modified
    since last vacuum, but <structfield>relfrozenxid</> can only be advanced
    when the whole table is scanned. The whole table is scanned when
    <structfield>relfrozenxid</> is more than
    <varname>vacuum_freeze_table_age</> transactions old, if
    <command>VACUUM FREEZE</> command is used, or if all pages happen to
    require vacuuming to remove dead row versions. If no whole-table-scanning
    <command>VACUUM</> is issued on the table until
    <varname>autovacuum_freeze_max_age</> is reached, an autovacuum will soon
    be forced for the table.
   </para>

   <para>
    Si pour une certaine raison l'autovacuum échoue à effacer les anciens XID
    d'une table, le système commencera à émettre des messages d'avertissement
    comme ceci quand les plus anciens XID de la base atteignent les 10 millions
    de transactions à partir du point de réinitialisation&nbsp;:

<programlisting>
WARNING:  database "mydb" must be vacuumed within 177009986 transactions
HINT:  To avoid a database shutdown, execute a database-wide VACUUM in "mydb".
</programlisting>

    (A manual <command>VACUUM</> should fix the problem, as suggested by the
    hint; but note that the <command>VACUUM</> must be performed by a
    superuser, else it will fail to process system catalogs and thus not
    be able to advance the database's <structfield>datfrozenxid</>.)
    Si ces avertissements sont ignorés, le système s'arrêtera et refusera
    d'exécuter toute nouvelle transaction dès qu'il n'en restera qu'un
    million avant la réinitialisation&nbsp;:

<programlisting>
ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and use a standalone backend to VACUUM in "mydb".
</programlisting>

    La marge de sécurité de un million de transactions existe pour permettre à
    l'administrateur de récupérer ces données sans perte en exécutant
    manuellement les commandes <command>VACUUM</command> requises. Néanmoins, comme le
    système n'excutera pas de commandes tant qu'il ne sera pas sorti du mode
    d'arrêt par sécurité, la seule façon de le faire est de stopper le
    serveur et d'utiliser un moteur simple utilisateur pour exécuter le
    <command>VACUUM</command>. Le mode d'arrêt n'est pas pris en compte par le moteur
    simple utilisateur. Voir la page de référence de <xref linkend="app-postgres"/> pour
    des détails sur l'utilisation du moteur simple utilisateur.
   </para>
  </sect2>

  <sect2 id="autovacuum">
   <title id="autovacuum-title">Le démon auto-vacuum</title>

   <indexterm>
    <primary>autovacuum</primary>
    <secondary>information générale</secondary>
   </indexterm>
   <para>
    <productname>PostgreSQL </productname> dispose d'une fonctionnalité
    optionnelle mais hautement recommandée appelée <firstterm>autovacuum</firstterm>,
    dont le but est d'automatiser l'exécution des commandes
    <command>VACUUM</command> et <command>ANALYZE </command>. Une fois activé,
    autovacuum vérifie les tables ayant un grand nombre de lignes insérées,
    mises à jour ou supprimées. Ces vérifications utilisent la fonctionnalité
    de récupération de statistiques&nbsp;; du coup, autovacuum ne peut
    pas être utilisé sauf si <xref linkend="guc-track-counts"/> est configuré
    à <literal>true</literal>.
    Dans la configuration par défaut, l'autovacuum est activé et les
    paramètres liés sont correctement configurés.
   </para>

   <para>
    The <quote>autovacuum daemon</> actually consists of multiple processes.
    Un processus démon permanent appelé <firstterm>autovacuum launcher</firstterm>
    (autrement dit le lanceur d'autovacuum), qui
    est en charge de lancer un processus travailleur (<firstterm>autovacuum
    worker</firstterm>) pour toutes les bases de données. Le lanceur distribuera
    le travail dans le temps mais essaiera de lancer un nouveau travailleur sur
    chaque base de données chaque <xref linkend="guc-autovacuum-naptime"/>
    secondes. Un travailleur sera lancé pour chaque base de données, avec un
    maximum de <xref linkend="guc-autovacuum-max-workers"/> processus fonctionnant
    en même temps. S'il y a plus de <xref linkend="guc-autovacuum-max-workers"/>
    bases à traiter, la prochaine base de données sera traitée dès qu'un autre
    travailleur a terminé. Les processus travailleurs vérifieront chaque table de
    leur base de données et exécutera un <command>VACUUM</command> et/ou un
    <command>ANALYZE</command> suivant les besoins.
   </para>

   <para>
    Le paramètre <xref linkend="guc-autovacuum-max-workers"/> limite le
    nombre maximum de travailleurs pouvant être lancés à tout moment. Si
    plusieurs grosses tables deviennent toutes éligibles pour un VACUUM dans
    un court espace de table, tous les travailleurs de l'autovacuum pourraient
    ne s'occuper que de ces tables pour un très long moment. Ceci aurait pour
    conséquences que les autres tables et bases ne seraient plus l'objet
    d'opérations de VACUUM jusqu'à la disponibilité d'un travailleur. Il
    n'y a pas de limite au nombre de travailleurs sur une seule base mais
    les travailleurs tentent d'éviter de répéter le travail qui a déjà été
    réalisé par d'autres travailleurs. Notez que le nombre de travailleurs
    en cours d'exécution ne comptent pas dans les limites <xref
    linkend="guc-max-connections"/> et <xref
    linkend="guc-superuser-reserved-connections"/>.
   </para>

   <para>
    Les tables dont la valeur de <structfield>relfrozenxid</structfield> est
    plus importante que <varname>autovacuum_freeze_max_age</varname> sont
    toujours l'objet d'un VACUUM (this also applies to those tables whose freeze max age has
    been modified via storage parameters; see below). Sinon, si le nombre de lignes obsolètes
    depuis le dernier <command>VACUUM</command> dépasse une <quote>limite de
    vacuum</quote>, la table bénéficie d'un VACUUM. La limite est définie
    ainsi&nbsp;:
<programlisting>limite du vacuum = limite de base du vacuum + facteur d'échelle du vacuum * nombre de lignes</programlisting>
    où la limite de base du vacuum est
    <xref linkend="guc-autovacuum-vacuum-threshold"/>,
    le facteur d'échelle du vacuum est
    <xref linkend="guc-autovacuum-vacuum-scale-factor"/>
    et le nombre de lignes est
    <structname>pg_class</structname>.<structfield>reltuples</structfield>.
    Le nombre de lignes obsolètes est obtenu à partir du récupérateur de
    statistiques&nbsp;; c'est un nombre à peu près précis, mis à jour après
    chaque instruction <command>UPDATE</command> et <command>DELETE</command>
    (il est seulement à peu près précis car certaines informations pourraient
    être perdues en cas de grosse charge).
   </para>

   <para>
    Pour ANALYZE, une condition similaire
    est utilisée&nbsp;: la limite, définie comme
<programlisting>limite du analyze = limite de base du analyze + facteur d'échelle du analyze * nombre de lignes</programlisting>
    est comparée au nombre de lignes insérées ou mises à jour depuis
    le dernier <command>ANALYZE</command>.
   </para>

   <para>
    Les limites et facteurs d'échelle par défaut sont pris dans
    <filename>postgresql.conf</filename>, mais il est possible de les surcharger
    table par table; see 
    <xref linkend="sql-createtable-storage-parameters"
    endterm="sql-createtable-storage-parameters-title"> for more information.
    If a setting
    has been changed via storage parameters, that value is used; otherwise the
    global settings are used. See <xref linkend="runtime-config-autovacuum"> for
    more details on the global settings.
   </para>

   <para>
    En plus des valeurs de la limite de base et des facteurs d'échelle, il
    existe six autres paramètres autovacuum pouvant être configurés pour chaque table
    via storage parameters.. Le premier paramètre, <literal>autovacuum_enabled</>,
    peut être configuré à <literal>false</literal> pour instruire le démon
    autovacuum de laisser cette table particulière. Dans ce cas, autovacuum
    touchera seulement la table quand il devra le faire pour prévenir la
    réinitialisation de l'ID de transaction. Deux autres paramètres, le
    délai du coût du VACUUM (<literal>autovacuum_vacuum_cost_delay</literal>)
    et la limite du coût du VACUUM
    (<literal>autovacuum_vacuum_cost_limit</literal>),
    sont utilisés pour configurer des valeurs spécifiques aux tables pour
    la fonctionnalité <xref linkend="runtime-config-resource-vacuum-cost"
    endterm="runtime-config-resource-vacuum-cost-title"/>.
    <literal>autovacuum_freeze_min_age</literal>,
    <literal>autovacuum_freeze_max_age</literal> et
    <literal>autovacuum_freeze_table_age</literal>
    sont utilisés pour configurer des valeurs par table, respectivement
    <xref linkend="guc-vacuum-freeze-min-age"/>,
    <xref linkend="guc-autovacuum-freeze-max-age"/> et
    <xref linkend="guc-vacuum-freeze-table-age">.
   </para>

   <para>
    Lorsque plusieurs processus autovacuum sont en cours d'exécution, la
    limite de coût est <quote>répartie</quote> parmi tous les processus pour
    que l'impact total sur le système soit identique quelque soit le nombre
    de processus en cours d'exécution.
   </para>
  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
  <title>Ré-indexation régulière</title>

  <indexterm zone="routine-reindex">
   <primary>ré-indexation</primary>
  </indexterm>

  <para>
   Dans certains cas, reconstruire périodiquement les index par la commande
   <xref linkend="sql-reindex" endterm="sql-reindex-title"/> vaut la peine.
  </para>

  <para>
   Dans les versions <productname>PostgreSQL</productname> antérieures à la 7.4, la
   réindexation périodique était fréquemment nécessaire pour éviter
   l'<quote>inflation des index</quote>, à cause d'un manque de récupération de
   l'espace interne dans les index B-tree. Toutes les situations dans lesquelles
   l'échelle des clés d'index change dans le temps &mdash; par exemple, un index
   sur l'horodatage dans une table où les anciennes entrées sont finalement
   supprimées &mdash; pourraient résulter en une inflation car les pages d'index
   des portions inutilisées de cet ensemble n'étaient pas réclamées pour être
   ré-utilisées. Au bout d'un certain temps, la taille de l'index pouvait
   devenir indéfiniment plus large que les données utiles qu'elle contient.
  </para>

  <para>
   Dans les versions 7.4 et ultérieures de <productname>PostgreSQL</productname>, les
   pages d'index qui sont devenues complètement vides sont récupérées pour être
   réutilisées. Il existe toujours une possibilité d'une utilisation inefficace
   de l'espace&nbsp;: si pratiquement toutes les clés d'index d'une page ont été
   supprimées, la page reste allouée. Donc, le cas d'une utilisation où la
   majorité des clés de l'index d'une page est supprimée est un cas où l'espace
   sera mal utilisé. Pour de tels usages, une réindexation périodique est
   recommandée.
  </para>

  <para>
   Le potentiel d'inflation des index qui ne sont pas des index B-tree n'a pas
   été particulièrement analysé. Garder un &oelig;il sur la taille physique de
   ces index est une bonne idée.
  </para>

  <para>
   De plus, pour les index B-tree, un index tout juste construit est quelque peu
   plus rapide qu'un index qui a été mis à jour plusieurs fois parce que
   les pages adjacentes logiquement sont habituellement aussi physiquement
   adjacentes dans un index nouvellement créé (cette considération ne s'applique
   pas aux index non B-tree). Il pourrait être intéressant de ré-indexer
   périodiquement simplement pour améliorer la vitesse d'accès.
  </para>
 </sect1>


 <sect1 id="logfile-maintenance">
  <title>Maintenance du fichier de traces</title>

  <indexterm zone="logfile-maintenance">
   <primary>traces serveur</primary>
   <secondary>maintenance du fichier de traces</secondary>
  </indexterm>

  <para>
   Sauvegarder les journaux de trace du serveur de bases de données dans un
   fichier plutôt que dans <filename>/dev/NULL</filename> est une bonne idée. Les
   journaux sont d'une utilité incomparable lorsqu'arrive le moment où des
   problèmes surviennent. Néanmoins, les journaux ont tendance à être
   volumineux (tout spécialement à des niveaux de débogage importants) et vous
   ne voulez pas les sauvegarder indéfiniment. Vous avez besoin de faire une
   <quote>rotation</quote> des journaux pour que les nouveaux journaux sont
   commencés et que les anciens soient supprimés après une période de temps
   raisonnable.
  </para>

  <para>
   Si vous redirigez simplement <systemitem>stderr</systemitem> du
   <command>postgres</command> dans un fichier, vous aurez un journal des
   traces mais la seule façon de le tronquer sera d'arrêter et de relancer
   le serveur. Ceci peut convenir si vous utilisez
   <productname>PostgreSQL</productname> dans un environnement de développement
   mais peu de serveurs de production trouveraient ce comportement acceptable.
  </para>

  <para>
   Une meilleure approche est d'envoyer la sortie
   <systemitem>stderr</systemitem> du serveur dans un programme de rotation de
   journaux. Il existe un programme interne de rotation que vous pouvez
   utiliser en configurant le paramètre <literal>logging_collector</literal> à
   <literal>true</literal> dans <filename>postgresql.conf</filename>. Les
   paramètres de contrôle pour ce programme sont décrits dans <xref
   linkend="runtime-config-logging-where"/>. Vous pouvez aussi utiliser cette
   approche pour capturer les données des journaux applicatifs dans un format
   CSV lisible par une machine
  </para>

  <para>
   Sinon, vous pourriez préférer utiliser un programme externe de rotation de
   journaux si vous en utilisez déjà un avec d'autres serveurs. Par exemple,
   l'outil <application>rotatelogs</application> inclus dans la distribution
   <productname>Apache</productname> peut être utilisé avec
   <productname>PostgreSQL</productname>. Pour cela, envoyez via un tube la
   sortie <systemitem>stderr</systemitem> du serveur dans le programme
   désiré. Si vous lancez le serveur avec <command>pg_ctl</command>, alors
   <systemitem>stderr</systemitem> est déjà directement renvoyé dans
   <systemitem>stdout</systemitem>, donc vous avez juste besoin d'ajouter la commande via
   un tube, par exemple&nbsp;:

<programlisting>pg_ctl start | rotatelogs /var/log/pgsql_log 86400</programlisting>
</para>

  <para>
   Une autre approche de production pour la gestion des journaux de trace est
   de les envoyer à <application>syslog</application> et de laisser <application>syslog</application>
   gérer la rotation des fichiers. Pour cela, initialisez le paramètre de
   configuration <literal>log_destination</literal> à <literal>syslog</literal> (pour tracer
   uniquement via <application>syslog</application>) dans <filename>postgresql.conf</filename>.
   Ensuite, vous pouvez envoyer un signal <literal>SIGHUP</literal> au démon
   <application>syslog</application> quand vous voulez le forcer à écrire dans un nouveau
   fichier. Si vous voulez automatiser la rotation des journaux, le programme
   <application>logrotate</application> peut être configuré pour fonctionner
   avec les journaux de traces provenant de <application>syslog</application>.
  </para>

  <para>
   Néanmoins, sur beaucoup de systèmes, <application>syslog</application> n'est pas très
   fiable, particulièrement avec les messages très gros&nbsp;; il pourrait
   tronquer ou supprimer des messages au moment où vous en aurez le plus besoin.
   De plus, sur <productname>Linux</productname>, <application>syslog</application> synchronisera tout
   message sur disque, amenant des performances assez pauvres. (Vous pouvez
   utiliser un <literal>-</literal> au début du nom de fichier dans le fichier de
   configuration <application>syslog</application> pour désactiver ce comportement.)
  </para>

  <para>
   Notez que toutes les solutions décrites ci-dessus font attention à lancer de
   nouveaux journaux de traces à des intervalles configurables mais ils ne
   gèrent pas la suppression des vieux fichiers de traces, qui ne sont
   probablement plus très intéressants. Vous voudrez probablement configurer
   un script pour supprimer périodiquement les anciens journaux. Une autre
   possibilité est de configurer le programme de rotation pour que les anciens
   journaux de traces soient écrasés de façon cyclique.
  </para>
 </sect1>
</chapter>
