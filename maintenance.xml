<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="maintenance">
 <title>Planifier les tâches de maintenance</title>

 <indexterm zone="maintenance">
  <primary>maintenance</primary>
 </indexterm>

 <indexterm zone="maintenance">
  <primary>routine maintenance</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname>, comme tout SGBD, requiert que certains
   tâches soient réalisées de façon régulière pour atteindre les performances
   optimales. Ces tâches, discutées maintenant, sont <emphasis>requises</emphasis>
   mais elles sont répétitives par nature et peuvent être facilement automatisées
   en utilisant des outils Unix standards comme les scripts
   <application>cron</application> ou le <application>Task Scheduler</application>
   de Windows. La responsabilité de la mise en place de ces
   scripts et du contrôle de leur bon fonctionnement relève de l'administrateur
   de la base.
  </para>

  <para>
   Une opération de maintenance évidente est la sauvegarde régulière des
   données. Sans une sauvegarde récente il est impossible de restaurer après
   un dommage grave (perte d'un disque, incendie, table supprimée par erreur,
   etc.). Les mécanismes de sauvegarde et restauration disponibles dans
   <productname>PostgreSQL</productname> sont détaillés dans le <xref
   linkend="backup"/>.
  </para>

  <para>
   L'autre tâche primordiale est de réaliser périodiquement un <quote>vacuum</quote>,
   c'est à dire <quote>faire le vide</quote> dans la base de données.
   Cette opération est détaillée dans la <xref linkend="routine-vacuuming"/>.
   La mise à jour des statistiques qui seront utilisées par le planificateur de
   requêtes sera discutée dans <xref linkend="vacuum-for-statistics"/>.
  </para>

  <para>
   La gestion du fichier de traces mérite aussi une attention régulière.
   Cela est détaillé dans la <xref linkend="logfile-maintenance"/>.
  </para>

  <para>
   <productname>PostgreSQL</productname> demande peu de maintenance par rapport
   à d'autres SGBD. Néanmoins, un suivi vigilant de ces tâches participera
   beaucoup à rendre le système productif et agréable à utiliser.
  </para>

 <sect1 id="routine-vacuuming">
  <title>Nettoyages réguliers</title>

  <indexterm zone="routine-vacuuming">
   <primary>vacuum</primary>
  </indexterm>

  <para>
   La commande <xref linkend="sql-vacuum" endterm="sql-vacuum-title"/> de
   <productname>PostgreSQL</productname> doit être exécutée régulièrement pour
   plusieurs raisons&nbsp;:

    <orderedlist>
     <listitem>
      <simpara>pour récupérer ou ré-utiliser l'espace disque occupé par les lignes supprimées
      ou mises à jour&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour mettre à jour les statistiques utilisées par l'optimiseur de
      <productname>PostgreSQL</productname>&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour prévenir la perte des données les plus anciennes à cause
      d'un <firstterm>cycle de l'identifiant de transaction (XID)</firstterm>.</simpara>
     </listitem>
    </orderedlist>
  </para>

  <para>
   La forme standard de <command>VACUUM</command> peut s'exécuter en parallèle
   avec les opérations de production de la base. Les commandes telles que
   <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>
   et <command>DELETE</command> continueront à fonctionner comme d'habitude
   mais vous ne pourrez pas modifier la définition d'une table avec des commandes
   comme <command>ALTER TABLE ADD COLUMN</command> lorsqu'elle est la cible du
   VACUUM. De plus, <command>VACUUM</command> nécessite une quantité
   supplémentaire de trafic en entrée/sortie qui peut causer des performances
   amoindries pour les autres sessions actives. Des paramètres de
   configuration peuvent être ajustés pour réduire l'impact sur les performances
   du VACUUM en tâche de fond &mdash; voir
   <xref linkend="runtime-config-resource-vacuum-cost"/>.
  </para>

  <para>
   Heureusement, <xref linkend="autovacuum" endterm="autovacuum-title"/> surveille
   l'activité des tables et exécute des <command>VACUUM</command> si
   nécessaire. L'autovacuum fonctionne dynamiquement donc il est souvent
   meilleur que des opérations de VACUUM programmées..
  </para>

  <sect2 id="vacuum-for-space-recovery">
   <title>Récupérer l'espace disque</title>

   <indexterm zone="vacuum-for-space-recovery">
    <primary>espace disque</primary>
   </indexterm>

   <para>
    Dans son fonctionnement normal, <productname>PostgreSQL</productname> ne
    supprime pas immédiatement les versions périmées des lignes après un
    <command>UPDATE</command> ou un <command>DELETE</command>.  Cette approche est
    nécessaire pour la consistance des accès
    concurrents (voir le <xref linkend="mvcc"/>)&nbsp;: les versions de la ligne ne
    doit pas être supprimée tant qu'elle est susceptible d'être lue par une
    autre transaction. Mais finalement, une ligne qui est plus vieille que
    toutes les transactions en cours n'est plus utile du tout. La place qu'elle
    utilise doit être rendue pour être réutilisée par d'autres lignes afin
    d'éviter un accroissement constant du volume occupé sur le disque. Cela est
    réalisé en exécutant <command>VACUUM</command>.
   </para>

   <para>
    Il existe deux variantes de la commande <command>VACUUM</command>. La
    première forme, connu en tant que <quote>vacuum fainéant</quote> ou plus
    simplement <command>VACUUM</command>, marque les données mortes dans les
    tables et les index pour une utilisation future&nbsp;; il ne tente
    <emphasis>pas</emphasis> de récupérer l'espace utilisée par
    cette donnée morte sauf si l'espace est à la fin de la table et qu'un
    verrou exclusif de table puisse être facilement obtenu. L'espace inutilisé
    au début ou au milieu du fichier ne résulte pas en un raccourcissement du
    fichier et de l'espace redonné au système d'exploitation. Cette variante de
    <command>VACUUM</command> peut être lancé en concurrence avec les autres
    opérations normales de la base de données.
   </para>

   <para>
   La seconde forme est la commande <command>VACUUM FULL</command>. Elle utilise
   un algorithme plus agressif pour récupérer l'espace consommé par les versions
   mortes des lignes. Tout espace qui est libéré par <command>VACUUM
   FULL</command> est immédiatement rendu au système d'exploitation et les
   données de la table sont compressées sur le disque. Malheureusement,
   cette variante de la commande <command>VACUUM</command> acquiert un verrou
   exclusif sur chaque table avant que <command>VACUUM FULL</command> ne la
   traite. Du coup, utiliser fréquemment <command>VACUUM FULL</command> peut
   avoir un effet extrêmement négatif sur les performances des requêtes
   concurrentes sur la base de données.
   </para>

   <para>
    La forme standard de <command>VACUUM</command> est mieux utilisé dans le but de
    maintenir une utilisation simple de l'espace disque. Donc, vous avez besoin
    de redonner de l'espace disque au système d'exploitation, vous pouvez
    utiliser <command>VACUUM FULL</command> &mdash; mais quel est l'intérêt de redonner
    de l'espace disque qui devra ensuite être de nouveau alloué&nbsp;? Des
    <command>VACUUM</command> standard et d'une fréquence modérée sont une meilleure
    approche que des <command>VACUUM FULL</command>, même non fréquents, pour maintenir
    des tables mises à jour fréquemment.
   </para>

   <para>
    Heureusement, l'autovacuum (<xref linkend="autovacuum"/>) surveille
    l'activité des tables et exécute des opérations <command>VACUUM</command>
    si nécessaire. Ceci élimine le besoin pour les administrateurs de
    s'inquiéter pour récupération de la place disque dans la plupart des cas.
   </para>

   <para>
    Pour les administrateurs qui veulent contrôler <command>VACUUM</command>
    eux-mêmes, la forme standard du <command>VACUUM</command> est mieux
    utilisée pour maintenir une bonne utilisation de l'espace disque. Si vous
    avez besoin de récupérer l'espace disque, vous pouvez utiliser 
    <command>VACUUM FULL</command> mais c'est déconseillé si la table va
    grossir de nouveau dans le futur. Des exécutions modérément fréquentes
    du <command>VACUUM</command> standard sont une meilleure approche que des
    <command>VACUUM FULL</command> occasionnels pour maintenir des tables
    fréquemment mises à jour. Néanmoins, si des tables fréquemment mises à
    jour n'ont pas eu de <command>VACUUM</command> fréquent, vous pouvez
    utiliser <command>VACUUM FULL</command> ou <command>CLUSTER</command>
    pour obtenir de nouveau de bonnes performances (il est bien plus lent
    de parcourir une table contenant une grosse majorité de lignes mortes).
   </para>

   <para>
    Pour ceux qui n'utilisent pas autovacuum, une approche alternative est de
    planifier un <command>VACUUM</command> sur la base complète une fois
    par jour lorsque l'utilisation n'est pas grande, avec en plus des
    opérations de <command>VACUUM</command> plus fréquentes pour les tables
    très impactées par des mises à jour, si nécessaire.
    (Certaines installations avec énormément de mises à jour peuvent exécuter
    des VACUUM toutes les quelques minutes.) Si vous avez plusieurs bases dans
    un cluster, n'oubliez pas d'exécuter un <command>VACUUM</command> sur
    chacune d'elles&nbsp;; le programme <xref
    linkend="app-vacuumdb" endterm="app-vacuumdb-title"/> pourrait être utile.
   </para>

   <para>
    <command>VACUUM FULL</command> est recommandé dans les cas où vous savez que vous
    avez supprimé la majorité des lignes dans une table, de façon à ce que la
    taille de la table soit réduit de façon conséquente avec l'approche plus
    plus agressive de <command>VACUUM FULL</command>. Utilisez le <command>VACUUM</command>
    standard, et non pas <command>VACUUM FULL</command>, pour les nettoyages standards.
   </para>

   <para>
    Si vous avez une table dont le contenu entier est supprimé sur une base périodique,
    considérez de le faire avec <command>TRUNCATE</command> plutôt qu'avec
    <command>DELETE</command> suivi par un <command>VACUUM</command>.
    <command>TRUNCATE</command> supprime le contenu entier de la table
    immédiatement sans nécessiter un <command>VACUUM</command> ou
    <command>VACUUM FULL</command> pour réclamer l'espace disque maintenant
    inutilisé.
</para>
  </sect2>

  <sect2 id="vacuum-for-statistics">
   <title>Maintenir les statistiques du planificateur</title>

   <indexterm zone="vacuum-for-statistics">
    <primary>statistiques</primary>
    <secondary>du planificateur</secondary>
   </indexterm>

   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>

   <para>
    L'optimiseur de requêtes de <productname>PostgreSQL</productname> s'appuie
    sur des informations statistiques sur le contenu des tables dans l'optique
    de générer des plans d'exécutions efficaces pour les requêtes. Ces
    statistiques sont collectées par la commande <xref linkend="sql-analyze"
    endterm="sql-analyze-title"/>, qui peut
    être invoquée seule ou comme une option de <command>VACUUM</command>. Il est
    important d'avoir des statistiques relativement à jour sans quoi des mauvais
    choix dans les plans d'exécution pourraient pénaliser la performance de la
    base.
   </para>

   <para>
    À l'instar du nettoyage pour récupérer l'espace, les statistiques doivent
    être plus souvent collectées pour les tables intensément modifiées que pour
    celles qui le sont moins. Mais même si la table est très modifiée, il se
    peut que ces collectes soient inutiles si la distribution probabiliste des
    données évolue peu. Une règle simple pour décider est de voir comment
    évoluent les valeurs minimum et maximum des données. Par exemple, une
    colonne de type <type>timestamp</type> qui contient la date de mise à jour
    de la ligne aura une valeur maximum en continuelle croissance au fur et à
    mesure des modifications&nbsp;; une telle colonne nécessitera plus de
    collectes statistiques qu'une colonne qui contient par exemple les URL des
    pages accédées sur un site web. La colonne qui contient les URL peut très
    bien être aussi souvent modifiée mais la distribution probabiliste des
    données changera certainement moins rapidement.
   </para>

   <para>
    Il est possible d'exécuter <command>ANALYZE</command> sur des tables spécifiques,
    voire des colonnes spécifiques&nbsp;; il a donc toute flexibilité pour
    mettre à jour certaines statistiques plus souvent que les autres en
    fonction des besoins de l'application. Quoi qu'il en soit, dans la pratique,
    il est généralement mieux de simplement analyser la base entière car il s'agit
    d'une opération rapide. Elle utilise un système d'échantillonage des lignes d'une
    table, ce qui lui évite de lire chaque ligne.
   </para>

   <tip>
    <para>
     Même si il n'est pas très productif de règler précisément la fréquence de
     <command>ANALYZE</command> pour chaque colonne, il peut être intéressant d'ajuster
     le niveau de détail des statistiques collectées pour chaque colonne. Les
     colonnes très utilisées dans les clauses <literal>WHERE</literal> et dont la
     distribution n'est pas uniforme requièrent des histogrammes plus précis
     que les autres colonnes. Voir <command>ALTER TABLE SET STATISTICS</command>.
    </para>
   </tip>

   <para>
    Heureusement, <xref linkend="autovacuum" endterm="autovacuum-title"/> surveille
    l'activité des tables et exécute des opérations <command>ANALYZE</command>
    si nécessaire. Ceci élimine le besoin pour les administrateurs de
    planifier manuellement ces opérations.
   </para>

   <para>
    Pour ceux qui n'utilisent pas l'autovacuum, une approche alternative
    serait de planifier un <command>ANALYZE</command> sur la base complète
    au moins une fois par jour&nbsp;; cela peut être combiné avec un
    <command>VACUUM</command> le soir. Néanmoins, les sites avec relativement
    peu de modifications dans les statistiques de table peuvent trouver cela
    trop et peut-être que des <command>ANALYZE</command> moins fréquents
    seraient suffisants.
   </para>
  </sect2>

  <sect2 id="vacuum-for-wraparound">
   <title>Éviter les cycles des identifiants de transactions</title>

   <indexterm zone="vacuum-for-wraparound">
    <primary>identifiant de transaction</primary>
    <secondary>cycle</secondary>
   </indexterm>

   <para>
    Le mécanisme de contrôle de concurrence multiversion (<acronym>MVCC</acronym>) de
    <productname>PostgreSQL</productname> s'appuie sur la possibilité de
    comparer des identifiants de transactions (<acronym>XID</acronym>)&nbsp;; c'est un
    nombre croissant&nbsp;: la version d'une ligne dont le XID d'insertion est
    supérieur au XID de la transaction en cours est <quote>dans le futur</quote> et
    ne doit pas être visible de la transaction courante. Comme les identifiants
    ont une taille limitée (32 bits à ce jour), un groupe qui est en activité
    depuis longtemps (plus de 4 milliards de transactions) pourrait connaître un
    cycle des identifiants de transaction&nbsp;: le XID reviendra à 0 et
    soudainement les transactions du passé sembleront appartenir au futur - ce
    qui signifie qu'elles deviennent invisibles. En bref, perte de données
    totale. (En réalité, les données sont toujours là mais c'est un piètre
    réconfort puisqu'elles resteront inaccessibles.) Pour éviter ceci, il est
    nécessaire d'exécuter un VACUUM sur chaque table de chaque base au moins
    au moins une fois à chaque milliard de transactions.
   </para>

   <para>
    La raison pour laquelle un VACUUM périodique résout le problème est que
    <productname>PostgreSQL</productname> distingue un ID de transaction spécial,
    <literal>FrozenXID</literal>. Ce XID est toujours considéré comme plus âgé
    que les XID normaux. Les XID normaux sont comparés sur une base
    modulo-2<superscript>31</superscript>. Cela signifie
    que pour chaque XID normal, il y en a deux milliards qui sont plus vieux et
    deux milliards qui sont plus récents. Une autre manière de le dire est que
    l'ensemble de définition des XID est circulaire et sans limite. De plus,
    une ligne créée avec un XID normal donné, la version de la ligne apparaîtra
    comme appartenant au passé pour les deux milliards de transactions qui
    suivront quelque soit le XID. Si la ligne existe encore après deux milliards
    de transactions, elle apparaîtra soudainement comme appartenant au futur.
    Pour éviter la disparition des données, les versions trop anciennes doivent
    se voir affecter le XID <literal>FrozenXID</literal> avant d'atteindre le seuil
    fatidique des deux milliards de transactions. Une fois qu'elles ont ce XID
    spécifique, elles appartiendront au passé pour toutes les transactions même
    en cas de cycle. Cette affectation des anciens XID est réalisée par
    <command>VACUUM</command>.
   </para>

   <para>
    Le comportement du <command>VACUUM</command> est contrôlé par le paramètre
    de configuration <xref linkend="guc-vacuum-freeze-min-age"/>&nbsp;: tout
    XID plus ancien que  <varname>vacuum_freeze_min_age</varname> transactions
    est remplacé par <literal>FrozenXID</literal>. Les valeurs plus importantes
    que <varname>vacuum_freeze_min_age</varname> préserve l'information
    transactionnelles plus longtemps alors que les valeurs plus petites
    augmentent le nombre de transactions qui peuvent survenir avant un nouveau
    VACUUM de la table.
   </para>

   <para>
    Le temps maximum où une table peut rester sans VACUUM est de deux millions
    de transactions moins <varname>vacuum_freeze_min_age</varname> qui a été
    utilisé lors du dernier VACUUM. Si elle devait rester sans VACUUM après
    cela, des pertes de données pourraient survenir. Pour s'assurer que cela
    n'arrive pas, <xref linkend="autovacuum" endterm="autovacuum-title"/> décrit dans
    <xref linkend="autovacuum"/> est appelé sur chaque table qui pourrait
    contenir des XID plus âgés que ne l'indique le paramètre de configuration
    <xref linkend="guc-autovacuum-freeze-max-age"/>. (Ceci arrivera même si
    autovacuum est désactivé.)
   </para>

   <para>
    Ceci implique que, si aucune opération de VACUUM n'est demandée sur une
    table, l'autovacuum sera automatiquement déclenché une fois toutes les
    <varname>autovacuum_freeze_max_age</varname> moins
    <varname>vacuum_freeze_min_age</varname> transactions. Pour les tables qui
    ont régulièrement l'opération de VACUUM pour réclamer l'espace perdu, ceci
    a peu d'importance. Néanmoins, pour les tables statiques (ceci incluant les
    tables qui ont des INSERT mais pas d'UPDATE ou de DELETE), il n'est pas
    nécessaire d'exécuter un VACUUM pour récupérer de la place et donc il
    peut être utile d'essayer de maximiser l'interval entre les autovacuums
    forcés sur de très grosses tables statiques. Évidemment, vous pouvez le
    faire soit en augmentant <varname>autovacuum_freeze_max_age</varname> soit
    en diminuant <varname>vacuum_freeze_min_age</varname>.
   </para>

   <para>
    Le seul inconvénient à augmenter <varname>autovacuum_freeze_max_age</varname>
    est que le sous-répertoire <filename>pg_clog</filename> du cluster prendre
    plus de place car il doit stocker le statut du COMMIT pour toutes les
    transactions depuis <varname>autovacuum_freeze_max_age</varname>. L'état de
    COMMIT utilise deux bits par transaction, donc si
    <varname>autovacuum_freeze_max_age</varname> a une valeur maximum permise
    d'un peu moins que deux billion, <filename>pg_clog</filename> peut grossir
    jusqu'à la moitié d'un Go. Si c'est rien comparé à votre taille de base
    totale, configurer <varname>autovacuum_freeze_max_age</varname> à son
    maximum permis est recommandé. Sinon, le configurer suivant ce que vous
    voulez comme stockage maximum dans <filename>pg_clog</filename>.
    (La valeur par défaut, 200 millions de transactions, se traduit en à peu près
    50&nbsp;Mo de stockage dans <filename>pg_clog</filename>.)
   </para>

   <para>
    Un inconvénient causé par la diminution de
    <varname>vacuum_freeze_min_age</varname> est que cela pourrait faire que
    <command>VACUUM</command> travaille sans raison&nbsp;: modifier le XID de
    la ligne d'une table à <literal>FrozenXID</literal> est une perte de temps
    si la ligne est modifiée rapidement après (ce qui fait qu'elle obtiendra
    un nouveau XID). Donc ce paramètre doit être suffisamment important pour
    que les lignes ne soient pas gelées jusqu'à ce qu'il soit pratiquement
    certain qu'elles ne seront plus modifiées. Un autre inconvénient en
    diminuant ce paramètre est que les détails sur la transaction exacte
    qui a inséré ou modifié une ligne seront perdus plus tôt. Cette information
    est quelque fois utile, particulièrement lors d'une analyse de ce qui s'est
    mal passé sur une base après un problème. Pour ces deux raisons, baisser
    ce paramètre n'est pas recommandé sauf pour les tables entièrement statiques.
   </para>

   <para>
    Pour tracer l'âge des plus anciens XID de la base, <command>VACUUM</command>
    stocke les statistiques sur XID dans les tables systèmes
    <structname>pg_class</structname> et <structname>pg_database</structname>.
    En particulier, la colonne <structfield>relfrozenxid</structfield> de la
    ligne <structname>pg_class</structname> d'une table contient le XID final
    du gel qui a été utilisé par le dernier <command>VACUUM</command> pour cette
    table. Il est garanti que tous les XID plus anciens que ce XID ont été
    remplacés par <literal>FrozenXID</literal> pour cette table. De façon
    similaire, la colonne <structfield>datfrozenxid</structfield> de la ligne
    <structname>pg_database</structname> de la base est une limite inférieure des
    XID normaux apparaissant dans cette base &mdash; c'est tout simplement le
    minimum des valeurs <structfield>relfrozenxid</structfield> par table dans
    cette base. Pour examiner cette information, le plus simple est d'exécuter
    des requêtes comme&nbsp;:

<programlisting>SELECT relname, age(relfrozenxid) FROM pg_class WHERE relkind = 'r';
SELECT datname, age(datfrozenxid) FROM pg_database;</programlisting>

    La colonne <literal>age</literal> mesure le nombre de transactions à partir
    du XID final vers le XID de transaction en cours. Immédiatement après un
    <command>VACUUM</command>, <literal>age(relfrozenxid)</literal> devrait être
    un peu plus que le paramètre <varname>vacuum_freeze_min_age</varname> qui a
    été utilisé (plus par le nombre de transactions commencées depuis l'exécution
    de <command>VACUUM</command>). Si <literal>age(relfrozenxid)</literal> dépasse
    <varname>autovacuum_freeze_max_age</varname>, un autovacuum sera bientôt
    forcé sur la table.
   </para>

   <para>
    Si pour une certaine raison l'autovacuum échoue à effacer les anciens XID
    d'une table, le système commencera à émettre des messages d'avertissement
    comme ceci quand les plus anciens XID de la base atteignent les 10 millions
    de transactions à partir du point de réinitialisation&nbsp;:

<programlisting>
WARNING:  database "mydb" must be vacuumed within 177009986 transactions
HINT:  To avoid a database shutdown, execute a full-database VACUUM in "mydb".
</programlisting>

    Si ces avertissements sont ignorés, le système s'arrêtera et refusera
    d'exécuter toute nouvelle transaction dès qu'il n'en restera qu'un
    million avant la réinitialisation&nbsp;:

<programlisting>
ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and use a standalone backend to VACUUM in "mydb".
</programlisting>

    La marge de sécurité de un million de transactions existe pour permettre à
    l'administrateur de récupérer ces données sans perte en exécutant
    manuellement les commandes <command>VACUUM</command> requises. Néanmoins, comme le
    système n'exécute pas de commandes tant qu'il n'est pas sorti du mode
    d'arrêt par sécurité, la seule façon de le faire est de stopper le
    serveur et d'utiliser un moteur simple utilisateur pour exécuter le
    <command>VACUUM</command>. Le mode d'arrêt n'est pas pris en compte par le moteur
    simple utilisateur. Voir la page de référence de <xref linkend="app-postgres"/> pour
    des détails sur l'utilisation du moteur simple utilisateur.
   </para>
  </sect2>

  <sect2 id="autovacuum">
   <title id="autovacuum-title">Le démon auto-vacuum</title>

   <indexterm>
    <primary>autovacuum</primary>
    <secondary>information générale</secondary>
   </indexterm>
   <para>
    À partir de <productname>PostgreSQL </productname> 8.1, il existe un
    processus serveur optionnel appelé <firstterm>autovacuum</firstterm>,
    dont le but est d'automatiser l'exécution des commandes
    <command>VACUUM</command> et <command>ANALYZE </command>. Une fois activé,
    autovacuum vérifie les tables ayant un grand nombre de lignes insérées,
    mises à jour ou supprimées. Ces vérifications utilisent la fonctionnalité
    de récupération de statistiques&nbsp;; du coup, autovacuum ne peut
    pas être utilisé sauf si <xref linkend="guc-track-counts"/> est configuré
    à <literal>true</literal>.
    Dans la configuration par défaut, l'autovacuum est activé et les
    paramètres liés sont correctement configurés.
   </para>

   <para>
    À partir de <productname>PostgreSQL</productname> 8.3, l'autovacuum a
    une architecture multi-processus&nbsp;: il y a un processus démon appelé
    le lanceur d'autovacuum (<firstterm>autovacuum launcher</firstterm>), qui
    est en charge de lancer un processus travailleur (<firstterm>autovacuum
    worker</firstterm>) pour toutes les bases de données. Le lanceur distribuera
    le travail dans le temps mais essaiera de lancer un nouveau travailleur sur
    chaque base de données chaque <xref linkend="guc-autovacuum-naptime"/>
    secondes. Un travailleur sera lancé pour chaque base de données, avec un
    maximum de <xref linkend="guc-autovacuum-max-workers"/> processus fonctionnant
    en même temps. S'il y a plus de <xref linkend="guc-autovacuum-max-workers"/>
    bases à traiter, la prochaine base de données sera traitée dès qu'un autre
    travailleur a terminé. Les processus travailleurs vérifieront chaque table de
    leur base de données et exécutera un <command>VACUUM</command> et/ou un
    <command>ANALYZE</command> suivant les besoins.
   </para>

   <para>
    Le paramètre <xref linkend="guc-autovacuum-max-workers"/> limite le
    nombre maximum de travailleurs pouvant être lancés à tout moment. Si
    plusieurs grosses tables deviennent toutes éligibles pour un VACUUM dans
    un court espace de table, tous les travailleurs de l'autovacuum pourraient
    ne s'occuper que de ces tables pour un très long moment. Ceci aurait pour
    conséquences que les autres tables et bases ne seraient plus l'objet
    d'opérations de VACUUM jusqu'à la disponibilité d'un travailleur. Il
    n'y a pas de limite au nombre de travailleurs sur une seule base mais
    les travailleurs tentent d'éviter de répéter le travail qui a déjà été
    réalisé par d'autres travailleurs. Notez que le nombre de travailleurs
    en cours d'exécution ne comptent pas dans les limites <xref
    linkend="guc-max-connections"/> et <xref
    linkend="guc-superuser-reserved-connections"/>.
   </para>

   <para>
    Les tables dont la valeur de <structfield>relfrozenxid</structfield> est
    plus importante que <varname>autovacuum_freeze_max_age</varname> sont
    toujours l'objet d'un VACUUM. Sinon, deux conditions sont utilisées pour
    déterminer l'opération qui s'applique. Si le nombre de lignes obsolètes
    depuis le dernier <command>VACUUM</command> dépasse une <quote>limite de
    vacuum</quote>, la table bénéficie d'un VACUUM. La limite est définie
    ainsi&nbsp;:
<programlisting>limite du vacuum = limite de base du vacuum + facteur d'échelle du vacuum * nombre de lignes</programlisting>
    où la limite de base du vacuum est
    <xref linkend="guc-autovacuum-vacuum-threshold"/>,
    le facteur d'échelle du vacuum est
    <xref linkend="guc-autovacuum-vacuum-scale-factor"/>
    et le nombre de lignes est
    <structname>pg_class</structname>.<structfield>reltuples</structfield>.
    Le nombre de lignes obsolètes est obtenu à partir du récupérateur de
    statistiques&nbsp;; c'est un nombre à peu près précis, mis à jour après
    chaque instruction <command>UPDATE</command> et <command>DELETE</command>
    (il est seulement à peu près précis car certaines informations pourraient
    être perdues en cas de grosse charge). Pour ANALYZE, une condition similaire
    est utilisée&nbsp;: la limite, définie comme
<programlisting>limite du analyze = limite de base du analyze + facteur d'échelle du analyze * nombre de lignes</programlisting>
    est comparée au nombre de lignes insérées ou mises à jour depuis
    le dernier <command>ANALYZE</command>.
   </para>

   <para>
    Les limites et facteurs d'échelle par défaut sont pris dans
    <filename>postgresql.conf</filename>, mais il est possible de les surcharger
    table par table avec des entrées du catalogue système <link
    linkend="catalog-pg-autovacuum"><structname>pg_autovacuum</structname></link>.
    Si une ligne <structname>pg_autovacuum</structname> existe pour une table
    particulière, les paramètres qu'elle indique sont appliqués&nbsp;; sinon les
    paramètres globaux sont utilisés. Voir <xref linkend="runtime-config-autovacuum"/>
    pour plus de détails sur les paramètres globaux.
   </para>

   <para>
    En plus des valeurs de la limite de base et des facteurs d'échelle, il
    existe cinq autres paramètres pouvant être configurés pour chaque table
    dans <structname>pg_autovacuum</structname>. Le premier,
    <structname>pg_autovacuum</structname>.<structfield>enabled</structfield>,
    peut être configuré à <literal>false</literal> pour instruire le démon
    autovacuum de laisser cette table particulière. Dans ce cas, autovacuum
    touchera seulement la table quand il devra le faire pour prévenir la
    réinitialisation de l'ID de transaction. Les deux paramètres suivants, le
    délai du coût du VACUUM
    (<structname>pg_autovacuum</structname>.<structfield>vac_cost_delay</structfield>)
    et la limite du coût du VACUUM
    (<structname>pg_autovacuum</structname>.<structfield>vac_cost_limit</structfield>),
    sont utilisés pour configurer des valeurs spécifiques aux tables pour
    la fonctionnalité <xref linkend="runtime-config-resource-vacuum-cost"
    endterm="runtime-config-resource-vacuum-cost-title"/>.
    Les deux derniers paramètres,
    (<structname>pg_autovacuum</structname>.<structfield>freeze_min_age</structfield>)
    et
    (<structname>pg_autovacuum</structname>.<structfield>freeze_max_age</structfield>), 
    sont utilisés pour configurer des valeurs par table, respectivement
    <xref linkend="guc-vacuum-freeze-min-age"/> et
    <xref linkend="guc-autovacuum-freeze-max-age"/>.
   </para>

   <para>
    Si une des valeurs dans <structname>pg_autovacuum</structname> est négative
    ou si aucune ligne n'est présente dans <structname>pg_autovacuum</structname>
    quelque soit la table, les valeurs correspondantes de
    <filename>postgresql.conf</filename> sont utilisées.
   </para>

   <para>
    Il n'y a pas de support pour créer des entrées dans
    <structname>pg_autovacuum</structname>, sauf en réalisant soi-même des
    insertions manuelles dans le catalogue. Cette fonctionnalité sera améliorée
    dans les prochaines versions et il est vraisemblable que la définition du
    catalogue changera.
   </para>

   <caution>
    <para>
     Le contenu du catalogue système <structname>pg_autovacuum</structname>
     n'est actuellement pas pris en compte dans les sauvegardes de bases de
     données créées par les outils <command>pg_dump</command> et
     <command>pg_dumpall</command>. Si vous voulez les préserver après
     un cycle sauvegarde/restauration, assurez-vous que vous avez sauvegardé
     manuellement le catalogue.
    </para>
   </caution>

   <para>
    Lorsque plusieurs processus autovacuum sont en cours d'exécution, la
    limite de coût est <quote>répartie</quote> parmi tous les processus pour
    que l'impact total sur le système soit identique quelque soit le nombre
    de processus en cours d'exécution.
   </para>
  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
  <title>Ré-indexation régulière</title>

  <indexterm zone="routine-reindex">
   <primary>ré-indexation</primary>
  </indexterm>

  <para>
   Dans certains cas, reconstruire périodiquement les index par la commande
   <xref linkend="sql-reindex" endterm="sql-reindex-title"/> vaut la peine.
  </para>

  <para>
   Dans les versions <productname>PostgreSQL</productname> antérieures à la 7.4, la
   réindexation périodique était fréquemment nécessaire pour éviter
   l'<quote>inflation des index</quote>, à cause d'un manque de récupération de
   l'espace interne dans les index B-tree. Toutes les situations dans lesquelles
   l'échelle des clés d'index change dans le temps &mdash; par exemple, un index
   sur l'horodatage dans une table où les anciennes entrées sont finalement
   supprimées &mdash; pourraient résulter en une inflation car les pages d'index
   des portions inutilisées de cet ensemble n'étaient pas réclamées pour être
   ré-utilisées. Au bout d'un certain temps, la taille de l'index pouvait
   devenir indéfiniment plus large que les données utiles qu'elle contient.
  </para>

  <para>
   Dans les versions 7.4 et ultérieures de <productname>PostgreSQL</productname>, les
   pages d'index qui sont devenues complètement vides sont récupérées pour être
   réutilisées. Il existe toujours une possibilité d'une utilisation inefficace
   de l'espace&nbsp;: si pratiquement toutes les clés d'index d'une page ont été
   supprimées, la page reste allouée. Donc, le cas d'une utilisation où la
   majorité des clés de l'index d'une page est supprimée est un cas où l'espace
   sera mal utilisé. Pour de tels usages, une réindexation périodique est
   recommandée.
  </para>

  <para>
   Le potentiel d'inflation des index qui ne sont pas des index B-tree n'a pas
   été particulièrement analysé. Garder un &oelig;il sur la taille physique de
   ces index est une bonne idée.
  </para>

  <para>
   De plus, pour les index B-tree, un index tout juste construit est quelque peu
   plus rapide qu'un index qui a été mis à jour plusieurs fois parce que
   les pages adjacentes logiquement sont habituellement aussi physiquement
   adjacentes dans un index nouvellement créé (cette considération ne s'applique
   pas aux index non B-tree). Il pourrait être intéressant de ré-indexer
   périodiquement simplement pour améliorer la vitesse d'accès.
  </para>
 </sect1>


 <sect1 id="logfile-maintenance">
  <title>Maintenance du fichier de traces</title>

  <indexterm zone="logfile-maintenance">
   <primary>traces serveur</primary>
   <secondary>maintenance du fichier de traces</secondary>
  </indexterm>

  <para>
   Sauvegarder les journaux de trace du serveur de bases de données dans un
   fichier plutôt que dans <filename>/dev/NULL</filename> est une bonne idée. Les
   journaux sont d'une utilité incomparable lorsqu'arrive le moment où des
   problèmes surviennent. Néanmoins, les journaux ont tendance à être
   volumineux (tout spécialement à des niveaux de débogage importants) et vous
   ne voulez pas les sauvegarder indéfiniment. Vous avez besoin de faire une
   <quote>rotation</quote> des journaux pour que les nouveaux journaux sont
   commencés et que les anciens soient supprimés après une période de temps
   raisonnable.
  </para>

  <para>
   Si vous redirigez simplement <systemitem>stderr</systemitem> du
   <command>postgres</command> dans un fichier, vous aurez un journal des
   traces mais la seule façon de le tronquer sera d'arrêter et de relancer
   le serveur. Ceci peut convenir si vous utilisez
   <productname>PostgreSQL</productname> dans un environnement de développement
   mais peu de serveurs de production trouveraient ce comportement acceptable.
  </para>

  <para>
   Une meilleure approche est d'envoyer la sortie
   <systemitem>stderr</systemitem> du serveur dans un programme de rotation de
   journaux. Il existe un programme interne de rotation que vous pouvez
   utiliser en configurant le paramètre <literal>logging_collector</literal> à
   <literal>true</literal> dans <filename>postgresql.conf</filename>. Les
   paramètres de contrôle pour ce programme sont décrits dans <xref
   linkend="runtime-config-logging-where"/>. Vous pouvez aussi utiliser cette
   approche pour capturer les données des journaux applicatifs dans un format
   CSV lisible par une machine
  </para>

  <para>
   Sinon, vous pourriez préférer utiliser un programme externe de rotation de
   journaux si vous en utilisez déjà un avec d'autres serveurs. Par exemple,
   l'outil <application>rotatelogs</application> inclus dans la distribution
   <productname>Apache</productname> peut être utilisé avec
   <productname>PostgreSQL</productname>. Pour cela, envoyez via un tube la
   sortie <systemitem>stderr</systemitem> du serveur dans le programme
   désiré. Si vous lancez le serveur avec <command>pg_ctl</command>, alors
   <systemitem>stderr</systemitem> est déjà directement renvoyé dans
   <systemitem>stdout</systemitem>, donc vous avez juste besoin d'ajouter la commande via
   un tube, par exemple&nbsp;:

<programlisting>pg_ctl start | rotatelogs /var/log/pgsql_log 86400</programlisting>
</para>

  <para>
   Une autre approche de production pour la gestion des journaux de trace est
   de les envoyer à <application>syslog</application> et de laisser <application>syslog</application>
   gérer la rotation des fichiers. Pour cela, initialisez le paramètre de
   configuration <literal>log_destination</literal> à <literal>syslog</literal> (pour tracer
   uniquement via <application>syslog</application>) dans <filename>postgresql.conf</filename>.
   Ensuite, vous pouvez envoyer un signal <literal>SIGHUP</literal> au démon
   <application>syslog</application> quand vous voulez le forcer à écrire dans un nouveau
   fichier. Si vous voulez automatiser la rotation des journaux, le programme
   <application>logrotate</application> peut être configuré pour fonctionner
   avec les journaux de traces provenant de <application>syslog</application>.
  </para>

  <para>
   Néanmoins, sur beaucoup de systèmes, <application>syslog</application> n'est pas très
   fiable, particulièrement avec les messages très gros&nbsp;; il pourrait
   tronquer ou supprimer des messages au moment où vous en aurez le plus besoin.
   De plus, sur <productname>Linux</productname>, <application>syslog</application> synchronisera tout
   message sur disque, amenant des performances assez pauvres. (Vous pouvez
   utiliser un <literal>-</literal> au début du nom de fichier dans le fichier de
   configuration <application>syslog</application> pour désactiver ce comportement.)
  </para>

  <para>
   Notez que toutes les solutions décrites ci-dessus font attention à lancer de
   nouveaux journaux de traces à des intervalles configurables mais ils ne
   gèrent pas la suppression des vieux fichiers de traces, qui ne sont
   probablement plus très intéressants. Vous voudrez probablement configurer
   un script pour supprimer périodiquement les anciens journaux. Une autre
   possibilité est de configurer le programme de rotation pour que les anciens
   journaux de traces soient écrasés de façon cyclique.
  </para>
 </sect1>
</chapter>
