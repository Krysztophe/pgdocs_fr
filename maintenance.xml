<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/maintenance.sgml,v 1.12 2005/09/22 18:34:42 guillaume Exp $ -->

<chapter id="maintenance">
 <title>Planifier les tâches de maintenance</title>

 <indexterm zone="maintenance">
  <primary>maintenance</primary>
 </indexterm>

 <indexterm zone="maintenance">
  <primary>routine maintenance</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname>, comme tout SGBD, requiert que certains
   tâches soient réalisées de façon régulière pour atteindre les performances
   optimales. Ces tâches, discutées maintenant, sont <emphasis>requises</emphasis>
   mais elles sont répétitives par nature et peuvent être facilement automatisées
   en utilisant des outils Unix standards comme les scripts
   <application>cron</application> ou le <application>Task Scheduler</application>
   de Windows. La responsabilité de la mise en place de ces
   scripts et du contrôle de leur bon fonctionnement relève de l'administrateur
   de la base.
  </para>

  <para>
   Une opération de maintenance évidente est la sauvegarde régulière des
   données. Sans une sauvegarde récente il est impossible de restaurer après
   un dommage grave (perte d'un disque, incendie, table supprimée par erreur,
   etc.). Les mécanismes de sauvegarde et restauration disponibles dans
   <productname>PostgreSQL</productname> sont détaillés dans le <xref
   linkend="backup"/>.
  </para>

  <para>
   L'autre tâche primordiale est de réaliser périodiquement un <quote>vacuum</quote>,
   c'est à dire <quote>faire le vide</quote> dans la base de données.
   Cette opération est détaillée dans la <xref linkend="routine-vacuuming"/>.
   La mise à jour des statistiques qui seront utilisées par le planificateur de
   requêtes sera discutée dans <xref linkend="vacuum-for-statistics"/>.
  </para>

  <para>
   La gestion du fichier de traces mérite aussi une attention régulière.
   Cela est détaillé dans la <xref linkend="logfile-maintenance"/>.
  </para>

  <para>
   <productname>PostgreSQL</productname> demande peu de maintenance par rapport
   à d'autres SGBD. Néanmoins, un suivi vigilant de ces tâches participera
   beaucoup à rendre le système productif et agréable à utiliser.
  </para>

 <sect1 id="routine-vacuuming">
  <title>Nettoyages réguliers</title>

  <indexterm zone="routine-vacuuming">
   <primary>vacuum</primary>
  </indexterm>

  <para>
   La commande <command>VACUUM</command> de <productname>PostgreSQL</productname>
   <emphasis>doit</emphasis> être exécutée régulièrement pour plusieurs raisons&nbsp;:

    <orderedlist>
     <listitem>
      <simpara>pour récupérer ou ré-utiliser l'espace disque occupé par les lignes supprimées
      ou mises à jour&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour mettre à jour les statistiques utilisées par l'optimiseur de
      <productname>PostgreSQL</productname>&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour prévenir la perte des données les plus anciennes à cause
      d'un <firstterm>cycle de l'identifiant de transaction (XID)</firstterm>.</simpara>
     </listitem>
    </orderedlist>

   La fréquence et le périmètre des exécutions de <command>VACUUM</command> variera
   pour chacune des raisons ci-dessus selon les besoins des sites. De plus, les
   administrateurs doivent appréhender chaque cas et développer une stratégie de
   maintenance appropriée. L'objectif de cette section est de décrire
   globalement les problèmes à résoudre&nbsp;; pour la syntaxe et les autres
   détails, voir la page de référence de la commande <xref linkend="sql-vacuum"
   endterm="sql-vacuum-title"/>.
  </para>

  <para>
   La forme standard de <command>VACUUM</command> peut s'exécuter en parallèle
   avec les opérations de production de la base. Les commandes telles que
   <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>
   et <command>DELETE</command> continueront à fonctionner comme d'habitude
   mais vous ne pourrez pas modifier la définition d'une table avec des commandes
   comme <command>ALTER TABLE ADD COLUMN</command> lorsqu'elle est la cible du VACUUM.
   Also, <command>VACUUM</command> requires a substantial amount of I/O
   traffic, which can cause poor performance for other active sessions.
   There are configuration parameters that can be adjusted to reduce the
   performance impact of background vacuuming &mdash; see
   <xref linkend="runtime-config-resource-vacuum-cost"/>.
  </para>

  <para>
   Un mécanisme automatisé de traitement des opérations <command>VACUUM</command>
   nécessaires a été ajouté dans <productname>PostgreSQL</productname> 8.1.
   Voir <xref linkend="autovacuum"/>.
  </para>

  <sect2 id="vacuum-for-space-recovery">
   <title>Récupérer l'espace disque</title>

   <indexterm zone="vacuum-for-space-recovery">
    <primary>espace disque</primary>
   </indexterm>

   <para>
    Dans son fonctionnement normal, <productname>PostgreSQL</productname> ne
    supprime pas immédiatement les versions périmées des lignes après un
    <command>UPDATE</command> ou un <command>DELETE</command>.  Cette approche est
    nécessaire pour la consistance des accès
    concurrents (voir le <xref linkend="mvcc"/>)&nbsp;: la version de la ligne ne
    doit pas être supprimée tant qu'elle est susceptible d'être lue par une
    autre transaction. Mais finalement, une ligne qui est plus vieille que
    toutes les transactions en cours n'est plus utile du tout. La place qu'elle
    utilise doit être rendu pour être réutilisée par d'autres lignes afin
    d'éviter un accroissement constant du volume occupé sur le disque. Cela est
    réalisé en exécutant <command>VACUUM</command>.
   </para>

   <para>
    Évidemment, une table qui subit beaucoup de mises à jour et suppressions
    nécessitera des nettoyages plus fréquents que les tables rarement modifiées.
    Il peut être pertinent de programmer périodiquement par <application>cron</application>
    des tâches spécifiques qui nettoient uniquement les tables concernées (avec
    <command>VACUUM</command>) et ignorent les tables que l'on sait peu
    modifiées. Ceci ne sera vraiment utile que s'il y a à la fois des tables
    volumineuses intensément modifiées et des tables volumineuses peu modifiées.
    En effet, le coût supplémentaire lié au nettoyage d'une petite table ne
    mérite pas que l'on s'en préoccupe.
   </para>

   <para>
    Il existe deux variantes de la commande <command>VACUUM</command>. La
    première forme, connu en tant que <quote>vacuum fainéant</quote> ou plus
    simplement <command>VACUUM</command>, marque les données expirées dans les
    tables et les index pour une utilisation future&nbsp;; il ne tente
    <emphasis>pas</emphasis> de récupérer l'espace utilisée par
    cette donnée expirée sauf si l'espace est à la fin de la table et qu'un
    verrou exclusif de table puisse être facilement obtenu. L'espace inutilisé
    au début ou au milieu du fichier ne résulte pas en un raccourcissement du
    fichier et de l'espace redonné au système d'exploitation. Cette variante de
    <command>VACUUM</command> peut être lancé en concurrence avec les autres
    opérations normales de la base de données.
   </para>

   <para>
   La seconde forme est la commande <command>VACUUM FULL</command>. Elle utilise
   un algorithme plus agressif pour récupérer l'espace consommé par les versions
   expirées des lignes. Tout espace qui est libéré par <command>VACUUM
   FULL</command> est immédiatement rendu au système d'exploitation.
   Malheureusement,
   cette variante de la commande <command>VACUUM</command> acquiert un verrou
   exclusif sur chaque table avant que <command>VACUUM FULL</command> ne la
   traite. Du coup, utiliser fréquemment <command>VACUUM FULL</command> peut
   avoir un effet extrêmement négatif sur les performances des requêtes
   concurrentes sur la base de données.
   </para>

   <para>
    La forme standard de <command>VACUUM</command> est mieux utilisé dans le but de
    maintenir une utilisation simple de l'espace disque. Donc, vous avez besoin
    de redonner de l'espace disque au système d'exploitation, vous pouvez
    utiliser <command>VACUUM FULL</command> &mdash; mais quel est l'intérêt de redonner
    de l'espace disque qui devra ensuite être de nouveau alloué&nbsp;? Des
    <command>VACUUM</command> standard et d'une fréquence modérée sont une meilleure
    approche que des <command>VACUUM FULL</command>, même non fréquents, pour maintenir
    des tables mises à jour fréquemment.
   </para>

   <para>
    La meilleure stratégie pour la plupart des sites est de planifier un
    <command>VACUUM</command> général sur toute la base une fois par jour, en dehors
    des horaires normaux de production, accompagné si nécessaire de nettoyages
    plus fréquents pour les tables subissant d'intenses modifications.
    (Quelques installations avec un taux extrêmement important des
    modifications de données lancent un <command>VACUUM</command> sur les
    tables très occupées jusqu'à une fois toutes les quelques minutes.) S'il y
    a plusieurs bases de données dans un cluster (groupe de bases de données),
    ne pas oublier de nettoyer chacune d'entre elles&nbsp;; l'exécutable
    <xref linkend="app-vacuumdb" endterm="app-vacuumdb-title"/> peut s'avérer utile.
   </para>

   <para>
    <command>VACUUM FULL</command> est recommandé dans les cas où vous savez que vous
    avez supprimé la majorité des lignes dans une table, de façon à ce que la
    taille de la table soit réduit de façon conséquente avec l'approche plus
    plus agressive de <command>VACUUM FULL</command>. Utilisez le <command>VACUUM</command>
    standard, et non pas <command>VACUUM FULL</command>, pour les nettoyages standards.
   </para>

   <para>
    Si vous avez une table dont le contenu entier est supprimé sur une base périodique,
    considérez de le faire avec <command>TRUNCATE</command> plutôt qu'avec
    <command>DELETE</command> suivi par un <command>VACUUM</command>.
    <command>TRUNCATE</command> supprime le contenu entier de la table
    immédiatement sans nécessiter un <command>VACUUM</command> ou
    <command>VACUUM FULL</command> pour réclamer l'espace disque maintenant
    inutilisé.
</para>
  </sect2>

  <sect2 id="vacuum-for-statistics">
   <title>Maintenir les statistiques du planificateur</title>

   <indexterm zone="vacuum-for-statistics">
    <primary>statistiques</primary>
    <secondary>du planificateur</secondary>
   </indexterm>

   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>

   <para>
    L'optimiseur de requêtes de <productname>PostgreSQL</productname> s'appuie
    sur des informations statistiques sur le contenu des tables dans l'optique
    de générer des plans d'exécutions efficaces pour les requêtes. Ces
    statistiques sont collectées par la commande <command>ANALYZE</command>, qui peut
    être invoquée seule ou comme une option de <command>VACUUM</command>. Il est
    important d'avoir des statistiques relativement à jour sans quoi des mauvais
    choix dans les plans d'exécution pourraient pénaliser la performance de la
    base.
   </para>

   <para>
    À l'instar du nettoyage pour récupérer l'espace, les statistiques doivent
    être plus souvent collectées pour les tables intensément modifiées que pour
    celles qui le sont moins. Mais même si la table est très modifiée, il se
    peut que ces collectes soient inutiles si la distribution probabiliste des
    données évolue peu. Une règle simple pour décider est de voir comment
    évoluent les valeurs minimum et maximum des données. Par exemple, une
    colonne de type <type>timestamp</type> qui contient la date de mise à jour
    de la ligne aura une valeur maximum en continuelle croissance au fur et à
    mesure des modifications&nbsp;; une telle colonne nécessitera plus de
    collectes statistiques qu'une colonne qui contient par exemple les URL des
    pages accédées sur un site web. La colonne qui contient les URL peut très
    bien être aussi souvent modifiée mais la distribution probabiliste des
    données changera certainement moins rapidement.
   </para>

   <para>
    Il est possible d'exécuter <command>ANALYZE</command> sur des tables spécifiques,
    voire des colonnes spécifiques&nbsp;; il a donc toute flexibilité pour
    mettre à jour certaines statistiques plus souvent que les autres en
    fonction des besoins de l'application. Quoi qu'il en soit, dans la pratique,
    il est généralement mieux de simplement analyser la base entière car il s'agit
    d'une opération rapide. Elle utilise un système d'échantillonage des lignes d'une
    table, ce qui lui évite de lire chaque ligne.
   </para>

   <tip>
    <para>
     Même si il n'est pas très productif de règler précisément la fréquence de
     <command>ANALYZE</command> pour chaque colonne, il peut être intéressant d'ajuster
     le niveau de détail des statistiques collectées pour chaque colonne. Les
     colonnes très utilisées dans les clauses <literal>WHERE</literal> et dont la
     distribution n'est pas uniforme requièrent des histogrammes plus précis
     que les autres colonnes. Voir <command>ALTER TABLE SET STATISTICS</command>.
    </para>
   </tip>

   <para>
    Pour la plupart des site, la meilleure stratégie est de programmer une
    collecte générale des statistiques sur toute la base, une fois par jour.
    Ceci peut être profitablement couplé avec un <command>VACUUM</command> (la nuit
    par exemple). Quoi qu'il en soit, les administrateurs des bases dont les
    statistiques changent peu pourront juger que cela est exagéré et que des
    exécutions moins fréquentes de <command>ANALYZE</command> sont bien suffisantes.
   </para>
  </sect2>

  <sect2 id="vacuum-for-wraparound">
   <title>Éviter les cycles des identifiants de transactions</title>

   <indexterm zone="vacuum-for-wraparound">
    <primary>identifiant de transaction</primary>
    <secondary>cycle</secondary>
   </indexterm>

   <para>
    Le mécanisme de contrôle de concurrence multiversion (<acronym>MVCC</acronym>) de
    <productname>PostgreSQL</productname> s'appuie sur la possibilité de
    comparer des identifiants de transactions (<acronym>XID</acronym>)&nbsp;; c'est un
    nombre croissant&nbsp;: la version d'une ligne dont le XID d'insertion est
    supérieur au XID de la transaction en cours est <quote>dans le futur</quote> et
    ne doit pas être visible de la transaction courante. Comme les identifiants
    ont une taille limitée (32 bits à ce jour), un groupe qui est en activité
    depuis longtemps (plus de 4 milliards de transactions) pourrait connaître un
    cycle des identifiants de transaction&nbsp;: le XID reviendra à 0 et
    soudainement les transactions du passé sembleront appartenir au futur - ce
    qui signifie qu'elles deviennent invisibles. En bref, perte de données
    totale. (En réalité, les données sont toujours là mais c'est un piètre
    réconfort puisqu'elles resteront inaccessibles.) Pour éviter ceci, il est
    nécessaire d'exécuter un VACUUM sur chaque table de chaque base au moins
    au moins une fois à chaque milliard de transactions.
   </para>

   <para>
    The reason that periodic vacuuming solves the problem is that
    <productname>PostgreSQL</productname> distinguishes a special XID
    <literal>FrozenXID</literal>.  This XID is always considered older
    than every normal XID. Les XID normaux sont comparés sur une base
    modulo-2<superscript>31</superscript>. Cela signifie
    que pour chaque XID normal, il y en a deux milliards qui sont plus vieux et
    deux milliards qui sont plus récents. Une autre manière de le dire est que
    l'ensemble de définition des XID est circulaire et sans limite. De plus,
    une ligne créée avec un XID normal donné, la version de la ligne apparaîtra
    comme appartenant au passé pour les deux milliards de transactions qui
    suivront quelque soit le XID. Si la ligne existe encore après deux milliards
    de transactions, elle apparaîtra soudainement comme appartenant au futur.
    Pour éviter la disparition des données, les versions trop anciennes doivent
    se voir affecter le XID <literal>FrozenXID</literal> avant d'atteindre le seuil
    fatidique des deux milliards de transactions. Une fois qu'elles ont ce XID
    spécifique, elles appartiendront au passé pour toutes les transactions même
    en cas de cycle. Cette affectation des anciens XID est réalisée par
    <command>VACUUM</command>.
   </para>

   <para>
    <command>VACUUM</command>'s behavior is controlled by the configuration parameter
    <xref linkend="guc-vacuum-freeze-min-age"/>: any XID older than
    <varname>vacuum_freeze_min_age</varname> transactions is replaced by
    <literal>FrozenXID</literal>.  Larger values of <varname>vacuum_freeze_min_age</varname>
    preserve transactional information longer, while smaller values increase
    the number of transactions that can elapse before the table must be
    vacuumed again.
   </para>

   <para>
    The maximum time that a table can go unvacuumed is two billion
    transactions minus the <varname>vacuum_freeze_min_age</> that was used
    when it was last vacuumed.
    If it were to go unvacuumed for longer than that,
    data loss could result.  To ensure that this does not
    happen, the <firstterm>autovacuum</> facility described in
    <xref linkend="autovacuum"> is invoked on any table
    that might contain XIDs older than the age specified by the
    configuration parameter
    <xref linkend="guc-autovacuum-freeze-max-age">.  (This will happen
    even if autovacuum is otherwise disabled.)
   </para>

   <para>
    This implies that if a table is not otherwise vacuumed,
    autovacuum will be invoked on it approximately once every
    <varname>autovacuum_freeze_max_age</varname> minus
    <varname>vacuum_freeze_min_age</varname> transactions.
    For tables that are regularly vacuumed for space reclamation purposes,
    this is of little importance.  However, for static tables
    (including tables that receive inserts, but no updates or deletes),
    there is no need for vacuuming for space reclamation, and so it can
    be useful to try to maximize the interval between forced autovacuums
    on very large static tables.  Obviously one can do this either by
    increasing <varname>autovacuum_freeze_max_age</varname> or by decreasing
    <varname>vacuum_freeze_min_age</varname>.
   </para>

   <para>
    The sole disadvantage of increasing <varname>autovacuum_freeze_max_age</varname>
    is that the <filename>pg_clog</filename> subdirectory of the database cluster
    will take more space, because it must store the commit status for all
    transactions back to the <varname>autovacuum_freeze_max_age</varname> horizon.
    The commit status uses two bits per transaction, so if
    <varname>autovacuum_freeze_max_age</varname> has its maximum allowed value of
    a little less than two billion, <filename>pg_clog</filename> can be expected to
    grow to about half a gigabyte.  If this is trivial compared to your
    total database size, setting <varname>autovacuum_freeze_max_age</varname> to
    its maximum allowed value is recommended.  Otherwise, set it depending
    on what you are willing to allow for <filename>pg_clog</filename> storage.
    (The default, 200 million transactions, translates to about 50MB of
    <filename>pg_clog</filename> storage.)
   </para>

   <para>
    One disadvantage of decreasing <varname>vacuum_freeze_min_age</varname> is that
    it may cause <command>VACUUM</command> to do useless work: changing a table row's
    XID to <literal>FrozenXID</literal> is a waste of time if the row is modified
    soon thereafter (causing it to acquire a new XID).  So the setting should
    be large enough that rows are not frozen until they are unlikely to change
    any more.  Another disadvantage of decreasing this setting is
    that details about exactly which transaction inserted or modified a
    row will be lost sooner.  This information sometimes comes in handy,
    particularly when trying to analyze what went wrong after a database
    failure.  For these two reasons, decreasing this setting is not
    recommended except for completely static tables.
   </para>

   <para>
    To track the age of the oldest XIDs in a database,
    <command>VACUUM</command> stores XID
    statistics in the system tables <structname>pg_class</structname> and
    <structname>pg_database</structname>.  In particular,
    the <structfield>relfrozenxid</structfield> column of a table's
    <structname>pg_class</structname> row contains the freeze cutoff XID that was used
    by the last <command>VACUUM</command> for that table.  All normal
    XIDs older than this cutoff XID are guaranteed to have been replaced by
    <literal>FrozenXID</literal> within the table.  Similarly,
    the <structfield>datfrozenxid</structfield> column of a database's
    <structname>pg_database</structname> row is a lower bound on the normal XIDs
    appearing in that database &mdash; it is just the minimum of the
    per-table <structfield>relfrozenxid</structfield> values within the database.
    A convenient way to
    examine this information is to execute queries such as

<programlisting>
SELECT relname, age(relfrozenxid) FROM pg_class WHERE relkind = 'r';
SELECT datname, age(datfrozenxid) FROM pg_database;</programlisting>

    The <literal>age</literal> column measures the number of transactions from the
    cutoff XID to the current transaction's XID.  Immediately after a
    <command>VACUUM</command>, <literal>age(relfrozenxid)</literal> should be a little
    more than the <varname>vacuum_freeze_min_age</varname> setting that was used
    (more by the number of transactions started since the <command>VACUUM</command>
    started).  If <literal>age(relfrozenxid)</literal> exceeds
    <varname>autovacuum_freeze_max_age</varname>, an autovacuum will soon be forced
    for the table.
   </para>

   <para>
    If for some reason autovacuum fails to clear old XIDs from a table,
    the system will begin to emit warning messages like this when the
    database's oldest XIDs reach ten million transactions from the wraparound
    point:

<programlisting>
WARNING:  database "mydb" must be vacuumed within 177009986 transactions
HINT:  To avoid a database shutdown, execute a full-database VACUUM in "mydb".
</programlisting>

    If these warnings are
    ignored, the system will shut down and refuse to execute any new
    transactions once there are fewer than 1 million transactions left
    until wraparound:

<programlisting>
ERROR:  database is shut down to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and use a standalone backend to VACUUM in "mydb".</programlisting>

    La marge de sécurité de un million de transactions existe pour permettre à
    l'administrateur de récupérer ces données sans perte en exécutant
    manuellement les commandes <command>VACUUM</command> requises. Néanmoins, comme le
    système n'excutera pas de commandes tant qu'il ne sera pas sorti du mode
    d'arrêt par sécurité, la seule façon de le faire est de stopper le
    serveur et d'utiliser un moteur simple utilisateur pour exécuter le
    <command>VACUUM</command>. Le mode d'arrêt n'est pas pris en compte par le moteur
    simple utilisateur. Voir la page de référence de <xref linkend="app-postgres"/> pour
    des détails sur l'utilisation du moteur simple utilisateur.
   </para>
  </sect2>

  <sect2 id="autovacuum">
   <title id="autovacuum-title">Le démon auto-vacuum</title>

   <indexterm>
    <primary>autovacuum</primary>
    <secondary>information générale</secondary>
   </indexterm>
   <para>
    À partir de <productname>PostgreSQL </productname> 8.1, il existe un
    processus serveur optionnel et séparé appelé le <firstterm>démon
    autovacuum</firstterm>, dont le but est d'automatiser l'exécution des
    commandes <command>VACUUM</command> et <command>ANALYZE </command>. Une
    fois activé, le démon autovacuum s'exécute périodiquement et vérifie les
    tables ayant un grand nombre de lignes insérées, mises à jour ou
    supprimées. Ces vérifications utilisent la fonctionnalité de récupération
    de statistiques au niveau ligne&nbsp;; du coup, le démon autovacuum ne peut
    pas être utilisé sauf si <xref linkend="guc-stats-start-collector"/> et <xref
    linkend="guc-stats-row-level"/> sont configurés à <literal>true</literal>.
    De plus, il est important d'autoriser un emplacement pour le processus
    autovacuum lors du choix de la valeur de <xref
    linkend="guc-superuser-reserved-connections"/>.
   </para>

   <para>
    The autovacuum daemon, when enabled, runs every <xref
    linkend="guc-autovacuum-naptime"/> seconds.  On each run, it selects
    one database to process and checks each table within that database.
    <command>VACUUM</command> or <command>ANALYZE</command> commands are
    issued as needed.
   </para>

   <para>
    Tables whose <structfield>relfrozenxid</> value is more than
    <varname>autovacuum_freeze_max_age</> transactions old are always
    vacuumed.  Otherwise,
    two conditions are used to determine which operation(s)
    to apply. Si le nombre de lignes obsolètes depuis le dernier
    <command>VACUUM</command> dépasse une <quote>limite de vacuum</quote>, la
    table bénéficie d'un VACUUM. La limite est définie
    ainsi&nbsp;:
<programlisting>limite du vacuum = limite de base du vacuum + facteur d'échelle du vacuum * nombre de lignes</programlisting>
    où la limite de base du vacuum est
    <xref linkend="guc-autovacuum-vacuum-threshold"/>,
    le facteur d'échelle du vacuum est
    <xref linkend="guc-autovacuum-vacuum-scale-factor"/>
    et le nombre de lignes est
    <structname>pg_class</structname>.<structfield>reltuples</structfield>.
    Le nombre de lignes obsolètes est obtenu à partir du récupérateur de
    statistiques&nbsp;; c'est un nombre à peu près précis, mis à jour après
    chaque instruction <command>UPDATE</command> et <command>DELETE</command>
    (il est seulement à peu près précis car certaines informations pourraient
    être perdues en cas de grosse charge). Pour ANALYZE, une condition similaire
    est utilisée&nbsp;: la limite, définie comme
<programlisting>limite du analyze = limite de base du analyze + facteur d'échelle du analyze * nombre de lignes</programlisting>
    est comparée au nombre de lignes insérées, mises à jour ou supprimées depuis
    le dernier <command>ANALYZE</command>.
   </para>

   <para>
    Les limites et facteurs d'échelle par défaut sont pris dans
    <filename>postgresql.conf</filename> mais il est possible de les surcharger
    table par table avec des entrées dans le catalogue système <link
    linkend="catalog-pg-autovacuum"><structname>pg_autovacuum</structname></link>.
    Si une ligne <structname>pg_autovacuum</structname> existe pour une table
    particulière, les paramètres qu'il spécifie sont appliqués&nbsp;; sinon les
    paramètres globaux sont utilisés. Voir <xref linkend="runtime-config-autovacuum"/>
    pour plus de détails sur les paramètres globaux.
   </para>

   <para>
    En plus des valeurs de la limite de base et des facteurs d'échelle, il
    existe cinq autres paramètres pouvant être configurés pour chaque table
    dans <structname>pg_autovacuum</structname>. Le premier,
    <structname>pg_autovacuum</structname>.<structfield>enabled</structfield>,
    peut être configuré à <literal>false</literal> pour instruire le démon
    autovacuum de laisser cette table particulière. Dans ce cas, autovacuum
    touchera seulement la table quand il devra le faire pour prévenir la
    réinitialisation de l'ID de transaction. Les deux paramètres suivants, le
    délai du coût du VACUUM
    (<structname>pg_autovacuum</structname>.<structfield>vac_cost_delay</structfield>)
    et la limite du coût du VACUUM
    (<structname>pg_autovacuum</structname>.<structfield>vac_cost_limit</structfield>),
    sont utilisés pour configurer des valeurs spécifiques aux tables pour
    la fonctionnalité <xref linkend="runtime-config-resource-vacuum-cost"
    endterm="runtime-config-resource-vacuum-cost-title"/>.
    The last two parameters,
    (<structname>pg_autovacuum</structname>.<structfield>freeze_min_age</structfield>)
    and
    (<structname>pg_autovacuum</structname>.<structfield>freeze_max_age</structfield>), 
    are used to set table-specific values for
    <xref linkend="guc-vacuum-freeze-min-age"> and
    <xref linkend="guc-autovacuum-freeze-max-age"> respectively.
   </para>

   <para>
    Si une des valeurs dans <structname>pg_autovacuum</structname> est négative
    ou si aucune ligne n'est présente dans <structname>pg_autovacuum</structname>
    quelque soit la table, les valeurs correspondantes de
    <filename>postgresql.conf</filename> sont utilisées.
   </para>

   <para>
    Il n'y a pas de support pour créer des entrées dans
    <structname>pg_autovacuum</structname>, sauf en réalisant soi-même des
    insertions manuelles dans le catalogue. Cette fonctionnalité sera améliorée
    dans les prochaines versions et il est vraisemblable que la définition du
    catalogue changera.
   </para>

   <caution>
    <para>
     Le contenu du catalogue système <structname>pg_autovacuum</structname>
     n'est actuellement pas pris en compte dans les sauvegardes de bases de
     données créées par les outils <command>pg_dump</command> et
     <command>pg_dumpall</command>. Si vous voulez les préserver après
     un cycle sauvegarde/restauration, assurez-vous que vous avez sauvegardé
     manuellement le catalogue.
    </para>
   </caution>

  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
  <title>Ré-indexation régulière</title>

  <indexterm zone="routine-reindex">
   <primary>ré-indexation</primary>
  </indexterm>

  <para>
   Dans certains cas, reconstruire périodiquement les index par la commande
   <xref linkend="sql-reindex" endterm="sql-reindex-title"/> vaut la peine.
  </para>

  <para>
   Dans les versions <productname>PostgreSQL</productname> antérieures à la 7.4, la
   réindexation périodique était fréquemment nécessaire pour éviter
   l'<quote>inflation des index</quote>, à cause d'un manque de récupération de
   l'espace interne dans les index B-tree. Toutes les situations dans lesquelles
   l'échelle des clés d'index change dans le temps &mdash; par exemple, un index
   sur l'horodatage dans une table où les anciennes entrées sont finalement
   supprimées &mdash; pourraient résulter en une inflation car les pages d'index
   des portions inutilisées de cet ensemble n'étaient pas réclamées pour être
   ré-utilisées. Au bout d'un certain temps, la taille de l'index pouvait
   devenir indéfiniment plus large que les données utiles qu'elle contient.
  </para>

  <para>
   Dans les versions 7.4 et ultérieures de <productname>PostgreSQL</productname>, les pages
   d'index pages qui sont devenues complètement vides sont récupérées pour être
   réutilisées. Il existe toujours une possibilité d'une utilisation inefficace
   de l'espace&nbsp;: si pratiquement toutes les clés d'index d'une page ont été
   supprimées, la page reste allouée. Donc, le cas d'une utilisation où la
   majorité des clés de l'index d'une page est supprimée est un cas où l'espace
   sera mal utilisé. La possibilité d'inflation n'est pas indéfinie &mdash; au
   pire, il reste une clé par page &mdash; mais il serait toujours utile de
   planifier une réindexation périodique pour les index ayant un tel usage.
  </para>

  <para>
   Le potentiel d'inflation des index qui ne sont pas des index B-tree n'a pas
   été particulièrement analysé. Garder un &oelig;il sur la taille physique de
   ces index est une bonne idée.
  </para>

  <para>
   De plus, pour les index B-tree, un index tout juste construit est quelque peu
   plus rapide qu'un index qui a été mis à jour plusieurs fois parce que
   les pages adjacentes logiquement sont habituellement aussi physiquement
   adjacentes dans un index nouvellement créé (cette considération ne s'applique
   pas aux index non B-tree). Il pourrait être intéressant de ré-indexer
   périodiquement simplement pour améliorer la vitesse d'accès.
  </para>
 </sect1>


 <sect1 id="logfile-maintenance">
  <title>Maintenance du fichier de traces</title>

  <indexterm zone="logfile-maintenance">
   <primary>traces serveur</primary>
   <secondary>maintenance du fichier de traces</secondary>
  </indexterm>

  <para>
   Sauvegarder les journaux de trace du serveur de bases de données dans un
   fichier plutôt que dans <filename>/dev/NULL</filename> est une bonne idée. Les
   journaux sont d'une utilité incomparable lorsqu'arrive le moment où des
   problèmes surviennent. Néanmoins, les journaux ont tendance à être
   volumineux (tout spécialement à des niveaux de débogage importants) et vous
   ne voulez pas les sauvegarder indéfiniment. Vous avez besoin de faire une
   <quote>rotation</quote> des journaux pour que les nouveaux journaux sont
   commencés et que les anciens soient supprimés après une période de temps
   raisonnable.
  </para>

  <para>
   Si vous redirigez simplement <systemitem>stderr</systemitem> du
   <command>postgres</command> dans un fichier, vous aurez un journal des
   traces mais la seule façon de le tronquer sera d'arrêter et de relancer
   le serveur. Ceci peut convenir si vous utilisez
   <productname>PostgreSQL</productname> dans un environnement de développement
   mais peu de serveurs de production trouveraient ce comportement acceptable.
  </para>

  <para>
   Une meilleure approche est d'envoyer la sortie <systemitem>stderr</systemitem>
   du serveur dans un programme de rotation de journaux. Il
   existe un programme interne de rotation que vous pouvez utiliser en
   configurant le paramètre <literal>redirect_stderr</literal> à
   <literal>true</literal> dans <filename>postgresql.conf</filename>. Les paramètres de
   contrôle pour ce programme sont décrits dans <xref
   linkend="runtime-config-logging-where"/>.
  </para>

  <para>
   Sinon, vous pourriez préférer utiliser un programme externe de rotation de
   journaux si vous en utilisez déjà un avec d'autres serveurs. Par exemple,
   l'outil <application>rotatelogs</application> inclus dans la distribution
   <productname>Apache</productname> peut être utilisé avec
   <productname>PostgreSQL</productname>. Pour cela, envoyez via un tube la
   sortie <systemitem>stderr</systemitem> du serveur dans le programme
   désiré. Si vous lancez le serveur avec <command>pg_ctl</command>, alors
   <systemitem>stderr</systemitem> est déjà directement renvoyé dans
   <systemitem>stdout</systemitem>, donc vous avez juste besoin d'ajouter la commande via
   un tube, par exemple&nbsp;:

<programlisting>pg_ctl start | rotatelogs /var/log/pgsql_log 86400</programlisting>
</para>

  <para>
   Une autre approche de production pour la gestion des journaux de trace est
   de les envoyer à <application>syslog</application> et de laisser <application>syslog</application>
   gérer la rotation des fichiers. Pour cela, initialisez le paramètre de
   configuration <literal>log_destination</literal> à <literal>syslog</literal> (pour tracer
   uniquement via <application>syslog</application>) dans <filename>postgresql.conf</filename>.
   Ensuite, vous pouvez envoyer un signal <literal>SIGHUP</literal> au démon
   <application>syslog</application> quand vous voulez le forcer à écrire dans un nouveau
   fichier. Si vous voulez automatiser la rotation des journaux, le programme
   <application>logrotate</application> peut être configuré pour fonctionner
   avec les journaux de traces provenant de <application>syslog</application>.
  </para>

  <para>
   Néanmoins, sur beaucoup de systèmes, <application>syslog</application> n'est pas très
   fiable, particulièrement avec les messages très gros&nbsp;; il pourrait
   tronquer ou supprimer des messages au moment où vous en aurez le plus besoin.
   De plus, sur <productname>Linux</productname>, <application>syslog</application> synchronisera tout
   message sur disque, amenant des performances assez pauvres. (Vous pouvez
   utiliser un <literal>-</literal> au début du nom de fichier dans le fichier de
   configuration <application>syslog</application> pour désactiver ce comportement.)
  </para>

  <para>
   Notez que toutes les solutions décrites ci-dessus font attention à lancer de
   nouveaux journaux de traces à des intervalles configurables mais ils ne
   gèrent pas la suppression des vieux fichiers de traces, qui ne sont
   probablement plus très intéressants. Vous voudrez probablement configurer
   un script pour supprimer périodiquement les anciens journaux. Une autre
   possibilité est de configurer le programme de rotation pour que les anciens
   journaux de traces soient écrasés de façon cyclique.
  </para>
 </sect1>
</chapter>
