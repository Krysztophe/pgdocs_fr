<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="maintenance">
 <title>Planifier les tâches de maintenance</title>

 <indexterm zone="maintenance">
  <primary>maintenance</primary>
 </indexterm>

 <indexterm zone="maintenance">
  <primary>routine maintenance</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname>, comme tout SGBD, requiert que certains
   tâches soient réalisées de façon régulière pour atteindre les performances
   optimales. Ces tâches, discutées maintenant, sont <emphasis>requises</emphasis>
   mais elles sont répétitives par nature et peuvent être facilement automatisées
   en utilisant des outils standards comme les scripts
   <application>cron</application> ou le <application>Task Scheduler</application>
   de Windows. La responsabilité de la mise en place de ces
   scripts et du contrôle de leur bon fonctionnement relève de l'administrateur
   de la base.
  </para>

  <para>
   Une opération de maintenance évidente est la sauvegarde régulière des
   données. Sans une sauvegarde récente il est impossible de restaurer après
   un dommage grave (perte d'un disque, incendie, table supprimée par erreur,
   etc.). Les mécanismes de sauvegarde et restauration disponibles dans
   <productname>PostgreSQL</productname> sont détaillés dans le <xref
   linkend="backup"/>.
  </para>

  <para>
   L'autre tâche primordiale est de réaliser périodiquement un <quote>vacuum</quote>,
   c'est à dire <quote>faire le vide</quote> dans la base de données.
   Cette opération est détaillée dans la <xref linkend="routine-vacuuming"/>.
   La mise à jour des statistiques qui seront utilisées par le planificateur de
   requêtes sera discutée dans <xref linkend="vacuum-for-statistics"/>.
  </para>

  <para>
   La gestion du fichier de traces mérite aussi une attention régulière.
   Cela est détaillé dans la <xref linkend="logfile-maintenance"/>.
  </para>

  <para>
   <ulink
   url="http://bucardo.org/check_postgres/"><application>check_postgres.pl</application></ulink>
   est disponible pour surveiller la santé des bases de données et pour
   rapporter des conditions inhabituelles. <application>check_postgres.pl</application>
   s'intègre bien avec Nagios et MRTG, mais il peut aussi fonctionner en autonome.
  </para>

  <para>
   <productname>PostgreSQL</productname> demande peu de maintenance par rapport
   à d'autres SGBD. Néanmoins, un suivi vigilant de ces tâches participera
   beaucoup à rendre le système productif et agréable à utiliser.
  </para>

 <sect1 id="routine-vacuuming">
  <title>Nettoyages réguliers</title>

  <indexterm zone="routine-vacuuming">
   <primary>vacuum</primary>
  </indexterm>

  <para>
   Le SGBD <productname>PostgreSQL</productname> nécessite des opérations de
   maintenance périodique connues sous le nom de <firstterm>VACUUM</firstterm>.
   Pour de nombreuses installations, il est suffisant de laisser travailler le
   <firstterm>démon autovacuum</firstterm>, qui est décrit dans <xref
   linkend="autovacuum"/>. Vous pourriez avoir besoin d'ajuster les paramètres
   de cet outil décrit ici pour obtenir de meilleurs résultats dans votre cas.
   Certains administrateurs de bases de données voudront suppléer ou remplacer
   les activités du démon avec une gestion manuelle des commandes
   <command>VACUUM</command>, qui seront typiquement exécutées suivant un
   planning par des scripts <application>cron</application> ou par le
   <application>Task Scheduler</application>. Pour configurer une gestion
   manuelle et correcte du VACUUM, il est essentiel de bien comprendre les
   quelques sous-sections suivantes. Les administrateurs qui se basent sur
   l'autovacuum peuvent toujours lire ces sections pour les aider à comprendre
   et à ajuster l'autovacuum.
  </para>

  <sect2 id="vacuum-basics">
   <title>Bases du VACUUM</title>

  <para>
   La commande <xref linkend="sql-vacuum" endterm="sql-vacuum-title"/> de
   <productname>PostgreSQL</productname> doit traiter chaque table régulièrement
   pour plusieurs raisons&nbsp;:

    <orderedlist>
     <listitem>
      <simpara>pour récupérer ou ré-utiliser l'espace disque occupé par les lignes supprimées
      ou mises à jour&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour mettre à jour les statistiques utilisées par l'optimiseur de
      <productname>PostgreSQL</productname>&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour prévenir la perte des données les plus anciennes à cause
      d'un <firstterm>cycle de l'identifiant de transaction (XID)</firstterm>.</simpara>
     </listitem>
    </orderedlist>

    Chacune de ces raisons impose de réaliser des opérations <command>VACUUM</command>
    de différentes fréquences et portées, comme expliqué dans les sous-sections
    suivantes.
   </para>

   <para>
    Il y a deux variantes de la commande <command>VACUUM</command>&nbsp;:
    <command>VACUUM</command> standard et <command>VACUUM FULL</command>.
    <command>VACUUM FULL</command> peut récupérer davantage d'espace disque mais
    s'exécute beaucoup plus lentement. Par ailleurs, la forme standard de
    <command>VACUUM</command> peut s'exécuter en parallèle avec les opérations
    de production des bases. Des commandes comme <command>SELECT</command>,
    <command>INSERT</command>, <command>UPDATE</command> et
    <command>DELETE</command> continueront de fonctionner de façon normale,
    bien que vous ne pourrez plus modifier la définition d'une table avec des
    commandes telles que <command>ALTER TABLE</command> pendant qu'elle sera en
    cours de <command>VACUUM</command>.
    <command>VACUUM FULL</command> nécessite un verrou exclusif sur la table sur
    laquelle il travaille, et ne peut donc pas être exécuté en parallèle avec une
    autre activité sur la table. Un autre inconvénient de 
    <command>VACUUM FULL</command> est que, bien qu'il réduise la taille des
    tables, il ne réduit pas la taille des index en proportion&nbsp;; en réalité,
    il peut rendre les index plus <emphasis>grands</emphasis>. En règle générale,
    par conséquent, les administrateurs devraient s'efforcer d'utiliser la commande
    standard <command>VACUUM</command> et éviter <command>VACUUM FULL</command>.
   </para>

   <para>
    <command>VACUUM</command> génère un nombre important d'entrées/sorties,
    ce qui peut entraîner de mauvaises performances pour les autres sessions
    actives. Des paramètres de configuration peuvent être ajustés pour réduire
    l'impact d'une opération VACUUM en arrière plan sur les
    performances&nbsp;&mdash; voir
    <xref linkend="runtime-config-resource-vacuum-cost"/>.
   </para>
  </sect2>

  <sect2 id="vacuum-for-space-recovery">
   <title>Récupérer l'espace disque</title>

   <indexterm zone="vacuum-for-space-recovery">
    <primary>espace disque</primary>
   </indexterm>

   <para>
    Avec <productname>PostgreSQL</productname>, les versions périmées des
    lignes ne sont pas immédiatement supprimées après une commande
    <command>UPDATE</command> ou <command>DELETE</command>.  Cette approche est
    nécessaire pour la consistance des accès
    concurrents (voir le <xref linkend="mvcc"/>)&nbsp;: la version de la ligne ne
    doit pas être supprimée tant qu'elle est susceptible d'être lue par une
    autre transaction. Mais finalement, une ligne qui est plus vieille que
    toutes les transactions en cours n'est plus utile du tout. La place qu'elle
    utilise doit être rendue pour être réutilisée par d'autres lignes afin
    d'éviter un accroissement constant du volume occupé sur le disque. Cela est
    réalisé en exécutant <command>VACUUM</command>.
   </para>

   <para>
    La forme standard de <command>VACUUM</command> élimine les versions 
    d'enregistrements morts  dans les tables et les index et marque l'espace
    comme réutilisable. Néanmoins, il ne rendra pas cet espace au système
    d'exploitation, sauf dans le cas spécial où des pages à la fin d'une table
    deviennent totalement vides et on peut facilement obtenir un verrou exclusif
    sur la table. Par opposition, <command>VACUUM FULL</command> compacte
    activement les tables en déplaçant les enregistrements vers des pages plus
    proches du début de la table. Il est par conséquent capable de forcer les pages
    de la fin de la table à être entièrement vides, grâce à quoi il pourra les
    rendre au système d'exploitation. Toutefois, si de nombreux enregistrements
    doivent être déplacés, l'opération peut durer très longtemps. Par ailleurs,
    déplacer un enregistrement demande de créer des entrées d'index dupliquées
    pour lui de façon temporaire (l'entrée pointant vers sa nouvelle adresse
    doit être crée avant que l'ancienne entrée ne puisse être supprimée)&nbsp;;
    la conséquence est que déplacer un grand nombre d'enregistrement peut faire
    fortement grossir l'index.
   </para>

   <para>
    Le but habituel d'un vacuum régulier est de lancer des <command>VACUUM</command>
    standards suffisamment souvent pour éviter d'avoir recours à
    <command>VACUUM FULL</command>. Le démon autovacuum essaie de fonctionner de
    cette façon, et n'exécutera jamais de <command>VACUUM FULL</command>. Avec
    cette approche, l'idée directrice n'est pas de maintenir les tables à leur
    taille minimale, mais de maintenir l'utilisation de l'espace disque à un niveau
    constant&nbsp;: chaque table occupe l'espace équivalent à sa taille minimum plus
    la quantité d'espace consommée entre deux vacuums. Bien que <command>VACUUM FULL</command>
    puisse être utilisé pour retourner une table à sa taille minimale et rendre
    l'espace disque au système d'exploitation, cela ne sert pas à grand chose,
    si cette table recommence à grossir dans un futur proche. Par conséquent,
    cette approche s'appuyant sur des commandes <command>VACUUM</command>
    exécutées à intervalles modérément rapprochés est une meilleure approche que
    d'exécuter des <command>VACUUM FULL</command> espacés pour des tables
    mises à jour de façon intensive.
   </para>

   <para>
    Certains administrateurs préfèrent planifier le passage de <command>VACUUM</command>
    eux-mêmes, par exemple faire le travail de nuit, quand la charge est faible.
    La difficulté avec cette stratégie est que si une table a un pic d'activité
    de mise à jour inattendu, elle pourrait grossir au point qu'un
    <command>VACUUM FULL</command> soit vraiment nécessaire pour récupérer
    l'espace. L'utilisation du démon d'autovacuum mitige ce problème, puisque
    le démon planifie les vacuum de façon dynamique, en réponse à l'activité
    de mise à jour. Il est peu raisonnable de désactiver totalement le démon,
    sauf si votre base a une activité extrêmement prévisible. Un compromis possible
    est de régler les paramètres du démon afin qu'il ne réagisse qu'à une activité
    exceptionnellement lourde de mise à jour, afin d'éviter seulement de perdre
    totalement le contrôle de la volumétrie, tout en laissant les 
    <command>VACUUM</command> planifiés faire le gros du travail quand la charge
    est normale.
   </para>

   <para>
    Pour ceux qui n'utilisent pas autovacuum, une approche typique alternative est de
    planifier un <command>VACUUM</command> sur la base complète une fois
    par jour lorsque l'utilisation n'est pas grande, avec en plus des
    opérations de <command>VACUUM</command> plus fréquentes pour les tables
    très impactées par des mises à jour, de la façon adéquate.
    (Certaines installations avec énormément de mises à jour peuvent exécuter
    des VACUUM toutes les quelques minutes.) Si vous avez plusieurs bases dans
    un cluster, n'oubliez pas d'exécuter un <command>VACUUM</command> sur
    chacune d'elles&nbsp;; le programme <xref
    linkend="app-vacuumdb" endterm="app-vacuumdb-title"/> pourrait être utile.
   </para>

   <tip>
   <para>
    Aucune des deux formes de <command>VACUUM</command> n'est entièrement
    satisfaisante quand une table contient un grand nombre d'enregistrements
    morts comme conséquence d'une mise à jour ou suppression massive.
    Si vous avez une table de ce genre, et que vous avez besoin de récupérer
    l'espace disque gaspillé, la meilleure façon est d'utiliser 
    <xref linkend="sql-cluster" endterm="sql-cluster-title"/> ou une des
    variantes de <xref linkend="sql-altertable" endterm="sql-altertable-title"/>.
    Ces commandes écrivent une nouvelle copie de la table et créent de nouveaux
    index pour elle. Comme <command>VACUUM FULL</command>, elles nécessitent
    un verrou exclusif. Notez qu'elles utilisent aussi temporairement de
    l'espace disque supplémentaire, puisque les anciennes copies de la table et des
    index ne peuvent être rendues tant que les nouvelles ne sont pas complètes.
    Dans le pire des scénarios, si votre disque est presque plein,
    <command>VACUUM FULL</command> peut être la seule alternative envisageable.
   </para>
   </tip>

   <tip>
   <para>
    Si vous avez une table dont le contenu entier est supprimé sur une base périodique,
    considérez de le faire avec <xref linkend="sql-truncate" endterm="sql-truncate-title"/> plutôt qu'avec
    <command>DELETE</command> suivi par un <command>VACUUM</command>.
    <command>TRUNCATE</command> supprime le contenu entier de la table
    immédiatement sans nécessiter un <command>VACUUM</command> ou
    <command>VACUUM FULL</command> pour réclamer l'espace disque maintenant
    inutilisé.
    Le désavantage est que les sémantiques MCC stricts sont violées.
   </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-statistics">
   <title id="vacuum-for-statistics-title">Maintenir les statistiques du planificateur</title>

   <indexterm zone="vacuum-for-statistics">
    <primary>statistiques</primary>
    <secondary>du planificateur</secondary>
   </indexterm>

   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>

   <para>
    L'optimiseur de requêtes de <productname>PostgreSQL</productname> s'appuie
    sur des informations statistiques sur le contenu des tables dans l'optique
    de générer des plans d'exécutions efficaces pour les requêtes. Ces
    statistiques sont collectées par la commande <xref linkend="sql-analyze"
    endterm="sql-analyze-title"/>, qui peut
    être invoquée seule ou comme une option de <command>VACUUM</command>. Il est
    important d'avoir des statistiques relativement à jour sans quoi des mauvais
    choix dans les plans d'exécution pourraient pénaliser les performances de la
    base.
   </para>

   <para>
    Le démon d'autovacuum, si activé, va automatiquement exécuter des commandes
    <command>ANALYZE</command> à chaque fois que le contenu d'une table aura
    changé suffisamment. Toutefois, des administrateurs peuvent préférer se fier
    à des opérations <command>ANALYZE</command> planifiées manuellement,
    en particulier s'il est connu que l'activité de mise à jour de la table
    n'aura pas d'impact sur les statistiques des colonnes <quote>intéressantes</quote>.
    Le démon planifie des <command>ANALYZE</command> uniquement en fonction
    du nombre d'enregistrements insérés, mis à jour ou supprimés&nbsp;
   </para>

   <para>
    À l'instar du nettoyage pour récupérer l'espace, les statistiques doivent
    être plus souvent collectées pour les tables intensément modifiées que pour
    celles qui le sont moins. Mais même si la table est très modifiée, il se
    peut que ces collectes soient inutiles si la distribution probabiliste des
    données évolue peu. Une règle simple pour décider est de voir comment
    évoluent les valeurs minimum et maximum des données. Par exemple, une
    colonne de type <type>timestamp</type> qui contient la date de mise à jour
    de la ligne aura une valeur maximum en continuelle croissance au fur et à
    mesure des modifications&nbsp;; une telle colonne nécessitera plus de
    collectes statistiques qu'une colonne qui contient par exemple les URL des
    pages accédées sur un site web. La colonne qui contient les URL peut très
    bien être aussi souvent modifiée mais la distribution probabiliste des
    données changera certainement moins rapidement.
   </para>

   <para>
    Il est possible d'exécuter <command>ANALYZE</command> sur des tables spécifiques,
    voire des colonnes spécifiques&nbsp;; il a donc toute flexibilité pour
    mettre à jour certaines statistiques plus souvent que les autres en
    fonction des besoins de l'application. Quoi qu'il en soit, dans la pratique,
    il est généralement mieux de simplement analyser la base entière car il s'agit
    d'une opération rapide. <command>ANALYZE</command> utilise un système d'échantillonage des lignes d'une
    table, ce qui lui évite de lire chaque ligne.
   </para>

   <tip>
    <para>
     Même si il n'est pas très productif de règler précisément la fréquence de
     <command>ANALYZE</command> pour chaque colonne, il peut être intéressant d'ajuster
     le niveau de détail des statistiques collectées pour chaque colonne. Les
     colonnes très utilisées dans les clauses <literal>WHERE</literal> et dont la
     distribution n'est pas uniforme requièrent des histogrammes plus précis
     que les autres colonnes. Voir <command>ALTER TABLE SET STATISTICS</command>,
     ou modifier les paramètres par défaut de la base de données en utilisant le
     paramètre de configuration <xref linkend="guc-default-statistics-target"/>.
    </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-wraparound">
   <title>Éviter les cycles des identifiants de transactions</title>

   <indexterm zone="vacuum-for-wraparound">
    <primary>identifiant de transaction</primary>
    <secondary>cycle</secondary>
   </indexterm>

   <para>
    Le mécanisme de contrôle de concurrence multiversion (<acronym>MVCC</acronym>) de
    <productname>PostgreSQL</productname> s'appuie sur la possibilité de
    comparer des identifiants de transactions (<acronym>XID</acronym>)&nbsp;; c'est un
    nombre croissant&nbsp;: la version d'une ligne dont le XID d'insertion est
    supérieur au XID de la transaction en cours est <quote>dans le futur</quote> et
    ne doit pas être visible de la transaction courante. Comme les identifiants
    ont une taille limitée (32 bits à ce jour), un groupe qui est en activité
    depuis longtemps (plus de 4 milliards de transactions) pourrait connaître un
    cycle des identifiants de transaction&nbsp;: le XID reviendra à 0 et
    soudainement les transactions du passé sembleront appartenir au futur - ce
    qui signifie qu'elles deviennent invisibles. En bref, perte de données
    totale. (En réalité, les données sont toujours là mais c'est un piètre
    réconfort puisqu'elles resteront inaccessibles.) Pour éviter ceci, il est
    nécessaire d'exécuter un VACUUM sur chaque table de chaque base au moins
    au moins une fois à chaque milliard de transactions.
   </para>

   <para>
    La raison pour laquelle un VACUUM périodique résout le problème est que
    <productname>PostgreSQL</productname> distingue un ID de transaction spécial,
    <literal>FrozenXID</literal>. Ce XID est toujours considéré comme plus âgé
    que les XID normaux. Les XID normaux sont comparés sur une base
    modulo-2<superscript>31</superscript>. Cela signifie
    que pour chaque XID normal, il y en a deux milliards qui sont plus vieux et
    deux milliards qui sont plus récents. Une autre manière de le dire est que
    l'ensemble de définition des XID est circulaire et sans limite. De plus,
    une ligne créée avec un XID normal donné, la version de la ligne apparaîtra
    comme appartenant au passé pour les deux milliards de transactions qui
    suivront quelque soit le XID. Si la ligne existe encore après deux milliards
    de transactions, elle apparaîtra soudainement comme appartenant au futur.
    Pour éviter la disparition des données, les versions trop anciennes doivent
    se voir affecter le XID <literal>FrozenXID</literal> avant d'atteindre le seuil
    fatidique des deux milliards de transactions. Une fois qu'elles ont ce XID
    spécifique, elles appartiendront au passé pour toutes les transactions même
    en cas de cycle. Cette affectation des anciens XID est réalisée par
    <command>VACUUM</command>.
   </para>

   <para>
    <xref linkend="guc-vacuum-freeze-min-age"/> contrôle l'âge que doit avoir une
    valeur XID avant qu'elle soit remplacée par <literal>FrozenXID</literal>. Les
    valeurs plus importantes de ces deux paramètres préservent l'information
    transactionnelle plus longtemps alors que les valeurs plus petites
    augmentent le nombre de transactions qui peuvent survenir avant un nouveau
    VACUUM de la table.
   </para>

   <para>
    <command>VACUUM</command> ignore habituellement les pages qui n'ont pas de
    lignes mortes, mais ces pages pourraient toujours avoir des versions de
    lignes avec d'anciennes valeurs XID. Pour s'assurer que tous les anciens
    XID ont été remplacés par <literal>FrozenXID</literal>, un parcours complet
    de la table est nécessaire. <xref linkend="guc-vacuum-freeze-table-age"/>
    contrôle quand <command>VACUUM</command> fait cela&nbsp;: un parcours
    complet est forcé si la table n'a pas été parcourue complètement pendant
    <varname>vacuum_freeze_table_age</varname> -
    <varname>vacuum_freeze_min_age</varname> transactions. En le configurant à
    zéro, cela force <command>VACUUM</command> à toujours parcourir toutes les
    pages, ignorant de ce fait la carte de visibilité.
   </para>

   <para>
    Le temps maximum où une table peut rester sans VACUUM est de deux millions
    de transactions moins <varname>vacuum_freeze_min_age</varname> quand
    <command>VACUUM</command> a parcouru la table complètement pour la dernière
    fois. Si elle devait rester sans VACUUM après
    cela, des pertes de données pourraient survenir. Pour s'assurer que cela
    n'arrive pas, autovacuum est appelé sur chaque table qui pourrait
    contenir des XID plus âgés que ne l'indique le paramètre de configuration
    <xref linkend="guc-autovacuum-freeze-max-age"/>. (Ceci arrivera même si
    autovacuum est désactivé.)
   </para>

   <para>
    Ceci implique que, si aucune opération de VACUUM n'est demandée sur une
    table, l'autovacuum sera automatiquement déclenché une fois toutes les
    <varname>autovacuum_freeze_max_age</varname> moins
    <varname>vacuum_freeze_min_age</varname> transactions. Pour les tables qui
    ont régulièrement l'opération de VACUUM pour réclamer l'espace perdu, ceci
    a peu d'importance. Néanmoins, pour les tables statiques (ceci incluant les
    tables qui ont des INSERT mais pas d'UPDATE ou de DELETE), il n'est pas
    nécessaire d'exécuter un VACUUM pour récupérer de la place et donc il
    peut être utile d'essayer de maximiser l'interval entre les autovacuums
    forcés sur de très grosses tables statiques. Évidemment, vous pouvez le
    faire soit en augmentant <varname>autovacuum_freeze_max_age</varname> soit
    en diminuant <varname>vacuum_freeze_min_age</varname>.
   </para>

   <para>
    Le maximum efficace pour <varname>vacuum_freeze_table_age</varname> est 0.95 * 
    <varname>autovacuum_freeze_max_age</varname>&nbsp;; un paramétrage plus haut
    que ça sera limité à ce maximum. Une valeur plus importante qie
    <varname>autovacuum_freeze_max_age</varname> n'aurait pas de sens car un
    autovacuum de préservation contre la ré-utilisation des identifiants de
    transactions serait déclenché, et le multiplicateur 0,95 laisse un peu de
    place pour exécuter un <command>VACUUM</command> manuel avant que cela ne
    survienne. Comme règle d'or, <command>vacuum_freeze_table_age</command> devrait
    être configuré à une valeur légèrement inférieure à
    <varname>autovacuum_freeze_max_age</varname>, laissant suffisamment d'espace
    pour qu'un <command>VACUUM</command> planifié régulièrement ou pour qu'un
    autovacuum déclenché par des activités normales de suppression et de mise à
    jour puissent être activés pendant ce laps de temps. Le configurer de façon
    trop proche pourrait déclencher des autovacuum de protection contre la
    ré-utilisation des identifiants de transactions, même si la table a été
    récemment l'objet d'un VACUUM pour récupérer l'espace, alors que des valeurs
    basses amènent à des parcours complets de table plus fréquents.
   </para>

   <para>
    Le seul inconvénient à augmenter <varname>autovacuum_freeze_max_age</varname>
    (et <varname>vacuum_freeze_table_age</varname> avec elle)
    est que le sous-répertoire <filename>pg_clog</filename> du cluster prendre
    plus de place car il doit stocker le statut du COMMIT pour toutes les
    transactions depuis <varname>autovacuum_freeze_max_age</varname>. L'état de
    COMMIT utilise deux bits par transaction, donc si
    <varname>autovacuum_freeze_max_age</varname> et
    <varname>vacuum_freeze_table_age</varname> ont une valeur maximum permise
    d'un peu moins que deux billion, <filename>pg_clog</filename> peut grossir
    jusqu'à la moitié d'un Go. Si c'est rien comparé à votre taille de base
    totale, configurer <varname>autovacuum_freeze_max_age</varname> à son
    maximum permis est recommandé. Sinon, le configurer suivant ce que vous
    voulez comme stockage maximum dans <filename>pg_clog</filename>.
    (La valeur par défaut, 200 millions de transactions, se traduit en à peu près
    50&nbsp;Mo de stockage dans <filename>pg_clog</filename>.)
   </para>

   <para>
    Un inconvénient causé par la diminution de
    <varname>vacuum_freeze_min_age</varname> est que cela pourrait faire que
    <command>VACUUM</command> travaille sans raison&nbsp;: modifier le XID de
    la ligne d'une table à <literal>FrozenXID</literal> est une perte de temps
    si la ligne est modifiée rapidement après (ce qui fait qu'elle obtiendra
    un nouveau XID). Donc ce paramètre doit être suffisamment important pour
    que les lignes ne soient pas gelées jusqu'à ce qu'il soit pratiquement
    certain qu'elles ne seront plus modifiées. Un autre inconvénient en
    diminuant ce paramètre est que les détails sur la transaction exacte
    qui a inséré ou modifié une ligne seront perdus plus tôt. Cette information
    est quelque fois utile, particulièrement lors d'une analyse de ce qui s'est
    mal passé sur une base après un problème. Pour ces deux raisons, baisser
    ce paramètre n'est pas recommandé sauf pour les tables entièrement statiques.
   </para>

   <para>
    Pour tracer l'âge des plus anciens XID de la base, <command>VACUUM</command>
    stocke les statistiques sur XID dans les tables systèmes
    <structname>pg_class</structname> et <structname>pg_database</structname>.
    En particulier, la colonne <structfield>relfrozenxid</structfield> de la
    ligne <structname>pg_class</structname> d'une table contient le XID final
    du gel qui a été utilisé par le dernier <command>VACUUM</command> pour cette
    table. Il est garanti que tous les XID plus anciens que ce XID ont été
    remplacés par <literal>FrozenXID</literal> pour cette table. De façon
    similaire, la colonne <structfield>datfrozenxid</structfield> de la ligne
    <structname>pg_database</structname> de la base est une limite inférieure des
    XID normaux apparaissant dans cette base &mdash; c'est tout simplement le
    minimum des valeurs <structfield>relfrozenxid</structfield> par table dans
    cette base. Pour examiner cette information, le plus simple est d'exécuter
    des requêtes comme&nbsp;:

<programlisting>SELECT relname, age(relfrozenxid) FROM pg_class WHERE relkind = 'r';
SELECT datname, age(datfrozenxid) FROM pg_database;</programlisting>

    La colonne <literal>age</literal> mesure le nombre de transactions à partir
    du XID final vers le XID de transaction en cours.
   </para>

   <para>
    <command>VACUUM</command>
    parcourt habituellement seulement les pages qui ont été modifiées depuis le
    dernier VACUUM mais <structfield>relfrozenxid</structfield> peut seulement
    être avancé quand la table est parcourue complètement. La table est parcourue
    entièrement quand <structfield>relfrozenxid</structfield> est agée de plus
    de <varname>vacuum_freeze_table_age</varname> transactions, quand la commande
    <command>VACUUM FREEZE</command> est utilisée ou quand toutes les pages se
    trouvent nécessiter un VACUUM pour supprimer les versions mortes des lignes.
    Après que <command>VACUUM</command> ait parcouru la table complète
    <literal>age(relfrozenxid)</literal> devrait être un peu plus grande que
    le paramètre <varname>vacuum_freeze_min_age</varname> qui a été utilisé
    (la différence étant due au nombre de transactions démarrées depuis que
    <command>VACUUM</command> a commencé son travail). Si aucun parcours de
    table complet ne se trouve exécuté via un <command>VACUUM</command> sur
    cette table, lorsque <varname>autovacuum_freeze_max_age</varname> est
    atteint, un autovacuum sera rapidement forcé sur la table.
   </para>

   <para>
    Si, pour une certaine raison, l'autovacuum échoue à effacer les anciens XID
    d'une table, le système commencera à émettre des messages d'avertissement
    comme ceci quand les plus anciens XID de la base atteignent les 10 millions
    de transactions à partir du point de réinitialisation&nbsp;:

<programlisting>
WARNING:  database "mydb" must be vacuumed within 177009986 transactions
HINT:  To avoid a database shutdown, execute a database-wide VACUUM in "mydb".
</programlisting>
    (Une commande <command>VACUUM</command> manuelle devrait résoudre le problème,
    comme suggéré par l'indice&nbsp;; mais notez que la commande
    <command>VACUUM</command> doit être exécutée par un superutilisateur, sinon
    elle échouera à mettre à jour les catalogues systèmes et ne pourra donc pas faire
    avancer le <structfield>datfrozenxid</structfield> de la base.)
    Si ces avertissements sont ignorés, le système s'arrêtera et refusera
    d'exécuter toute nouvelle transaction dès qu'il n'en restera qu'un
    million avant la réinitialisation&nbsp;:

<programlisting>
ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and use a standalone backend to VACUUM in "mydb".
</programlisting>

    La marge de sécurité de un million de transactions existe pour permettre à
    l'administrateur de récupérer ces données sans perte en exécutant
    manuellement les commandes <command>VACUUM</command> requises. Néanmoins, comme le
    système n'exécute pas de commandes tant qu'il n'est pas sorti du mode
    d'arrêt par sécurité, la seule façon de le faire est de stopper le
    serveur et d'utiliser un moteur simple utilisateur pour exécuter le
    <command>VACUUM</command>. Le mode d'arrêt n'est pas pris en compte par le moteur
    simple utilisateur. Voir la page de référence de <xref linkend="app-postgres"/> pour
    des détails sur l'utilisation du moteur simple utilisateur.
   </para>
  </sect2>

  <sect2 id="autovacuum">
   <title id="autovacuum-title">Le démon auto-vacuum</title>

   <indexterm>
    <primary>autovacuum</primary>
    <secondary>information générale</secondary>
   </indexterm>
   <para>
    <productname>PostgreSQL </productname> dispose d'une fonctionnalité
    optionnelle mais hautement recommandée appelée <firstterm>autovacuum</firstterm>,
    dont le but est d'automatiser l'exécution des commandes
    <command>VACUUM</command> et <command>ANALYZE </command>. Une fois activé,
    autovacuum vérifie les tables ayant un grand nombre de lignes insérées,
    mises à jour ou supprimées. Ces vérifications utilisent la fonctionnalité
    de récupération de statistiques&nbsp;; du coup, autovacuum ne peut
    pas être utilisé sauf si <xref linkend="guc-track-counts"/> est configuré
    à <literal>true</literal>.
    Dans la configuration par défaut, l'autovacuum est activé et les
    paramètres liés sont correctement configurés.
   </para>

   <para>
    Le <quote>démon autovacuum</quote> est constitué de plusieurs processus.
    Un processus démon permanent appelé <firstterm>autovacuum launcher</firstterm>
    (autrement dit le lanceur d'autovacuum), qui
    est en charge de lancer un processus travailleur (<firstterm>autovacuum
    worker</firstterm>) pour toutes les bases de données. Le lanceur distribuera
    le travail dans le temps mais essaiera de lancer un nouveau travailleur sur
    chaque base de données chaque <xref linkend="guc-autovacuum-naptime"/>
    secondes. Un travailleur sera lancé pour chaque base de données, avec un
    maximum de <xref linkend="guc-autovacuum-max-workers"/> processus fonctionnant
    en même temps. S'il y a plus de <xref linkend="guc-autovacuum-max-workers"/>
    bases à traiter, la prochaine base de données sera traitée dès qu'un autre
    travailleur a terminé. Chaque processus travailleur vérifiera chaque table de
    leur base de données et exécutera un <command>VACUUM</command> et/ou un
    <command>ANALYZE</command> suivant les besoins.
   </para>

   <para>
    Le paramètre <xref linkend="guc-autovacuum-max-workers"/> limite le
    nombre maximum de travailleurs pouvant être lancés à tout moment. Si
    plusieurs grosses tables deviennent toutes éligibles pour un VACUUM dans
    un court espace de table, tous les travailleurs de l'autovacuum pourraient
    ne s'occuper que de ces tables pour un très long moment. Ceci aurait pour
    conséquences que les autres tables et bases ne seraient plus l'objet
    d'opérations de VACUUM jusqu'à la disponibilité d'un travailleur. Il
    n'y a pas de limite au nombre de travailleurs sur une seule base mais
    les travailleurs tentent d'éviter de répéter le travail qui a déjà été
    réalisé par d'autres travailleurs. Notez que le nombre de travailleurs
    en cours d'exécution ne comptent pas dans les limites <xref
    linkend="guc-max-connections"/> et <xref
    linkend="guc-superuser-reserved-connections"/>.
   </para>

   <para>
    Les tables dont la valeur de <structfield>relfrozenxid</structfield> est
    plus importante que <xref linkend="guc-autovacuum-freeze-max-age"/> sont
    toujours l'objet d'un VACUUM (cela s'applique aux tables dont le 'freeze max age'
    a été modifié par les paramètres de stockage&nbsp;; voyez plus bas).
    Sinon, si le nombre de lignes obsolètes
    depuis le dernier <command>VACUUM</command> dépasse une <quote>limite de
    vacuum</quote>, la table bénéficie d'un VACUUM. La limite est définie
    ainsi&nbsp;:
<programlisting>limite du vacuum = limite de base du vacuum + facteur d'échelle du vacuum * nombre de lignes</programlisting>
    où la limite de base du vacuum est
    <xref linkend="guc-autovacuum-vacuum-threshold"/>,
    le facteur d'échelle du vacuum est
    <xref linkend="guc-autovacuum-vacuum-scale-factor"/>
    et le nombre de lignes est
    <structname>pg_class</structname>.<structfield>reltuples</structfield>.
    Le nombre de lignes obsolètes est obtenu à partir du récupérateur de
    statistiques&nbsp;; c'est un nombre à peu près précis, mis à jour après
    chaque instruction <command>UPDATE</command> et <command>DELETE</command>
    (il est seulement à peu près précis car certaines informations pourraient
    être perdues en cas de grosse charge). Si la valeur de
    <structfield>relfrozenxid</structfield> pour la table est supérieure à
    <varname>vacuum_freeze_table_age</varname>, la table complète est parcourue
    pour geler les anciennes lignes et pour avancer
    <structfield>relfrozenxid</structfield>, sinon seules les pages qui ont été
    modifiées depuis le dernier VACUUM sont parcourues par l'opération de
    VACUUM.
   </para>

   <para>
    Pour ANALYZE, une condition similaire
    est utilisée&nbsp;: la limite, définie comme
<programlisting>limite du analyze = limite de base du analyze + facteur d'échelle du analyze * nombre de lignes</programlisting>
    est comparée au nombre de lignes insérées ou mises à jour depuis
    le dernier <command>ANALYZE</command>.
   </para>

   <para>
    Les limites et facteurs d'échelle par défaut sont pris dans
    <filename>postgresql.conf</filename>, mais il est possible de les surcharger
    table par table&nbsp;; voir
    <xref linkend="sql-createtable-storage-parameters"
    endterm="sql-createtable-storage-parameters-title"/> pour plus d'informations.
    Si un paramètre a été modifié via les paramètres de stockage, cette valeur
    est utilisée&nbsp;; sinon les paramètres globaux sont utilisés. Voir
    <xref linkend="runtime-config-autovacuum"/> pour plus d'informations sur les
    paramètres globaux.
   </para>

   <para>
    En plus des valeurs de la limite de base et des facteurs d'échelle, il
    existe six autres paramètres autovacuum pouvant être configurés pour chaque table
    via les paramètres de stockage. Le premier paramètre,
    <literal>autovacuum_enabled</literal>,
    peut être configuré à <literal>false</literal> pour instruire le démon
    autovacuum de laisser cette table particulière. Dans ce cas, autovacuum
    touchera seulement la table quand il devra le faire pour prévenir la
    réinitialisation de l'ID de transaction. Deux autres paramètres, le
    délai du coût du VACUUM (<literal>autovacuum_vacuum_cost_delay</literal>)
    et la limite du coût du VACUUM
    (<literal>autovacuum_vacuum_cost_limit</literal>),
    sont utilisés pour configurer des valeurs spécifiques aux tables pour
    la fonctionnalité <xref linkend="runtime-config-resource-vacuum-cost"
    endterm="runtime-config-resource-vacuum-cost-title"/>.
    <literal>autovacuum_freeze_min_age</literal>,
    <literal>autovacuum_freeze_max_age</literal> et
    <literal>autovacuum_freeze_table_age</literal>
    sont utilisés pour configurer des valeurs par table, respectivement
    <xref linkend="guc-vacuum-freeze-min-age"/>,
    <xref linkend="guc-autovacuum-freeze-max-age"/> et
    <xref linkend="guc-vacuum-freeze-table-age"/>.
   </para>

   <para>
    Lorsque plusieurs processus autovacuum sont en cours d'exécution, la
    limite de coût est <quote>répartie</quote> parmi tous les processus pour
    que l'impact total sur le système soit identique quelque soit le nombre
    de processus en cours d'exécution.
   </para>
  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
  <title>Ré-indexation régulière</title>

  <indexterm zone="routine-reindex">
   <primary>ré-indexation</primary>
  </indexterm>

  <para>
   Dans certains cas, reconstruire périodiquement les index par la commande
   <xref linkend="sql-reindex" endterm="sql-reindex-title"/> vaut la peine.
  </para>

  <para>
   Dans les versions <productname>PostgreSQL</productname> antérieures à la 7.4, la
   réindexation périodique était fréquemment nécessaire pour éviter
   l'<quote>inflation des index</quote>, à cause d'un manque de récupération de
   l'espace interne dans les index B-tree. Toutes les situations dans lesquelles
   l'échelle des clés d'index change dans le temps &mdash; par exemple, un index
   sur l'horodatage dans une table où les anciennes entrées sont finalement
   supprimées &mdash; pourraient résulter en une inflation car les pages d'index
   des portions inutilisées de cet ensemble n'étaient pas réclamées pour être
   ré-utilisées. Au bout d'un certain temps, la taille de l'index pouvait
   devenir indéfiniment plus large que les données utiles qu'elle contient.
  </para>

  <para>
   Dans les versions 7.4 et ultérieures de <productname>PostgreSQL</productname>, les
   pages d'index qui sont devenues complètement vides sont récupérées pour être
   réutilisées. Il existe toujours une possibilité d'une utilisation inefficace
   de l'espace&nbsp;: si pratiquement toutes les clés d'index d'une page ont été
   supprimées, la page reste allouée. Donc, le cas d'une utilisation où la
   majorité des clés de l'index d'une page est supprimée est un cas où l'espace
   sera mal utilisé. Pour de tels usages, une réindexation périodique est
   recommandée.
  </para>

  <para>
   Le potentiel d'inflation des index qui ne sont pas des index B-tree n'a pas
   été particulièrement analysé. Garder un &oelig;il sur la taille physique de
   ces index est une bonne idée.
  </para>

  <para>
   De plus, pour les index B-tree, un index tout juste construit est quelque peu
   plus rapide qu'un index qui a été mis à jour plusieurs fois parce que
   les pages adjacentes logiquement sont habituellement aussi physiquement
   adjacentes dans un index nouvellement créé (cette considération ne s'applique
   pas aux index non B-tree). Il pourrait être intéressant de ré-indexer
   périodiquement simplement pour améliorer la vitesse d'accès.
  </para>
 </sect1>


 <sect1 id="logfile-maintenance">
  <title>Maintenance du fichier de traces</title>

  <indexterm zone="logfile-maintenance">
   <primary>traces serveur</primary>
   <secondary>maintenance du fichier de traces</secondary>
  </indexterm>

  <para>
   Sauvegarder les journaux de trace du serveur de bases de données dans un
   fichier plutôt que dans <filename>/dev/NULL</filename> est une bonne idée. Les
   journaux sont d'une utilité incomparable lorsqu'arrive le moment où des
   problèmes surviennent. Néanmoins, les journaux ont tendance à être
   volumineux (tout spécialement à des niveaux de débogage importants) et vous
   ne voulez pas les sauvegarder indéfiniment. Vous avez besoin de faire une
   <quote>rotation</quote> des journaux pour que les nouveaux journaux sont
   commencés et que les anciens soient supprimés après une période de temps
   raisonnable.
  </para>

  <para>
   Si vous redirigez simplement <systemitem>stderr</systemitem> du
   <command>postgres</command> dans un fichier, vous aurez un journal des
   traces mais la seule façon de le tronquer sera d'arrêter et de relancer
   le serveur. Ceci peut convenir si vous utilisez
   <productname>PostgreSQL</productname> dans un environnement de développement
   mais peu de serveurs de production trouveraient ce comportement acceptable.
  </para>

  <para>
   Une meilleure approche est d'envoyer la sortie
   <systemitem>stderr</systemitem> du serveur dans un programme de rotation de
   journaux. Il existe un programme interne de rotation que vous pouvez
   utiliser en configurant le paramètre <literal>logging_collector</literal> à
   <literal>true</literal> dans <filename>postgresql.conf</filename>. Les
   paramètres de contrôle pour ce programme sont décrits dans <xref
   linkend="runtime-config-logging-where"/>. Vous pouvez aussi utiliser cette
   approche pour capturer les données des journaux applicatifs dans un format
   CSV lisible par une machine
  </para>

  <para>
   Sinon, vous pourriez préférer utiliser un programme externe de rotation de
   journaux si vous en utilisez déjà un avec d'autres serveurs. Par exemple,
   l'outil <application>rotatelogs</application> inclus dans la distribution
   <productname>Apache</productname> peut être utilisé avec
   <productname>PostgreSQL</productname>. Pour cela, envoyez via un tube la
   sortie <systemitem>stderr</systemitem> du serveur dans le programme
   désiré. Si vous lancez le serveur avec <command>pg_ctl</command>, alors
   <systemitem>stderr</systemitem> est déjà directement renvoyé dans
   <systemitem>stdout</systemitem>, donc vous avez juste besoin d'ajouter la commande via
   un tube, par exemple&nbsp;:

<programlisting>pg_ctl start | rotatelogs /var/log/pgsql_log 86400</programlisting>
</para>

  <para>
   Une autre approche de production pour la gestion des journaux de trace est
   de les envoyer à <application>syslog</application> et de laisser <application>syslog</application>
   gérer la rotation des fichiers. Pour cela, initialisez le paramètre de
   configuration <literal>log_destination</literal> à <literal>syslog</literal> (pour tracer
   uniquement via <application>syslog</application>) dans <filename>postgresql.conf</filename>.
   Ensuite, vous pouvez envoyer un signal <literal>SIGHUP</literal> au démon
   <application>syslog</application> quand vous voulez le forcer à écrire dans un nouveau
   fichier. Si vous voulez automatiser la rotation des journaux, le programme
   <application>logrotate</application> peut être configuré pour fonctionner
   avec les journaux de traces provenant de <application>syslog</application>.
  </para>

  <para>
   Néanmoins, sur beaucoup de systèmes, <application>syslog</application> n'est pas très
   fiable, particulièrement avec les messages très gros&nbsp;; il pourrait
   tronquer ou supprimer des messages au moment où vous en aurez le plus besoin.
   De plus, sur <productname>Linux</productname>, <application>syslog</application> synchronisera tout
   message sur disque, amenant des performances assez pauvres. (Vous pouvez
   utiliser un <literal>-</literal> au début du nom de fichier dans le fichier de
   configuration <application>syslog</application> pour désactiver la synchronisation.)
  </para>

  <para>
   Notez que toutes les solutions décrites ci-dessus font attention à lancer de
   nouveaux journaux de traces à des intervalles configurables mais ils ne
   gèrent pas la suppression des vieux fichiers de traces, qui ne sont
   probablement plus très intéressants. Vous voudrez probablement configurer
   un script pour supprimer périodiquement les anciens journaux. Une autre
   possibilité est de configurer le programme de rotation pour que les anciens
   journaux de traces soient écrasés de façon cyclique.
  </para>
 </sect1>
</chapter>
