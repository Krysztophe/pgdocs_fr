<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/manage-ag.sgml,v 1.9 2005/09/15 07:03:19 guillaume Exp $ -->

<chapter id="managing-databases">

 <title>Administration des bases de données</title>

 <indexterm zone="managing-databases"><primary>base de données</primary></indexterm>

 <para>
  Chaque instance d'un serveur <productname>PostgreSQL</productname>
  gère une ou plusieurs bases de données. Les bases de données sont
  donc le niveau hiérarchique le plus élevé pour organiser des objets
  <acronym>SQL</acronym> (<quote>objets de base de données</quote>). Ce
  chapitre décrit les propriétés des bases de données et comment les
  créer, les administrer et les détruire.
 </para>

 <sect1 id="manage-ag-overview">

  <title>Aperçu</title>

  <indexterm zone="manage-ag-overview">
   <primary>schéma</primary>
  </indexterm>

  <para>
   Une base de données est un ensemble nommé d'objets
   <acronym>SQL</acronym> (<quote>objets de base de
   données</quote>). En général, chaque objet de base de données
   (table, fonction etc.) appartient à une et une seule base de
   données (mais certains catalogues système, par exemple
   <literal>pg_database</literal>, appartiennent à tout le groupe et sont
   accessibles depuis toutes les bases de données du groupe). Plus
   précisément, une base de données est une collection de schémas et
   les schémas contiennent les tables, fonctions, etc. Ainsi, la
   hiérarchie complète est&nbsp;: serveur, base de données, schéma, table
   (ou un autre type d'objet, comme une fonction).
  </para>

  <para>
   Lors de la connexion au serveur de bases de données, une application cliente
   doit spécifier dans sa requête de connexion la base de données à laquelle
   elle veut se connecter. Il n'est pas possible d'accéder à plus
   d'une base de données via la même connexion (mais une application
   n'est pas limitée dans le nombre de connexions qu'elle établit avec
   une ou plusieurs bases de données). Les bases de
   données sont séparées physiquement et le contrôle d'accès est géré
   au niveau de la connexion. Si une instance de serveur
   <productname>PostgreSQL</productname> doit héberger des projets ou des
   utilisateurs censés rester séparés et sans interaction, il est
   recommandé de les répartir sur plusieurs bases de données. Si les
   projets ou les utilisateurs sont reliés et doivent pouvoir partager
   leurs ressources, alors ils devraient être placés dans la même base
   de données mais éventuellement dans des schémas différents. Les schémas sont
   une structure purement logique et qui peut accéder à ce qui est géré par le
   système des droits. Pour plus d'informations sur la manipulation des schémas,
   voir la <xref linkend="ddl-schemas"/>.
  </para>

  <para>
   Les bases de données sont créées avec la commande <command>CREATE DATABASE</command>
   (voir la <xref linkend="manage-ag-createdb"/>) et détruites avec la commande
   <command>DROP DATABASE</command> (voir la <xref linkend="manage-ag-dropdb"/>). Pour
   déterminer l'ensemble des bases de données existantes, examinez le catalogue
   système <structname>pg_database</structname>, par exemple
<synopsis>SELECT datname FROM pg_database;</synopsis>
   La méta-commande <literal>\l</literal> du programme <xref linkend="app-psql"/> et
   l'option en ligne de commande <option>-l</option> sont aussi utiles pour afficher
   les bases de données existantes.
  </para>

  <note>
   <para>
    Le standard <acronym>SQL</acronym> appelle les bases de données des
    <quote>catalogues</quote> mais il n'y a aucune différence en pratique.
   </para>
  </note>

 </sect1>

 <sect1 id="manage-ag-createdb">

  <title>Création d'une base de données</title>

  <para>
   Pour pouvoir créer une base de données, il faut que le serveur
   <productname>PostgreSQL</productname> soit lancé (voir la <xref
   linkend="server-start"/>).
  </para>

  <para>
   Les bases de données sont créées à l'aide de la commande SQL
   <xref linkend="sql-createdatabase"
   endterm="sql-createdatabase-title"/>:<indexterm><primary>CREATE
   DATABASE</primary></indexterm>
    <synopsis>CREATE DATABASE <replaceable>nom</replaceable>;</synopsis>
   ou <replaceable>nom</replaceable> suit les règles habituelles pour les
   identifiants <acronym>SQL</acronym>. Le rôle actuel devient
   automatiquement le propriétaire de la nouvelle base de
   données. C'est au propriétaire de la base de données qu'il revient
   de la supprimer par la suite (ce qui supprime aussi tous les objets
   qu'elle contient, même s'ils ont un propriétaire différent).
  </para>

  <para>
   La création de bases de données est une opération protégée. Voir la <xref
   linkend="role-attributes"/> sur la manière d'attribuer des droits.
  </para>

  <para>
   Comme vous devez être connecté au serveur de base de données pour
   exécuter la commande <command>CREATE DATABASE</command>, reste à
   savoir comment créer la première base de données d'un site. La
   première base de données est toujours créée par la commande
   <command>initdb</command> quand l'aire de stockage des données est
   initialisée (voir la <xref linkend="creating-cluster"/>). Cette base
   de données est appelée <literal>postgres</literal>.
   <indexterm><primary>postgres</primary></indexterm> Donc,
   pour créer la première base de données <quote>ordinaire</quote>, vous pouvez
   vous connecter à <literal>postgres</literal>.
  </para>

  <para>
   Une deuxième base de données,
   <literal>template1</literal>,<indexterm><primary>template1</primary></indexterm>
   est aussi créée par <command>initdb</command>. Quand une nouvelle base de données
   est créée à l'intérieur du groupe, <literal>template1</literal> est
   généralement cloné. Cela signifie que tous les changements effectués sur
   <literal>template1</literal> sont propagés à toutes les bases de
   données créées ultérieurement. Du coup, il est déconseillé d'utiliser
   <literal>template1</literal> pour votre travail
   quotidien mais cette propriété, utilisée judicieusement, peut être
   utile. Pour plus de détails, voir la <xref
   linkend="manage-ag-templatedbs"/>.
  </para>

  <para>
   Pour plus de confort, il existe aussi un programme que vous pouvez
   exécuter à partir du shell pour créer de nouvelles bases de
   données, <command>createdb</command>.<indexterm><primary>createdb</primary></indexterm>
    <synopsis>createdb <replaceable class="parameter">nom_base</replaceable></synopsis>
   <command>createdb</command> ne fait rien de magique. Il se connecte à la
   base de données <literal>postgres</literal> et exécute la commande
   <command>CREATE DATABASE</command>, exactement comme ci-dessus. La page de
   référence sur <xref linkend="app-createdb"/> contient les détails de son
   invocation. Notez que <command>createdb</command> sans aucun argument
   crée une base de donnée portant le nom de l'utilisateur courant,
   ce qui n'est peut-être pas ce que vous voulez.
  </para>

  <note>
   <para>
    Le <xref linkend="client-authentication"/> contient des informations
    sur la manière de restreindre l'accès à une base de données.
   </para>
  </note>

  <para>
   Parfois, vous voulez créer une base de données pour quelqu'un
   d'autre. Ce rôle doit devenir le propriétaire de la
   nouvelle base de données afin de pouvoir la configurer et
   l'administrer lui-même. Pour faire ceci, utilisez l'une des
   commandes suivantes&nbsp;:
    <programlisting>CREATE DATABASE <replaceable>nom_base</replaceable> OWNER <replaceable>nom_role</replaceable>;</programlisting>
   dans l'environment SQL ou
    <programlisting>createdb -O <replaceable>nom_role</replaceable> <replaceable>nom_base</replaceable></programlisting>
   dans le shell. Vous devez être super-utilisateur pour créer une
   base de données pour quelqu'un d'autre c'est-à-dire pour un rôle
   dont vous n'êtes pas membre.
  </para>

 </sect1>

 <sect1 id="manage-ag-templatedbs">

  <title>Bases de données modèles</title>

  <para>
   En fait, <command>CREATE DATABASE</command> fonctionne en copiant une base
   de données préexistante. Par défaut, cette commande copie la base
   de données système standard
   <literal>template1</literal>.<indexterm><primary>template1</primary></indexterm> Ainsi,
   cette base de données est le <quote>modèle</quote> à partir duquel de
   nouvelles bases de données sont créées. Si vous ajoutez des objets
   à <literal>template1</literal>, ces objets seront copiés dans les bases de
   données utilisateur créées ultérieurement. Ce comportement permet
   d'apporter des modifications locales au jeu standard d'objets des
   bases de données. Par exemple, si vous installez le langage de
   procédures <application>PL/pgSQL</application> dans <literal>template1</literal>, celui-ci
   sera automatiquement disponible dans les bases de données
   utilisateur sans qu'il soit nécessaire de faire quelque chose de
   spécial au moment où ces bases de données sont créées.
  </para>

  <para>
   Il y a une seconde base de données système standard appelée
   <literal>template0</literal>.<indexterm><primary>template0</primary></indexterm> Cette
   base de données contient les mêmes données que le contenu initial
   de <literal>template1</literal>, c'est-à-dire seulement les objets
   standards prédéfinis dans votre version de
   <productname>PostgreSQL</productname>. <literal>template0</literal> ne
   devrait jamais être modifiée après <command>initdb</command>. En indiquant
   à <command>CREATE DATABASE</command> de copier <literal>template0</literal> au
   lieu de <literal>template1</literal>, vous pouvez créer une base de
   données utilisateur <quote>vierge</quote> qui ne contient aucun des
   ajouts locaux à <literal>template1</literal>. Ceci est particulièrement
   pratique quand on restaure une sauvegarde réalisé avec <literal>pg_dump</literal>&nbsp;:
   le script de dump devrait être restauré dans une base de données
   vierge pour être sûr de recréer le contenu correct de la base
   de données sauvegardée, sans survenue de conflits avec des objets qui
   auraient été ajoutés à <literal>template1</literal>.
  </para>

  <para>
   Pour créer une base de données à partir de
   <literal>template0</literal>, utilisez
    <programlisting>CREATE DATABASE <replaceable>nom_base</replaceable> TEMPLATE template0;</programlisting>
   dans l'environnement SQL ou
    <programlisting>createdb -T template0 <replaceable>nom_base</replaceable></programlisting>
   dans le shell.
  </para>

  <para>
   Il est possible de créer des bases de données modèles
   supplémentaires et, à vrai dire, on peut copier n'importe quelle
   base de données d'un cluster en la désignant comme modèle pour la
   commande <command>CREATE DATABASE</command>. Cependant, il importe de
   comprendre, que ceci n'est pas (encore) à prendre comme une commande
   <quote><command>COPY DATABASE</command></quote> de portée
   générale.
   La principale limitation est qu'aucune autre session ne peut être connectée
   à la base source tant qu'elle est copiée. <command>CREATE
   DATABASE</command> échouera si une autre connexion existe à son lancement.
   Sinon, les nouvelles connexions à la base source sont verrouillées jusqu'à
   la fin de <command>CREATE DATABASE</command>.
  </para>

  <para>
   Deux drapeaux utiles existent dans
   <literal>pg_database</literal><indexterm><primary>pg_database</primary></indexterm>
   pour chaque base de données&nbsp;: les colonnes
   <literal>datistemplate</literal> et
   <literal>datallowconn</literal>. <literal>datistemplate</literal>
   peut être positionné à vrai pour indiquer qu'une base de données a
   vocation à servir de modèle à <command>CREATE DATABASE</command>. Si ce
   drapeau est positionné à vrai, la base de données peut être clonée
   par tout utilisateur ayant le droit <literal>CREATEDB</literal>&nbsp;; s'il est
   positionné à faux, seuls les super-utilisateurs et le propriétaire
   de la base de données peuvent la cloner. Si
   <literal>datallowconn</literal> est positionné à faux, alors aucune
   nouvelle connexion à cette base de données n'est autorisée (mais
   les sessions existantes ne sont pas tuées simplement en
   positionnant ce drapeau à faux). La base de données
   <literal>template0</literal> est normalement marquée
   <literal>datallowconn = false</literal> pour empêcher qu'elle ne soit
   modifiée. Aussi bien <literal>template0</literal> que
   <literal>template1</literal> devraient toujours être marquées
   <literal>datistemplate = true</literal>.
  </para>

  <para>
   Après avoir préparé ou modifé une base de données modèle, exécuter les
   commandes <command>VACUUM FREEZE</command> dans cette base de données est une
   bonne idée. Si cela se fait alors qu'il n'y a pas d'autre transaction
   ouverte dans la
   même base de données, alors il est garanti que toutes les lignes de
   la base de données seront <quote>gelées</quote> et ne seront pas sujettes
   à des problèmes de réutilisation d'ID de transaction déjà
   attribués. C'est particulièrement important pour une base de
   données qui aura le drapeau <literal>datallowconn</literal>
   positionné à faux puisqu'il sera impossible d'effectuer les
   <command>VACUUM</command> de maintenance sur une telle base de
   données. Voir la <xref linkend="vacuum-for-wraparound"/> pour plus
   d'informations.
  </para>

  <note>
   <para>
    <literal>template1</literal> et <literal>template0</literal> n'ont pas de
    caractère particulier en dehors du fait que <literal>template1</literal>
    est la base de données source par défaut pour la commande
    <command>CREATE DATABASE</command>. Par exemple, on pourrait supprimer
    <literal>template1</literal> et la recréer à partir de
    <literal>template0</literal> sans effet secondaire gênant. Ce procédé
    peut être utile lorsqu'on a encombré <literal>template1</literal>
    d'objets inutiles.
   </para>

   <para>
    La base de données <literal>postgres</literal> est aussi créé quand le groupe est
    initialisé. Cette base de données a pour but de devenir une base de données
    par défaut pour la connexion des utilisateurs et applications. C'est une
    simple copie de <literal>template1</literal> et peut être supprimée et re-créée
    si nécessaire.
   </para>
  </note>

 </sect1>

 <sect1 id="manage-ag-config">

  <title>Configuration d'une base de données</title>

  <para>
   Comme il est dit dans le <xref linkend="runtime-config"/>, le serveur
   <productname>PostgreSQL</productname> offre un grand nombre de variables de
   configuration à chaud. Vous pouvez spécifier des valeurs par défaut,
   valables pour une base de données particulière, pour nombre de ces
   variables.
  </para>

  <para>
   Par exemple, si pour une raison quelconque vous voulez désactiver
   l'optimiseur <acronym>GEQO</acronym> pour une base de donnée particulière,
   vous n'avez pas besoin de le désactiver pour toutes les bases de données ou
   de faire en sorte que tout client se connectant exécute la commande
   <literal>SET geqo TO off;</literal>. Pour appliquer ce réglage par défaut à
   la base de données en question, vous pouvez exécuter la commande 
    <programlisting>ALTER DATABASE ma_base SET geqo TO off;</programlisting>
   Cela sauvegarde le réglage (mais ne l'applique pas immédiatement).
   Lors des connexions ultérieures à cette base de données, tout se passe
   comme si la commande
   <literal>SET geqo TO off;</literal> est exécutée juste avant de commencer
   la session. Notez que les utilisateurs peuvent cependant modifier ce
   réglage pendant la session&nbsp;; il s'agit seulement d'un réglage par
   défaut. Pour annuler un tel réglage par défaut, utilisez <literal>ALTER
   DATABASE <replaceable>nom_base</replaceable> RESET
   <replaceable>nomvariable</replaceable>;</literal>.
  </para>

 </sect1>

 <sect1 id="manage-ag-dropdb">
  <title>Détruire une base de données</title>

  <para>
   Les bases de données sont détruites avec la commande
   <xref linkend="sql-dropdatabase" endterm="sql-dropdatabase-title"/>&nbsp;:<indexterm><primary>DROP  
   DATABASE</primary></indexterm>
<synopsis>DROP DATABASE <replaceable>nom</replaceable>;</synopsis>
   Seul le propriétaire de la base de données ou un superutilisateur peut
   supprimer une base de données.
   Supprimer une base de données supprime tous les objets qui étaient contenus
   dans la base. La destruction d'une base de données ne peut pas être annulée.
  </para>

  <para>
   Vous ne pouvez pas exécuter la commande <command>DROP DATABASE</command>
   en étant connecté à la base de données cible. Néanmoins, vous pouvez être
   connecté à une autre base de données, ceci incluant la base 
   <literal>template1</literal>. <literal>template1</literal> pourrait être la seule option
   pour supprimer la dernière base utilisateur d'un groupe donné.
  </para>

  <para>
   Pour une certaine facilité, il existe un script shell qui supprime les bases
   de données, <xref linkend="app-dropdb"/>&nbsp;:<indexterm><primary>dropdb</primary></indexterm>
<synopsis>dropdb <replaceable class="parameter">nom_base</replaceable></synopsis>
   (Contrairement à <command>createdb</command>, l'action par défaut n'est pas de
   supprimer la base possédant le nom de l'utilisateur en cours.)
  </para>
 </sect1>

 <sect1 id="manage-ag-tablespaces">
  <title>Espaces logiques</title>

  <indexterm zone="manage-ag-tablespaces">
   <primary>espace logique</primary>
  </indexterm>

   <para>
    Les espaces logiques dans <productname>PostgreSQL</productname> permettent aux
    administrateurs de bases de données de définir l'emplacement dans le
    système de fichiers où seront stockés les fichiers représentant les objets
    de la base de données. Une fois créé, un espace logique peut être référencé
    par son nom lors de la création d'objets.
   </para>

   <para>
    En utilisant les espaces logiques, un administrateur peut contrôler les
    emplacements sur le disque d'une installation <productname>PostgreSQL</productname>.
    Ceci est utile dans au moins deux cas. Tout d'abord, si la partition ou le
    volume sur lequel le groupe a été initialisé arrive à court d'espace disque
    mais ne peut pas être étendu, un espace logique peut être créé sur une
    partition différente et utilisé jusqu'à ce que le système soit
    reconfiguré.
   </para>

   <para>
    Deuxièmement, les espaces logiques permettent à un administrateur
    d'utiliser sa connaissance des objets de la base pour optimiser les
    performances. Par exemple, un index qui est très utilisé peut être placé
    sur un disque très rapide et disponible, comme un périphérique mémoire.
    En même temps, une table stockant des données archivées et peu utilisée
    ou dont les performances ne portent pas à conséquence pourra être stockée
    sur un disque système plus lent, moins cher.
   </para>

   <para>
    Pour définir un espace logique, utilisez la commande <xref
    linkend="sql-createtablespace" endterm="sql-createtablespace-title"/>, par exemple&nbsp;:
    <indexterm><primary>CREATE TABLESPACE</primary></indexterm>
<programlisting>CREATE TABLESPACE espace_rapide LOCATION '/mnt/sda1/postgresql/data';</programlisting>
    L'emplacement doit être un répertoire existant, possédé par l'utilisateur
    système <productname>PostgreSQL</productname>. Tous les objets créés par la suite dans
    l'espace logique seront stockés dans des fichiers contenus dans ce
    répertoire.
   </para>

   <note>
    <para>
     Il n'y a généralement aucune raison de créer plus d'un espace logique
     sur un système de fichiers logique car vous ne pouvez pas contrôler
     l'emplacement des fichiers individuels à l'intérieur de ce système de
     fichiers logique. Néanmoins, <productname>PostgreSQL</productname> ne vous impose
     aucune limitation et, en fait, il n'est pas directement conscient des
     limites du système de fichiers sur votre système. Il stocke juste les
     fichiers dans les répertoires que vous lui indiquez.
    </para>
   </note>

   <para>
    La création d'un espace logique lui-même doit être fait en tant que
    superutilisateur de la base de données mais, après cela, vous pouvez
    autoriser des utilisateurs standards de la base de données à l'utiliser.
    Pour cela, donnez-leur le droit <literal>CREATE</literal> sur l'espace logique.
   </para>

   <para>
    Les tables, index et des bases de données entières peuvent être affectés
    à des espaces logiques particuliers. Pour cela, un utilisateur disposant
    du droit <literal>CREATE</literal> sur un espace logique donné doit passer le
    nom de l'espace logique comme paramètre de la commande. Par exemple, ce
    qui suit crée une table dans l'espace logique <literal>espace1</literal>&nbsp;:
<programlisting>CREATE TABLE foo(i int) TABLESPACE espace1;</programlisting>
   </para>

   <para>
    Autrement, utilisez le paramètre <xref
    linkend="guc-default-tablespace"/>&nbsp;:
<programlisting>SET default_tablespace = espace1;
CREATE TABLE foo(i int);</programlisting>
    Quand <varname>default_tablespace</varname> est configuré avec autre chose qu'une
    chaîne vide, il fournit une clause <literal>TABLESPACE</literal> implicite pour
    les commandes <command>CREATE TABLE</command> et <command>CREATE INDEX</command> qui
    n'en ont pas d'explicites.
   </para>

   <para>
    L'espace logique associé avec une base de données est utilisé pour stocker
    les catalogues système de la base, ainsi que tous les fichier temporaires
    créés par les processus serveur utilisant cette base de données. De plus,
    il est l'espace par défaut pour les tables et index créés à l'intérieur
    de cette base de données si aucune clause <literal>TABLESPACE</literal> n'est
    fournie (soit explicitement soit via <varname>default_tablespace</varname>) lors
    de la création des objets. Si une base de données est créée sans spécifier
    d'espace logique pour elle, le serveur utilise le même espace logique que
    celui de la base modèle utilisée comme copie.
   </para>

   <para>
    Deux espaces logiques sont automatiquement créés par <literal>initdb</literal>.
    L'espace logique <literal>pg_global</literal> est utilisé pour les catalogues
    système partagés. L'espace logique <literal>pg_default</literal> est l'espace
    logique par défaut des bases de données <literal>template1</literal> et
    <literal>template0</literal> (et, du coup, sera l'espace logique par défaut pour
    les autres bases de données sauf en cas de surcharge par une clause
    <literal>TABLESPACE</literal> dans <command>CREATE DATABASE</command>).
   </para>

   <para>
    Une fois créé, un espace logique peut être utilisé à partir de toute base
    de données si l'utilisateur le souhaitant dispose du droit nécessaire.
    Ceci signifie qu'un espace logique ne peut pas supprimé tant que tous les
    objets de toutes les bases de données utilisant l'espace logique n'ont
    pas été supprimés.
   </para>

   <para>
    Pour supprimer un espace logique vide, utilisez la commande <xref
    linkend="sql-droptablespace" endterm="sql-droptablespace-title"/>.
   </para>

   <para>
    Pour déterminer l'ensemble d'espaces logiques existants, examinez le
    catalogue système <structname>pg_tablespace</structname>, par exemple
<synopsis>SELECT spcname FROM pg_tablespace;</synopsis>
    La métacommande <literal>\db</literal> du programme <xref linkend="app-psql"/> est
    aussi utile pour afficher les espaces logiques existants.
   </para>

   <para>
    <productname>PostgreSQL</productname> fait une utilisation intensive des liens
    symboliques pour simplifier l'implémentation des espaces logiques. Ceci
    signifie que les espaces logiques peuvent être utilisés
    <emphasis>seulement</emphasis> sur les systèmes supportant les liens symboliques.
   </para>

   <para>
    Le répertoire <filename>$PGDATA/pg_tblspc</filename> contient des liens symboliques
    qui pointent vers chacun des espaces logiques utilisateur dans le groupe.
    Bien que non recommandé, il est possible d'ajuster la configuration des
    espaces logiques à la main en redéfinissant ces liens. Deux
    avertissements&nbsp;: ne pas le faire alors que le serveur est en cours
    d'exécution, mettez à jour le catalogue <structname>pg_tablespace</structname>
    pour indiquer les nouveaux emplacements (si vous ne le faites pas,
    <literal>pg_dump</literal> continuera à afficher les anciens emplacements des
    espaces logiques).
   </para> 

 </sect1>

</chapter>
