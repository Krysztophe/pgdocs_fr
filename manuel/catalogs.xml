<?xml version="1.0" encoding="UTF-8"?>
<!--
 Documentation of the system catalogs, directed toward PostgreSQL developers
 $Header: /var/lib/cvs/pgsql-fr/sgml/catalogs.sgml,v 1.11 2005/09/22 18:34:39 guillaume Exp $
 -->

<chapter id="catalogs">
 <title>Catalogues système</title>

  <para>
   Les catalogues système sont le lieu où une base de données relationnelle
   stocke les métadonnées des schémas, comme les informations sur les tables 
   et les colonnes, et des données de suivi internes.
   Les catalogues système de <productname>PostgreSQL</productname> sont de
   simples tables. Vous pouvez les supprimer et les recréer, ajouter des
   colonnes, insérer et mettre à jour des valeurs, et mettre un joyeux bazar
   dans votre système. Normalement, on ne devrait pas modifier les catalogues
   système soi-même, il y a toujours des commandes SQL pour le faire. (Par
   exemple, <command>CREATE DATABASE</command> insère une ligne dans le 
   catalogue <structname>pg_database</structname> &mdash; et crée physiquement
   la base de données sur le disque.) Il y a des exceptions pour certaines 
   opérations particulièrement ésotériques, comme l'ajout de méthodes d'accès
   aux index.
  </para>

 <sect1 id="catalogs-overview">
  <title>Aperçu</title>

  <para>
   <xref linkend="catalog-table"/> liste les catalogues système.
   Une documentation détaillée sur les catalogues systèmes vient plus loin.
  </para>

  <para>
   La plupart des catalogues système sont recopiés de la base de données modèle
   lors de la création de la base de données et sont donc spécifiques à 
   chaque base de données. Un petit nombre de catalogues sont physiquement 
   partagés par toutes les bases de données d'une installation de 
   <productname>PostgreSQL</productname>. Ils sont indiqués dans les 
   descriptions des catalogues.
  </para>

  <table id="catalog-table">
   <title>Catalogues système</title>

   <tgroup cols="2">
    <colspec colnum="1" colwidth="1*"/>
    <colspec colnum="2" colwidth="2*"/>
    <thead>
     <row>
      <entry>Nom du catalogue</entry>
      <entry>Contenu</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <entry>fonctions d'agrégat</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <entry>méthodes d'accès aux index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <entry>opérateurs des méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <entry>procédures de support des méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <entry>valeurs par défaut des colonnes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <entry>colonnes des tables (<quote>attributs</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link></entry>
      <entry>identifiants d'autorisation (rôles)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link></entry>
      <entry>relations d'appartenance aux identifiants d'autorisation</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-autovacuum"><structname>pg_autovacuum</structname></link></entry>
      <entry>paramètres de configuration de l'autovacuum par relation</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <entry>conversions de types de données (cast)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <entry>tables, index, séquences, vues (<quote>relations</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <entry>contraintes de vérification, contraintes uniques, contraintes de  
      clés primaires, contraintes de clés étrangères</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <entry>informations de conversions de codage</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <entry>bases de données de l'installation <productname>PostgreSQL</productname> </entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <entry>dépendances entre objets de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <entry>descriptions ou commentaires des objets de base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <entry>informations supplémentaires des index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <entry>hiérarchie d'héritage de tables</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <entry>langages pour écrire des fonctions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <entry>gros objets</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-listener"><structname>pg_listener</structname></link></entry>
      <entry>support de notification asynchrone</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <entry>schémas</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <entry>classes d'opérateurs de méthodes d'accès aux index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <entry>opérateurs</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link></entry>
      <entry>données modèles pour les langages de procédures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <entry>fonctions et procédures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <entry>règles de réécriture de requêtes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link></entry>
      <entry>dépendances sur les objets partagés</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <entry>statistiques de l'optimiseur de requêtes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link></entry>
      <entry>tablespaces dans ce groupe de bases de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <entry>déclencheurs</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <entry>types de données</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-aggregate">
  <title><structname>pg_aggregate</structname></title>

  <indexterm zone="catalog-pg-aggregate">
   <primary>pg_aggregate</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_aggregate</structname> stocke les informations 
   sur les fonctions d'agrégat. Une fonction d'agrégat est une fonction
   qui opère sur un ensemble de données (typiquement une colonne de chaque ligne
   qui correspond à une condition de requête) et retourne une valeur unique 
   calculée à partir de toutes ces valeurs.
   Les fonctions d'agrégat classiques sont
   <function>sum</function> (somme), <function>count</function> (compteur) et
   <function>max</function> (plus grande valeur). Chaque entrée dans
   <structname>pg_aggregate</structname> est une extension d'une entrée dans
   <structname>pg_proc</structname>.  L'entrée de <structname>pg_proc</structname>
   décrit le nom de l'agrégat, les types de données d'entrée et de sortie, et
   d'autres informations des fonctions ordinaires.
  </para>

  <table>
   <title>Les colonnes de <structname>pg_aggregate</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>aggfnoid</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID <structname>pg_proc</structname> de la fonction
       d'agrégat</entry>
     </row>
     <row>
      <entry><structfield>aggtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>fonction de transition</entry>
     </row>
     <row>
      <entry><structfield>aggfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>fonction finale (zéro s'il n'y en a pas)</entry>
     </row>
     <row>
      <entry><structfield>aggsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Opérateur de tri associé (zéro si aucun)</entry>
     </row>
     <row>
      <entry><structfield>aggtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de la donnée interne de transition (état) de la fonction d'agrégat</entry>
     </row>
     <row>
      <entry><structfield>agginitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Valeur initiale de la fonction de transition. C'est un champ texte qui
       contient la valeur initiale dans sa représentation externe en chaîne de 
       caractères. Si ce champ NULL, la valeur d'état de transition 
       est initialement NULL.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les nouvelles fonctions d'agrégat sont enregistrées avec la commande 
   <command>CREATE AGGREGATE</command>. Lisez la <xref linkend="xaggr"/>  pour 
   avoir plus d'informations sur l'écriture des fonctions d'agrégat et sur
   la signification des fonctions de transition, etc.
  </para>

 </sect1>


 <sect1 id="catalog-pg-am">
  <title><structname>pg_am</structname></title>

  <indexterm zone="catalog-pg-am">
   <primary>pg_am</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_am</structname> enregistre les informations sur
   les méthodes d'accès aux index. Il y a une ligne pour chaque méthode d'accès
   supportée par le système. Le contenu de ce catalogue est discuté en détails
   dans <xref linkend="indexam"/>.
   </para>

  <table>
   <title>Colonnes de <structname>pg_am</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la méthode d'accès</entry>
     </row>

     <row>
      <entry><structfield>amstrategies</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de stratégies d'opérateur pour cette méthode d'accès</entry>
     </row>

     <row>
      <entry><structfield>amsupport</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de routines de support pour cette méthode d'accès</entry>
     </row>

     <row>
      <entry><structfield>amorderstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Zéro si l'index n'a pas d'ordre de tri, sinon, numéro de 
      de stratégie de l'opérateur de stratégie qui décrit l'ordre de tri</entry>
     </row>

     <row>
      <entry><structfield>amcanunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Est-ce que la méthode d'accès supporte les index
       uniques&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amcanmulticol</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Est-ce que la méthode d'accès supporte les index
       multicolonnes&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amoptionalkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Est-ce que la méthode d'accès supporte un parcours sans aucune
      contrainte pour la première colonne de l'index&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amindexnulls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Est-ce que la méthode d'accès supporte les entrées d'index NULLs&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amconcurrent</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Est-ce que la méthode d'accès supporte les mises à jour 
      concurrentes&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amgettuple</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>prochaine ligne valide</quote></entry>
     </row>

     <row>
      <entry><structfield>aminsert</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>insérer cette ligne</quote></entry>
     </row>

     <row>
      <entry><structfield>ambeginscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>commencer un nouveau balayage</quote></entry>
     </row>

     <row>
      <entry><structfield>aminsert</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>insérer cette ligne</quote></entry>
     </row>

     <row>
      <entry><structfield>ambeginscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>exécuter un nouveau parcours</quote></entry>
     </row>

     <row>
      <entry><structfield>amgettuple</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>prochaine ligne valide</quote></entry>
     </row>

     <row>
      <entry><structfield>amgetmulti</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>récupérer plusieurs lignes</quote></entry>
     </row>

     <row>
      <entry><structfield>amrescan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>redémarrer ce balayage</quote></entry>
     </row>

     <row>
      <entry><structfield>amendscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>arrêter ce balayage</quote></entry>
     </row>

     <row>
      <entry><structfield>ammarkpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>marquer la position actuelle dans le balayage</quote></entry>
     </row>

     <row>
      <entry><structfield>amrestrpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>restaurer une position de balayage
       sauvegardée</quote></entry>
     </row>

     <row>
      <entry><structfield>ambuild</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>construire un nouvel index</quote></entry>
     </row>

     <row>
      <entry><structfield>ambulkdelete</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de destruction en masse</entry>
     </row>

     <row>
      <entry><structfield>amvacuumcleanup</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de nettoyage post-<command>VACUUM</command></entry>
     </row>

     <row>
      <entry><structfield>amcostestimate</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction d'estimation du coût d'un balayage d'index</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-amop">
  <title><structname>pg_amop</structname></title>

  <indexterm zone="catalog-pg-amop">
   <primary>pg_amop</primary>
  </indexterm>

  <para> Le catalogue <structname>pg_amop</structname> stocke les informations 
  sur les opérateurs associés aux classes d'opérateurs de méthodes d'accès aux index.
  Il y a une ligne pour chaque opérateur qui est membre d'une classe d'opérateurs.
  </para>

  <table>
   <title>Colonnes de <structname>pg_amop</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amopclaid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>La classe d'opérateur d'index de cette entrée.</entry>
     </row>

     <row>
      <entry><structfield>amopsubtype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Sous-type pour distinguer plusieurs entrées d'une stratégie&nbsp;;
       zéro par défaut</entry>
     </row>

     <row>
      <entry><structfield>amopstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Numéro de stratégie d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>amopreqcheck</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Une entrée trouvée dans l'index doit être revérifiée.</entry>
     </row>

     <row>
      <entry><structfield>amopopr</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>OID de l'opérateur</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-amproc">
  <title><structname>pg_amproc</structname></title>

  <indexterm zone="catalog-pg-amproc">
   <primary>pg_amproc</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_amproc</structname> enregistre des informations
   sur les procédures de support associées aux classes d'opérateurs de méthodes 
   d'accès. Il y a une ligne pour chaque procédure de support appartenant à
   une classe d'opérateur.
  </para>

  <table>
   <title>Colonnes de <structname>pg_amproc</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amopclaid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>La classe d'opérateurs d'index de cette entrée</entry>
     </row>

     <row>
      <entry><structfield>amprocsubtype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Sous-type dans le cas d'une routine intertype, zéro sinon</entry>
     </row>

     <row>
      <entry><structfield>amprocnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Numéro de procédure de support</entry>
     </row>

     <row>
      <entry><structfield>amproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID de la procédure</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title><structname>pg_attrdef</structname></title>

  <indexterm zone="catalog-pg-attrdef">
   <primary>pg_attrdef</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_attrdef</structname> stocke les valeurs par
   défaut des colonnes. Les informations principales des colonnes sont stockées
   dans <structname>pg_attribute</structname> (voir plus loin). Seules les
   colonnes pour lesquelles une valeur par défaut est explicitement indiquée
   (quand la table est créée ou quand une colonne est ajoutée) ont une entrée dans 
   <structname>pg_attrdef</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_attrdef</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>adrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>La table de cette colonne.</entry>
     </row>

     <row>
      <entry><structfield>adnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Numéro de la colonne</entry>
     </row>

     <row>
      <entry><structfield>adbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Représentation interne de la valeur par défaut de la colonne</entry>
     </row>

     <row>
      <entry><structfield>adsrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Une représentation lisible de la valeur par défaut</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Le champ <structfield>adsrc</structfield> est historique et il est mieux 
   de ne pas l'utiliser parce qu'il ne conserve pas de trace des modifications qui
   pourraient affecter la représentation de la valeur par défaut. La
   compilation inverse du champ <structfield>adbin</structfield> (avec
   <function>pg_get_expr</function> par exemple) est une meilleure façon d'afficher la
   valeur par défaut.
  </para>

 </sect1>


 <sect1 id="catalog-pg-attribute">
  <title><structname>pg_attribute</structname></title>

  <indexterm zone="catalog-pg-attribute">
   <primary>pg_attribute</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_attribute</structname> stocke les informations
   sur les colonnes des tables. Il y a exactement une ligne de 
   <structname>pg_attribute</structname> pour chaque colonne de chaque table de
   la base de données. (Il y a aussi des attributs pour les index et, en fait,
   tous les objets qui possèdent des entrées dans <structname>pg_class</structname>.)
  </para>

  <para>
   Le terme attribut est équivalent à colonne et est utilisé pour des raisons 
   historiques.
  </para>

  <table>
   <title>Colonnes de <structname>pg_attribute</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>attrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>La table de cette colonne</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Le nom de la colonne</entry>
     </row>

     <row>
      <entry><structfield>atttypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Le type de données de cette colonne</entry>
     </row>

     <row>
      <entry><structfield>attstattarget</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>attstattarget</structfield> contrôle le niveau de détail des
       statistiques accumulées pour cette colonne par <xref linkend="sql-analyze"
       endterm="sql-analyze-title"/>.
       Une valeur de zéro indique qu'aucune statistique ne doit être collectée.
       Une valeur négative indique d'utiliser l'objectif de statistiques 
       par défaut.
       Le sens exacte d'une valeur positive dépend du type de données.
       Pour les données scalaires, <structfield>attstattarget</structfield>
       est à la fois le nombre visé de <quote>valeurs les plus courantes</quote>
       et le nombre visé d'histogrammes à créer.
      </entry>
     </row>

     <row>
      <entry><structfield>attlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Une copie de <literal>pg_type.typlen</literal> pour le type de cette 
       colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>attnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Le numéro de la colonne. Les colonnes ordinaires sont numérotées en 
       commençant par 1. Les colonnes système, comme les 
       <structfield>oid</structfield>, ont des numéros négatifs arbitraires.
      </entry>
     </row>

     <row>
      <entry><structfield>attndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Nombre de dimensions, si la colonne est de type tableau, sinon 0.
       (Pour l'instant, le nombre de dimensions des tableaux n'est pas contrôlé,
       donc une valeur autre que zéro indique que <quote>c'est un tableau</quote>.)
      </entry>
     </row>

     <row>
      <entry><structfield>attcacheoff</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Toujours -1 sur disque, mais peut être mis à jour, en mémoire, pour 
       mettre en cache l'emplacement de l'attribut dans la ligne.
      </entry>
     </row>

     <row>
      <entry><structfield>atttypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>atttypmod</structfield> des données spécifiques au type
       de données précisé lors de la création de la table (par exemple, la
       taille maximale d'une colonne de type <type>varchar</type>). Il est
       transmis à des fonctions spécifiques au type d'entrée de données et de
       vérification de taille. La valeur est généralement de -1 pour les types
       de données qui n'ont pas besoin de <structfield>atttypmod</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>attbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Une copie de <literal>pg_type.typbyval</literal> pour ce type de données.
      </entry>
     </row>

     <row>
      <entry><structfield>attstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Contient normalement une copie de <literal>pg_type.typstorage</literal> pour
       ce type de données. Pour les types de données TOASTables, cette valeur 
       peut être modifiée après la création de la colonne pour contrôler la règle
       de stockage.
      </entry>
     </row>

     <row>
      <entry><structfield>attalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Contient une copie de <literal>pg_type.typalign</literal> pour le type de 
       cette colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>attnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique une contrainte de colonne non NULL. Il est possible de changer
       cette colonne pour activer ou désactiver cette contrainte. 
       </entry>
     </row>

     <row>
      <entry><structfield>atthasdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique que cette colonne a une valeur par défaut. Dans ce cas, il y 
       aura une entrée correspondante dans le catalogue 
       <structname>pg_attrdef</structname> pour définir cette valeur.
      </entry>
     </row>

     <row>
      <entry><structfield>attisdropped</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique que cette colonne a été supprimée et n'est plus valide. Une 
       colonne supprimée est toujours présente physiquement dans la table,
       mais elle est ignorée par l'analyseur de requête et ne peut être
       accédée en SQL.
      </entry>
     </row>

     <row>
      <entry><structfield>attislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Cette colonne est définie localement dans la relation. Notez qu'une
       colonne peut être définie localement et héritée simultanément.
      </entry>
     </row>

     <row>
      <entry><structfield>attinhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Nombre d'ancêtres directs de cette colonne. Une colonne qui a un nombre
       d'ancêtres différent de zéro ne peut être supprimée ni renommée.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
	Dans l'entrée <structname>pg_attribute</structname> d'une colonne
	supprimée, <structfield>atttypid</structfield> est réinitialisée à
	zéro mais <structfield>attlen</structfield> et les autres champs copiés à
	partir de <structname>pg_type</structname> sont toujours valides. Cet arrangement est
	nécessaire pour s'adapter à la situation où le type de données de la
	colonne supprimée a été ensuite supprimé et qu'il n'existe donc plus de
	ligne <structname>pg_type</structname>. <structfield>attlen</structfield> et les
	autres champs peuvent être utilisés pour interpréter le contenu
	d'une ligne de la table.
  </para>
 </sect1>


 <sect1 id="catalog-pg-authid">
  <title><structname>pg_authid</structname></title>

  <indexterm zone="catalog-pg-authid">
   <primary>pg_authid</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_authid</structname> contient des informations
   sur les identifiants pour les autorisations d'accès aux bases de données
   (rôles). Un rôle reprend les concepts des <quote>utilisateurs</quote> et des
   <quote>groupes</quote>. Un utilisateur est principalement un rôle qui a
   l'attribut de connexion (<structfield>rolcanlogin</structfield>). Tout rôle (avec ou
   sans <structfield>rolcanlogin</structfield>) peut avoir d'autres rôles comme
   membres&nbsp;; voir <link
   linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link>.
  </para>

  <para>
   Comme ce catalogue contient les mots de passe, il n'est pas lisible par
   tout le monde.
   <link linkend="view-pg-roles"><structname>pg_roles</structname></link>
   est une vue, lisible par tout le monde, de 
   <structname>pg_authid</structname> mais qui vide le champ du mot de passe.
  </para>

  <para>
   <xref linkend="user-manag"/> contient des informations détaillées sur les
   utilisateurs et sur la gestion des droits.
  </para>

  <para>
   Comme l'identité des utilisateurs est identique pour tout le groupe de bases
   de données, <structname>pg_authid</structname> est partagé parmi toutes les
   bases d'un groupe&nbsp;; il n'existe qu'une copie de
   <structname>pg_authid</structname> par groupe, et non pas une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_authid</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du rôle</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle est un superutilisateur</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle hérite automatiquement des droits des rôles dont il est
       membre</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle peut créer d'autres rôles</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Le rôle peut mettre à jour les catalogues système directement. (Même
       un superutilisateur ne peut le faire si cette colonne ne vaut pas
       <literal>true</literal>.)
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Le rôle peut se connecter, c'est-à-dire qu'il peut être donné
       comme identifiant d'autorisation de session.
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour les rôles qui peuvent se connecter, ceci indique le nombre maximum
       de connexions concurrentes que peut avoir ce rôle. -1 signifie sans
       limite.
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Le mot de passe (peut-être crypté)&nbsp;; NULL si aucun</entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry></entry>
      <entry>Temps d'expiration du mot de passe (seulement utilisé pour
       l'authentification par mot de passe)&nbsp;; NULL si valable indéfiniment
       </entry>
     </row>

     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Valeurs par défaut des variables de configuration pour la
        session</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-auth-members">
  <title><structname>pg_auth_members</structname></title>

  <indexterm zone="catalog-pg-auth-members">
   <primary>pg_auth_members</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_auth_members</structname> affiche les relations
   membres entre les rôles. Tout ensemble non circulaire d'appartenances est
   autorisé.
  </para>

  <para>
   Parce que les identités de l'utilisateur sont sur tout le groupe,
   <structname>pg_auth_members</structname> est partagé parmi toutes les bases
   de données d'un groupe&nbsp;: il n'existe qu'une seule copie de
   <structname>pg_auth_members</structname> par groupe, pas une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_auth_members</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>roleid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant d'un rôle qui a un membre</entry>
     </row>

     <row>
      <entry><structfield>member</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant d'un rôle qui est membre d'un
        <structfield>roleid</structfield></entry>
     </row>

     <row>
      <entry><structfield>grantor</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant du rôle qui a donné cet appartenance</entry>
     </row>

     <row>
      <entry><structfield>admin_option</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si <structfield>member</structfield> pourrait donner l'appartenance de
      <structfield>roleid</structfield> aux autres</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-autovacuum">
  <title><structname>pg_autovacuum</structname></title>

  <indexterm zone="catalog-pg-autovacuum">
   <primary>pg_autovacuum</primary>
  </indexterm>

  <indexterm zone="catalog-pg-autovacuum">
   <primary>autovacuum</primary>
   <secondary>configuration par table</secondary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_autovacuum</structname> stocke des paramètres de
   configuration optionnels par relation pour <xref linkend="autovacuum"
   endterm="autovacuum-title"/>. S'il existe
   une entrée ici pour une relation particulière, les paramètres donnés seront
   utilisés par autovacuum pour cette table. Si aucune entrée n'est présente, 
   les paramètres par défaut du système seront utilisés.
  </para>

  <table>
   <title>Colonnes de <structname>pg_autovacuum</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>vacrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Le table concernée par cette entrée</entry>
     </row>

     <row>
      <entry><structfield>enabled</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si <literal>false</literal>, cette table n'est jamais prise en compte 
        par autovacuum</entry>
     </row>

     <row>
      <entry><structfield>vac_base_thresh</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Nombre minimum de lignes modifiées avant de lancer un
        vacuum</entry>
     </row>

     <row>
      <entry><structfield>vac_scale_factor</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Multiplicateur pour reltuples à ajouter à
       <structfield>vac_base_thresh</structfield></entry>
     </row>

     <row>
      <entry><structfield>anl_base_thresh</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Nombre minimum de lignes modifiées avant de lancer une
        analyse</entry>
     </row>

     <row>
      <entry><structfield>anl_scale_factor</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Multiplicateur pour reltuples à ajouter à
        <structfield>anl_base_thresh</structfield></entry>
     </row>

     <row>
      <entry><structfield>vac_cost_delay</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Paramètre <varname>vacuum_cost_delay</varname> personnalisé</entry>
     </row>

     <row>
      <entry><structfield>vac_cost_limit</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Paramètre <varname>vacuum_cost_limit</varname> personnalisé</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Le démon autovacuum lance une opération de <command>VACUUM</command> sur une
   table particulière quand le nombre de lignes mises à jour ou supprimées
   dépasse <structfield>vac_base_thresh</structfield> plus
   <structfield>vac_scale_factor</structfield> fois le nombre de lignes
   réelles actuellement estimées dans la relation. De façon similaire, il
   initie une opération <command>ANALYZE</command> quand le nombre de lignes
   insérées, mises à jour ou supprimées dépasse
   <structfield>anl_base_thresh</structfield> plus
   <structfield>anl_scale_factor</structfield> fois le nombre de lignes réelles
   actuellement estimées comme faisant parties de la relation.
  </para>

  <para>
   Tout champ numérique peut contenir <literal>-1</literal> (ou toute autre valeur
   numérique) pour indiquer que la valeur par défaut du système doit être
   utilisée pour cette valeur particulière. Observez que la variable
   <structfield>vac_cost_delay</structfield> hérite sa valeur par défaut du paramètre
   de configuration <varname>autovacuum_vacuum_cost_delay</varname> ou de
   <varname>vacuum_cost_delay</varname> si le premier est négatif. La même logique
   s'applique à <structfield>vac_cost_limit</structfield>.
  </para>

 </sect1>


 <sect1 id="catalog-pg-cast">
  <title><structname>pg_cast</structname></title>

  <indexterm zone="catalog-pg-cast">
   <primary>pg_cast</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_cast</structname> stocke les chemins de 
   conversion de type de donnée, qu'ils soient par défaut ou définis avec la
   commande <command>CREATE CAST</command>.
  </para>

  <table>
   <title>Colonnes de <structfield>pg_cast</structfield></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>castsource</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID du type de données source</entry>
     </row>

     <row>
      <entry><structfield>casttarget</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID du type de données en sortie</entry>
     </row>

     <row>
      <entry><structfield>castfunc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       OID de la fonction à utiliser pour faire cette conversion. Vaut Zéro si
       les types de données sont binairement compatibles (c'est-à-dire si aucune
       opération n'est nécessaire pour effectuer la transformation).
      </entry>
     </row>

     <row>
      <entry><structfield>castcontext</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indique dans quel contexte la conversion peut être utilisée.
       <literal>e</literal> si seules les conversions explicites sont autorisées (avec
       <literal>CAST</literal> ou <literal>::</literal>).
       <literal>a</literal> si les conversions implicites lors de l'affectation à une
       colonne sont autorisées, en plus des conversions explicites.
       <literal>i</literal> si les conversions implicites dans les expressions sont 
       autorisées en plus des autres cas.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
    Les fonctions de conversion listées dans <structname>pg_cast</structname>
    doivent toujours prendre le type source de la conversion comme type du
    premier argument et renvoyer le type de destination de la conversion comme
    type de retour. Une fonction de conversion peut avoir jusqu'à trois
    arguments. Le deuxième argument, s'il est présent, doit être du type
    <type>integer</type>&nbsp;; il reçoit le modificateur de type associé avec le
    type de destination ou <literal>-1</literal> s'il n'y en a pas. Le troisième
    argument, s'il est présent, doit être du type <type>boolean</type>&nbsp;; il
    reçoit <literal>true</literal> si la conversion est une conversion explicite,
    <literal>false</literal> sinon.
  </para>

  <para>
    Il est légitime de créer une entrée <structname>pg_cast</structname> dans
    laquelle les types source et cible sont les mêmes, si la fonction associée
    prend plus d'un argument. De telles entrées représentent les
    <quote>fonctions de coercition de longueur</quote> qui forcent les valeurs du type
    à être légal pour une valeur particulière du modificateur de type.
    Néanmoins, notez qu'à présent il n'existe aucun support pour associer des
    modifications de type autres que ceux de base avec des types de données créés
    par l'utilisateur. Du coup, cette fonctionnalité est seulement utile pour
    un petit nombre de types intégrés qui ont une syntaxe de modificateur de
    type construit dans leur grammaire.
  </para>

  <para>
    Quand une entrée <structname>pg_cast</structname> a des types différents
    pour la source et la destination et qu'une fonction prend plus d'un
    argument, il représente la conversion d'un type vers un autre et la
    coercition en une seule étape. Quand une telle entrée est absente, la
    coercition vers un type qui utilise un modificateur de type implique deux
    étapes, une pour convertir entre les types de données et une seconde pour
    appliquer le modificateur.
  </para>
 </sect1>

 <sect1 id="catalog-pg-class">
  <title><structname>pg_class</structname></title>

  <indexterm zone="catalog-pg-class">
   <primary>pg_class</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_class</structname> catalogue les tables, et 
   à peu près tout ce qui a des colonnes ou qui ressemble de près ou de loin à
   une table. Cela inclut les index (mais il faut aussi aller voir dans
   <structname>pg_index</structname>), les séquences, les vues, les types
   composites et certaines sortes de relations spéciales&nbsp;; voir
   <structfield>relkind</structfield>.
   Par la suite, lorsque l'on parle de <quote>relation</quote>, on parle de
   tous ces types d'objets. Toutes les colonnes n'ont pas un sens pour tous les
   types de relations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_class</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la table, vue, index, etc.</entry>
     </row>

     <row>
      <entry><structfield>relnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de noms qui contient cette relation.
      </entry>
     </row>

     <row>
      <entry><structfield>reltype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>
       OID du type de données qui correspond au type de ligne de cette table,
       s'il y en a un.
       Zéro pour les index qui n'ont pas d'entrée dans <structname>pg_type</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>relowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
       .oid</literal></entry>
      <entry>Propriétaire de la relation.</entry>
     </row>

     <row>
      <entry><structfield>relam</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-am"><structname>pg_am</structname></link>
       .oid</literal></entry>
      <entry>Si c'est un index, OID de la méthode d'accès utilisée (B-tree,
       hash, etc.)</entry>
     </row>

     <row>
      <entry><structfield>relfilenode</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Nom du fichier disque de cette relation&nbsp;; 0 s'il n'y en a
       pas.</entry>
     </row>

     <row>
      <entry><structfield>reltablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       Le tablespace dans lequel cette relation est stockée. Si zéro, l'espace
       logique par défaut de cette base de données est utilisée. (Sans intérêt si
       la relation n'a pas de fichier sur disque.)
     </entry>
     </row>

     <row>
      <entry><structfield>relpages</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Taille du fichier disque, exprimée en pages (de taille 
       <symbol>BLCKSZ</symbol>).
       Ce n'est qu'une estimation utilisée par l'optimiseur. Elle est mise à 
       jour par les commandes <command>VACUUM</command>,
       <command>ANALYZE</command> et quelques commandes DDL comme <command>CREATE
       INDEX</command>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltuples</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       Nombre de lignes de la table.
       Ce n'est qu'une estimation utilisée par l'optimiseur. Elle est mise à 
       jour par les commandes <command>VACUUM</command>,
       <command>ANALYZE</command> et quelques commandes DDL comme
       <command>CREATE INDEX</command>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>
       OID de la table TOAST associée à cette table. 0 s'il n'y en a pas.
       La table TOAST stocke les attributs de grande taille <quote>hors de la
       ligne</quote> dans une table secondaire.
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastidxid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>
       Pour une table TOAST, OID de son index. 0 si ce n'est pas une table
       TOAST.
      </entry>
     </row>

     <row>
      <entry><structfield>relhasindex</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si cette table a (ou a eu récemment) un ou plusieurs index.
       Ce champ est mis à jour par <command>CREATE INDEX</command>, mais pas
       remis à faux immédiatement après <command>DROP INDEX</command>.
       <command>VACUUM</command> remet <structfield>relhasindex</structfield> à faux s'il
       s'aperçoit que la table n'a pas d'index.
      </entry>
     </row>

     <row>
      <entry><structfield>relisshared</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si cette table est partagée par toutes les bases de données
      du groupe de bases de données. Seuls certains catalogues système (comme
      <structname>pg_database</structname>) sont partagés.</entry>
     </row>

     <row>
      <entry><structfield>relkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>r</literal> = table ordinaire, <literal>i</literal> = index,
       <literal>S</literal> = séquence, <literal>v</literal> = vue, <literal>c</literal> =
       type composite, <literal>s</literal> = spécial, <literal>t</literal> = table TOAST.
      </entry>
     </row>

     <row>
      <entry><structfield>relnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Nombre de colonnes utilisateur dans la relation (sans compter les
       colonnes système). Il doit y avoir le même nombre d'entrées dans
       <structname>pg_attribute</structname>. Voir aussi
       <literal>pg_attribute.attnum</literal>.
      </entry>
     </row>

     <row>
      <entry><structfield>relchecks</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Nombre de contraintes de vérification sur la table&nbsp;; voir le
       catalogue <structname>pg_constraint</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltriggers</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Nombre de déclencheurs sur la table&nbsp;; voir le catalogue
       <structname>pg_trigger</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>relukeys</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Inutilisé. (Ce n'est <emphasis>pas</emphasis> le nombre de clés
       uniques de la table.)</entry>
     </row>

     <row>
      <entry><structfield>relfkeys</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Inutilisé. (Ce n'est <emphasis>pas</emphasis> le nombre de clés 
      étrangères de la table.)</entry>
     </row>

     <row>
      <entry><structfield>relrefs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Inutilisé</entry>
     </row>

     <row>
      <entry><structfield>relhasoids</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si on génère un OID pour chaque ligne de la relation.
      </entry>
     </row>

     <row>
      <entry><structfield>relhaspkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si la table a (ou a eu) une clé primaire.
      </entry>
     </row>

     <row>
      <entry><structfield>relhasrules</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la table comprend des règles&nbsp;; voir le catalogue
       <structname>pg_rewrite</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>relhassubclass</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si au moins une table hérite ou a hérité de celle-ci.</entry>
     </row>

     <row>
      <entry><structfield>relacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Droits d'accès&nbsp;; voir <xref linkend="sql-grant"
       endterm="sql-grant-title"/> et <xref linkend="sql-revoke"
       endterm="sql-revoke-title"/> pour plus de
       détails.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-constraint">
  <title><structname>pg_constraint</structname></title>

  <indexterm zone="catalog-pg-constraint">
   <primary>pg_constraint</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_constraint</structname> stocke les vérifications,
   clés primaires, clés uniques et étrangères des tables (Les contraintes de
   colonnes ne sont pas traitées de manière particulière. Elles sont 
   équivalentes à des contraintes de tables.) Les contraintes NOT NULL sont
   représentées dans le catalogue <structname>pg_attribute</structname>.
  </para>

  <para>
   Les contraintes de vérification de domaine sont aussi stockées ici.
  </para>

  <table>
   <title>Colonnes de <structname>pg_constraint</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la contrainte (pas nécessairement unique&nbsp;!)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de noms qui contient cette contrainte.
      </entry>
     </row>

     <row>
      <entry><structfield>contype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
        <literal>c</literal> = contrainte de vérification,
        <literal>f</literal> = contrainte de clé étrangère,
        <literal>p</literal> = contrainte de clé primaire,
        <literal>u</literal> = contrainte de clé unique
      </entry>
     </row>

     <row>
      <entry><structfield>condeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La contrainte est-elle différable&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>condeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La contrainte est-elle différée par défaut&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>conrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid
       </literal></entry>
      <entry>Table à laquelle appartient la contrainte&nbsp;; 0 si ce n'est pas
       une contrainte de table.
      </entry>
     </row>

     <row>
      <entry><structfield>contypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>Domaine auquel appartient la contrainte&nbsp;; 0 si ce n'est pas
       une contrainte de domaine.
      </entry>
     </row>

     <row>
      <entry><structfield>confrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>Si c'est une clé étrangère, la table référencée&nbsp;; sinon
       0</entry>
     </row>

     <row>
      <entry><structfield>confupdtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Code de l'action de mise à jour de la clé étrangère</entry>
     </row>

     <row>
      <entry><structfield>confdeltype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Code de l'action de suppression de clé étrangère</entry>
     </row>

     <row>
      <entry><structfield>confmatchtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Type de vérification de clé étrangère</entry>
     </row>

     <row>
      <entry><structfield>conkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link
       linkend="catalog-pg-attribute"><structname>pg_attribute</structname>
       </link>.attnum</literal></entry>
      <entry>Si c'est une contrainte de table, liste des colonnes
       contraintes</entry>
     </row>

     <row>
      <entry><structfield>confkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link
       linkend="catalog-pg-attribute"><structname>pg_attribute</structname>
       </link>.attnum</literal></entry>
      <entry>Si c'est une clé étrangère, liste des colonnes référencées</entry>
     </row>

     <row>
      <entry><structfield>conbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>S'il s'agit d'une contrainte de vérification, représentation
       interne de l'expression</entry>
     </row>

     <row>
      <entry><structfield>consrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>S'il s'agit d'une contrainte de vérification, représentation
       compréhensible de l'expression</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <structfield>consrc</structfield> n'est pas mis à jour lors de modification
    d'objets référencés&nbsp;; par exemple, il ne pistera pas les renommages de
    colonnes. Plutôt que se fier à ce champ, il est mieux d'utiliser
    <function>pg_get_constraintdef()</function> pour extraire la définition d'une
    contrainte de vérification.
   </para>
  </note>

  <note>
   <para>
    <literal>pg_class.relchecks</literal> doit connaître le même nombre de 
    contraintes de vérification pour chaque relation.
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-conversion">
  <title><structname>pg_conversion</structname></title>

  <indexterm zone="catalog-pg-conversion">
   <primary>pg_conversion</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_conversion</structname> décrit les procédures
   disponibles de conversion de codage. Voir la commande <xref
   linkend="sql-createconversion" endterm="sql-createconversion-title"/> pour
   plus d'information.
  </para>

  <table>
   <title>Colonnes de <structname>pg_conversion</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la conversion (unique au sein d'un espace de noms)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de nom qui contient cette conversion.
      </entry>
     </row>

     <row>
      <entry><structfield>conowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
	linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
	.oid</literal></entry>
      <entry>Propriétaire de la conversion</entry>
     </row>

     <row>
      <entry><structfield>conforencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>ID du codage source</entry>
     </row>

     <row>
      <entry><structfield>contoencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>ID du codage de destination</entry>
     </row>

     <row>
      <entry><structfield>conproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname></link>
       .oid</literal></entry>
      <entry>Procédure de conversion</entry>
     </row>

     <row>
      <entry><structfield>condefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai s'il s'agit de la conversion par défaut</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-database">
  <title><structname>pg_database</structname></title>

  <indexterm zone="catalog-pg-database">
   <primary>pg_database</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_database</structname> stocke les informations sur
   les bases de données disponibles. Les bases de données sont créées avec la
   commande <command>CREATE DATABASE</command>. Consultez le <xref
   linkend="managing-databases"/> pour avoir des détails sur la signification de
   certains paramètres.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_database</structname> est partagé entre toutes les bases de
   données d'un groupe de bases&nbsp;: il n'y a qu'une seule copie de
   <structname>pg_database</structname> par groupe, pas une par base.
  </para>

  <table>
   <title>Colonnes de <structname>pg_database</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la base de données</entry>
     </row>

     <row>
      <entry><structfield>datdba</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
       .oid</literal></entry>
      <entry>Propriétaire de la base, généralement l'utilisateur qui l'a
       créée</entry>
     </row>

     <row>
      <entry><structfield>encoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Codage des caractères pour cette base de données.</entry>
     </row>

     <row>
      <entry><structfield>datistemplate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si ce champ vaut vrai, alors la base peut être utilisée dans la clause
       <literal>TEMPLATE</literal> de la commande <command>CREATE
       DATABASE</command> pour créer une nouvelle base qui sera un clone de 
       celle-ci.
      </entry>
     </row>

     <row>
      <entry><structfield>datallowconn</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si ce champ vaut faux, alors personne ne peut se connecter à cette
       base de données. Ceci permet d'empêcher toute altération de la base 
       <literal>template0</literal>.
      </entry>
     </row>

     <row>
      <entry><structfield>datconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Configure le nombre maximum de connexions concurrentes effectuées sur
       cette base de données. -1 indique qu'il n'y a pas de limite.
      </entry>
     </row>

     <row>
      <entry><structfield>datlastsysoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       Dernier OID système de la base de données&nbsp;; utile en particulier
       pour <application>pg_dump</application>.
      </entry>
     </row>

     <row>
      <entry><structfield>datvacuumxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       Toutes les lignes insérées ou supprimées par des ID de transaction
       inférieurs à celui-ci ont été marquées <quote>validé de manière avérée</quote>
       ou <quote>annulé de manière avérée</quote> dans cette base de données. 
       C'est utilisé pour déterminer quand l'espace des journaux de validation
       peut être réutilisé.
      </entry>
     </row>

     <row>
      <entry><structfield>datfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       Toutes les lignes insérées ou supprimées par des ID de transaction
       inférieurs à celui-ci ont été réétiquetés avec un ID de transaction
       permanent  (<quote>gelé</quote> dans cette base de données. C'est utile pour
       vérifier si une base de données doit être rapidement nettoyée avec 
       <command>VACUUM</command> pour éviter les problèmes créés par une remise
       à zéro du compteur de transaction.
      </entry>
     </row>

     <row>
      <entry><structfield>dattablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       Le tablespace par défaut de la base de données.
       À l'intérieur de cette base de données, toutes les tables pour lesquelles
       <structname>pg_class</structname>.<structfield>reltablespace</structfield> vaut zéro seront
       stockées dans ce tablespace&nbsp;; en particulier, tous les catalogues
       système non partagés seront ici.
      </entry>
     </row>

     <row>
      <entry><structfield>datconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Valeurs par défaut de la session pour les variables modifiables en 
       cours de fonctionnement.
      </entry>
     </row>

     <row>
      <entry><structfield>datacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir <xref linkend="sql-grant"
       endterm="sql-grant-title"/> et <xref linkend="sql-revoke"
       endterm="sql-revoke-title"/> pour des détails.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-depend">
  <title><structname>pg_depend</structname></title>

  <indexterm zone="catalog-pg-depend">
   <primary>pg_depend</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_depend</structname> enregistre les relations de
   dépendances entre les objets de la base de données. Cette information permet
   à la commande <command>DROP</command> de trouver quels autres objets doivent être
   supprimés par la commande <command>DROP CASCADE</command> ou au contraire empêchent
   la suppression dans le cas de <command>DROP RESTRICT</command>.
  </para>

  <para>
   Voir aussi also <link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link>,
   réalisant une fonction similaire pour les dépendances impliquant des
   objets partagés sur tout le groupe de bases de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_depend</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>OID du catalogue système dans lequel l'objet dépendant se
       trouve.</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet dépendant</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour une colonne de table, ce champ indique le numéro de colonne (les
       champs <structfield>objid</structfield> et <structfield>classid</structfield> se réfèrent à 
       la table elle-même). Pour tous les autres types d'objets, cette colonne
       est à zéro.
      </entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>OID du catalogue système dans lequel l'objet référencé se trouve.
      </entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet référencé</entry>
     </row>

     <row>
      <entry><structfield>refobjsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour une colonne de table, ce champ indique le numéro de colonne (les
       champs <structfield>refobjid</structfield> et <structfield>refclassid</structfield> se réfèrent
       à la table elle même). Pour tous les autres types d'objets, cette colonne
       est à zéro.
      </entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Code définissant la sémantique de cette relation de dépendance. Voir le 
       texte.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Dans tous les cas, une entrée dans <structname>pg_depend</structname> indique
   que l'objet référence ne peut pas être supprimé sans supprimer aussi l'objet
   dépendant. Néanmoins, il y a des nuances, identifiées par
   <structfield>deptype</structfield>&nbsp;:

   <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</symbol> (<literal>n</literal>)</term>
     <listitem>
      <para>
       Une relation normale entre des objets créés séparément. L'objet dépendant
       peut être supprimé sans affecter l'objet référencé. L'objet référencé ne
       peut être supprimé qu'en précisant l'option <literal>CASCADE</literal>,
       auquel cas l'objet dépendant est supprimé lui-aussi. Exemple&nbsp;: une
       colonne de table a une dépendance normale avec ses types de données. 
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant peut être supprimé séparément de l'objet de référence,
       et doit être automatiquement supprimé si l'objet référencé est supprimé,
       quel que soit le mode <literal>RESTRICT</literal> ou <literal>CASCADE</literal>.
       Exemple&nbsp;: une contrainte nommée sur une table est auto-dépendante
       sur la table et sera automatiquement supprimée en même temps que la
       table.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</symbol> (<literal>i</literal>)</term>
     <listitem>
      <para>
       L'objet dépendant a été créé comme une partie de l'objet référencé et 
       n'est réellement qu'une partie de son implémentation interne. Un
       <command>DROP</command> de l'objet dépendant sera interdit (avec un message 
       à l'utilisateur lui proposant de faire un <command>DROP</command> de l'objet
       référencé à la place). Une suppression de l'objet référencé sera propagée
       à l'objet dépendant que <command>CASCADE</command> soit précisé ou non.
       Exemple&nbsp;: un trigger qui est créé pour vérifier une contrainte de
       clé étrangère, est rendu dépendant de l'entrée de la contrainte dans
       <structname>pg_constraint</structname>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>
       Il n'y a pas d'objet dépendant&nbsp;; ce type d'entrée signale que le
       système lui même dépend de l'objet référencé, et donc que l'objet ne doit
       jamais être supprimé. Les entrées de ce type sont créées uniquement par
       <command>initdb</command>. Les colonnes pour l'objet dépendant 
       contiennent des zéros.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   D'autres types de dépendance pourraient apparaître dans le futur.
  </para>

 </sect1>


 <sect1 id="catalog-pg-description">
  <title><structname>pg_description</structname></title>

  <indexterm zone="catalog-pg-description">
   <primary>pg_description</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_description</structname> stocke des descriptions 
   (commentaires) optionnels pour chaque objet de la base de données. Les
   descriptions sont manipulées avec la commande <command>COMMENT</command> et
   lues avec les commandes <literal>\d</literal> de
   <application>psql</application>. Les descriptions de nombreux objets internes
   sont prédéfinies dans <structname>pg_description</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_description</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet décrit.</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>OID du système catalogue dans lequel apparaît l'objet
       décrit.</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour un commentaire sur une table, le numéro de colonne. Les champs
       <structfield>objoid</structfield> et <structfield>classoid</structfield> font référence à la
       table elle-même. Pour tous les autres types de données, cette colonne 
       est à zéro.
      </entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Texte quelconque qui sert de description à cet objet.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-index">
  <title><structname>pg_index</structname></title>

  <indexterm zone="catalog-pg-index">
   <primary>pg_index</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_index</structname> contient une partie des 
   informations sur les index. Le reste se trouve essentiellement dans
   <structname>pg_class</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_index</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>indexrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>OID de l'entrée dans <structname>pg_class</structname> pour cet index</entry>
     </row>

     <row>
      <entry><structfield>indrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>OID de l'entrée dans <structname>pg_class</structname> de la table sur 
       laquelle cet index porte.
      </entry>
     </row>

     <row>
      <entry><structfield>indnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de colonnes de l'index (duplique
      <literal>pg_class.relnatts</literal>)</entry>
     </row>

     <row>
      <entry><structfield>indisunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai s'il s'agit d'un index unique.</entry>
     </row>

     <row>
      <entry><structfield>indisprimary</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si cet index est la clé primaire de la table.
      (<structfield>indisunique</structfield> doit toujours être vrai quand ce champ l'est
aussi.)</entry>
     </row>

     <row>
      <entry><structfield>indisclustered</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la table était organisée en fonction de cet index.</entry>
     </row>

     <row>
      <entry><structfield>indkey</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       C'est un tableau de valeurs <structfield>indnatts</structfield> qui
       indique quelles colonnes de table sont compris dans cet index. Par
       exemple, une valeur <literal>1 3</literal> signifie que la première et
       la troisième colonne de la table sont la clé de l'index. Un zéro dans
       ce tableau indique que l'attribut de l'index correspondant est une
       expression sur les colonnes de la table plutôt qu'une simple référence
       de colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>indclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       Pour chaque colonne dans la clé d'indexage, ceci contient l'OID de la
       classe d'opérateur à utiliser. Voir
       <structname>pg_opclass</structname> pour plus de détails.
      </entry>
     </row>

     <row>
      <entry><structfield>indexprs</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Arbres d'expressions (en représentation
      <function>nodeToString()</function>)
      pour les attributs d'index qui ne sont pas de simples références de 
      colonnes. Il s'agit d'une liste avec un élément pour chaque entrée à
      zéro dans <structfield>indkey</structfield>. Nul si tous les attributs d'index sont 
      de simples références.</entry>
      </row>

     <row>
      <entry><structfield>indpred</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry> Arbre d'expression (en représentation
       <function>nodeToString()</function>) pour les prédicats d'index partiels.
       Nul s'il ne s'agit pas d'un index partiel.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title><structname>pg_inherits</structname></title>

  <indexterm zone="catalog-pg-inherits">
   <primary>pg_inherits</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_inherits</structname> enregistre l'information sur la 
   hiérarchie d'héritage des tables. Il existe une entrée pour chaque table enfant
   direct dans la base de données. (L'héritage indirect peut être déterminé en
   suivant les chaînes des entrées.)
  </para>

  <table>
   <title>Colonnes de <structname>pg_inherits</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>inhrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>
       OID de la table fille.
      </entry>
     </row>

     <row>
      <entry><structfield>inhparent</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>
       OID de la table mère.
      </entry>
     </row>

     <row>
      <entry><structfield>inhseqno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       S'il y a plus d'un parent direct pour une table fille (héritage multiple), ce 
       nombre indique dans quel ordre les colonnes héritées doivent être 
       arrangées. Le compteur commence à 1.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-language">
  <title><structname>pg_language</structname></title>

  <indexterm zone="catalog-pg-language">
   <primary>pg_language</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_language</structname> enregistre les langages
   avec lesquels vous pouvez écrire des fonctions ou des 
   procédures stockées. Voir à <xref linkend="sql-createlanguage"
   endterm="sql-createlanguage-title"/> et dans le
   <xref linkend="xplang"/> pour avoir plus d'information sur les gestionnaires
   de langages.
  </para>

  <table>
   <title>Colonnes de <structname>pg_language</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>lanname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du langage</entry>
     </row>

     <row>
      <entry><structfield>lanispl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vaut faux pour les langages internes (comme <acronym>SQL</acronym>) et
       vrai pour les langages définis par l'utilisateur. Pour l'instant, 
       <application>pg_dump</application> utilise ce champ pour déterminer 
       quels langages doivent être sauvegardés mais cela sera peut-être 
       un jour remplacé par un mécanisme différent.
      </entry>
     </row>

     <row>
      <entry><structfield>lanpltrusted</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai s'il s'agit bien d'un langage de confiance, ce qui signifie qu'il
       n'est pas supposé donner acès à tout ce qui se trouve en dehors de
       l'exécution normale des requêtes SQL. Seuls les superutilisateurs
       peuvent créer des fonctions dans des langages qui ne sont pas de
       confiance.
      </entry>
     </row>

     <row>
      <entry><structfield>lanplcallfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname></link>
       .oid</literal></entry>
      <entry>
       Pour les langages non-internes, ceci référence le gestionnaire de
       langage, qui est une fonction spéciale en charge de l'exécution de toutes
       les fonctions écrites dans ce langage.
      </entry>
     </row>

     <row>
      <entry><structfield>lanvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname></link>
       .oid</literal></entry>
      <entry>
       Ceci référence une fonction de validation de langage, en charge de 
       vérifier la syntaxe et la validité des nouvelles fonctions lorsqu'elles
       sont créées. Zéro si aucun validateur n'est fourni.
      </entry>
     </row>

     <row>
      <entry><structfield>lanacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;;; voir <xref linkend="sql-grant"
       endterm="sql-grant-title"/> et <xref linkend="sql-revoke"
       endterm="sql-revoke-title"/> pour les détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title><structname>pg_largeobject</structname></title>

  <indexterm zone="catalog-pg-largeobject">
   <primary>pg_largeobject</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_largeobject</structname> contient les données
   qui décrivent les <quote>objets de grande taille</quote>. Un gros objet
   est identifié par un OID qui lui est affecté lors de sa création.
   Chaque objet de grande taille est coupé en segments ou <quote>pages</quote>
   suffisamment petites pour être facilement stockées dans des lignes de 
   <structname>pg_largeobject</structname>.
   La taille de données par page est définie par <literal>LOBLKSIZE</literal>, qui vaut
   actuellement <literal>BLCKSZ/4</literal>, soit habituellement 2&nbsp;Ko).
  </para>

  <table>
   <title>Colonnes de <structname>pg_largeobject</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>loid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Identifiant de l'objet de grande taille auquel appartient cette
       page.</entry>
     </row>

     <row>
      <entry><structfield>pageno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Numéro de cette page parmi son objet de grande taille, en partant
       de zéro.</entry>
     </row>

     <row>
      <entry><structfield>data</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       Données effectivement stockées dans l'objet de grande taille. Il ne fait
       jamais plus de <symbol>LOBLKSIZE</symbol> mais peut faire moins.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Chaque ligne de <structname>pg_largeobject</structname> contient les données
   d'une page de l'objet de grande taille, en commençant à l'octet
   (<literal>pageno * LOBLKSIZE</literal>) de l'objet. Ceci permet un stockage
   économique&nbsp;: des pages peuvent manquer, et d'autres faire moins de
   <literal>LOBLKSIZE</literal> octets même si elles ne sont pas les dernières de leur
   objet. Les parties manquantes sont considérées comme des suites de zéro.
  </para>

 </sect1>


 <sect1 id="catalog-pg-listener">
  <title><structname>pg_listener</structname></title>

  <indexterm zone="catalog-pg-listener">
   <primary>pg_listener</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_listener</structname> supporte les commandes
   <xref linkend="sql-listen" endterm="sql-listen-title"/> et
   <xref linkend="sql-notify" endterm="sql-notify-title"/>. Un notifié
   (<quote>listener</quote>) crée une entrée dans
   <structname>pg_listener</structname> pour chaque nom de notification qu'il
   attend. Un notifieur parcourt <structname>pg_listener</structname>
   et met à jour chaque entrée pour montrer qu'une notification est arrivée.
   Le notifieur envoie aussi un signal (en utilisant le numéro de processus
   PID) enregistré dans la table pour prévenir le notifié.
  </para>

  <table>
   <title>Colonnes de <structname>pg_listener</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la notification. (Il ne doit pas spécialement correspondre
      à un nom de relation de la base. Le nom <structfield>relname</structfield>
      est historique.)
      </entry>
     </row>

     <row>
      <entry><structfield>listenerpid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>PID du processus serveur qui a créé cette entrée.</entry>
     </row>

     <row>
      <entry><structfield>notification</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Zéro si aucun événement n'est en attente pour ce notifié. Si un 
       événement est en attente, ce champ contient le PID du processus serveur
       qui a envoyé cette notification.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-namespace">
  <title><structname>pg_namespace</structname></title>

  <indexterm zone="catalog-pg-namespace">
   <primary>pg_namespace</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_namespace</structname> stocke les espaces de noms. Un
   espace de noms est la structure sous-jacente des schémas SQL&nbsp;: chaque
   espace de noms peut avoir un ensemble séparé de relations, types, etc. sans
   qu'il y ait de conflit de noms.
  </para>

  <table>
   <title>Colonnes de <structname>pg_namespace</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>nspname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'espace de noms</entry>
     </row>

     <row>
      <entry><structfield>nspowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
       .oid</literal></entry>
      <entry>Propriétaire de l'espace de noms</entry>
     </row>

     <row>
      <entry><structfield>nspacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir <xref linkend="sql-grant"
       endterm="sql-grant-title"/> et <xref linkend="sql-revoke"
       endterm="sql-revoke-title"/> pour des détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
  <title><structname>pg_opclass</structname></title>

  <indexterm zone="catalog-pg-opclass">
   <primary>pg_opclass</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_opclass</structname> définit les classes
   d'opérateurs de méthodes d'accès aux index. Chaque classe d'opérateur définit
   la sémantique pour les colonnes d'index d'un type particulier, pour une
   méthode d'accès particulière. Notez qu'il peut y avoir plusieurs classes
   d'opérateurs pour une combinaison donnée de type/méthode d'accès, ce qui
   permet de supporter différents comportements.
  </para>

  <para>
   Les classes d'opérateurs sont longuement décrites dans la <xref
   linkend="xindex"/>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_opclass</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>opcamid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-am"><structname>pg_am</structname></link>
       .oid</literal></entry>
      <entry>Méthode d'accès à l'index pour lequel est la classe
       d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>opcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la classe d'opérateurs</entry>
     </row>

     <row>
      <entry><structfield>opcnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>Espace de noms de la classe d'opérateurs.</entry>
     </row>

     <row>
      <entry><structfield>opcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
       .oid</literal></entry>
      <entry>Propriétaires de la classe d'opérateurs.</entry>
     </row>

     <row>
      <entry><structfield>opcintype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname></link>
       .oid</literal></entry>
      <entry>Type de données que la classe d'opérateurs indexe.</entry>
     </row>

     <row>
      <entry><structfield>opcdefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la classe d'opérateurs est la classe par défaut pour
       <structfield>opcintype</structfield></entry>
     </row>

     <row>
      <entry><structfield>opckeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname></link>
       .oid</literal></entry>
      <entry>Type de données stocké dans l'index ou zéro s'il s'agit du même que
       <structfield>opcintype</structfield></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   La plus grande partie des informations définissant une classe d'opérateurs
   n'est pas dans les lignes de <structname>pg_opclass</structname> mais
   dans les lignes correspondantes de <structname>pg_amop</structname> et
   <structname>pg_amproc</structname>.
   Ces lignes sont considérées comme faisant partie de la définition de classe
   d'opérateurs, un peu de la même façon qu'une relation est définie par une
   ligne unique de <structname>pg_class</structname> et par les lignes 
   associées de <structname>pg_attribute</structname> et d'autres tables.
  </para>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title><structname>pg_operator</structname></title>

  <indexterm zone="catalog-pg-operator">
   <primary>pg_operator</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_operator</structname> stocke les informations sur les 
   opérateurs. Voir la commande <xref linkend="sql-createoperator"
   endterm="sql-createoperator-title"/> et la
   <xref linkend="xoper"/> pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_operator</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oprname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de nom qui contient cet opérateur.
      </entry>
     </row>

     <row>
      <entry><structfield>oprowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-authid"><structname>pg_authid</structname>
       </link>.oid</literal></entry>
      <entry>Propriétaire de l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>b</literal> = infix (<quote>les deux</quote>), <literal>l</literal> = prefix
       (<quote>gauche</quote>), <literal>r</literal> = postfix (<quote>droit</quote>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprcanhash</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Cet opérateur supporte les jointures par découpage.</entry>
     </row>

     <row>
      <entry><structfield>oprleft</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>Type de l'opérande de gauche</entry>
     </row>

     <row>
      <entry><structfield>oprright</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>Type de l'opérande de droite</entry>
     </row>

     <row>
      <entry><structfield>oprresult</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname></link>
       .oid</literal></entry>
      <entry>Type du résultat</entry>
     </row>

     <row>
      <entry><structfield>oprcom</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname></link>
       .oid</literal></entry>
      <entry>Commutateur de cet opérateur, s'il en existe un.</entry>
     </row>

     <row>
      <entry><structfield>oprnegate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname>
       </link>.oid</literal></entry>
      <entry>Négateur de cet opérateur, s'il en existe un.</entry>
     </row>

     <row>
      <entry><structfield>oprlsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname>
       </link>.oid</literal></entry>
      <entry>
       Si cet opérateur supporte les jointures par fusion (merge join), ce champ
       contient l'opérateur qui permet de trier le type de l'opérateur de gauche
       (<literal>L&lt;L</literal>).
      </entry>
     </row>

     <row>
      <entry><structfield>oprrsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname>
       </link>.oid</literal></entry>
      <entry>
       Si cet opérateur supporte les jointures par fusion (merge join), ce champ
       contient l'opérateur qui permet de trier le type de l'opérateur de droite
       (<literal>R&lt;R</literal>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprltcmpop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname>
       </link>.oid</literal></entry>
      <entry>
       Si cet opérateur supporte les jointures par fusion (merge join), ce champ
       contient l'opérateur qui permet de comparer les types des opérandes 
       de gauche et de droite(<literal>L&lt;R</literal>).
      </entry>
     </row>

     <row>
      <entry><structfield>oprgtcmpop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname>
       </link>.oid</literal></entry>
      <entry>
       Si cet opérateur supporte les jointures par fusion (merge join), ce champ
       contient l'opérateur plus grand que qui compare les types d'opérandes de 
       gauche et de droite (<literal>L&gt;R</literal>).
      </entry>
     </row>

     <row>
      <entry><structfield>oprcode</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction qui implémente cet opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprrest</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction d'estimation de sélectivité de restriction pour cet
       opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprjoin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction d'estimation de sélectivité de jointure pour cet
       opérateur</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les colonnes inutilisées contiennent des zéros, par exemple
   <structfield>oprleft</structfield> vaut zéro pour un opérateur préfixe.
  </para>

 </sect1>


 <sect1 id="catalog-pg-pltemplate">
  <title><structname>pg_pltemplate</structname></title>

  <indexterm zone="catalog-pg-pltemplate">
   <primary>pg_pltemplate</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_pltemplate</structname> stocke des informations
   modèles (<quote>template</quote>) pour les langages de procédures. Un modèle pour
   un langage permet la création de ce langage dans une base de données
   particulière avec une simple commande <command>CREATE LANGUAGE</command>, sans
   avoir besoin de spécifier les détails de l'implémentation.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_pltemplate</structname> est partagé parmi toutes les bases
   de données d'un groupe&nbsp;: il n'existe qu'une seule copie de
   <structname>pg_pltemplate</structname> par groupe, et non pas une par base
   de données. Ceci fait que l'information est accessible de chaque base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_pltemplate</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du langage auquel est dédié ce modèle</entry>
     </row>

     <row>
      <entry><structfield>tmpltrusted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry><literal>True</literal> s'il s'agit d'un langage de
       confiance</entry>
     </row>

     <row>
      <entry><structfield>tmplhandler</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Nom de la fonction de gestion des appels</entry>
     </row>

     <row>
      <entry><structfield>tmplvalidator</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Nom de la fonction validateur, ou NULL si aucune</entry>
     </row>

     <row>
      <entry><structfield>tmpllibrary</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Chemin de la bibliothèque partagée qui implémente ce
       langage</entry>
     </row>

     <row>
      <entry><structfield>tmplacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès au modèle (actuellement inutilisé)</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Il n'existe actuellement aucune commande qui manipule les modèles des
   langages de procédures&nbsp;; pour modifier l'information intégrée, un
   superutilisateur doit modifier la table en utilisant les commandes
   ordinaires, INSERT, DELETE ou UPDATE. Il est probable qu'une future version
   de <productname>PostgreSQL</productname> proposera des commandes permettant
   de modifier les entrées d'une façon plus propre.
  </para>

  <para>
   Une fois implémenté, le champ <structfield>tmplacl</structfield> fournira
   un contrôle des accès au modèle (c'est-à-dire le droit de créer un langage
   à partir de ce modèle), mais pas un contrôle des accès aux langages créés
   à partir de ce modèle.
  </para>

 </sect1>


 <sect1 id="catalog-pg-proc">
  <title><structname>pg_proc</structname></title>

  <indexterm zone="catalog-pg-proc">
   <primary>pg_proc</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_proc</structname> stocke les informations sur les fonctions
   (ou procédures). Voir <xref linkend="sql-createfunction"
   endterm="sql-createfunction-title"/> et <xref linkend="xfunc"/> pour plus
   d'informations.
  </para>

  <para>
   Cette table contient des données pour les fonctions d'agrégat comme pour
   les fonctions simples. Si <structfield>proisagg</structfield> est vrai, il
   devrait y avoir une ligne correspondante dans
   <structfield>pg_aggregate</structfield>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_proc</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>proname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la fonction</entry>
     </row>

     <row>
      <entry><structfield>pronamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de noms auquel cette fonction appartient.
      </entry>
     </row>

     <row>
      <entry><structfield>proowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-authid"><structname>pg_authid</structname>
       </link>.oid</literal></entry>
      <entry>Propriétaire de la fonction.</entry>
     </row>

     <row>
      <entry><structfield>prolang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-language"><structname>pg_language</structname>
       </link>.oid</literal></entry>
      <entry>Langage ou interface d'appel pour cette fonction</entry>
     </row>

     <row>
      <entry><structfield>proisagg</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La fonction est une fonction d'agrégat.</entry>
     </row>

     <row>
      <entry><structfield>prosecdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, la fonction définit la sécurité (c'est-à-dire une
       fonction <quote>setuid</quote>).
      </entry>
     </row>

     <row>
      <entry><structfield>proisstrict</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si vrai, la fonction retourne NULL si un de ses arguments au moins est
       NULL. Dans ce cas, la fonction ne sera en fait pas appelée du tout. 
       Les fonctions qui ne sont pas <quote>strictes</quote> doivent être 
       préparées à traiter des paramètres NULL.
      </entry>
     </row>

     <row>
      <entry><structfield>proretset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, la fonction retourne un ensemble (c'est-à-dire des valeurs
       multiples du type défini).
      </entry>
     </row>

     <row>
      <entry><structfield>provolatile</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>provolatile</structfield> indique si le résultat de la 
       fonction dépend uniquement de ses arguments ou s'il est affecté par
       des facteurs externes. Il vaut <literal>i</literal> pour les fonctions
       <quote>immuables</quote>, qui donnent toujours le même résultat quand les
       paramètres entrés sont les mêmes. Il vaut <literal>s</literal> pour les
       fonctions <quote>stables</quote>, dont le résultat (pour les mêmes paramètres
       d'entrée) ne change pas tout au long d'un balayage (de table). Il vaut
       <literal>v</literal> pour les fonctions <quote>volatiles</quote>, dont le
       résultat peut varier à tout instant. (Utilisez <literal>v</literal>
       aussi pour les fonctions qui ont des effets de bord, afin que les appels
       à ces fonctions ne soient pas optimisés.)
      </entry>
     </row>

     <row>
      <entry><structfield>pronargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre d'arguments</entry>
     </row>

     <row>
      <entry><structfield>prorettype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname></link>
       .oid</literal></entry>
      <entry>Type de données renvoyé</entry>
     </row>

     <row>
      <entry><structfield>proargtypes</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname></link>
       .oid</literal></entry>
      <entry>
       Un tableau contenant les types de données des arguments de la fonction.
       Ceci inclut seulement les arguments en entrée (ceci incluant les
       arguments INOUT) et représente, du coup, la signature d'appel de la
       fonction.
      </entry>
     </row>

     <row>
      <entry><structfield>proallargtypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       Un tableau avec les types de données des arguments de la fonction. Ceci
       inclut tous les arguments (y compris les arguments OUT et INOUT)&nbsp;;
       néanmoins, si tous les arguments sont IN, ce champ sera NULL. Notez que
       l'indice commence à 1 alors que, pour des raisons historiques,
       <structfield>proargtypes</structfield> commence à partir de 0.
      </entry>
     </row>

     <row>
      <entry><structfield>proargmodes</structfield></entry>
      <entry><type>char[]</type></entry>
      <entry></entry>
      <entry>
        Un tableau avec les modes des arguments de la fonction, codés avec
        <literal>i</literal> pour les arguments IN,
        <literal>o</literal> pour les arguments OUT,
        <literal>b</literal> pour les arguments INOUT.
        Si tous les arguments sont des arguments IN, ce champ sera NULL.
        Notez que les indices correspondent aux positions de
        <structfield>proallargtypes</structfield>, et non pas de
        <structfield>proargtypes</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>proargnames</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Un tableau avec les noms des arguments de la fonction. Les arguments
       sans nom sont initialisés à des chaînes vides dans le tableau.
       Si aucun des arguments a un nom, ce champ sera NULL.
       Notez que les indices correspondent aux positions de
       <structfield>proallargtypes</structfield>, et non pas de
       <structfield>proargtypes</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>prosrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Ce champ indique au gestionnaire de fonctions la façon d'invoquer la
       fonction. Il peut s'agir du code source pour un langage interprété, d'un
       symbole lié, d'un nom de fichier ou de n'importe quoi d'autre, en
       fonction du langage ou de la convention d'appel.
      </entry>
     </row>

     <row>
      <entry><structfield>probin</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>Information supplémentaire sur la façon d'invoquer la fonction.
       Encore une fois, l'interprétation dépend du langage.
      </entry>
     </row>

     <row>
      <entry><structfield>proacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir <xref linkend="sql-grant"
       endterm="sql-grant-title"/> et <xref linkend="sql-revoke"
       endterm="sql-revoke-title"/> pour plus de détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Pour les fonctions compilées, intégrées et chargées dynamiquement,
   <structfield>prosrc</structfield> contient le nom de la fonction en langage C
   (symbol lié). Pour tous les autres types
   de langages, <structfield>prosrc</structfield> contient le code source de la
   fonction. <structfield>probin</structfield> est inutilisé, sauf pour les 
   fonctions en C chargées dynamiquement, pour lesquelles il donne le nom de 
   fichier de la bibliothèque partagée qui contient la fonction.
  </para>

 </sect1>

 <sect1 id="catalog-pg-rewrite">
  <title><structname>pg_rewrite</structname></title>

  <indexterm zone="catalog-pg-rewrite">
   <primary>pg_rewrite</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_rewrite</structname> stocke les règles de 
   réécriture pour les tables et les vues.
  </para>

  <table>
   <title>Colonnes de <structname>pg_rewrite</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la règle</entry>
     </row>

     <row>
      <entry><structfield>ev_class</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>Table sur laquelle porte cette règle.</entry>
     </row>

     <row>
      <entry><structfield>ev_attr</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Colonne sur laquelle porte cette règle. Actuellement, cette colonne
       vaut toujours zéro pour indiquer qu'il s'agit de la table entière.
      </entry>
     </row>

     <row>
      <entry><structfield>ev_type</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Type d'évènement déclenchant la règle&nbsp;:
        1 = <command>SELECT</command>, 2 = <command>UPDATE</command>, 3 = <command>INSERT</command>, 
        4 = <command>DELETE</command>
      </entry>
     </row>

     <row>
      <entry><structfield>is_instead</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai s'il s'agit d'une règle <literal>INSTEAD</literal> 
       (à la place de).
      </entry>
     </row>

     <row>
      <entry><structfield>ev_qual</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Arbre d'expression (sous la forme d'une représentation
       <function>nodeToString()</function>) pour la condition qualifiant la
       règle.
      </entry>
     </row>

     <row>
      <entry><structfield>ev_action</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Arbre de requête (sous la forme d'une représentation
       <function>nodeToString()</function>) pour l'action de la règle.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>pg_class.relhasrules</literal>
    doit être vrai si une table a au moins une règle dans ce catalogue.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-shdepend">
  <title><structname>pg_shdepend</structname></title>

  <indexterm zone="catalog-pg-shdepend">
   <primary>pg_shdepend</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_shdepend</structname> enregistre les relations
   de dépendance entre les objets de la base de données et les objets partagés,
   comme les rôles. Cette information permet à
   <productname>PostgreSQL</productname> de s'assurer que tous ces objets sont
   déréférencés lors d'une tentative de suppression.
  </para>

  <para>
   Voir aussi <link 
   linkend="catalog-pg-depend"><structname>pg_depend</structname></link>, qui
   réalise une fonction similaire pour les dépendances impliquant les objets
   contenus dans une seule base de données.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_shdepend</structname> est partagé parmi toutes les bases de
   données d'un groupe&nbsp;: il n'existe qu'une seule copie de
   <structname>pg_shdepend</structname> par groupe, pas une par base de
   données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shdepend</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>L'OID de la base de données où se trouve l'objet dépendant, ou
      zéro pour un objet partagé</entry>
     </row>

     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'OID du catalogue système dont fait partie l'objet
        dépendant</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>L'OID de l'objet spécifique dépendant</entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>L'OID du catalogue système dont fait partie l'objet référencé
        (doit être un catalogue partagé)</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>L'OID de l'objet spécifique référencé</entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Un code définissant les sémantiques spécifiques des relations de cette
       dépendance&nbsp;; voir le texte.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Dans tous les cas, une entrée <structname>pg_shdepend</structname> indique
   que l'objet référencé pourrait ne pas être supprimé sans supprimer aussi
   l'objet dépendant. Néanmoins, il existe quelques différences identifiées
   par <structfield>deptype</structfield>&nbsp;:

   <variablelist>
    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_OWNER</symbol> (<literal>o</literal>)</term>
     <listitem>
      <para>
       L'objet référencé (qui doit être un rôle) est le propriétaire de
       l'objet dépendant.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_ACL</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       L'objet référencé (qui doit être un rôle) est mentionné dans la liste
       de contrôle des accès (<acronym>ACL</acronym>, acronyme de
       <foreignphrase>access control list</foreignphrase>) de l'objet
       dépendant. (Une entrée <symbol>SHARED_DEPENDENCY_ACL</symbol> n'est pas faite
       pour le propriétaire de l'objet car ce dernier aura quand même une
       entrée <symbol>SHARED_DEPENDENCY_OWNER</symbol>.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>
       Il n'existe pas d'objet dépendant&nbsp;; ce type d'entrée est un signal
       indiquant que le système lui-même dépend de l'objet référencé et que,
       du coup, cet objet ne doit jamais être supprimé. Les entrées de ce type
       sont créées seulement par <command>initdb</command>. Les colonnes
       pour l'objet dépendant contiennent des zéros.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Les autres types de dépendances pourront être nécessaires dans le futur.
   Notez en particulier que la définition actuelle supporte seulement les
   rôles comme objets référencés.
  </para>

 </sect1>


 <sect1 id="catalog-pg-statistic">
  <title><structname>pg_statistic</structname></title>

  <indexterm zone="catalog-pg-statistic">
   <primary>pg_statistic</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_statistic</structname> stocke des données
   statistiques sur le contenu de la base de données. Les entrées sont créées 
   par <command>ANALYZE</command>, puis utilisées par l'optimiseur de requêtes.
   Il y a une entrée pour chaque colonne de table qui a été analysée.
   Notez que les données statistiques sont par définition des approximations, 
   même si elles sont à jour.
  </para>

  <para>
   <structname>pg_statistic</structname> stocke aussi les données
   statistiques sur les valeurs des expressions d'index. Elles sont décrites
   comme si elles étaient de vraies colonnes&nbsp;; en particulier,
   <structfield>starelid</structfield> référence l'index. Néanmoins, aucune
   entrée n'est effectuée pour une colonne d'index ordinaire sans expression
   car cela serait redondant avec l'entrée pour la colonne sous-jacente de la
   table.
  </para>

  <para>
   Comme des statistiques différentes seront appropriées pour des types de 
   données différents, <structname>pg_statistic</structname> est prévu pour
   ne faire qu'un minimum de suppositions sur les types de statistiques qu'il
   stocke. Seules des statistiques extrêmement générales (comme les valeurs
   NULL) ont des colonnes dédiées. Tout le reste est stocké dans des 
   <quote>emplacements</quote>, qui sont des groupes de colonnes associées 
   dont le contenu est identifié par un numéro de code dans l'une des colonnes
   de l'emplacement. Pour plus d'information, voir 
   <filename>src/include/catalog/pg_statistic.h</filename>.
  </para>

  <para>
   <structname>pg_statistic</structname> ne doit pas être lisible par le public
   car même les données statistiques peuvent être considérées comme sensibles.
   (Exemple&nbsp;: les valeurs maximales et minimales d'une colonne de salaire
   peuvent être assez intéressantes).
   <link linkend="view-pg-stats"><structname>pg_stats</structname></link> est
   une vue sur <structname>pg_statistic</structname> accessible à tous, qui
   n'expose que les informations sur ces tables qui sont accessibles à
   l'utilisateur courant.
  </para>

  <table>
   <title>Colonnes de <structname>pg_statistic</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>starelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>Table ou index à laquelle la colonne décrite appartient.</entry>
     </row>

     <row>
      <entry><structfield>staattnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link
       linkend="catalog-pg-attribute"><structname>pg_attribute</structname>
       </link>.attnum</literal></entry>
      <entry>Numéro de la colonne décrite.</entry>
     </row>

     <row>
      <entry><structfield>stanullfrac</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Fraction des entrées de la colonne qui ont une valeur
       NULL.</entry>
     </row>

     <row>
      <entry><structfield>stawidth</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Taille moyenne stockée des entrées non NULL.</entry>
     </row>

     <row>
      <entry><structfield>stadistinct</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry> 
       Nombre de valeurs distinctes non NULL dans la colonne. Une 
       valeurs positive est le nombre réel de valeurs distinctes. Une valeur
       négative est le négatif d'une fraction du nombre de lignes dans la table
       (par exemple, une colonne dans laquelle les valeurs apparaissent environ
       deux fois en moyenne pourrait être représentée par 
       <structfield>stadistinct</structfield> = -0.5). Une valeur à zéro indique que le
       nombre de valeurs distinctes est inconnu.
      </entry>
     </row>

     <row>
      <entry><structfield>stakind<replaceable>N</replaceable></structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Numéro de code indiquant quel type de statistiques est stocké dans
       <quote>l'emplacement</quote> numéro <replaceable>N</replaceable> de la ligne de
       <structname>pg_statistic</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>staop<replaceable>N</replaceable></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
	linkend="catalog-pg-operator"><structname>pg_operator</structname>
	</link>.oid</literal></entry>
      <entry>
       Opérateur utilisé pour dériver les statistiques stockées dans 
       <quote>l'emplacement</quote> numéro <replaceable>N</replaceable>. Par exemple, un
       emplacement d'histogramme montrerait l'opérateur <literal>&lt;</literal>,
       qui définit l'ordre de tri des données.
      </entry>
     </row>

     <row>
      <entry><structfield>stanumbers<replaceable>N</replaceable></structfield></entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>
       Statistiques numériques du genre approprié pour
       <quote>l'emplacement</quote> numéro <replaceable>N</replaceable> ou NULL si le type
       d'emplacement ne nécessite pas de valeurs numériques.
      </entry>
     </row>

     <row>
      <entry><structfield>stavalues<replaceable>N</replaceable></structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       Valeurs de données de la colonne du type approprié pour 
       <quote>l'emplacement</quote> numéro <replaceable>N</replaceable> ou NULL si
       le type d'emplacement ne stocke aucune valeur de données. Chaque valeur
       d'élément du tableau est en fait du type de données de la colonne 
       spécifiée, si bien qu'il n'y a aucun moyen de définir ces colonnes 
       autrement qu'avec le type <type>anyarray</type> (tableau quelconque).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-tablespace">
   <title><structname>pg_tablespace</structname></title>
   
   <indexterm zone="catalog-pg-tablespace">
     <primary>pg_tablespace</primary>
   </indexterm>
   
   <para>
     Le catalogue <structname>pg_tablespace</structname> enregistre les
     informations sur les tablespaces disponibles. Les tables peuvent
     être placées dans des tablespaces particuliers pour aider à
     l'administration des espaces de stockage.
   </para>
   
   <para>
     Contrairement à la plupart des catalogues système, 
     <structname>pg_tablespace</structname> est partagée parmi toutes les bases
     de données du groupe&nbsp;: il n'y a donc qu'une copie de
     <structname>pg_tablespace</structname> par groupe, et non pas une par
     base.
   </para>
   
   <table>
     <title>Colonnes de <structname>pg_tablespace</structname></title>
   
   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
     <thead>
       <row>
         <entry>Nom</entry>
         <entry>Type</entry>
         <entry>Références</entry>
         <entry>Description</entry>
       </row>
     </thead>
     
     <tbody>
       <row>
         <entry><structfield>spcname</structfield></entry>
         <entry><type>name</type></entry>
         <entry></entry>
         <entry>Nom du tablespace</entry>
       </row>
       
       <row>
         <entry><structfield>spcowner</structfield></entry>
         <entry><type>oid</type></entry>
         <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
         <entry>Propriétaire du tablespace, habituellement l'utilisateur
           qui l'a créé</entry>
       </row>
       
       <row>
         <entry><structfield>spclocation</structfield></entry>
         <entry><type>text</type></entry>
         <entry></entry>
         <entry>Emplacement (chemin vers le répertoire) de l'espace
           logique</entry>
       </row>
       
       <row>
         <entry><structfield>spcacl</structfield></entry>
         <entry><type>aclitem[]</type></entry>
         <entry></entry>
         <entry>
           Droits d'accès&nbsp;; voir
           <xref linkend="sql-grant" endterm="sql-grant-title"/> et
           <xref linkend="sql-revoke" endterm="sql-revoke-title"/> pour les
           détails.
           </entry>
           </row>
         </tbody>
       </tgroup>
     </table>
   </sect1>


   <sect1 id="catalog-pg-trigger">
  <title><structname>pg_trigger</structname></title>

  <indexterm zone="catalog-pg-trigger">
   <primary>pg_trigger</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_trigger</structname> stocke les informations sur
   les déclencheurs des tables. Voir la commande <xref linkend="sql-createtrigger"
   endterm="sql-createtrigger-title"/> pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_trigger</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tgrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>Table sur laquelle porte le déclencheur</entry>
     </row>

     <row>
      <entry><structfield>tgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>
       Nom du déclencheur (doit être unique parmi les déclencheurs 
       d'une table).
      </entry>
     </row>

     <row>
      <entry><structfield>tgfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction à appeler</entry>
     </row>

     <row>
      <entry><structfield>tgtype</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Masque de bits identifiant les conditions du déclencheur.</entry>
     </row>

     <row>
      <entry><structfield>tgenabled</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur est activé.</entry>
     </row>

     <row>
      <entry><structfield>tgisconstraint</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur implémente une contrainte d'intégrité 
       référentielle.
      </entry>
     </row>

     <row>
      <entry><structfield>tgconstrname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la contrainte d'intégrité référentielle.</entry>
     </row>

     <row>
      <entry><structfield>tgconstrrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>Table référencée par une contrainte d'intégrité
       référentielle.</entry>
     </row>

     <row>
      <entry><structfield>tgdeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur est différable.</entry>
     </row>

     <row>
      <entry><structfield>tginitdeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si initialement le déclencheur est différé.</entry>
     </row>

     <row>
      <entry><structfield>tgnargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de chaînes d'arguments passées à la fonction de
       déclencheur.</entry>
     </row>

     <row>
      <entry><structfield>tgattr</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>Actuellement inutilisé.</entry>
     </row>

     <row>
      <entry><structfield>tgargs</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       Chaînes d'arguments à passer au déclencheur, chacune terminée par un
       NULL.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>pg_class.reltriggers</literal> doit être d'accord avec le nombre
    de déclencheurs trouvés dans cette table.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-type">
  <title><structname>pg_type</structname></title>

  <indexterm zone="catalog-pg-type">
   <primary>pg_type</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_type</structname> stocke les informations sur les
   types de données. Les types de base (types scalaires) sont créés avec la 
   commande <xref linkend="sql-createtype" endterm="sql-createtype-title"/> et
   les domaines avec <xref linkend="sql-createdomain"
   endterm="sql-createdomain-title"/>. Un type composite est créé
   automatiquement pour chaque table de la base et représenter ainsi la
   structure des lignes de la table. Il est aussi possible de créer des types
   composites avec <command>CREATE TYPE AS</command> .
  </para>

  <table>
   <title>Colonnes de <structname>pg_type</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>typname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du type</entry>
     </row>

     <row>
      <entry><structfield>typnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de noms qui contient ce type.
      </entry>
     </row>

     <row>
      <entry><structfield>typowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
       .oid</literal></entry>
      <entry>Propriétaire du type</entry>
     </row>

     <row>
      <entry><structfield>typlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Pour les types de taille fixe, <structfield>typlen</structfield> est le
       nombre d'octets de la représentation interne du type. Mais pour les types
       de longueur variable, <structfield>typlen</structfield> est négatif.
       -1 indique un type <quote>varlena</quote>  (qui a un attribut de longueur),
       -2 indique une chaîne C terminée par le caractère NULL.
      </entry>
     </row>

     <row>
      <entry><structfield>typbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <structfield>typbyval</structfield> détermine si les routines internes
       passent une valeur de ce type par valeur ou par référence.
       <structfield>typbyval</structfield> doit être faux si 
       <structfield>typlen</structfield> ne vaut pas 1, 2 ou 4 (ou 8 sur les
       machines dont le mot-machine est de 8 octets). Les types de longueur
       variable sont toujours passés par référence. Notez que
       <structfield>typbyval</structfield> peut être faux même si la longueur
       permettrait un passage par valeur&nbsp;; c'est le cas pour le type 
       <type>float4</type>, par exemple.
      </entry>
     </row>

     <row>
      <entry><structfield>typtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typtype</structfield> vaut <literal>b</literal> pour un
       type de base, <literal>c</literal> pour un type composite (c'est-à-dire
       le type d'une ligne de table), <literal>d</literal> pour un domaine
       ou <literal>p</literal> pour un pseudo-type. 
       Voir aussi <structfield>typrelid</structfield> et
       <structfield>typbasetype</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>typisdefined</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si le type est défini et faux s'il ne s'agit que d'un remplissage
       pour un type qui n'est pas encore défini. Lorsque 
       <structfield>typisdefined</structfield> est faux, rien à part le nom du
       type, l'espace de noms et l'OID n'est fiable.
      </entry>
     </row>

     <row>
      <entry><structfield>typdelim</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Caractère qui sépare deux valeurs de ce type lorsque le programme
       lit les valeurs d'un tableau en entrée. Notez que le délimiteur est
       associé au type d'élément du tableau, pas au type tableau.
      </entry>
     </row>

     <row>
      <entry><structfield>typrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>
       S'il s'agit d'un type composite (voir
       <structfield>typtype</structfield>), alors cette colonne pointe vers la
       ligne de <structname>pg_class</structname> qui définit la table
       correspondante. Pour un type composite sans table, l'entrée dans
       <structname>pg_class</structname> ne représente pas vraiment une table,
       mais elle est néanmoins nécessaire pour trouver les lignes de
       <structname>pg_attribute</structname> liées au type. Zéro pour les types
       autres que composites.
      </entry>
     </row>

     <row>
      <entry><structfield>typelem</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>
       Si <structfield>typelem</structfield> est différent de zéro, alors il identifie
       une autre ligne de <structname>pg_type</structname>. Le type courant peut
       alors être utilisé comme un tableau contenant des valeurs de type
       <structfield>typelem</structfield>. Un <quote>vrai</quote> type tableau a
       une longueur variable (<structfield>typlen</structfield> = -1), mais
       certains types de longueur fixe (<structfield>typlen</structfield> &gt;
       0) ont aussi un <structfield>typelem</structfield> non nul, par exemple 
       <type>name</type> et <type>point</type>. Si un type de longueur fixe 
       a un <structfield>typelem</structfield>, alors sa représentation interne
       doit être un certain nombre de valeurs de ce type
       <structfield>typelem</structfield>, sans autre donnée. Les types de
       données tableau de taille variable ont un en-tête défini par les
       sous-routines de tableau.
       </entry>
     </row>

     <row>
      <entry><structfield>typinput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction de conversion en entrée (format texte).</entry>
     </row>

     <row>
      <entry><structfield>typoutput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction de conversion en sortie (format texte).</entry>
     </row>

     <row>
      <entry><structfield>typreceive</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction de conversion en entrée (format binaire), 
       ou 0 s'il n'y en a pas</entry>
     </row>

     <row>
      <entry><structfield>typsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction de conversion en sortie (format binaire), 
       ou 0 s'il n'y en a pas</entry>
     </row>

     <row>
      <entry><structfield>typanalyze</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction ANALYZE personnalisée  ou 0 pour utiliser la fonction standard</entry>
     </row>

     <row>
      <entry><structfield>typalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>

       <structfield>typalign</structfield> est l'alignement requis pour stocker
       une valeur de ce type. Cela s'applique au stockage sur disque aussi bien
       qu'à la plupart des représentations de cette valeur dans
       <productname>PostgreSQL</productname>.
       Lorsque des valeurs multiples sont stockées consécutivement, comme dans
       la représentation d'une ligne complète sur disque, un remplissage est 
       inséré avant la donnée de ce type pour qu'elle commence à l'alignement
       spécifié. La référence de l'alignement est le début de la première donnée
       de la séquence.
      </para><para>
       Les valeurs possibles sont&nbsp;:
       <itemizedlist>
        <listitem>
         <para><literal>c</literal> = alignement <type>char</type> ce qui signifie
          qu'aucun alignement n'est nécessaire&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>s</literal> = alignement <type>short</type> (deux octets sur la
          plupart des machines)&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>i</literal> = alignement <type>int</type> (quatre octets sur la
          plupart des machines)&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>d</literal> = alignement <type>double</type> (huit octets sur
          la plupart des machines, mais pas sur toutes).</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <para>
        Pour les types utilisés dans les tables systèmes il est indispensable
        que les tailles et alignements définis dans
        <structname>pg_type</structname> soient en accord avec la façon dont le 
        compilateur disposera la colonne dans une structure représentant une 
        ligne de table.
       </para>
      </note></entry>
     </row>

     <row>
      <entry><structfield>typstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typstorage</structfield> indique, pour les types varlena 
       (ceux pour lesquels <structfield>typlen</structfield> = -1), si le type
       est préparé pour le TOASTage et quelle stratégie par défaut doit être
       utilisée pour les attributs de ce type. Les valeurs possibles sont&nbsp;:
       <itemizedlist>
        <listitem>
         <para><literal>p</literal>&nbsp;: la valeur doit être stockée
          normalement&nbsp;;</para>
        </listitem>
        <listitem>
         <para>
          <literal>e</literal>&nbsp;: la valeur peut être stockée dans une relation
           <quote>secondaire </quote> (si la relation en a une, voir 
           <literal>pg_class.reltoastrelid</literal>)&nbsp;;
          </para>
        </listitem>
        <listitem>
         <para><literal>m</literal>&nbsp;: la valeur peut être stockée compressée sur
          place&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>x</literal>&nbsp;: la valeur peut être stockée compressée sur
          place ou stockée dans une relation <quote>secondaire</quote>.
         </para>
        </listitem>
       </itemizedlist>
       Notez que les colonnes <literal>m</literal> peuvent aussi être déplacées dans 
       une table de stockage secondaire, mais seulement en dernier recours
       (les colonnes <literal>e</literal> et <literal>x</literal> sont déplacées d'abord).
      </para></entry>
     </row>

     <row>
      <entry><structfield>typnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typnotnull</structfield> représente une contrainte non NULL
       pour ce type. Ceci n'est utilisé que pour les domaines.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typbasetype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry><para>
       S'il s'agit d'un domaine, (voir <structfield>typtype</structfield>),
       alors <structfield>typbasetype</structfield> identifie le type sur
       lequel celui-ci est basé. Zéro s'il ne s'agit pas d'un domaine.
       </para></entry>
     </row>

     <row>
      <entry><structfield>typtypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       Les domaines utilisent <structfield>typtypmod</structfield> pour 
       enregistrer le <literal>typmod</literal> à appliquer à leur type de base (-1 si
       le type de base n'utilise pas de <literal>typmod</literal>). -1 si ce type
       n'est pas un domaine.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typndims</structfield> est le nombre de dimensions de
       tableau pour un domaine qui est un tableau (c'est-à-dire dont
       <structfield>typbasetype</structfield> est un type tableau&nbsp;; le
       <structfield>typelem</structfield> du domaine correspondra au
       <structfield>typelem</structfield> du type de base). Zéro pour les types
       autres que les domaines tableaux.
     </para></entry>
     </row>

     <row>
      <entry><structfield>typdefaultbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       Si <structfield>typdefaultbin</structfield> n'est pas NULL, ce champ est la 
       représentation <function>nodeToString()</function> d'une expression par 
       défaut pour le type. Ceci n'est utilisé que pour les domaines.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typdefault</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typdefault</structfield> est NULL si le type n'a pas de valeur par
       défaut associée. Si <structfield>typdefaultbin</structfield> est non NULL,
       <structfield>typdefault</structfield> doit contenir une version lisible de 
       l'expression par défaut représentée par <structfield>typdefaultbin</structfield>.
       Si <structfield>typdefaultbin</structfield> est NULL et si
       <structfield>typdefault</structfield> ne l'est pas, alors
       <structfield>typdefault</structfield> est la représentation externe de la valeur par
       défaut du type, qui peut être passée à la fonction de conversion en
       entrée du type pour produire une constante.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="views-overview">
  <title>Vues système</title>

  <para>
   En plus des catalogues système, <productname>PostgreSQL</productname>
   apporte un certain nombre de vues internes. Quelques vues systèmes apportent un
   moyen simple et agréable d'accéder à des requêtes habituellement utilisées
   dans les catalogues systèmes. D'autres vues donnent accès à l'état du serveur
   interne.
  </para>

  <para>
   Le schéma information (<xref linkend="information-schema"/>) fournit un autre
   ensemble de vues qui rejoignent les fonctionnalités des vues systèmes. Comme
   le schéma information est en SQL standard alors que les vues décrites ici
   sont spécifiques à <productname>PostgreSQL</productname>, il est généralement
   mieux d'utiliser le schéma information si celui-ci apporte toutes les
   informations dont vous avez besoin.
  </para>

  <para>
   <xref linkend="view-table"/> indique les vues systèmes décrites ici.
   Une documentation plus détaillée de chaque vue suit ceci. Il existe en plus
   des vues supplémentaires permettant d'accéder aux résultats du collecteur de
   statistiques&nbsp; elles sont décrites dans le <xref
   linkend="monitoring-stats-views-table"/>.
  </para>

  <para>
   Sauf lorsque c'est noté, toutes les vues décrites ici sont en lecture seule.
  </para>

  <table id="view-table">
   <title>Vues système</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>But</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="view-pg-group"><structname>pg_group</structname></link></entry>
      <entry>groupe d'utilisateurs de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-indexes"><structname>pg_indexes</structname></link></entry>
      <entry>index</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-locks"><structname>pg_locks</structname></link></entry>
      <entry>verrous actuellement contenus</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link></entry>
      <entry>transactions actuellement préparées</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-roles"><structname>pg_roles</structname></link></entry>
      <entry>rôles dans la base de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-rules"><structname>pg_rules</structname></link></entry>
      <entry>règles</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-settings"><structname>pg_settings</structname></link></entry>
      <entry>configuration</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-shadow"><structname>pg_shadow</structname></link></entry>
      <entry>utilisateurs des bases de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-stats"><structname>pg_stats</structname></link></entry>
      <entry>statistiques du planificateur</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-tables"><structname>pg_tables</structname></link></entry>
      <entry>tables</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user"><structname>pg_user</structname></link></entry>
      <entry>utilisateurs des bases de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-views"><structname>pg_views</structname></link></entry>
      <entry>vues</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-group">
  <title><structname>pg_group</structname></title>

  <indexterm zone="view-pg-group">
   <primary>pg_group</primary>
  </indexterm>

  <para>
   La vue <structname>pg_group</structname> existe puor des raisons de
   compatibilité ascendante&nbsp;: elle émule un catalogue qui a existé avant
   la version 8.1 de <productname>PostgreSQL</productname>. Elle affiche les
   noms et membres de tous les rôles qui ne sont pas marqués comme
   <structfield>rolcanlogin</structfield>, ce qui est une approximation de l'ensemble des
   rôles utilisés comme des groupes.
  </para>

  <table>
   <title>Colonnes de <structname>pg_group</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>groname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Nom du groupe</entry>
     </row>

     <row>
      <entry><structfield>grosysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant du groupe</entry>
     </row>

     <row>
      <entry><structfield>grolist</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Un tableau contenant les identifiants des rôles de ce 
      groupe</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-indexes">
  <title><structname>pg_indexes</structname></title>

  <indexterm zone="view-pg-indexes">
   <primary>pg_indexes</primary>
  </indexterm>

  <para>
   La vue <structname>pg_indexes</structname> fournit un accès à des
   informations utiles sur chaque index de la base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_indexes</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.4*"/>
    <colspec colnum="3" colwidth="1.3*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>nom du schéma contenant les tables et index</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>nom de la table concernant cet index</entry>
     </row>
     <row>
      <entry><structfield>indexname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>nom de l'index</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>nom du tablespace contenant l'index (NULL s'il s'agit de la
       valeur par défaut de la base de données)</entry>
     </row>
     <row>
      <entry><structfield>indexdef</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>définition de l'index (une commande de création reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-locks">
  <title><structname>pg_locks</structname></title>

  <indexterm zone="view-pg-locks">
   <primary>pg_locks</primary>
  </indexterm>

  <para>
   La vue <structname>pg_locks</structname> fournit un accès aux informations
   concernant les verrous détenus par les transactions ouvertes à
   l'intérieur du serveur de bases de données. Voir le <xref linkend="mvcc"/>
   pour une discussion plus importante sur les verrous.
  </para>

  <para>
   <structname>pg_locks</structname> contient une ligne par objet verrouillable
   actif, mode de verrouillage demandé et transaction indiquée. Donc, le même
   objet verrouillable pourrait apparaître plusieurs fois si plusieurs
   transactions ont pris ou attendent des verrous sur celui-ci. Néanmoins, un
   objet qui n'est pas verrouillé n'apparaîtra pas du tout.
  </para>

  <para>
   Il existe plusieurs types distincts d'objets verrouillables&nbsp;: des
   relations complètes (par exemple les tables), des pages individuelles de
   relations, des lignes individuelles de relations, des identifiants de
   transaction et des objets généraux de la base de données (identifiés par
   l'OID de la classe et l'OID de l'objet, de la même façon que dans
   <structname>pg_description</structname> ou
   <structname>pg_depend</structname>). De plus, le droit d'étendre une
   relation est représenté comme un objet verrouillable séparé.
  </para>

  <table>
   <title>Colonnes <structname>pg_locks</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.7*"/>
    <colspec colnum="3" colwidth="0.7*"/>
    <colspec colnum="4" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>locktype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       type de l'objet verrouillable&nbsp;:
       <literal>relation</literal>,
       <literal>extend</literal>,
       <literal>page</literal>,
       <literal>tuple</literal>,
       <literal>transactionid</literal>,
       <literal>object</literal> ou
       <literal>userlock</literal>
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>
       l'OID de la base de données dans laquelle existe l'objet, ou zéro si
       l'objet est partagé, ou NULL si l'objet est un identifiant de
       transaction
      </entry>
     </row>
     <row>
      <entry><structfield>relation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       l'OID de la relation, ou NULL si l'objet n'est pas une relation ou ne
       fait pas partie d'une relation
      </entry>
     </row>
     <row>
      <entry><structfield>page</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       le numéro de page à l'intérieur de cette relation, ou NULL si l'objet
       n'est pas une ligne ou une page de la relation
      </entry>
     </row>
     <row>
      <entry><structfield>tuple</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       le numéro de ligne dans la page, ou NULL si l'objet n'est pas une ligne
      </entry>
     </row>
     <row>
      <entry><structfield>transactionid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       l'identifiant d'une transaction, ou NULL si l'objet n'est pas un
       identifiant de transaction
      </entry>
     </row>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       l'OID du catalogue système contenant l'objet, ou NULL si l'objet n'est
       pas un objet général de la base de données
      </entry>
     </row>
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>
       l'OID de l'objet dans son catalogue système, ou NULL si l'objet n'est
       pas un objet général de la base de données
      </entry>
     </row>
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       pour la colonne d'une table, ceci est le numéro de la colonne
       (<structfield>classid</structfield> et <structfield>objid</structfield> font référence à la
       table elle-même). Pour tous les autres types d'objets, cette colonne
       vaut zéro. NULL si l'objet n'est pas un objet général de la base de
       données.
      </entry>
     </row>
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       l'ID de la transaction qui détient ou attend ce verrou.
      </entry>
     </row>
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       l'identifiant du processus serveur détenant ou attendant le verrou.
       NULL si le verrou est possédé par une transaction préparée.
      </entry>
     </row>
     <row>
      <entry><structfield>mode</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Nom du mode de verrou détenu ou attendu par ce processus (voir la
       <xref linkend="locking-tables"/>)</entry>
     </row>
     <row>
      <entry><structfield>granted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>vrai si le verrou est détenu, faux s'il est attendu</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structfield>granted</structfield> est vrai sur une ligne représentant un
   verrou tenu par la transaction indiquée. Une valeur faux indique que cette
   transaction attend l'acquisition du verrou, ce qui implique qu'une autre
   transaction a choisi un mode de verrouillage conflictuel sur le même objet
   partageable. La transaction en attente dormira jusqu'à la relâche du verrou
   (ou jusqu'à ce qu'une situation de blocage soit détectée). Une transaction
   seule peut attendre d'acquérir au plus un verrou à la fois.
  </para>

  <para>
   Chaque transaction détient un verrou exclusif sur son identifiant de
   transaction durant toute la durée de son exécution. Si une transaction trouve
   nécessaire d'attendre spécifiquement une autre transaction, elle le fait en
   essayant d'acquérir un verrou partagé sur l'identifiant de l'autre
   transaction. Ceci sera couronné de succès seulement lorsque l'autre
   transaction termine et relâche son verrou.
  </para>

  <para>
   Bien que les lignes sont un type d'objet verrouillable, les informations sur
   les verroux au niveau ligne sont stockées sur disque, et non pas en mémoire.
   Du coup, les verroux niveau ligne n'apparaissent normalement pas dans cette
   vue. Si une transaction est en attente d'un verrou niveau ligne, cela
   apparaîtra sur la vue comme en attente de l'identifiant de la transaction
   du déteneur actuel du verrou de cette ligne.
  </para>

  <para>
   Si les verroux définis par l'utilisateur sont utilisés, ils sont affichés
   en utilisant les colonnes des objets généraux de la base de données.
   Néanmoins, la signification réelle des champs verrou dans de tels cas
   concerne l'utilisateur.
  </para>

  <para>
   Quand la vue <structname>pg_locks</structname> est accédée, les structures de
   données du gestionnaire interne de verrous sont momentanément verrouillées 
   et une copie est faite pour que la vue s'affiche. Ceci nous assure que la
   vue produise un ensemble consistant de résultats, tout en ne bloquant pas
   les opérations habituelles du gestionnaire de verrous plus longuement que
   nécessaire. Néanmoins, il peut y avoir des impacts sur les performances de
   la base de données si cette vue est lue fréquemment.
  </para>

  <para>
   <structname>pg_locks</structname> fournit une vue globale de tous les verrous
   du cluster de bases de données, et non pas seulement une vue de ceux de la
   base en cours. Bien que sa colonne <structfield>relation</structfield> puisse
   être jointe avec <structname>pg_class</structname>.<structfield>oid</structfield> pour identifier
   les relations verrouillées, ceci ne fonctionnera correctement qu'avec les
   relations de la base en cours (celles pour qui la colonne
   <structfield>database</structfield> est soit l'OID de la base en cours soit
   zéro).
  </para>

  <para>
   Si vous avez activé le collecteur de statistiques, la colonne
   <structfield>pid</structfield> peut être jointe à la colonne
   <structfield>procpid</structfield> de la vue
   <structname>pg_stat_activity</structname> pour obtenir plus d'information sur
   le propriétaire de la session ou attendant de détenir le verrou.
   De plus, si vous utilisez les transactions préparées, la colonne
   <structfield>transaction</structfield> peut être jointe à la colonne
   <structfield>transaction</structfield> de la vue
   <structname>pg_prepared_xacts</structname> pour obtenir plus d'informations
   sur les transactions préparées qui détiennent les verroux. (Une
   transaction préparée ne peut jamais être en attente d'un verrou mais elle
   continue à détenir les verroux qu'elle a acquis pendant son exécution.)
  </para>

 </sect1>

 <sect1 id="view-pg-prepared-xacts">
  <title><structname>pg_prepared_xacts</structname></title>

  <indexterm zone="view-pg-prepared-xacts">
   <primary>pg_prepared_xacts</primary>
  </indexterm>

  <para>
   La vue <structname>pg_prepared_xacts</structname> affiche des informations
   sur les transactions actuellement préparées pour une validation en deux
   phases (voir <xref linkend="sql-prepare-transaction"
   endterm="sql-prepare-transaction-title"/> pour les détails).
  </para>

  <para>
   <structname>pg_prepared_xacts</structname> contient une ligne par
   transaction préparée. Une entrée est supprimée quand la transaction est
   validée ou annulée.
  </para>

  <table>
   <title>Colonnes de <structname>pg_prepared_xacts</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       L'identifiant numérique de la transaction préparée
      </entry>
     </row>
     <row>
      <entry><structfield>gid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Identifiant global de transaction
      </entry>
     </row>
     <row>
      <entry><structfield>prepared</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry></entry>
      <entry>
       L'heure de préparation de la transaction pour validation
      </entry>
     </row>
     <row>
      <entry><structfield>owner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>
       Le nom de l'utilisateur qui a exécuté la transaction
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>
       Nom de la base de données dans laquelle a été exécutée la transaction
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Lors d'un accès à la vue <structname>pg_prepared_xacts</structname>,
   les structures de données du
   gestionnaire interne des transactions sont momentanément verrouillées et
   une copie de la vue est faite pour affichage. Ceci nous assure que la vue
   produit un ensemble cohérent de résultats tout en ne bloquant pas les
   opérations normales plus longtemps que nécessaire. Néanmoins, il pourrait
   y avoir un impact sur les performances de la base de données si cette vue
   est lue fréquemment.
  </para>

 </sect1>


 <sect1 id="view-pg-roles">
  <title><structname>pg_roles</structname></title>

  <indexterm zone="view-pg-roles">
   <primary>pg_roles</primary>
  </indexterm>

  <para>
   La vue <structname>pg_roles</structname> fournit un accès aux informations
   des rôles de la base de données. C'est tout simplement une vue accessible
   de <link
   linkend="catalog-pg-authid"><structname>pg_authid</structname></link> et qui
   vide le champ du mot de passe.
  </para>

  <para>
   Cette vue expose explicitement la colonne OID de la table sous-jacente car
   cela est nécessaire pour réaliser des jointures avec les autres catalogues.
  </para>

  <table>
   <title>Colonnes de <structname>pg_roles</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du rôle</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle est un superutilisateur</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle hérite automatiquement des droits des rôles dont il est
       membre</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle peut créer d'autres rôles</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Le rôle peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Le rôle peut mettre à jour explicitement les catalogues système. 
       (Même un superutilisateur ne peut pas le faire si cette colonne n'est
       pas positionnée à <literal>true</literal>.)
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Le rôle peut se connecter, c'est-à-dire que ce rôle peut être indiqué
       comme identiant initial d'autorisation de session.
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour les rôles pouvant se connecter, ceci configure le nombre
       maximum de connexions concurrentes que peut réaliser ce rôle. -1
       signifie qu'il n'y a pas de limite.
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Ce n'est pas le mot de passe (toujours
        <literal>********</literal>)</entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry></entry>
      <entry>Date/heure d'expiration du mot de passe (utilisées seulement pour
       l'authentification du mot de passe)&nbsp;; NULL s'il est toujours
       valable</entry>
     </row>

     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Variables de configuration par défaut pour la session</entry>
     </row>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant du rôle</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-rules">
  <title><structname>pg_rules</structname></title>

  <indexterm zone="view-pg-rules">
   <primary>pg_rules</primary>
  </indexterm>

  <para>
   La vue <structname>pg_rules</structname> fournit un accès à des informations
   utiles sur les règles de réécriture des requêtes.
  </para>

  <table>
   <title>Colonnes de <structname>pg_rules</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>nom du schéma contenant la table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>nom de la table pour laquelle est créée la règle</entry>
     </row>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.rulename</literal></entry>
      <entry>nom de la règle</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>définition de la règle (une commande de création reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_rules</structname> exclut les règles ON SELECT rules
   des vues&nbsp;; elles sont disponibles dans <structname>pg_views</structname>.
  </para>

 </sect1>

 <sect1 id="view-pg-settings">
  <title><structname>pg_settings</structname></title>

  <indexterm zone="view-pg-settings">
   <primary>pg_settings</primary>
  </indexterm>

  <para>
   La vue <structname>pg_settings</structname> fournit un accès aux paramètres
   d'exécution du serveur. C'est essentiellement une autre interface aux
   commandes <command>SHOW</command> et <command>SET</command>. Elle fournit aussi un accès à
   certaines informations sur chaque paramètre qui ne sont pas directement
   accessibles avec <command>SHOW</command>, telles que les valeurs minimales et maximales.
  </para>

  <table>
   <title>Colonnes de <structname>pg_settings</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>nom du paramètres d'exécution</entry>
     </row>
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry>valeur actuelle du paramètre</entry>
     </row>
     <row>
      <entry><structfield>category</structfield></entry>
      <entry><type>text</type></entry>
      <entry>groupe logique du paramètre</entry>
     </row>
     <row>
      <entry><structfield>short_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>une description brève du paramètre</entry>
     </row>
     <row>
      <entry><structfield>extra_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>information supplémentaire, plus détaillée, sur le paramètre</entry>
     </row>
     <row>
      <entry><structfield>context</structfield></entry>
      <entry><type>text</type></entry>
      <entry>contexte requis pour initialiser la valeur du paramètre</entry>
     </row>
     <row>
      <entry><structfield>vartype</structfield></entry>
      <entry><type>text</type></entry>
      <entry>type du paramètre (<literal>bool</literal>, <literal>integer</literal>,
       <literal>real</literal> ou <literal>string</literal>)
      </entry>
     </row>
     <row>
      <entry><structfield>source</structfield></entry>
      <entry><type>text</type></entry>
      <entry>source de la valeur du paramètre actuel</entry>
     </row>
     <row>
      <entry><structfield>min_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>valeur minimum autorisée du paramètre (NULL pour les valeurs non
       numériques)</entry>
     </row>
     <row>
      <entry><structfield>max_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>valeur maximum autorisée du paramètre (NULL pour les valeurs non
       numériques)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  
  <para>
   La vue <structname>pg_settings</structname> n'accepte pas d'insertion ou de
   suppression mais peut être mise à jour. Un <command>UPDATE</command> appliqué
   à une ligne de <structname>pg_settings</structname> est équivalent à
   l'exécution de la commande <xref linkend="sql-set" endterm="sql-set-title"/>
   sur ce paramètre nommé. Le changement affecte seulement la valeur utilisée
   par la session actuelle. Si un <command>UPDATE</command> est lancé à
   l'intérieur d'une transaction qui est annulée plus tard, les effets de la
   commande <command>UPDATE</command> disparaissent lorsque les effets de la
   transaction sont annulés. Une fois que la transaction est validée, les effets
   persistent jusqu'à la fin de la session, à moins qu'un autre
   <command>UPDATE</command> ou <command>SET</command> ne modifie la valeur.
  </para>

 </sect1>

 <sect1 id="view-pg-shadow">
  <title><structname>pg_shadow</structname></title>

  <indexterm zone="view-pg-shadow">
   <primary>pg_shadow</primary>
  </indexterm>

  <para>
   La vue <structname>pg_shadow</structname> existe pour des raisons de
   compatibilité ascendante&nbsp;: elle émule un catalogue qui a existé avant
   la version 8.1 de <productname>PostgreSQL</productname>. Elle affiche les
   propriétés de tous les rôles marqués <structfield>rolcanlogin</structfield>.
  </para>

  <para>
   Le nom vient du fait que cette table ne devait pas être lisible par le
   public car elle contient les mots de passe.
   <link linkend="view-pg-user"><structname>pg_user</structname></link>
   est une vue sur <structname>pg_shadow</structname>, lisible publiquement car
   elle vide le contenu du champ du mot de passe.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shadow</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Nom de l'utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Identifiant de cet utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur est un superutilisateur</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       L'utilisateur peut mettre à jour les catalogues système. (Même un
       superutilisateur ne peut pas le faire si cette colonne ne vaut pas
       <literal>true</literal>.)
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Mot de passe (pouvant être crypté)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>Date/heure d'expiration du mot de passe (seulement utilisé pour
      l'authentification par mot de passe)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Valeurs par défaut des variables de configuration pour la session
        </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-stats">
  <title><structname>pg_stats</structname></title>

  <indexterm zone="view-pg-stats">
   <primary>pg_stats</primary>
  </indexterm>

  <para>
   La vue <structname>pg_stats</structname> fournit un accès aux informations
   stockées dans la table système <link
   linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>.
   Cette vue autorise un accès aux seules lignes de
   <structname>pg_statistic</structname> correspondant aux tables pour lequel
   l'utilisateur a un droit de lecture et, donc, aucun problème de sécurité
   n'empêche l'accès en lecture de cette vue au public.
  </para>

  <para>
   <structname>pg_stats</structname> est aussi conçu pour afficher l'information
   dans un format plus lisible que le catalogue sous-jacent, au prix d'un schéma
   qui doit être étendu lorsque de nouveaux types sont définis dans
   <structname>pg_statistic</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_stats</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>nom de la table</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <entry>nom de la colonne décrite par cette ligne</entry>
     </row>

     <row>
      <entry><structfield>null_frac</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>fraction d'entrées de colonnes qui sont NULL</entry>
     </row>

     <row>
      <entry><structfield>avg_width</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>largeur moyenne en octets des entrées de la colonne</entry>
     </row>

     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Si plus grand que zéro, le nombre estimé de valeurs distinctes dans
      la colonne. Si négatif, le nombre de valeurs distinctes divisé par le
      nombre de lignes, le tout muliplié par -1. (La forme négative est utilisée
      quand <command>ANALYZE</command> croit que le nombre de valeurs distinctes a
      tendance à grossir au fur et à mesure que la table grossit&nbsp;; la forme
      positive est utilisé lorsque la commande semble avoir un nombre fixe de
      valeurs possibles.) Par exemple, -1 indique une colonne unique pour
      laquelle le nombre de valeurs distinctes est identique aux nombres de
      lignes.
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>Une liste des valeurs habituelles dans cette colonne. (NULL si
       aucune valeur ne semble identique aux autres.)</entry>
     </row>

     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>Une liste des fréquences des valeurs les plus habituelles,
       c'est-à-dire le nombre d'occurrences de chacune divisé par le nombre
       total de lignes. (NULL lorsque
       <structfield>most_common_vals</structfield> l'est.)
     </entry>
     </row>

     <row>
      <entry><structfield>histogram_bounds</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>Une liste des valeurs qui divisent les valeurs de la colonne en
       groupes de population approximativement identique. Les valeurs dans
       <structfield>most_common_vals</structfield>, s'ils existent, sont omises de ce
       calcul d'histogramme. (Cette colonne est NULL si le type de données de la
       colonne ne dispose pas de l'opérateur <literal>&lt;</literal> ou si la liste
       <structfield>most_common_vals</structfield> tient compte de la population complète.)
      </entry>
     </row>

     <row>
      <entry><structfield>correlation</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Corrélation statistique entre l'ordre physique des lignes et
       l'ordre logique des valeurs de la colonne. Ceci va de -1 à +1. Lorsque la
       valeur est plus près de -1 ou +1, un parcours de l'index sur la colonne
       sera estimé moins cher que si cette valeur tend vers zéro, à cause de la
       réduction d'accès aléatoire au disque. (Cette colonne est NULL si le type
       de données de la colonne n'a pas l'opérateur <literal>&lt;</literal> operator.)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Le nombre maximum d'entrées dans <structfield>most_common_vals</structfield>
   et <structfield>histogram_bounds</structfield> est configurable colonne par colonne en
   utilisant la commande <command>ALTER TABLE SET STATISTICS</command> ou globalement
   avec le paramètre d'exécution <xref linkend="guc-default-statistics-target"/>.
  </para>

 </sect1>

 <sect1 id="view-pg-tables">
  <title><structname>pg_tables</structname></title>

  <indexterm zone="view-pg-tables">
   <primary>pg_tables</primary>
  </indexterm>

  <para>
   La vue <structname>pg_tables</structname> fournit un accès à des informations
   utiles sur chaque table de la base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_tables</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>nom du schéma contenant la table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>nom de la table</entry>
     </row>
     <row>
      <entry><structfield>tableowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>nom du propriétaire de la table</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link
       linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>nom du tablespace contenant la table (NULL s'il s'agit du
       tablespace par défaut pour cette base)</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasindex</literal></entry>
      <entry>vrai si la table a (ou a récemment eu) des index</entry>
     </row>
     <row>
      <entry><structfield>hasrules</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasrules</literal></entry>
      <entry>vrai si la table dispose de règles</entry>
     </row>
     <row>
      <entry><structfield>hastriggers</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.reltriggers</literal></entry>
      <entry>vrai si la table dispose de déclencheurs (triggers)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user">
  <title><structname>pg_user</structname></title>

  <indexterm zone="view-pg-user">
   <primary>pg_user</primary>
  </indexterm>

  <para>
   La vue <structname>pg_user</structname> fournit un accès aux informations
   concernant les utilisateurs de la base de données. C'est une simple vue
   lisible publiquement de
   <link linkend="view-pg-shadow"><structname>pg_shadow</structname></link>
   mais qui n'affiche pas le champ du mot de passe.
  </para>

  <table>
   <title>Colonnes de <structname>pg_user</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Identifiant de l'utilisateur (un nombre arbitraire utilisé en
       référence à cet utilisateur)</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur est un super-utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       L'utilisateur pourrait mettre à jour les tables systèmes. (Même un
       super-utilisateur ne pourrait pas le faire tant que cette colonne n'est
       pas initialisée à vrai.
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Ce n'est pas le mot de passe (toujours <literal>********</literal>)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>Temps d'expiration du mot de passe (utilisé seulement pour
       l'authentification des mots de passe)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Variables d'exécution par défaut de la session</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-views">
  <title><structname>pg_views</structname></title>

  <indexterm zone="view-pg-views">
   <primary>pg_views</primary>
  </indexterm>

  <para>
   La vue <structname>pg_views</structname> fournit un accès à d'importantes
   informations de chaque vue de la base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_views</structname></title>

   <tgroup cols="4">
    <colspec colnum="1" colwidth="0.7*"/>
    <colspec colnum="2" colwidth="0.5*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <colspec colnum="4" colwidth="1.8*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma contenant la vue</entry>
     </row>
     <row>
      <entry><structfield>viewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la vue</entry>
     </row>
     <row>
      <entry><structfield>viewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Nom du propriétaire de la vue</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Définition de la vue (une requête SELECT reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-tabs-mode:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/share/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->


