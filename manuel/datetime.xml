<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/datetime.sgml,v 1.12 2005/09/22 18:34:40 guillaume Exp $
-->

 <appendix id="datetime-appendix">
  <title>Support de date/heure</title>

  <para>
   <productname>PostgreSQL</productname> utilise un analyseur heuristique interne
   pour le support des dates/heures données en entrée. Les dates et heures sont
entrées
   en tant que chaînes, et sont découpées en champs distincts avec une
détermination
   préliminaire du type d'information contenu dans le champ. Chaque champ est
   interpreté et soit il lui est attribué une valeur numérique, soit il est ignoré ou rejeté.
   Le parseur contient des tables de correspondance internes pour tout les
champs
   textuels y compris les mois, les jours de la semaine et les fuseaux
horaires.
  </para>

  <para>
   Cette annexe contient des informations sur le contenu de ces tables de
   correspondance et décrit les méthodes utilisées par le parseur pour décoder
   les dates et heures.
  </para>

  <sect1>
   <title>Interprétation des Entrées Date/Heure</title>

   <para>
    Les entrées de type date/heure sont toutes décodées en utilisant le processus
suivant.
   </para>

   <procedure>
    <step>
     <para>
      Diviser la chaîne d'entrée en marqueurs et cataloguer chaque marqueur en
      tant que une chaîne, heure, fuseau horaire ou nombre.
     </para>

     <substeps>
      <step>
       <para>
	Si un marqueur numérique contient les deux points (<literal>:</literal>),
	ceci est une
	chaîne d'heure. Inclure tout les chiffres et deux points suivants.
       </para>
      </step>

      <step>
       <para>
	Si un marqueur numérique contient un tiret (<literal>-</literal>), une
	barre oblique (<literal>/</literal>) ou plus d'un point
	(<literal>.</literal>), ceci est une chaîne de date qui contient peut-être
	un mois sous forme de texte. Si un marqueur de date a déjà été vu, il
	est alors interprété comme un nom de fuseau horaire
	(par exemple <literal>America/New_York</literal>).
       </para>
      </step>

      <step>
       <para>
	Si un marqueur est uniquement numérique alors il est soit un champ
simple
        ou une date concaténée ISO 8601 (i.e.,
	<literal>19990113</literal> pour le 13 janvier 1999) ou heure
	(i.e., <literal>141516</literal> pour 14:15:16).
       </para>
      </step>

      <step>
       <para>
	Si le marqueur commence avec un plus (<literal>+</literal>) ou un moins
	(<literal>-</literal>), alors il est soit un fuseau horaire numérique,
	soit un champ spécial.
       </para>
      </step>
     </substeps>
    </step>

    <step>
     <para>
      Si un marqueur est une chaîne texte, le comparer avec les différentes chaînes
      possibles&nbsp;:
     </para>
     
     <substeps>
      <step>
       <para>
	Faire une recherche binaire dans la table de correspondance pour le
	marqueur en tant qu'abréviation de fuseau horaire.
       </para>
      </step>
      
      <step>
       <para>
	Faire une recherche binaire dans la table de correspondance pour le
	marqueur en tant que chaîne spéciale (i.e., <literal>today</literal>),
	jour (i.e., <literal>Thursday</literal>),
	mois (i.e., <literal>January</literal>),
	ou du bruit (i.e., <literal>at</literal>, <literal>on</literal>).
       </para>
      </step>
      
      <step>
       <para>
	Si pas trouvé, faire une recherche binaire similaire dans une table de
	correspondance pour faire correspondre le marqueur avec un fuseau horaire.
       </para>
      </step>

      <step>
       <para>
	Si toujours pas trouvé, lever une erreur.
       </para>
      </step>
     </substeps>
    </step>
    
    <step>
     <para>
      Quand le marqueur est un nombre ou un champ de nombre:
     </para>

     <substeps>
      <step>
       <para>
	S'il y a huit ou six chiffres,
	et aucun autre champ date n'a été lu, alors l'interpréter comme
	une <quote>date concaténée</quote> (i.e.,
	<literal>19990118</literal> ou <literal>990118</literal>).
	L'interprétation est <literal>AAAAMMJJ</literal> ou <literal>AAMMJJ</literal>.
       </para>
      </step>

      <step>
       <para>
	Si le marqueur est de trois chiffres
	et une année a déjà été lue, alors il sera interprété comme un jour de l'année.
       </para>
      </step>
      
      <step>
       <para>
	Si quatre ou six chiffres et une année ont déjà été lus, alors il sera
interprété
	comme une heure (<literal>HHMM</literal> or <literal>HHMMSS</literal>).
       </para>
      </step>

      <step>
       <para>
	Si trois chiffres ou plus et aucun champ date n'a été trouvé, il sera
interprété
	comme année (ceci force l'ordre aa-mm-jj des champs dates restants).
       </para>
      </step>

      <step>
       <para>
        Sinon l'ordre de champ date est supposé suivre le paramêtre
	<varname>DateStyle</varname> : mm-jj-aa, jj-mm-aa, ou aa-mm-jj.
	Lever une erreur si un champ jour ou mois est découvert hors des
limites.
       </para>
      </step>
     </substeps>
    </step>

    <step>
     <para>
      Si BC a été spécifié, rendre NULL l'année et ajouter un pour
      le stockage interne.  (Il n'y a pas d'année zéro dans le calendrier
Grégorien,
      alors numériquement 1 BC devient l'année zéro.)
     </para>
    </step>

    <step>
     <para>
      Si BC n'a pas été spécifié et le champ année fait deux chiffres en
longueur, alors
      ajuster l'année a quatre chiffres. Si le champ vaut moins que 70 alors
ajouter 2000,
      sinon ajouter 1900.

      <tip>
       <para>
	Les années Grégoriennes AD 1-99 peuvent être entrées en utilisant 4
	chiffres avec les zéros de devant (i.e., <literal>0099</literal> est
	AD 99).
       </para>
      </tip>
     </para>
    </step>
   </procedure>
  </sect1>


  <sect1 id="datetime-keywords">
   <title>Mots clés Date/Heure</title>

   <para>
    <xref linkend="datetime-month-table"/> montre les marqueurs qui sont
    reconnus commme les noms des mois.
   </para>

    <table id="datetime-month-table">
     <title>Noms des mois</title>
     <tgroup cols="2">
      <thead>
       <row>
	<entry>Mois</entry>
	<entry>Abréviations</entry>
       </row>
      </thead>
      <tbody>
        <row>
          <entry>Janvier</entry>
          <entry>Jan</entry>
        </row>
        <row>
          <entry>Février</entry>
          <entry>Feb</entry>
        </row>
        <row>
          <entry>Mars</entry>
          <entry>Mar</entry>
        </row>
        <row>
          <entry>Avril</entry>
          <entry>Apr</entry>
        </row>
        <row>
          <entry>Mai</entry>
          <entry></entry>
        </row>
        <row>
          <entry>Juin</entry>
          <entry>Jun</entry>
        </row>
        <row>
          <entry>Juillet</entry>
          <entry>Jul</entry>
        </row>
        <row>
          <entry>Août</entry>
          <entry>Aug</entry>
        </row>
        <row>
          <entry>Septembre</entry>
          <entry>Sep, Sept</entry>
        </row>
        <row>
          <entry>Octobre</entry>
          <entry>Oct</entry>
        </row>
        <row>
          <entry>Novembre</entry>
          <entry>Nov</entry>
        </row>
        <row>
          <entry>Décembre</entry>
          <entry>Dec</entry>
        </row>
      </tbody>
     </tgroup>
    </table>

    <para>
     <xref linkend="datetime-dow-table"/> montre les marqueurs qui sont
     reconnus comme les noms des jours de la semaine.
    </para>

     <table id="datetime-dow-table">
      <title>Noms des jours de la semaine</title>
      <tgroup cols="2">
       <thead>
	<row>
	 <entry>Jour</entry>
	 <entry>Abréviation</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>Dimanche</entry>
	 <entry>Sun</entry>
	</row>
	<row>
	 <entry>Lundi</entry>
	 <entry>Mon</entry>
	</row>
	<row>
	 <entry>Mardi</entry>
	 <entry>Tue, Tues</entry>
	</row>
	<row>
	 <entry>Mercredi</entry>
	 <entry>Wed, Weds</entry>
	</row>
	<row>
	 <entry>Jeudi</entry>
	 <entry>Thu, Thur, Thurs</entry>
	</row>
	<row>
	 <entry>Vendredi</entry>
	 <entry>Fri</entry>
	</row>
	<row>
	 <entry>Samedi</entry>
	 <entry>Sat</entry>
	</row>
       </tbody>
      </tgroup>
     </table>

   <para>
    <xref linkend="datetime-mod-table"/> montre les marqueurs qui servent
    à modifier divers contenus.
   </para>

    <table id="datetime-mod-table">
     <title>Modificateurs de Champs Date/Heure</title>
     <tgroup cols="2">
      <thead>
       <row>
	<entry>Identifiant</entry>
	<entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry><literal>ABSTIME</literal></entry>
	<entry>Ignoré</entry>
       </row>
       <row>
	<entry><literal>AM</literal></entry>
	<entry>Heure avant 12:00</entry>
       </row>
       <row>
	<entry><literal>AT</literal></entry>
	<entry>Ignoré</entry>
       </row>
       <row>
	<entry><literal>JULIAN</literal>, <literal>JD</literal>, <literal>J</literal></entry>
	<entry>Le champ suivant est un jour Julien</entry>
       </row>
       <row>
	<entry><literal>ON</literal></entry>
	<entry>Ignoré</entry>
       </row>
       <row>
	<entry><literal>PM</literal></entry>
	<entry>Heure à ou après 12:00</entry>
       </row>
       <row>
	<entry><literal>T</literal></entry>
	<entry>Le champ suivant est de temps</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Le mot clé <literal>ABSTIME</literal> est ignoré pour des raisons
    historiques: Dans de très vieilles versions de
    <productname>PostgreSQL</productname>, des valeurs invalides de type
<type>abstime</type>
    étaient émises en tant que <literal>Invalid Abstime</literal>. Par contre,
ceci n'est plus
    le cas et ce mot clé sera probablement abandonné dans une future version.
   </para>

  </sect1>

  <sect1 id="datetime-config-files">
  <title>Fichiers de configuration date/heure</title>

   <indexterm>
    <primary>fuseau horaire</primary>
    <secondary>abréviations en entrée</secondary>
   </indexterm>

   <para>
    Comme les abréviations de fuseaux horaire ne sont pas bien standardisés,
    <productname>PostgreSQL</productname> fournit un moyen de personnaliser
    l'ensemble d'abréviations acceptées par le serveur. Le paramètre en
    exécution <xref linkend="guc-timezone-abbreviations"/> détermine
    l'ensemble des abréviations actives. Bien que ce paramètre puisse être
    modifié par tout utilisateur de la base, les valeurs possibles sont
    sous le contrôle de l'administrateur de la base &mdash; ce sont en fait
    les noms des fichiers de configuration stockés dans
    <filename>.../share/timezonesets/</filename> du répertoire d'installation.
    En ajoutant ou en modifiant les fichiers de ce répertoire, l'administrateur
    peut configurer la politique pour les abréviations système.
   </para>

   <para>
    <literal>timezone_abbreviations</literal> peut être configuré avec tout nom
    de fichier se trouvant dans <filename>.../share/timezonesets/</filename> si
    le nom du fichier est entièrement alphabétique. (L'interdiction de
    caractères non alphabétique dans <literal>timezone_abbreviations</literal>
    empêche la lecture de fichiers en dehors du répertoire attendu et
    empêche aussi la lecture de fichiers de sauvegarde et d'autres fichiers.)
   </para>

   <para>
    Un fichier d'abréviation de zones horaires peut contenir des lignes blanches
    et des commentaires (lignes commençant avec un <literal>#</literal>). Les
    lignes qui ne sont pas des commentaires doivent être dans un de ces
    formats&nbsp;:

<synopsis>
<replaceable>nom_fuseau_horaire</replaceable> <replaceable>décalage</replaceable>
<replaceable>nom_fuseau_horaire</replaceable> <replaceable>décalage</replaceable> D
@INCLUDE <replaceable>nom_fichier</replaceable>
@OVERRIDE
</synopsis>
   </para>

   <para>
    Un <replaceable>nom_fuseau_horaire</replaceable> est tout simplement
    l'abréviation à définir. Le <replaceable>décalage</replaceable> est le
    décalage en secondes à partir d'UTC, une valeur positive signifiant à
    l'est de Greenwich, une valeur négative signifiant à l'ouest.
    negative being west. Par exemple, -18000 représente cinq heures à l'ouest
    de Greenwich, soit l'heure standard de la coût ouest nord américaine.
    <literal>D</literal> indique que le nom du fuseau représente l'heure
    de changement d'heure plutôt que l'heure standard. Comme tous les
    décalages de fuseau horaire sont sur des limites de 15 minutes, le nombre
    de secondes doit être un multiple de 900.
   </para>

   <para>
    La syntaxe <literal>@INCLUDE</literal> autorise l'inclusion d'autres fichiers
    du répertoire <filename>.../share/timezonesets/</filename>. Les inclusions
    peuvent être imbriquées jusqu'à une certaine profondeur.
   </para>

   <para>
    La syntaxe <literal>@OVERRIDE</literal> indique que les entrées suivantes du
    fichier pourraient surcharger des entrées précédentes (c'est-à-dire des
    entrées obtenues à partir de fichiers inclus). Sans cela, les définitions en
    conflit pour les mêmes abréviations de zone horaire sont considérées comme
    une erreur.
   </para>

   <para>
    Dans une installation non modifiée, le fichier <filename>Default</filename>
    contient toutes les abréviations de fuseaux horaire sans conflit pour la
    plupart du monde. Les fichiers supplémentaires <filename>Australia</filename>
    et <filename>India</filename> sont fournis pour ces régions&nbsp;: ces
    fichiers incluent en premier le fichier <literal>Default</literal> puis
    ajoutent ou modifient les fuseaux horaires suivant leur besoin.
   </para>

   <para>
    Pour des raisons de référence, une installation standard contient aussi
    des fichiers <filename>Africa.txt</filename>, <filename>America.txt</filename>,
    etc, contenant des informations sur chaque abréviation connue pour être
    utilisé en accord avec la base de données de fuseau horaire
    <literal>zic</literal>. Les définitions des noms de zone trouvées dans ces
    fichiers peuvent être copiées et collées dans un fichier de configuration
    personnalisé si nécessaire. Notez que ces fichiers ne peuvent pas être
    directement référencés dans le paramètre
    <literal>timezone_abbreviations</literal> à cause du point dans leur nom.
   </para>

   <note>
    <para>
     Si une erreur survient lors de la lecture des ensembles de données sur les
     fuseaux horaires, aucune nouvelle valeur n'est acceptée mais les anciennes
     sont conservées. Si l'erreur survient au lancement de la base, le
     lancement échoue.
    </para>
   </note>

   <caution>
    <para>
     Les abréviations de fuseau horaire définies dans le fichier de configuration
     surchargent les informations sans fuseaux dans
     <productname>PostgreSQL</productname>.
     Par exemple, le fichier de configuration <filename>Australia</filename>
     définit <literal>SAT</literal> (pour <foreignphrase>South Australian Standard
     Time</foreignphrase>, soit l'heure standard pour l'Australie du sud). Quand
     ce fichier est actif, <literal>SAT</literal> ne sera plus reconnu comme
     abréviation pour samedi (<foreignphrase>Saturday</foreignphrase>).
    </para>
   </caution>

   <caution>
    <para>
     Si vous modifiez les fichiers de <filename>.../share/timezonesets/</filename>,
     c'est à vous d'en faire des sauvegardes &mdash; une sauvegarde normale de
     base n'incluera pas ce répertoire.
    </para>
   </caution>

  </sect1>

  <sect1 id="datetime-units-history">
  <title>Histoire d'unités</title>

  <para>
   Le Julian Date a été inventé par le savant français
   Joseph Justus Scaliger (1540-1609)
   et tient probablement son nom du pere de Scaliger,
   le scholar Italian Julius Caesar Scaliger (1484-1558).
   Les astronomes ont utilisés la periode Julian pour donner un nombre unique
   a chaque jour depuis le 1 Janvier 4713 BC. ceci est la date dite Julian
   (JD). JD 0 designe les 24 heures de midi UTC le 1 Janvier 4713 BC
   jusqu'à midi UTC le 2 Janvier 4713 BC.
  </para>

   <para>
   La <quote>Date Julian</quote> est différente du <quote>calendrier
   Julian</quote>.  Le calendrier Julian 
   a été introduit par Julius Caesar en 45 BC. Il était utilisé de maniére
   courante jusqu'en l'an 1582, ou des pays ont commencés à se convertir au
   calendrier Grégorien.  Dans le calendrier Julian, l'année tropical est
   arrondie à 365 1/4 jours = 365.25 jours. ceci donne une erreur d'à peu près
   1 jour tout les 128 ans.
  </para>

  <para>   
   L'erreur de calendrier grandissante poussa le Pape
   Gregory XIII a réformé le calendrier en accord avec les
   instructions du Conseil de Trente.
   Dans le calendrier Grégorien, l'année tropical est arrondie en
   365 + 97 / 400 jours = 365.2425 jours. Donc, il faut à peu prés 3300
   années pour l'année tropical pour virer d'un jour par rapport au
   calendrier Grégorien.
  </para>

  <para>
   L'arrondi 365+97/400 est obtenu en ayant 97 années bissextiles
   tous les 400 ans, en utilisant les régles suivantes:

   <simplelist>
    <member>
     Toutes les années divisibles par 4 sont des années bissextiles.
    </member>
    <member>
     Par contre, toutes les années divisibles par 100 ne sont pas des années
bissextiles.
    </member>
    <member>
     Par contre, toutes les années divisibles par 400 sont, finalement, des
années bissextiles.
    </member>
   </simplelist>

   Donc 1700, 1800, 1900, 2100 et 2200 ne sont pas des années bissextiles. Mais
1600,
   2000 et 2400 sont des années bissextiles.

   Par opposition, dans le plus ancien calendrier Julian, toutes les années
divisibles par
   4 sont des années bissextiles.
  </para>

  <para>
   L'annonce du Pape de février 1582 décrétait que 10 jours devaient étre
supprimés
   du mois d'octobre 1582 pour que le 15 octobre suivent immédiatement après le
4
   octobre.
   Cela a été appliqué en Italie, Pologne, Portugal et Espagne. Les autres pays
   catholiques ont suivi peu de temps mais les pays protestants ont été plus
   récalcitrants à changer et la Gréce n'a pas changé avant le début du 20ème
   siècle.

   La réforme a été appliquée par la Grande Bretagne et ses colonies (y compris
ce
   qui est maintenant les Etats-Unis) en 1752.
   Donc le 2 septembre 1752 a été suivi du 14 septembre 1752.

   ceci est la raison pour laquelle la commande <command>cal</command> produit
   la sortie suivante:

<screen>$ <userinput>cal 9 1752</userinput>
   septembre 1752
di lu ma me je ve sa
       1  2 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30</screen>
  </para>

   <note>
    <para>
     Le standard SQL stipule que <quote>Au sein d'une définition d'un
     <quote>datetime literal</quote>, les <quote>valeurs date/heure</quote>
     sont restreintes par les règles naturelles pour les dates et heures
     relatives au calendrier Grégorien</quote>. Les dates entre
     1752-09-03 et 1752-09-13, bien qu'éliminées dans plusieurs pays
     par ordre du Pape, sont conformes aux <quote>règles naturelles</quote> et
sont
     donc des dates valables.
    </para>
   </note>

  <para>
   Différents calendriers ont été developés dans différentes parties du monde,
   la plupart précédant le système Grégorien.

   Par exemple,
   les débuts du calendrier chinois peuvent être évalués au alentour du 14ème
   siécle avant J-C. La légende veut que l'empereur Huangdi invente le
   calendrier en 2637 avant J-C.
   
   La République de Chine utilise le calendrier Grégorien pour ses besoins
   civils. Le calendrier chinois est utilisé pour déterminer les festivals.
  </para>
 </sect1>
</appendix>
