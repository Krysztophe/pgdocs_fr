<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/diskusage.sgml,v 1.9 2005/09/15 07:03:16 guillaume Exp $
-->

<chapter id="diskusage">
 <title>Surveiller l'utilisation du disque</title>

 <para>
  Ce chapitre explique comment surveiller l'utilisation du disque faite par
  <productname>PostgreSQL</productname>.
  
 </para>

 <sect1 id="disk-usage">
  <title>Déterminer l'utilisation du disque</title>

  <indexterm zone="disk-usage">
   <primary>utilisation du disque</primary>
  </indexterm>

  <para>
   Chaque table possède un fichier principal dans lequel la majorité
   des données sont stockées. Si la table contient des colonnes pouvant recevoir 
   de grandes valeurs, il existe aussi un fichier <acronym>TOAST</acronym> associé à la
   table de stockage de ces valeurs (voir la <xref linkend="storage-toast"/>).
   Si la table <acronym>TOAST</acronym> existe, un index lui est associé.
   Des index peuvent également être associés à la table de base.
   Chaque table ou index est stocké dans un fichier distinct &mdash;
   ou plusieurs si la taille du fichier dépasse 1&nbsp;Go.
   Les conventions de nommage de ces fichiers sont décrites dans la
   <xref linkend="storage-file-layout"/>.
  </para>

  <para>
   Les disques peuvent être surveillés de trois façons différentes&nbsp;:
   depuis <application>psql</application> en utilisant les informations retournées par
   <command>VACUUM</command>, depuis <application>psql</application> avec les outils de 
   <filename>contrib/dbsize</filename> et en ligne de commande avec les outils de
   <filename>contrib/oid2name</filename>.
  </para>

  <para>
   L'utilisation de <application>psql</application> sur une base de données 
   récemment &laquo;&nbsp;nettoyée&nbsp;&raquo; (<command>VACUUM</command>) ou
   &laquo;&nbsp;analysée&nbsp;&raquo; (<command>ANALYZE</command>), permet de lancer des
   requêtes pour connaître l'occupation disque d'une table&nbsp;:
<programlisting>SELECT relfilenode, relpages FROM pg_class WHERE relname = 'customer';

 relfilenode | relpages 
-------------+----------
       16806 |       60
(1 ligne)</programlisting>
   Chaque page utilise en général 8&nbsp;Ko d'espace disque.
  </para>
  
  <para>
   <structfield>relpage</structfield> n'est mis à jour que par
   les commandes <command>VACUUM</command>, <command>ANALYZE</command> et
   par quelques commandes de définition de données (DDL, Data Definition
   Language), telle que <command>CREATE INDEX</command>. La valeur de
   <structfield>relfilenode</structfield> est intéressante pour l'examen direct du fichier
   de table.
  </para>

  <para>
   Pour connaître l'espace disque utilisé par les tables 
   <acronym>TOAST</acronym>, on utilise une requête similaire à la suivante&nbsp;:
<programlisting>SELECT relname, relpages
    FROM pg_class,
         (SELECT reltoastrelid FROM pg_class
          WHERE relname = 'customer') ss
    WHERE oid = ss.reltoastrelid
       OR oid = (SELECT reltoastidxid FROM pg_class
                 WHERE oid = ss.reltoastrelid)
    ORDER BY relname;

       relname        | relpages 
----------------------+----------
 pg_toast_16806       |        0
 pg_toast_16806_index |        1</programlisting>
  </para>

  <para>
   On peut aussi facilement afficher la taille des index&nbsp;:
<programlisting>SELECT c2.relname, c2.relpages
    FROM pg_class c, pg_class c2, pg_index i
    WHERE c.relname = 'customer'
        AND c.oid = i.indrelid
        AND c2.oid = i.indexrelid
        ORDER BY c2.relname;

       relname        | relpages 
----------------------+----------
 customer_id_indexdex |       26</programlisting>
  </para>

  <para>
   Les tables et les index les plus volumineux sont repérés à l'aide de la requête
   suivante&nbsp;:
<programlisting>SELECT relname, relpages FROM pg_class ORDER BY relpages DESC;

       relname        | relpages 
----------------------+----------
 bigtable             |     3290
 customer             |     3144</programlisting>
  </para>

  <para>
   <filename>contrib/dbsize</filename> charge dans la base les fonctions permettant
   de calculer la taille d'une base ou d'une table à partir de 
   <application>psql</application> sans utiliser <command>VACUUM</command> ou <command>ANALYZE</command>.
  </para>

  <para>
   L'utilitaire <filename>contrib/oid2name</filename> permet de connaître
   l'utilisation du disque. Des exemples d'utilisation sont repris dans 
   le fichier <filename>README.oid2name</filename> situé dans le répertoire
   de l'utilitaire. On y trouve notamment un script d'affichage de l'utilisation
   du disque pour chaque base de données.
  </para>
 </sect1>

 <sect1 id="disk-full">
  <title>Problème de disque plein</title>

  <para>
   La tâche la plus importante d'un administrateur de base de données, 
   concernant la surveillance des disques, est de s'assurer que le disque ne
   se remplisse pas complètement. Un disque de données plein ne corrompra pas
   les données mais il peut empêcher toute activité. S'il s'agit
   du disque contenant les fichier WAL, le serveur émettera une alerte
   PANIC avant un arrêt éventuel.
  </para>

  <para>
   S'il n'est pas possible de libérer de la place sur le disque, il faut
   envisager le déplacement de quelques fichiers vers d'autres systèmes de
   fichiers à l'aide des tablespaces. Voir la
   <xref linkend="manage-ag-tablespaces"/> pour plus d'informations.
  </para>

  <tip>
   <para>
   Certains systèmes de fichiers réagissent mal près des limites de remplissage.
   Il est donc préférable de ne pas attendre ce moment pour réagir.
   </para>
  </tip>

  <para>
   Si le système supporte les quotas disque par utilisateur, la
   base de données sera soumise au quota de
   l'utilisateur qui exécute le serveur de base de données. Dépasser le
   quota aura les mêmes conséquences qu'un disque plein.
  </para>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->





