<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/dml.sgml,v 1.8 2005/09/15 07:03:16 guillaume Exp $ -->

<chapter id="dml">
 <title>Manipulation de données</title>

 <remark>
  Ce chapitre est toujours assez incomplet.
 </remark>

 <para>
  Le chapitre précédent présentait la création des tables et
  des autres structures de stockage des données. Il est temps de remplir ces
  tables avec des données. Ce chapitre présente l'insertion, la mise à jour et
  la suppression des données des tables.
  Il introduit également les outils de modifications automatiques des
  données en fonction d'évènements précis&nbsp;:
  les déclencheurs et les règles de réécriture. Le chapitre suivant présente
  l'élimination des données perdues.
 </para>

 <sect1 id="dml-insert">
  <title>Insertion de données</title>

  <indexterm zone="dml-insert">
   <primary>insertion</primary>
  </indexterm>

  <indexterm zone="dml-insert">
   <primary>INSERT</primary>
  </indexterm>

  <para>
   Quand une table est créée, elle ne contient aucune donnée.
   La première chose à faire, c'est d'y insérer des données. Sans quoi
   la base de données n'est pas d'une grande utilité.
   Les données sont insérées ligne par ligne. Il est évidemment possible
   d'insérer plus d'une ligne mais il n'est pas possible d'entrer moins
   d'une ligne à la fois. Même lorsque seules les valeurs d'une partie des colonnes sont connues, une ligne complète doit être créée.
  </para>

  <para>
   Pour créer une nouvelle ligne, la commande <xref
   linkend="sql-insert" xreflabel="sql-insert-title"/> est utilisée.
   La commande a besoin du nom de la table et d'une valeur pour
   chaque colonne de cette table.
   Soit la table des produits du <xref linkend="ddl"/>&nbsp;:
<programlisting>CREATE TABLE produits (
    no_produit integer,
    nom text,
    prix numeric
);</programlisting>
   Une commande d'insertion d'une ligne peut être&nbsp;:
<programlisting>INSERT INTO produits VALUES (1, 'Fromage', 9.99);</programlisting>
   Les données sont listées dans l'ordre des colonnes 
   dans la table, séparées par des virgules. Souvent, les
   données sont des constantes (litéraux) mais les expressions
   scalaires sont aussi acceptées.
  </para>

  <para>
   La syntaxe précédente oblige à connaître l'ordre des colonnes.
   Pour éviter cela, les colonnes peuvent être explicitement listées.
   Les deux commandes suivantes ont, ainsi, le même effet que la 
   précédente&nbsp;:
<programlisting>INSERT INTO produits (no_produit, nom, prix) VALUES (1, 'Fromage', 9.99);
INSERT INTO produits (nom, prix, no_produit) VALUES ('Fromage', 9.99, 1);</programlisting>
   Beaucoup d'utilisateurs recommandent de toujours lister les noms de colonnes.
  </para>
<!-- -->
  <para>
   Si les valeurs de certaines colonnes ne sont pas connues, 
   elles peuvent être omises. Dans ce cas, elles seront remplies avec leur 
   valeur par défaut. Par exemple,
<programlisting>INSERT INTO produits (no_produit, nom) VALUES (1, 'Fromage');
INSERT INTO produits VALUES (1, 'Fromage');</programlisting>
   La seconde instruction est une extension de 
   <productname>PostgreSQL</productname>. Elle remplit les colonnes de 
   gauche à droite avec toutes les valeurs données, et les autres prennent
   leur valeur par défaut.
  </para>
<!-- -->
  <para>
   Il est possible, pour plus de clarté, d'appeler explicitement les valeurs
   par défaut, pour certaines colonnes ou pour la ligne complète.
<programlisting>INSERT INTO produits (no_produit, nom, prix) VALUES (1, 'Fromage', DEFAULT);
INSERT INTO produits DEFAULT VALUES;</programlisting>
  </para>

  <tip>
   <para>
    Pour faire des chargements en masse (insertion de grandes quantités 
    de données, <quote>bulk load</quote> en anglais), on s'intéressera à la
    commande <xref linkend="sql-copy" endterm="sql-copy-title"/>. 
    Elle n'est pas aussi souple que la
    commande <xref linkend="sql-insert" endterm="sql-insert-title"/> mais
    est plus efficace. La <xref linkend="populate"/> comporte de plus amples
    informations sur l'amélioration des performances lors de chargements
    en masse.
   </para>
  </tip>
 </sect1>

 <sect1 id="dml-update">
  <title>Mise à jour de données</title>

  <indexterm zone="dml-update">
   <primary>modification</primary>
  </indexterm>

  <indexterm zone="dml-update">
   <primary>mise à jour</primary>
  </indexterm>

  <indexterm zone="dml-update">
   <primary>UPDATE</primary>
  </indexterm>

  <para>
   La modification de données présentes en base est
   appelée mise à jour (update en anglais).
   Il est possible de mettre à jour une ligne spécifique, toutes
   les lignes ou un sous-ensemble de lignes de la table. Chaque colonne peut
   être mise à jour séparément&nbsp;;
   les autres colonnes ne sont alors pas modifiées.
  </para>

  <para>
   Pour réaliser une mise à jour, trois informations sont nécessaires&nbsp;:
   <orderedlist spacing="compact">
    <listitem>
     <para>le nom de la table et de la colonne à mettre à jour&nbsp;;</para>
    </listitem>

    <listitem>
     <para>la nouvelle valeur de la colonne&nbsp;;</para>
    </listitem>

    <listitem>
     <para>les lignes à mettre à jour.</para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Comme cela a été vu dans le <xref linkend="ddl"/>, le SQL ne donne pas,
   par défaut, d'identifiant unique pour les lignes. Il n'est, de ce fait, 
   pas toujours possible d'indiquer directement la ligne à mettre à jour. 
   On précisera plutôt les conditions qu'une ligne doit remplir pour
   être mise à jour. Si la table possède une clé primaire
   (qu'elle soit déclarée ou non), une ligne unique peut être choisie en
   précisant une condition sur la clé primaire. Les outils graphiques
   d'accès aux bases de données utilisent ce principe pour permettre
   les modifications de lignes individuelles.
  </para>

  <para>
   La commande suivante, par exemple, modifie tous les produits dont le prix est de 5 en le passant à 10.
<programlisting>UPDATE produits SET prix = 10 WHERE prix = 5;</programlisting>
    Cela peut mettre à jour zéro, une ou plusieurs lignes.
    L'exécution d'une commande <literal>UPDATE</literal> qui ne met à jour aucune ligne ne représente pas une erreur.
  </para>

  <para>
   Dans le détail de la commande, on trouve tout d'abord, le mot clé
   <literal>UPDATE</literal> suivi du nom de la table.
   Le nom de la table peut toujours être préfixé par un nom de
   schéma&nbsp; dans le cas contraire elle est recherchée dans le chemin.
   On trouve ensuite le mot clé <literal>SET</literal> suivi du nom de la
   colonne, un signe égal et la nouvelle valeur de la colonne, qui peut être
   une constante ou une expression scalaire. 
  </para>
   
  <para>
   Par exemple, pour augmenter de 10% le prix de tous les
   produits, on peut exécuter&nbsp;:
<programlisting>UPDATE produits SET prix = prix * 1.10;</programlisting>
  </para>
  
  <para>
   L'expression donnant la nouvelle valeur peut
   faire référence aux valeurs courantes de la ligne.
  </para>
  
  <para>
   Il n'a pas été indiqué ici de clause <literal>WHERE</literal>.
   Si elle est omise, toutes les lignes de la table sont
   modifiées. Si elle est présente, seules les lignes qui remplissent la
   condition <literal>WHERE</literal> sont mises à jour.
   Le signe égal dans la clause <literal>SET</literal>
   réalise une affectation, alors que celui de la clause 
   <literal>WHERE</literal> permet une comparaison. Pour autant, cela ne crée pas
   d'ambiguïté. La condition <literal>WHERE</literal> n'est pas
   nécessairement un test d'égalité&nbsp; de nombreux autres opérateurs existent
   (voir le <xref linkend="functions"/>). Mais le résultat de l'expression est 
   booléen.
  </para>

  <para>
   Il est possible de mettre plus d'une colonne à jour par 
   une seule commande <command>UPDATE</command> en indiquant plusieurs
   colonnes dans la clause <literal>SET</literal>. 
  </para>
  
  <para>
   Par exemple&nbsp;:
<programlisting>UPDATE ma_table SET a = 5, b = 3, c = 1 WHERE a &gt; 0;</programlisting>
  </para>
 </sect1>

 <sect1 id="dml-delete">
  <title>Suppression de données</title>

  <indexterm zone="dml-delete">
   <primary>suppression</primary>
  </indexterm>

  <indexterm zone="dml-delete">
   <primary>DELETE</primary>
  </indexterm>

  <para>
   Les parties précédentes présentent l'ajout et la modification de données.
   Il reste à présenter leur suppression quand elles ne sont plus nécessaires. 
   Comme pour l'insertion, la suppression ne peut se faire que par ligne
   entière. Le SQL ne propose pas de moyen
   d'accéder à une ligne particulière. C'est pourquoi la suppression de
   lignes se fait en indiquant les conditions à remplir par les lignes à
   supprimer. S'il y a une clé primaire dans la table, alors il est
   possible d'indiquer précisément la ligne à supprimer.
   Mais on peut aussi supprimer un groupe de lignes qui remplissent une
   condition, ou même toutes les lignes d'une table en une fois.
  </para>

  <para>
   Pour supprimer des lignes, on utilise la commande <xref linkend="sql-delete"
   xreflabel="sql-delete-title"/>&nbsp;; la syntaxe est très similaire à la
   commande <command>UPDATE</command>. 
  </para>
  
  <para>
   Par exemple, pour supprimer toutes les lignes de
   la table produits qui ont un prix de 10, on exécute&nbsp;:
<programlisting>DELETE FROM produits WHERE prix = 10;</programlisting>
  </para>

  <para>
   En indiquant simplement
<programlisting>DELETE FROM produits;</programlisting>
   on supprime toutes les lignes de la table. Attention aux mauvaises
   manipulations&nbsp;!
  </para>
 </sect1>
</chapter>

