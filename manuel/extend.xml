<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /cvsroot/pgsql-fr/sgml/extend.sgml,v 1.1 2003/08/15 13:41:51 guillaume 
Exp $-->

 <chapter id="extend">
  <title>Extension de <acronym>SQL</acronym></title>

   <indexterm zone="extend">
    <primary>Extension de SQL</primary>
   </indexterm>

  <para>
  Dans cette section, nous discutons de la façon d'étendre le langage de
  requêtes <productname>PostgreSQL</productname> en ajoutant des&nbsp;:
  <itemizedlist spacing="compact" mark="bullet">
    <listitem>
     <para>
      fonctions (commençant à la <xref linkend="xfunc"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      agrégats (commençant à la <xref linkend="xaggr"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      types de données (commençant à la <xref linkend="xtypes"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      opérateurs (commençant à la <xref linkend="xoper"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
     classes d'opérateurs pour les index (commençant à la
     <xref linkend="xindex"/>).
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <sect1 id="extend-how">
   <title>Comment fonctionne l'extensibilité</title>

   <para>
    <productname>PostgreSQL</productname> est extensible parce qu'il opère
    grâce à un catalogue. Si vous êtes familier avec les systèmes standards de
    bases de données, vous savez qu'ils enregistrent les informations
    concernant les bases de données, les tables, les colonnes, etc., dans ce
    qu'on nomme communément des catalogues systèmes (certains systèmes appellent
    cela le dictionnaire de données). Pour l'utilisateur, les catalogues
    apparaissent comme des tables ordinaires mais le <acronym>SGBD</acronym>
    y enregistre ses écritures internes. Une différence essentielle entre
    <productname>PostgreSQL</productname> et les systèmes de bases de données
    relationnelles est que <productname>PostgreSQL</productname> enregistre
    beaucoup plus d'informations dans ses catalogues&nbsp;: pas seulement 
    l'information à propos des tables et des colonnes, mais aussi
    l'information au sujet des types de données, des fonctions, des méthodes
    d'accès, etc. Ces tables peuvent être modifiées par l'utilisateur et,
    puisque <productname>PostgreSQL</productname> fonde ses opérations sur ces
    tables, cela signifie que <productname>PostgreSQL</productname> peut être
    étendu par les utilisateurs. En comparaison, les systèmes de bases de 
    données conventionnels peuvent seulement être étendus en modifiant les
    procédures dans le code source ou en installant des modules spécifiquement
    écrits par le vendeur de <acronym>SGBD</acronym>.
  </para>
  
  <para>Encore mieux, le serveur <productname>PostgreSQL</productname> peut
    s'ajouter du code écrit par l'utilisateur grâce au chargement
    dynamique. C'est-à-dire que l'utilisateur peut spécifier un fichier de code
    objet (par exemple une bibliothèque partagée) qui implémente un nouveau
    type ou une nouvelle fonction et que <productname>PostgreSQL</productname>
    chargera à la demande. Il est encore plus évident d'ajouter au serveur du
    code écrit en <acronym>SQL</acronym>. Cette possibilité de modifier son
    fonctionnement <quote>à la volée</quote> fait de
    <productname>PostgreSQL</productname> un outil unique pour le prototypage
    rapide de nouvelles applications et de structures de stockage.
  </para>
  
 </sect1>
   
   <sect1 id="extend-type-system"> 
     <title>Système de typage de <productname>PostgreSQL</productname></title>

   <indexterm zone="extend-type-system">
    <primary>type de base</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type de données</primary>
    <secondary>base</secondary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type composé</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>type de données</primary>
    <secondary>composé</secondary>
   </indexterm>

   <para>
    Les types de données de <productname>PostgreSQL</productname> sont répartis en types de base, 
    types composé, types de domaine et pseudo-types.
   </para>

   <sect2>
    <title>Types de base</title>

    <para>
     Les types de base sont ceux implémentés avant le langage 
     <acronym>SQL</acronym> comme <type>int4</type> (typiquement dans un langage de
     bas niveau comme le C). Ils correspondent généralement à ce qu'on nomme
     les types de données abstraits. <productname>PostgreSQL</productname> peut
     opérer avec de tels types seulement au travers de fonctions apportées par
     l'utilisateur et comprend uniquement le comportement de tels types par la
     description qu'en a fait l'utilisateur. Les types de base sont ensuite
     sous-divisés en types scalaires et tableaux. Pour chaque type scalaire, un
     type de tableau correspondant est automatiquement créé, pouvant contenir
     des tableaux à la taille des variables de ce type scalaire.
    </para>
    
   </sect2>

   <sect2>
    <title>Types composés</title>

    <para>
     Les types composés, ou types lignes, sont créés lorsqu'un utilisateur
     crée une table. Il est aussi possible d'utiliser <xref
     linkend="sql-createtype" endterm="sql-createtype-title"/> pour définir un
     type composé <quote>autonome</quote>, donc non associé à une table. Un type
     composé est simplement une liste de types avec des noms de champ
     associés. Une valeur pour un type composé est une ligne ou un
     enregistrement de valeurs de champ. L'utilisateur peut accéder aux champs
     composant à partir de requêtes <acronym>SQL</acronym>. Référez-vous à la <xref
     linkend="rowtypes"/> pour plus d'informations sur les types composé.
    </para>
    
   </sect2>

   <sect2>
    <title>Domaines</title>

    <para>
     Un domaine est basé sur un type de base particulier et est interchangeable
     pour de nombreux buts avec son type de base. Néanmoins, un domaine pourrait
     avoir des contraintes restreignant ses valeurs valides à un sous-ensemble
     du type de base de départ.
    </para>

    <para>
     Les domaines peuvent être créés avec les commandes <acronym>SQL</acronym>
     <xref linkend="sql-createdomain" endterm="sql-createdomain-title"/>. Leur
     création et utilisation ne sont pas discutées dans ce chapitre.
    </para>
   </sect2>

   <sect2>
    <title>Pseudo-Types</title>

    <para>
     Il existe quelques <quote>pseudo-types</quote> pour certains buts très
     spécifiques. Les pseudo-types ne peuvent pas apparaître comme colonnes de
     tables ou d'attributs de types composés, mais peuvent être utilisés pour
     déclarer les types d'argument ou de résultat de fonctions. Cela fournit un
     mécanisme à l'intérieur du système de types pour identifier les classes
     spéciales de fonctions. Le <xref linkend="datatype-pseudotypes-table"/> liste
     les pseudos-types existants.
    </para>
    
   </sect2>

   <sect2 id="extend-types-polymorphic">
    <title>Types polymorphiques</title>

   <indexterm zone="extend-types-polymorphic">
    <primary>type polymorphique</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>fonction polymorphique</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>type</primary>
    <secondary>polymorphique</secondary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>fonction</primary>
    <secondary>polymorphique</secondary>
   </indexterm>

    <para>
     Deux pseudo-types d'un grand intérêt sont <type>anyelement</type> et
     <type>anyarray</type>, collectivement appelés des <firstterm>types
     polymorphiques</firstterm>. Toute fonction déclarée utilisant ces types est dite
     être une <firstterm>fonction polymorphique</firstterm>. Une fonction polymorphique
     peut opérer sur différents types de données, les types de données
     spécifiques étant déterminés par les types de données réellement passés
     lors d'un appel particulier.
    </para>

    <para>
     Les arguments et résultats polymorphiques sont liés les uns aux autres et
     sont modifiés en un type spécifique de données lorsqu'une requête appelant
     une fonction polymorphique est analysée. Chaque position (argument ou
     valeur de retour) déclarée en tant que <type>anyelement</type> est
     autorisée à avoir tout type de donnée spécifique mais, sur un seul appel,
     elles doivent toutes avoir le <emphasis>même</emphasis> type. Chaque
     position déclarée comme <type>anyarray</type> peut avoir n'importe quel
     type de données mais, de façon similaire, elles doivent toutes avoir le même
     type. Si des positions sont déclarées <type>anyarray</type> et d'autres
     <type>anyelement</type>, le type de tableau réel dans les positions
     <type>anyarray</type> doit être un tableau dont les éléments sont du même
     type que ceux des positions <type>anyelement</type>.
    </para>

    <para>
     Du coup, lorsque plus d'un argument est déclaré polymorphique, l'effet est
     que seules certaines combinaisons de types d'argument sont autorisées. Par
     exemple, une fonction déclarée de cette façon
     <literal>equal(anyelement, anyelement)</literal> prendra seulement deux valeurs en
     entrées, à condition qu'elles soient du même type.
    </para>

    <para>
     Lorsque la valeur de retour d'une fonction est déclarée polymorphique, il
     doit exister au moins un argument lui-aussi polymorphique et le type de
     données fourni en argument détermine le type de données du code de retour
     pour cet appel. Par exemple, s'il n'existait pas déjà un mécanisme
     d'abonnement d'un tableau, nous pourrions définir une fonction qui
     implémente cet abonnement avec <literal>subscript(anyarray, integer)
     returns anyelement</literal>. Cette déclaration contraint le premier argument à
     être de type tableau et permet à l'analyseur d'inférer le bon type de
     retour à partir du type du premier argument.
    </para>
   </sect2>
  </sect1>

  &xfunc;
  &xaggr;
  &xtypes;
  &xoper;
  &xindex;
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
