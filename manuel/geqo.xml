<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/geqo.sgml,v 1.7 2005/09/15 07:03:17 guillaume Exp $
Genetic Optimizer
-->
<!-- SAS : 20080107, PG8111 -->

 <chapter id="geqo">
  <chapterinfo>
   <author>
    <firstname>Martin</firstname>
    <surname>Utesch</surname>
    <affiliation>
     <orgname>
      University of Mining and Technology
     </orgname>
     <orgdiv>
      Institute of Automatic Control
     </orgdiv>
     <address>
      <city>
       Freiberg
      </city>
      <country>
       Germany
      </country>
     </address>
    </affiliation>
   </author>
   <date>1997-10-02</date>
  </chapterinfo>

  <title id="geqo-title">Optimiseur génétique de requêtes
    (<foreignphrase>Genetic Query Optimizer</foreignphrase>)</title>

  <para>
   <note>
    <title>Auteur</title>
    <para>
     Écrit par Martin Utesch (<email>utesch@aut.tu-freiberg.de</email>)
     de l'Institut de Contrôle Automatique à l'Université des Mines et de 
     Technologie de Freiberg, Allemagne.
    </para>
   </note>
  </para>

  <sect1 id="geqo-intro">
   <title>Gérer les requêtes, un problème d'optimisation complexe</title>

   <para>
    De tous les opérateurs relationnels, le plus difficile à exécuter et à
    optimiser est la jointure (<firstterm>join</firstterm>). Le nombre de plans
    alternatifs pour répondre à une requête croît de façon exponentielle avec le
    nombre de jointures. Un effort supplémentaire d'optimisation est dû
    au support d'une variété de <firstterm>méthodes de jointure</firstterm>
    (boucles imbriquées, jointures de hachage, jointures de fusion...) pour
    exécuter des jointures individuelles et une diversité
    d'<firstterm>index</firstterm> (par exemple R-tree, B-tree, découpage...)
    comme chemins d'accès des relations.
   </para>

   <para>
    L'implantation de l'optimiseur de <productname>PostgreSQL</productname>
    réalise une <firstterm>recherche quasi-exhaustive</firstterm> sur
    l'ensemble des stratégies alternatives. Cet algorithme, tout d'abord
    introduit à l'origine dans la base de données <quote>System R</quote> d'IBM,
    produit un ordre de jointure quasi-optimal mais peut prendre beaucoup de temps et d'espace
    mémoire à mesure que le nombre de jointures grandit.
    L'optimiseur ordinaire de requêtes de
    <productname>PostgreSQL</productname> devient donc inapproprié pour les
    requêtes qui joignent un grand nombre de tables.
   </para>

   <para>
    L'Institut de Contrôle Automatique de l'Université des Mines et de 
    Technologie, basé à Freiberg, en Allemagne, a rencontré des difficultés
    lorsque ses employés ont voulu utiliser le SGBD
    <productname>PostgreSQL</productname> comme moteur pour leur système de
    support pour la maintenance d'une grille de courant électrique. Le SGBD
    avait besoin de gérer des requêtes comprenant de nombreuses jointures pour la
    machine d'inférence du système de connaissances.
   </para>

   <para>
<!-- Supprimé dans la v83 et v82 -->
    Les difficultés en terme de performance pour l'exploration des plans de
    requêtes possibles ont créé la demande du développement d'une nouvelle
    technique d'optimisation.
   </para>

<!-- Mais je n'ai pas les sources de PG81 sous la main -->
   <para>
    La suite du document décrit le codage d'un <firstterm>algorithme
    génétique</firstterm> de résolution de l'ordonnancement des jointures
    efficace pour les requêtes à jointures nombreuses.
   </para>
  </sect1>

  <sect1 id="geqo-intro2">
   <title>Algorithmes génétiques</title>

<!-- fitness : ? Je doute qu'il s'agisse de forme physique :-/ 
     to fit : s'intégrer, entrer, s'encastrer... 
     adaptation me semble convenir -->
   <para>
    L'algorithme génétique (<acronym>GA</acronym>) est une méthode
    d'optimisation heuristique qui opère par recherches non déterministes,
    aléatoires. L'ensemble des solutions possibles au problème d'optimisation
    est considéré comme une <firstterm>population</firstterm>
    d'<firstterm>individus</firstterm>. Le degré d'adaptation d'un individu
    à son environnement est indiqué par sa <firstterm>valeur d'adaptation</firstterm>
    (<foreignphrase>fitness</foreignphrase>).
   </para>

   <para>
    Les coordonnées d'un individu dans l'espace de recherche sont représentées
    par des <firstterm>chromosomes</firstterm>, en fait un ensemble de chaînes
    de caractères. Un <firstterm>gène</firstterm> est une sous-section de
    chromosome qui code la valeur d'un paramètre simple en cours d'optimisation.
    Les codages habituels d'un gène sont
    <firstterm>binary</firstterm> ou <firstterm>integer</firstterm>.
   </para>

   <para>
    La simulation des opérations d'évolution
    (<firstterm>recombinaison</firstterm>, <firstterm>mutation</firstterm> et
    <firstterm>sélection</firstterm>) permet de trouver de nouvelles
    générations de points de recherche qui présentent une meilleure adaptation
    moyenne que leurs ancêtres.
   </para>

   <para>
    Selon la <acronym>FAQ</acronym> de <systemitem
    class="resource">comp.ai.genetic</systemitem>, on ne peut pas réellement
    affirmer qu'un <acronym>GA</acronym> n'est pas purement une recherche
    aléatoire. Un <acronym>GA</acronym> utilise des processus stochastiques, mais
    le résultat est assurément non-aléatoire (il est mieux qu'aléatoire). 
   </para>

   <figure id="geqo-diagram">
    <title>Diagramme structuré d'un algorithme génétique</title>

    <informaltable frame="none">
     <tgroup cols="2">
      <tbody>
       <row>
        <entry>P(t)</entry>
        <entry>génération des ancêtres au temps t</entry>
       </row>

       <row>
        <entry>P''(t)</entry>
        <entry>génération des descendants au temps t</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

<literallayout class="monospaced">
+=========================================+
|&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Algorithme GA  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;|
+=========================================+
| INITIALISE t := 0                       |
+=========================================+
| INITIALISE P(t)                         |
+=========================================+
| évalue ADAPTATION de P(t)               |
+=========================================+
| tant que pas CRITERE ARRET faire        |
|   +-------------------------------------+
|   | P'(t)  := RECOMBINAISON{P(t)}       |
|   +-------------------------------------+
|   | P''(t) := MUTATION{P'(t)}           |
|   +-------------------------------------+
|   | P(t+1) := SELECTION{P''(t) + P(t)}  |
|   +-------------------------------------+
|   | évalue ADAPTATION de P''(t)         |
|   +-------------------------------------+
|   | t := t + 1                          |
+===+=====================================+
</literallayout>
   </figure>
  </sect1>

  <sect1 id="geqo-pg-intro">
   <title>Optimisation génétique des requêtes (<acronym>GEQO</acronym>) dans
     PostgreSQL</title>

   <para>
    Le module <acronym>GEQO</acronym> utilise une approche du problème
    d'optimisation des requêtes similaire à celui du voyageur
    de commerce (<acronym>TSP</acronym>). Les plans de requêtes possibles sont
    codés comme des chaînes d'entiers. Chaque chaîne représente l'ordre de
    jointure d'une relation de la requête à une autre. Par exemple, l'arbre de
    jointure
<literallayout class="monospaced">
   /\
  /\ 2
 /\ 3
4  1
</literallayout>
    est codé avec la chaîne d'entiers '4-1-3-2', ce qui signifie&nbsp;:
    première jointure entre les relations '4' et '1', puis '3' et enfin
    '2', avec 1, 2, 3, 4 les identifiants des relations pour l'optimiseur de
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    Diverses parties du module <acronym>GEQO</acronym> sont adaptées de l'algorithme
    Genitor de D. Whitley.
   </para>

   <para>
    Les caractéristiques spécifiques de l'implantation du
    <acronym>GEQO</acronym> sont&nbsp;:

    <itemizedlist spacing="compact" mark="bullet">
     <listitem>
      <para>
      <!-- least fit : plus divergent ? -->
       l'utilisation d'un algorithme génétique monostable (ou à état stable)
       (remplacement des individus les moins ciblés au lieu d'un remplacement
       global de génération) permet une convergence rapide vers des plans de
       requêtes améliorés ; c'est indispensable au traitement des requêtes dans un
       temps raisonnable&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
      <!-- Je me souviens maintenant pourquoi j'avais déjà buté sur cette
      relecture du temps de la 8.0... -->
      <!-- edge recombination crossover et edge losses ? -->
       l'utilisation de croisements (recombinaisons) aux limites est particulièrement
       adapté pour la restriction des pertes aux limites lors de la résolution
       du problème du voyageur de commerce par un algorithme génétique&nbsp;;
      </para>
     </listitem>

     <listitem>
      <para>
       la mutation en tant qu'opérateur génétique est rendue obsolète afin
       d'éviter la nécessité de mécanismes de réparation lors de la génération
       de tournées valides du problème du voyageur de commerce.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Le module <acronym>GEQO</acronym> permet à l'optimiseur de requêtes de
    <productname>PostgreSQL</productname> de supporter les requêtes disposant
    de jointures importantes de manière efficace via une recherche non
    exhaustive.
   </para>

  <sect2 id="geqo-future">
   <title>Tâches à réaliser pour la future implantation du <acronym>GEQO</acronym>
    </title>

     <para>
      Un gros travail est toujours nécessaire pour améliorer les paramètres de
      l'algorithme génétique.
      Dans le fichier
      <filename>src/backend/optimizer/geqo/geqo_main.c</filename>,
      pour les routines <function>gimme_pool_size</function> et
      <function>gimme_number_generations</function>, il faut trouver un
      compromis pour que les paramètres satisfassent deux besoins
      concurrents&nbsp;:
      <itemizedlist spacing="compact">
       <listitem>
	<para>
	 l'optimisation du plan de requête&nbsp;;
	</para>
       </listitem>
       <listitem>
	<para>
	 le temps de calcul.
	</para>
       </listitem>
      </itemizedlist>
     </para>

     <para>
      À un niveau plus basique, il n'est pas certain qu'optimiser
      une requête avec un algorithme génétique conçu pour le problème du
      voyageur de commerce approprié. Dans le cas du voyageur de commerce, le
      coût associé à une sous-chaîne quelconque (tour partiel) est
      indépendant du reste du tour, mais cela n'est certainement plus vrai dans
      le cas de l'optimisation de requêtes. Du coup, la question reste posée quant au fait
      que la recombinaison soit la procédure de mutation la plus efficace.
     </para>

   </sect2>
  </sect1>

 <sect1 id="geqo-biblio">
  <title>Lectures supplémentaires</title>

  <para>
   Les ressources suivantes contiennent des informations supplémentaires sur
   les algorithmes génétiques&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      <ulink url="http://www.cs.bham.ac.uk/Mirrors/ftp.de.uu.net/EC/clife/www/location.htm">The
      Hitch-Hiker's Guide to Evolutionary Computation</ulink> (FAQ de <ulink
      url="news://comp.ai.genetic"></ulink>)&nbsp;;
     </para>
    </listitem>
   
    <listitem>
     <para>
      <ulink url="http://www.red3d.com/cwr/evolve.html">Evolutionary
      Computation and its application to art and design</ulink>, par
      Craig Reynolds&nbsp;;
     </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="elma04"/>
     </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="fong"/>
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
