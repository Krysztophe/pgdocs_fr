<?xml version="1.0" encoding="UTF-8"?>
<!-- $PostgreSQL: pgsql/doc/src/sgml/gin.sgml,v 2.4 2006/09/18 12:11:36 teodor Exp $ -->

<chapter id="GIN">
<title>Index GIN</title>

   <indexterm>
    <primary>index</primary>
    <secondary>GIN</secondary>
   </indexterm>

<sect1 id="gin-intro">
 <title>Introduction</title>

 <para>
   <acronym>GIN</acronym> est l'acronyme de <foreignphrase>Generalized Inverted
   Index</foreignphrase>. C'est une structure d'index stockant des ensembles de
   paires (clé, liste de lignes) où le terme <quote>liste de lignes</quote>
   est un ensemble de lignes dans lesquelles la clé est valable. Chaque valeur
   indexée peut contenir plusieurs clés, pour que le même identifiant de ligne
   apparaisse dans plusieurs listes postées.
 </para>

 <para>
   Il est généralisé dans le sens qu'un index <acronym>GIN</acronym> n'a pas
   besoin de connaître l'opération qu'il accélère. À la place, il utilise
   les stratégies personnalisées définies pour des types de données particuliers.
 </para>

 <para>
  Un avantage de <acronym>GIN</acronym> est qu'il autorise le développement
  de types de données personnalisés avec des méthodes d'accès appropriées par
  un expert dans le domaine du type de données, plutôt que par un expert des
  bases de données. L'utilisation de <acronym>GiST</acronym> fournit le
  même avantage.
 </para>

  <para>
   L'implémentation de <acronym>GIN</acronym> dans
   <productname>PostgreSQL</productname> est principalement l'oeuvre de
   Teodor Sigaev et Oleg Bartunov. Plus d'informations sur <acronym>GIN</acronym>
   sont disponibles sur leur <ulink
   url="http://www.sai.msu.su/~megera/wiki/Gin">site web</ulink>.
  </para>
</sect1>

<sect1 id="gin-extensibility">
 <title>Extensibilité</title>

 <para>
   L'interface <acronym>GIN</acronym> a un haut niveau d'abstraction, nécessitant
   à la personne implémentant la méthode d'accès d'implémenter seulement les
   sémantiques du type de données en cours d'accès. La couche 
   <acronym>GIN</acronym> elle-même s'occupe de la concurrence, des traces
   et des recherches dans la structure de l'arbre.
 </para>

 <para>
   Ce qui est nécessaire pour qu'une méthode d'accès <acronym>GIN</acronym>
   fonctionne est d'implémenter quatre méthodes définies par l'utilisateur,
   méthodes qui définissent le comportement des clés dans l'arbre
   et les relations entre les clés, les valeurs indexées et les requêtes
   indexables. En bref, <acronym>GIN</acronym> combine une extensibilité
   avec une généralisation, une ré-utilisation du code et une interface
   claire.
 </para>

 <para>
   Les quatre méthodes qu'une classe d'opérateur d'index
   <acronym>GIN</acronym> doit fournir sont&nbsp;:
 </para>

 <variablelist>
    <varlistentry>
     <term>int compare(Datum a, Datum b)</term>
     <listitem>
      <para>
	   Compare les clés (valeurs non indexées&nbsp;!) et renvoie un entier
	   plus ptit que zéro, zéro ou plus grand que zéro, indiquant que la
	   première clé est plus petite, égale à, plus grande que la seconde.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Datum* extractValue(Datum inputValue, uint32 *nkeys)</term>
     <listitem>
      <para>
	   Renvoie un tableau de clés à partir de valeurs à indexer. Le nombre
	   de clés renvoyées doit être stocké dans <literal>*nkeys</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Datum* extractQuery(Datum query, uint32 *nkeys,
		StrategyNumber n)</term>
     <listitem>
      <para>
       Renvoie un tableau de clés suivant une valeur indiquée&nbsp;; c'est-à-dire
       que <literal>query</literal> est la valeur du côté droit d'un opérateur
       indexable dont le côté gauche est la colonne indexée.
       <literal>n</literal> est le numéro de stratégie de l'opérateur dans la
       classe d'opérateur (voir <xref linkend="xindex-strategies"/>). Souvent,
       <function>extractQuery</function> aura besoin de consulter
       <literal>n</literal> pour déterminer le type de données de
       <literal>query</literal> et les valeurs de clés qui doivent être
       extraites. Le nombre de clés renvoyées doit être stocké dans
       <literal>*nkeys</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>bool consistent(bool check[], StrategyNumber n, Datum query)</term>
     <listitem>
      <para>
       Renvoie TRUE si la valeur indexée satisfait l'opérateur de la requête
       avec un numéro de stratégie <literal>n</literal> (ou pourrait satisfaire
       si l'opérateur est marqué RECHECK dans la classe d'opérateur).
       Le tableau <literal>check</literal> a la même longueur que le nombre de
       clés précédemment renvoyées par <function>extractQuery</function> pour
       cette requête. Chaque élément du tableau <literal>check</literal> est
       TRUE si la valeur indexée contient la clé correspondante de la requête,
       c'est-à-dire si check[i] == TRUE, la i-ième clé du tableau résultant
       d'<function>extractQuery</function> est présent dans la valeur indexée.
       Le datum original <literal>query</literal> (pas le tableau de la clé
       extraite&nbsp;!) est passé au cas où la méthode
       <function>consistent</function> a besoin de le consulter.
      </para>
     </listitem>
    </varlistentry>

  </variablelist>

</sect1>

<sect1 id="gin-implementation">
 <title>Implémentation</title>

 <para>
  En interne, un index <acronym>GIN</acronym> contient un index B-tree construit
  sur des clés, où chaque clé est un élément de la valeur indexé (un membre d'un
  tableau par exemple) et où chaque ligne d'une page enfant est soit un pointeur
  vers un B-tree sur des pointeurs heap (PT, posting tree) soit une liste de
  pointeurs heap (PL, posting list) si la liste est suffisamment petite.
 </para>

</sect1>

<sect1 id="gin-tips">
<title>Conseils et astuces sur GIN</title>

 <variablelist>
  <varlistentry>
   <term>Create vs insert</term>
   <listitem>
	<para>
	 Dans la plupart des cas, l'insertion dans un index <acronym>GIN</acronym>
	 est lent à cause de la probabilité d'insertion de nombreuses clés pour
	 chaque valeur. Donc, en cas de nombreuses insertions dans une table, il
	 est conseillé de supprimer l'index GIN et de le re-créer après
	 l'opération d'insertion.
	</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><xref linkend="guc-gin-fuzzy-search-limit"/></term>
   <listitem>
	<para>
	 La raison principale qui a poussé le développement des index
	 <acronym>GIN</acronym> a été la création du support des recherches de texte
	 complet dans <productname>PostgreSQL</productname> et il arrive
	 fréquemment qu'une recherche renvoie un gros ensemble de résultats.
	 De plus, ceci arrive souvent quand la requête contient des mots très
	 fréquents, de telle façon qu'un gros ensemble de résultats n'est même pas
	 utile. La lecture des lignes du disque et leur tri prend beaucoup de temps,
	 ce qui est une situation inacceptable en production. (Notez que la
	 recherche dans l'index est en soi très rapide.)
	</para>
	<para>
	 Pour faciliter l'exécution contrôlée de telles requêtes,
	 <acronym>GIN</acronym> a une limite supérieure souple configurable sur la
	 taille de l'ensemble renvoyée, le paramètre de configuration
	 <varname>gin_fuzzy_search_limit</varname>. Par défaut, il est configuré à
	 0 (c'est-à-dire sans limite). Si une limite différente de 0 est renvoyée,
	 alors l'ensemble renvoyé est un sous-ensemble du résultat complet, choisi
	 au hasard.
	</para>
	<para>
	 <quote>Douce</quote> (<foreignphrase>Soft</foreignphrase>) signifie
	 que le nombre réel des résultats renvoyés pourrait être légèrement
	 différent de la limite spécifiée, suivant la requête et la qualité du
	 générateur de nombres aléatoires du système.
	</para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="gin-limit">
 <title>Limitations</title>

 <para>
  <acronym>GIN</acronym> n'a pas de support du parcours d'index complets&nbsp;:
  comme il y a souvent de nombreuses clés par valeur, chaque pointeur de pile
  serait renvoyé plusieurs fois et il n'existe pas de moyen simple d'empêcher
  cela.
 </para>

 <para>
  Quand <function>extractQuery</function> ne renvoit aucune clé,
  <acronym>GIN</acronym> émettra une erreur. Suivant l'opérateur, une requête
  vide pourrait correspondre à toute ou aucune des valeurs indexées (par
  exemple, chaque tableau contient le tableau vide mais ne surcharge pas le
  tableau vide) et <acronym>GIN</acronym> ne peut pas déterminer la bonne
  réponse ou produire un résultat de parcours d'un index complet s'il pouvait
  déterminer si c'était correct.
 </para>

 <para>
  Ne renvoyer aucune clé n'est pas une erreur de <function>extractValue</function> mais
  dans ce cas, la valeur indexée ne sera pas représentée dans l'index. C'est une
  autre raison pour laquelle le parcours d'index complet n'est pas utile &mdash;
  il manquerait ce type de lignes.
 </para>

 <para>
  <acronym>GIN</acronym> recherche les clés par une égalité seule. Ceci pourra
  être amélioré dans le futur.
 </para>
</sect1>

<sect1 id="gin-examples">
 <title>Exemples</title>

 <para>
  La distribution des sources de <productname>PostgreSQL</productname> inclut
  des classes <acronym>GIN</acronym> pour les tableaux à une dimension de tous
  les types internes. Les modules <filename>contrib</filename> suivants
  contiennent aussi des classes d'opérateurs <acronym>GIN</acronym>&nbsp;:
 </para>
 
 <variablelist>
  <varlistentry>
   <term>intarray</term>
   <listitem>
    <para>Support amélioré pour int4[]</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>tsearch2</term>
   <listitem>
    <para>Support pour l'indexage inversé de texte. Ceci est bien plus rapide
     pour les ensembles de gros documents principalement statiques.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</sect1>

</chapter>
