<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $PostgreSQL: pgsql/doc/src/sgml/gin.sgml,v 2.4 2006/09/18 12:11:36 teodor Exp $ -->

<chapter id="GIN">
<title>Index GIN</title>

   <indexterm>
    <primary>index</primary>
    <secondary>GIN</secondary>
   </indexterm>

<sect1 id="gin-intro">
 <title>Introduction</title>

 <para>
   <acronym>GIN</acronym> est l'acronyme de <foreignphrase>Generalized Inverted
   Index</foreignphrase>. C'est une structure d'index stockant des ensembles de
   paires (clé, liste de lignes) où le terme <quote>liste de lignes</quote>
   est un ensemble de lignes dans lesquelles la clé est valable. Chaque ligne
   peut contenir plusieurs clés.
 </para>

 <para>
   Il est généralisé dans le sens qu'un index <acronym>GIN</acronym> n'a pas
   besoin de connaître l'opération qu'il accélère. À la place, il utilise
   les stratégies personnalisées définies pour des types de données particuliers.
 </para>

 <para>
  Un avantage de <acronym>GIN</acronym> est qu'il autorise le développement
  de types de données personnalisés avec des méthodes d'accès appropriées par
  un expert dans le domaine du type de données, plutôt que par un expert des
  bases de données. L'utilisation de <acronym>GiST</acronym> fournit le
  même avantage.
 </para>

  <para>
   L'implémentation de <acronym>GIN</acronym> dans
   <productname>PostgreSQL</productname> est principalement l'oeuvre de
   Teodor Sigaev et Oleg Bartunov. Plus d'informations sont disponibles
   sur leur <ulink url="http://www.sai.msu.su/~megera/oddmuse/index.cgi/Gin">site
   web</ulink>.
  </para>

</sect1>

<sect1 id="gin-extensibility">
 <title>Extensibilité</title>

 <para>
   L'interface <acronym>GIN</acronym> a un haut niveau d'abstraction, nécessitant
   à la personne implémentant la méthode d'accès d'implémenter seulement les
   sémantiques du type de données en cours d'accès. La couche 
   <acronym>GIN</acronym> elle-même s'occupe de la concurrence, des traces
   et des recherches dans la structure de l'arbre.
 </para>

 <para>
   Ce qui est nécessaire pour qu'une méthode d'accès <acronym>GIN</acronym>
   fonctionne est d'implémenter quatre méthodes définies par l'utilisateur,
   méthodes qui définissent le comportement des clés dans l'arbre. En bref,
   <acronym>GIN</acronym> combine l'extensibilité avec la généralité, la
   réutilisation de code et une interface propre.
 </para>

</sect1>

<sect1 id="gin-implementation">
 <title>Implémentation</title>

 <para>
  En interne, <acronym>GIN</acronym> consiste en un index B-tree construit sur
  des clés, où chaque clé est un élement d'une valeur indexée (élément d'un
  tableau par exemple) et où chaque ligne d'une page enfant est soit un
  pointeur vers un B-tree sur des pointeurs de l'en-tête (PT, arbre de lignes)
  soit une liste de pointeurs d'en-tête (PL, liste de lignes) si la ligne est
  suffisamment petite.
 </para>

 <para>
   Il existe quatre méthodes qu'une classe d'opérateur de l'index
   <acronym>GIN</acronym> doit fournir (les prototypes sont en pseudocode)&nbsp;:
 </para>

 <variablelist>
    <varlistentry>
     <term>int compare( Datum a, Datum b )</term>
     <listitem>
      <para>
	   Compare les clés (valeurs non indexées&nbsp;!) et renvoie un entier
	   plus ptit que zéro, zéro ou plus grand que zéro, indiquant que la
	   première clé est plus petite, égale à, plus grande que la seconde.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Datum* extractValue(Datum inputValue, uint32 *nkeys)</term>
     <listitem>
      <para>
	   Renvoie un tableau de clés de valeurs à indexer, nkeys devrait contenir
	   le nombre de clés renvoyées.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Datum* extractQuery(Datum query, uint32 nkeys, 
		StrategyNumber n)</term>
     <listitem>
      <para>
	   Renvoie un tableau de clés de la requête à exécuter. n contient le
	   numéro de stratégie de l'opération (voir <xref linkend="xindex-strategies"/>).
	   Suivant n, la requête pourrait être d'un type différent.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>bool consistent( bool check[], StrategyNumber n, Datum query)</term>
     <listitem>
      <para>
	   Renvoie TRUE si la valeur indexée satisfait le qualifiant de la requête
	   avec une stratégie n (ou pourrait satisfaire dans le cas d'une marque
	   RECHECK dans la classe d'opérateur). Chaque élément d'un tableau de
	   vérification est TRUE si la valeur indexée a une clé correspondante
	   dans la requête : si (check[i] == TRUE ) le i-ème clé de la requête
	   est présente dans la valeur indexée.
      </para>
     </listitem>
    </varlistentry>

  </variablelist>

</sect1>

<sect1 id="gin-tips">
<title>Conseils et astuces sur GIN</title>

 <variablelist>
  <varlistentry>
   <term>Create vs insert</term>
   <listitem>
	<para>
	 Dans la plupart des cas, l'insertion dans un index <acronym>GIN</acronym>
	 est lent à cause de la probabilité d'insertion de nombreuses clés pour
	 chaque valeur. Donc, en cas de nombreuses insertions dans une table, il
	 est conseillé de supprimer l'index GIN et de le re-créer après
	 l'opération d'insertion.
	</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>gin_fuzzy_search_limit</term>
   <listitem>
	<para>
	 La raison principale qui a poussé le développement des index
	 <acronym>GIN</acronym> était le support des recherches de texte
	 complet dans <productname>PostgreSQL</productname> et il arrive
	 fréquemment qu'une recherche renvoie un gros ensemble de résultats.
	 La lecture des lignes du disque et leur tri prend beaucoup de temps,
	 ce qui est une situation inacceptable en production. (Notez que la
	 recherche dans l'index est en soi très rapide.)
    </para>
	<para>
	 De telles requêtes contiennent habituellement des mots très fréquents,
	 donc les résultats ne sont pas très utiles. Pour faciliter l'exécution
	 de telles requêtes, <acronym>GIN</acronym> a une limite douce supérieure
	 configurable pour la taille de l'ensemble renvoyé. Elle est déterminée
	 par la variable GUC <varname>gin_fuzzy_search_limit</varname>. Elle vaut
	 0 par défaut (aucune limite).
	</para>
	<para>
	 Si une limite de recherche différente de zéro est configurée, alors
	 l'ensemble renvoyée est un sous-ensemble de l'ensemble complet des
	 résultats, choisi au hasard.
	</para>
	<para>
	 <quote>Douce</quote> signifie que le nombre réel des résultats renvoyés
	 pourrait être légèrement différent de la limite spécifiée, suivant la
	 requête et la qualité du générateur de nombres aléatoires du système.
	</para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="gin-limit">
 <title>Limitations</title>

 <para>
  <acronym>GIN</acronym> ne supporte pas les parcours d'index complets à cause
  de leur inefficacité extrême&nbsp;: comme il existe souvent de nombreuses clés
  pour une valeur, chaque pointeur d'en-tête sera renvoyé plusieurs fois.
 </para>

 <para>
  Quand extractQuery ne renvoit aucune clé, <acronym>GIN</acronym> rapportera
  une erreur&nbsp;: pour différentes classes d'opérateurs et stratégies, la
  signification sémantique d'une requête vide pourrait être différente (par
  exemple, tout tableau contient un tableau vide mais il n'y a pas croisement
  avec le tableau vide). <acronym>GIN</acronym> ne peut pas proposer une
  réponse raisonnable.
 </para>

 <para>
  <acronym>GIN</acronym> recherche les clés par une égalité seule. Ceci pourra
  être amélioré dans le futur.
 </para>
</sect1>

<sect1 id="gin-examples">
 <title>Exemples</title>

 <para>
  La distribution des sources de <productname>PostgreSQL</productname> inclut
  des classes <acronym>GIN</acronym> pour les tableaux à une dimension de tous
  les types internes. Les modules <filename>contrib</filename> suivants
  contiennent aussi des classes d'opérateurs <acronym>GIN</acronym>&nbsp;:
 </para>
 
 <variablelist>
  <varlistentry>
   <term>intarray</term>
   <listitem>
    <para>Support amélioré pour int4[]</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>tsearch2</term>
   <listitem>
    <para>Support pour l'indexage inversé de texte. Ceci est bien plus rapide
     pour les ensembles de gros documents principalement statiques.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</sect1>

</chapter>
