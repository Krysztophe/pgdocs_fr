<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/information_schema.sgml,v 1.12 2005/09/22 18:34:41 guillaume Exp $ -->

<chapter id="information-schema">
 <title>Schéma d'informations</title>

 <indexterm zone="information-schema">
  <primary>schéma d'informations</primary>
 </indexterm>

 <para>
  Le schéma d'informations consiste en un ensemble de vues contenant des
  informations sur les objets définis dans la base de données actuelle. Le
  schéma d'informations est défini dans le standard SQL et, du coup, est
  supposé portable et stable &mdash; contrairement aux catalogues système qui
  sont spécifiques à <productname>PostgreSQL</productname> et modelés suivant
  l'implémentation. Néanmoins, les vues du schéma d'informations ne contiennent
  pas d'information sur les fonctionnalités spécifiques à
  <productname>PostgreSQL</productname>&nbsp;; pour cela, vous devez travailler
  avec les catalogues système ou d'autres vues spécifiques à
  <productname>PostgreSQL</productname>.
 </para>

 <sect1 id="infoschema-schema">
  <title>Le schéma</title>

  <para>
   Le schéma d'informations est lui-même un schéma nommé 
   <literal>information_schema</literal>. Ce schéma existe automatiquement dans
   toutes les bases de données. Le propriétaire de ce schéma est le propriétaire
   initial de la base de données du cluster et cet utilisateur a naturellement
   tous les droits sur ce schéma, incluant la possibilité de le supprimer
   (mais l'espace gagné ainsi sera minuscule).
  </para>

  <para>
   Par défaut, le schéma d'informations n'est pas dans le chemin de recherche
   des schémas, donc vous avez besoin d'accéder à tous les objets qu'il contient
   via des noms qualifiés. Comme les noms de certains des objets du schéma
   d'information sont des noms génériques pouvant survenir dans les applications
   utilisateur, vous devez faire attention si vous placez le schéma
d'information dans le chemin.
  </para>
 </sect1>

 <sect1 id="infoschema-datatypes">
  <title>Types de données</title>

  <para>
   Les colonnes des vues du schéma d'informations utilisent des types de 
   données spéciaux, définis dans le schéma d'informations. Ils sont définis
   comme des domaines simples sur des types internes. Vous ne devriez pas
   utiliser ces types en dehors du schéma d'informations mais vos applications
   doivent y être préparées si elles font des sélections à partir du schéma
   d'informations.
  </para>

  <para>
   Ces types sont&nbsp;:

   <variablelist>
    <varlistentry>
     <term><type>cardinal_number</type></term>
     <listitem>
      <para>
       Un entier non négatif.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>character_data</type></term>
     <listitem>
      <para>
       Une chaîne de caractères (sans longueur maximum spécifiée).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>sql_identifier</type></term>
     <listitem>
      <para>
       Une chaîne de caractères. Elle est utilisée pour les identifiants SQL,
       le type de données <type>character_data</type> est utilisé pour tout
       autre type de données texte.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>time_stamp</type></term>
     <listitem>
      <para>
       Un domaine au-dessus du type <type>timestamp with time zone</type>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Chaque colonne du schéma d'informations a un des ces quatre types.
  </para>

  <para>
   Les données booléenne (true/false) sont représentées dans le schéma
   d'informations par une colonne de type <type>character_data</type> contenant
   soit <literal>YES</literal> soit <literal>NO</literal> (le schéma
   d'informations a été inventé par le standard SQL, du coup cette convention
   est nécessaire pour conserver la compatibilité du moteur du schéma
   d'informations).
  </para>
 </sect1>

 <sect1 id="infoschema-information-schema-catalog-name">
  <title><literal>information_schema_catalog_name</literal></title>

  <para>
   <literal>information_schema_catalog_name</literal> est une table qui
   contient en permanence une ligne et une colonne contenant le nom de la base
   de données actuelle (catalogue courant dans la terminologie SQL).
  </para>

  <table>
   <title>Colonnes de <literal>information_schema_catalog_name</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant ce schéma
        d'informations</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-administrable-role-authorizations">
  <title><literal>administrable_role_authorizations</literal></title>

  <para>
   La vue <literal>administrable_role_authorizations</literal>
   identifie tous les rôles pour lesquelles l'utilisateur courant l'option
   ADMIN.
  </para>

  <table>
   <title>Colonnes de <literal>administrable_role_authorizations</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du rôle pour lequel cette appartenance de rôle a été donnée
       (pourrait être l'utilisateur courant ou un rôle différent dans le cas
       d'appartenances de rôles imbriquées).
      </entry>
     </row>

     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'un rôle</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>YES</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-applicable-roles">
  <title><literal>applicable_roles</literal></title>

  <para>
   La vue <literal>applicable_roles</literal> identifie tous les rôles dont
   l'utilisateur actuel peut utiliser les droits. Cela signifie qu'il y a
   certaines chaînes de donnation des droits de l'utilisateur courant au
   rôle en question. L'utilisateur lui-même est un rôle applicable.
   L'ensemble de rôles applicables est habituellement utilisé pour la
   vérification des droits.
   <indexterm><primary>applicable role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>applicable</secondary></indexterm>
  </para>

  <table>
   <title>Colonnes de <literal>applicable_roles</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.0*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.4*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du rôle pour qui cette appartenance a été donnée (pourrait être
       l'utilisateur en cours ou un rôle différent dans le cas de rôles
       imbriquées)
      </entry>
     </row>

     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'un rôle</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si le bénéficiaire a l'option ADMIN sur le rôle,
       <literal>NO</literal> dans le cas contraire
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-attributes">
  <title><literal>attributes</literal></title>

  <para>
   La vue <literal>attributes</literal> contient des informations sur les
   attributs des types de données composites définis dans la base.
   (Notez que la vue ne donne pas d'informations sur les colonnes de table,
   qui sont quelque fois appelées attributs dans le contexte de PostgreSQL.)
  </para>

  <table>
   <title>Colonnes de <literal>attributes</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base contenant le type de données (toujours la base en
       cours)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le type de données</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type de données</entry>
     </row>

     <row>
      <entry><literal>attribute_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'attribut</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Position de l'attribut dans le type de données (le décompte commence
       à 1)</entry>
     </row>

     <row>
      <entry><literal>attribute_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Expression par défaut de l'attribut</entry>
     </row>

     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si l'attribut peut être NULL,
       <literal>NO</literal> dans le cas contraire.
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données de l'attribut s'il s'agit d'un type interne ou
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir
       la vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié
       dans <literal>attribute_udt_name</literal> et les colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un caractère ou une chaîne
       de bits, la longueur maximum déclarée&nbsp;; NULL pour tous les autres
       types de données ou si aucune longueur maximum n'a été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type caractère,
       la longueur maximum en octets (bytes) d'un datum (ceci ne
       devrait pas intéresser les utilisateurs de
       <productname>PostgreSQL</productname>)&nbsp;; NULL pour tous les autres
       types.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette colonne
       contient la précision (déclarée ou implicite) du type pour cet attribut.
       La précision indique le nombre de chiffres significatifs. Elle peut être
       exprimée en décimal (base 10) ou en binaire (base 2) comme le précise la
       colonne <literal>numeric_precision_radix</literal>. Pour tous les autres
       types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette colonne
       indique la base d'expression des colonnes <literal>numeric_precision</literal>
       et <literal>numeric_scale</literal>. La valeur est soit 2 soit 10. Pour
       tous les autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique exact,
       cette colonne contient l'échelle (déclarée ou implicite) du type pour cet
       attribut. L'échelle indique le nombre de chiffres significatifs à droite
       du point décimal. Elle peut être exprimée en décimal (base 10) ou en
       binaire (base 2) comme le précise la colonne
       <literal>numeric_precision_radix</literal>. Pour tous les autres types
       de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie une date, heure ou un interval,
       la précision déclarée&nbsp;; NULL pour tous les autres types de données
       et pour ceux dont la précision n'est pas déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implémentée</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implémentée</entry>
     </row>

     <row>
      <entry><literal>attribute_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base où le type de données de l'attribut est défini (toujours
       la base en cours)
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma où le type de données de l'attribut est défini
      </entry>
     </row>

     <row>
      <entry><literal>attribute_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données de l'attribut
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux ont toujours une cardinalité maximale
       dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur du type de données de la colonne, unique
       parmi les descripteurs de types de données de la table. Ceci est
       principalement utile pour des jointures avec d'autres instances de tels
       identifiants. (Le format spécifique de l'identifiant n'est pas défini
       et il n'est pas garanti qu'il reste identique dans les versions futures.)
      </entry>
     </row>

     <row>
      <entry><literal>is_derived_reference_attribute</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Voir aussi dans <xref linkend="infoschema-columns"/>, une vue structurée de
   façon similaire, pour plus d'informations sur certaines des colonnes.
  </para>
 </sect1>

 <sect1 id="infoschema-check-constraint-routine-usage">
  <title><literal>check_constraint_routine_usage</literal></title>

  <para>
   La vue <literal>check_constraint_routine_usage</literal> identifie les
   routines (fonctions et procédures) utilisées par une contrainte de
   vérification. Seules sont montrées les routines qui appartiennent au rôle
   actuellement activé.
  </para>

  <table>
   <title>Colonnes de <literal>check_constraint_routine_usage</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base contenant la contrainte (toujours la base en cours)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base contenant la fonction (toujours la base en cours)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraints">
  <title><literal>check_constraints</literal></title>

  <para>
   La vue <literal>check_constraints</literal> contient toutes les contraintes
   de vérification définies soit sur une table soit sur un domaine, possédées
   par un rôle actuellement activé (le propriétaire d'une table ou d'un domaine est
   le propriétaire de la contrainte).
  </para>

  <table>
   <title>Colonnes de <literal>check_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la base
        de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>check_clause</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>L'expression de vérification de la contrainte</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-domain-usage">
  <title><literal>column_domain_usage</literal></title>

  <para>
   La vue <literal>column_domain_usage</literal> identifie toutes les colonnes
   (d'une table ou d'une vue) utilisant un domaine défini dans la base de
   données courante et possédé par un rôle actuellement activé.
  </para>

  <table>
   <title>Colonnes de <literal>column_domain_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours la base de
        données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
        données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-privileges">
  <title><literal>column_privileges</literal></title>

  <para>
   La vue <literal>column_privileges</literal> identifie tous les droits
   octroyés sur les colonnes à un rôle actuellement activé ou par un rôle
   actuellement activé. Il existe une ligne pour chaque combinaison de colonne,
   de personne donnant des droits et de personne recevant des droits.
  </para>

  <para>
   Dans <productname>PostgreSQL</productname>, vous pouvez seulement donner des
   droits sur des tables entières, pas sur des colonnes individuelles. Du
   coup, la vue contient les mêmes informations que
   <literal>table_privileges</literal> avec une représentation d'une ligne
   pour chaque colonne dans chaque table appropriée mais cela couvre seulement
   les types droits où la granularité des colonnes est possible&nbsp;:
   <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal>, <literal>REFERENCES</literal>. Si vous souhaitez
que vos applications puissent remplir les développements futurs possibles, le bon choix
est d'utiliser cette vue en tant que <literal>table_privileges</literal> si un des
types droit est concerné.
  </para>

  <table>
   <title>Colonnes de <literal>column_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle ayant donné ce droit</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle auxquels les droits reviendront</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table ayant les colonnes 
      (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table et les colonnes</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table contenant la colonne</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de droit&nbsp;: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal> ou
       <literal>REFERENCES</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être accordé,
<literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-column-udt-usage">
  <title><literal>column_udt_usage</literal></title>

  <para>
   La vue <literal>column_udt_usage</literal> identifie toutes les colonnes
   utilisant les types de données dont un rôle actuellement activé est propriétaire.
   Notez que, dans <productname>PostgreSQL</productname>, les types de données
   internes se comportent comme des types définis par l'utilisateur, donc
   ils sont aussi inclus ici. Voir aussi la <xref linkend="infoschema-columns"/>
   pour plus de détails.
  </para>

  <table>
   <title>Colonnes de <literal>column_udt_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données où le type de donnée de la colonne (le type
       sous-jacent du domaine, si applicable) est défini (toujours la base de
       données courante)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma où le type de donnée de la colonne (le type
       sous-jacent du domaine, si applicable) est défini
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données de la colonne (le type sous-jacent du domaine,
       si applicable)
      </entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-columns">
  <title><literal>columns</literal></title>

  <para>
   La vue <literal>columns</literal> contient des informations sur toutes les
   colonnes de table (et colonnes de vue) de la base de données. Les colonnes
   système (<literal>oid</literal>, etc.) ne sont pas inclus. Seules les colonnes,
   auxquelles l'utilisateur a accès, sont affichées (qu'il soit le propriétaire
   ou qu'il ait quelques droits).
  </para>

  <table>
   <title>Colonnes de <literal>columns</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Position de la colonne dans la table (la numérotation commençant à
       1)</entry>
     </row>

     <row>
      <entry><literal>column_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Expression par défaut de la colonne</entry>
     </row>

     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si la colonne peut contenir des valeurs NULL,
       <literal>NO</literal> dans le cas contraire. Une contrainte not NULL est
       une façon pour obtenir qu'une colonne soit connue comme ne pouvant pas
       contenir de valeurs NULL mais il en existe d'autres.
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type de données de la colonne, s'il s'agit d'un type interne ou d'un
       tableau (<literal>ARRAY</literal>) (dans ce cas, voir la vue
       <literal>element_types</literal>) sinon défini par l'utilisateur
       (<literal>USER-DEFINED</literal>) (dans ce cas, le type est identifié
       dans <literal>udt_name</literal> et dispose des colonnes associés). Si la
       colonne est basée sur un domaine, cette colonne est une référence au type
       sous-jacent du domaine (et le domaine est identifié dans
       <literal>domain_name</literal> et dispose des colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un caractère ou un type de
       chaîne de bits, la longueur maximum déclarée&nbsp;; NULL pour tous les
       autres types de données ou si aucune longueur maximum n'a été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type caractère, la longueur
       maximum en octets (bytes) d'un datum (ceci ne devrait pas concerner les
       utilisateurs <productname>PostgreSQL</productname>)&nbsp;; NULL pour les
       autres types de données.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette
       colonne contient la précision (déclarée ou implicite) du type pour cette
       colonne. Cette précision indique le nombre de chiffres significatifs.
       Elle pourrait être exprimée en décimal (base 10) ou en binaire (base 2)
       comme indiqué dans la colonne
       <literal>numeric_precision_radix</literal>. Pour tous les autres types de
       données, la colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numérique, cette
       colonne indique dans quel base les valeurs des colonnes
       <literal>numeric_precision</literal> et      
       <literal>numeric_scale</literal> sont exprimées. La valeur est soit 2
       soit 10. Pour tous les autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie un type numeric exactement,
       cette colonne contient l'échelle (déclarée ou implicite) du type de cette
       colonne. L'échelle indique le nombre de chiffres significatifs à la
       droite du point décimal. Elle pourrait être exprimée en décimal (base 10)
       ou en binaire (base 2), comme indiqué dans la colonne
       <literal>numeric_precision_radix</literal>. Pour tous les autres types de
       données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si <literal>data_type</literal> identifie une date, une heure ou un type
       interval, la précision déclarée&nbsp;; NULL pour tous les autres types
       de données ou si aucune précision n'a été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implémenté</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implémenté</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Si la colonne a un type domain, le nom de la base de données où le type
       est défini (toujours la base de données courante), sinon NULL.
      </entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Si la colonne a un type domain, le nom du schéma où le domaine est
       défini, sinon NULL.
      </entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Si la colonne a un type de domaine, le nom du domaine, sinon
       NULL.</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données où le type de données de la colonne (le type
       sous-jacent du domaine, si applicable) est défini (toujours la base de
       données courante)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma où le type de données de la colonne (le type sous-jacent
       du domaine, si applicable) est défini
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données de la colonne (le type sous-jacent du domaine,
       si applicable)
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux ont toujours une cardinalité 
       maximum illimitée avec <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur du type de données de la colonne, unique
       parmi les descripteurs de type de données contenu dans la table. Ceci 
       est principalement utile pour joindre d'autres instances de ces
       identifiants (le format spécifique de l'identifiant n'est ni défini ni
       assuré de rester identique dans les versions futures).
      </entry>
     </row>

     <row>
      <entry><literal>is_self_referencing</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_identity</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>identity_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>identity_start</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>identity_increment</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>identity_maximum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>identity_minimum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>identity_cycle</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>is_generated</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>generation_expression</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si la colonne est modifiable,
       <literal>NO</literal> dans le cas contraire (les colonnes des tables de
       base sont toujours modifiables, les colonnes des vues ne le sont pas
       nécessairement)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Comme les types de données peuvent être définis avec une grande variété de 
   moyens en SQL et comme <productname>PostgreSQL</productname> contient des
   moyens supplémentaires pour définir des types de données, leurs
   représentations dans le schéma d'information peut être assez complexe. La
   colonne <literal>data_type</literal> est supposée identifier le type de
   données interne sous-jacent de la colonne. Dans
   <productname>PostgreSQL</productname>, cela signifie que le type est défini
   dans le schéma du catalogue système <literal>pg_catalog</literal>. Cette
   colonne pourrait être utile si l'application peut correctement gérer les
   types internes (par exemple, formater les types numériques différemment
   ou utiliser les données dans les colonnes de précisions). Les colonnes
   <literal>udt_name</literal>, <literal>udt_schema</literal> et
   <literal>udt_catalog</literal> identifient toujours le type de données
   sous-jacent de la colonne même si la colonne est basée sur un domaine (comme
   <productname>PostgreSQL</productname> traite les types internes comme des
   types définis par l'utilisateur, les types internes apparaissent aussi ici.
   Ceci est une extension du standard SQL). Ces colonnes devraient être
   utilisées si une application souhaite traiter les données différemment suivant
   le type car, dans ce cas, peu importe si la colonne est réellement basée sur
   un domaine. Si la colonne est basée sur un domaine, l'identité du domaine est
   stockée dans les colonnes <literal>domain_name</literal>,
   <literal>domain_schema</literal> et <literal>domain_catalog</literal>. Si
   vous souhaitez assembler les colonnes avec leur types de données associés et
   traiter les domaines comme des types séparés, vous pouvez écrire
   <literal>coalesce(domain_name, udt_name)</literal>, etc.
  </para>
 </sect1>

 <sect1 id="infoschema-constraint-column-usage">
  <title><literal>constraint_column_usage</literal></title>

  <para>
   La vue <literal>constraint_column_usage</literal> identifie toutes les
   colonnes de la base de données courante utilisées par des contraintes.
   Seules sont affichées les colonnes contenues dans une table possédée par
   un rôle actuellement activé. Pour une contrainte de vérification, cette vue
   identifie les colonnes utilisées dans l'expression de la vérification. Pour
   une contrainte de clé étrangère, cette vue identifie les colonnes que la clé
   étrangère référence. Pour une contrainte unique ou de clé primaire, cette vue
   identifie les colonnes contraintes.
  </para>

  <table>
   <title>Colonnes de <literal>constraint_column_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la table contenant la colonne
       utilisée par cette contrainte (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant la table contenant la colonne utilisée par
       cette contrainte
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table contenant la colonne utilisée par certaines contraintes
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la colonne utilisée par certaines contraintes
      </entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-constraint-table-usage">
  <title><literal>constraint_table_usage</literal></title>

  <para>
   La vue <literal>constraint_table_usage</literal> identifie toutes les
   tables de la base de données courante utilisées par des contraintes et
   possédées par un rôle actuellement activé (ceci est différent de la vue
   <literal>table_constraints</literal> qui identifie toutes les contraintes
   avec la table de leur définition). Pour une contrainte de clé étrangère,
   cette vue identifie la table que la clé étrangère référence. Pour une
   contrainte unique ou de clé primaire, cette vue identifie simplement la table
   à laquelle appartient la contrainte. Les contraintes de vérification et les
   contraintes non NULL ne sont pas inclus dans cette vue.
  </para>

  <table>
   <title>Colonnes de <literal>constraint_table_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la table utilisée par quelques
       contraintes (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant la table utilisée par quelques contraintes
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table utilisée par quelques contraintes</entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-data-type-privileges">
  <title><literal>data_type_privileges</literal></title>

  <para>
   La vue <literal>data_type_privileges</literal> identifie tous les
descripteurs de type de données auxquels l'utilisateur a accès parce qu'il en
est le propriétaire ou parce qu'il dispose de quelques droits sur le
descripteur. Un descripteur de type de données est généré quand un type de
données est utilisé dans la définition d'une colonne de table, d'un domaine ou
d'une fonction (en tant que paramètre ou que code de retour) et stocke quelques
informations sur la façon dont est utilisé le type de données (par exemple la
longueur maximum déclarée, si applicable). Chaque descripteur de type de
données se voit affecter un identifiant unique parmi les descripteurs de type de
données affectés à un objet (table, domaine, fonction). Cette vue n'est
probablement pas utile pour les applications mais est utilisée pour définir
d'autres vues dans le schéma d'informations.
  </para>

  <table>
   <title>Colonnes de <literal>data_type_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant l'objet décrit (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant l'objet décrit</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'objet décrit</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type d'objet décrit&nbsp;: fait partie de
       <literal>TABLE</literal> (le descripteur de type de données concerne une
       colonne de cette table), <literal>DOMAIN</literal> (le descripteur
       concerne ce domaine), <literal>ROUTINE</literal> (le descripteur est lié
       à un type de paramètre ou de code de retour de cette fonction).
      </entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       identifiant du descripteur de type de données, unique parmi les
       descripteurs de type de données pour le même objet.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-constraints">
  <title><literal>domain_constraints</literal></title>

  <para>
   La vue <literal>domain_constraints</literal> contient toutes les contraintes
   appartenant aux domaines définis dans la base courante.
  </para>

  <table>
   <title>Colonnes de <literal>domain_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si la contrainte est déferrable,
       <literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si la contrainte est déferrable et
       initialement déférrée, <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-udt-usage">
  <title><literal>domain_udt_usage</literal></title>

  <para>
   La vue <literal>domain_udt_usage</literal> identifie tous les domaines
   utilisant les types de données possédés par un rôle actuellement activé. Notez que,
   dans <productname>PostgreSQL</productname>, les types de données internes
   se comportent comme des types définis par l'utilisateur, donc ils sont aussi
   inclus ici.
  </para>

  <table>
   <title>Colonnes de <literal>domain_udt_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données où le type de données domaine est défini
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma où est défini le type de données domaine</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type de données domaine</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domains">
  <title><literal>domains</literal></title>

  <para>
   La vue <literal>domains</literal> contient tous les domaines définis dans la
   base de données courante.
  </para>

  <table>
   <title>Colonnes de <literal>domains</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le domaine (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le domaine</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du domaine</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données du domaine s'il s'agit d'un type interne, ou
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
       vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est
       identifié dans <literal>udt_name</literal> et comprend des colonnes
       associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type caractère ou chaîne de bits, la longueur
       maximale déclarée&nbsp;; NULL pour tous les autres types de données ou
       si aucune longueur maximale n'a été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type caractère, la longueur maximale en octets (bytes)
       d'un datum (ceci ne devrait pas concerner les utilisateurs
       <productname>PostgreSQL</productname>)&nbsp;; NULL pour tous les autres
       types.
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type numérique, cette colonne contient la précision
       (déclarée ou implicite) du type de cette colonne. Cette précision
       indique le nombre de chiffres significatifs. Elle peut être exprimée en
       décimal (base 10) ou en binaire (base 2), comme indiqué dans la colonne
       <literal>numeric_precision_radix</literal>. Pour les autres types de
       données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a un type numérique, cette colonne indique la base des
       valeurs des colonnes <literal>numeric_precision</literal> et
       <literal>numeric_scale</literal>. La valeur est soit 2 soit 10. Pour tous
       les autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a le type numeric, cette colonne contient l'échelle
       (déclarée ou implicite) du type pour cette colonne. L'échelle indique le
       nombre de chiffres significatifs à la droite du point décimal. Elle peut
       être exprimée en décimal (base 10) ou en binaire (base 2), comme indiqué
       dans la colonne <literal>numeric_precision_radix</literal>. Pour tous les
       autres types de données, cette colonne est NULL.
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Si le domaine a une date, heure ou un type intervalle, la précision
       déclarée&nbsp;; NULL pour les autres types de données ou si la précision
       n'a pas été déclarée.
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implémenté</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implémenté</entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Expression par défaut du domaine</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans laquelle est défini le type de
       données domaine (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma où le type de données domaine est défini</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du type de données domaine</entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux ont toujours une cardinalité 
       maximale illimitée dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur de type de données du domaine, unique
       parmi les descripteurs de type de données restant dans le domaine (ce qui
       est trivial car un domaine contient seulement un descripteur de type de
       données). Ceci est principalement utile pour joindre d'autres instances
       de tels identifiants (le format spécifique de l'identifiant n'est pas
       défini et il n'est pas garanti qu'il restera identique dans les versions
       futures).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-element-types">
  <title><literal>element_types</literal></title>

  <para>
   La vue <literal>element_types</literal> contient les descripteurs de type 
   de données des éléments de tableaux. Lorsqu'une colonne de table, domaine,
   paramètre de fonction ou code de retour de fonction est définie comme un
   type tableau, la vue respective du schéma d'informations contient seulement
   <literal>ARRAY</literal> dans la colonne <literal>data_type</literal>. Pour
   obtenir des informations sur le type d'élément du tableau, vous pouvez
   joindre la vue respective avec cette vue. Par exemple, pour afficher les
   colonnes d'une table avec les types de données et les types d'élément de
   tableau, si applicable. Vous pouvez faire
<programlisting>SELECT c.column_name, c.data_type, e.data_type AS element_type
FROM information_schema.columns c LEFT JOIN information_schema.element_types e
     ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE', c.dtd_identifier)
       = (e.object_catalog, e.object_schema, e.object_name, e.object_type, e.collection_type_identifier))
WHERE c.table_schema = '...' AND c.table_name = '...'
ORDER BY c.ordinal_position;
</programlisting>
   Cette vue inclut seulement les objets auxquels l'utilisateur courant a
   accès en étant le propriétaire ou en disposant de quelques droits.
  </para>

  <table>
   <title>Colonnes de <literal>element_types</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant l'objet qui utilise le tableau en
       cours de description (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant l'objet utilisant le tableau en cours de
       description
      </entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de l'objet utilisant le tableau en cours de description
      </entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type de l'objet utilisant le tableau en cours de description&nbsp;:
       il fait partie de <literal>TABLE</literal> (le tableau est utilisé par
       une colonne de cette table), <literal>DOMAIN</literal> (le tableau est
       utilisé par ce domaine), <literal>ROUTINE</literal> (le tableau est
       utilisé par un paramètre ou le type du code de retour de cette fonction).
      </entry>
     </row>

     <row>
      <entry><literal>collection_type_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       L'identifiant du descripteur de type de données du tableau en cours de
       description. Utilisez cette colonne en la joignant avec les
       colonnes <literal>dtd_identifier</literal> des autres vues du
       schéma d'informations.
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le type de données des éléments du tableau s'il s'agit d'un type
       interne, sinon <literal>USER-DEFINED</literal> (dans ce cas, le type est
       identifié comme <literal>udt_name</literal> et dispose des colonnes
       associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données d'éléments de tableau dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implémenté</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données pour lequel le type de données est défini
       (toujours dans la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma dans lequel sont définis les types de données des éléments
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données des éléments
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux ont une cardinalité maximum
       illimitée dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant pour le descripteur de type de données de l'élément.
       Ce n'est pas utile actuellement.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-enabled-roles">
  <title><literal>enabled_roles</literal></title>

  <para>
   La vue <literal>enabled_roles</literal> identifie les <quote>rôles
   actuellement activés</quote>. Les rôles activés sont définis
   récursivement comme l'utilisateur courant avec tous les rôles qui ont été
   donnés aux rôles activés avec l'héritage automatique. En d'autres termes,
   ce sont les rôles dont l'utilisateur courant est automatiquement membre,
   direct ou indirect.
   <indexterm><primary>enabled role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>enabled</secondary></indexterm>
  </para>

  <para>
   Pour la vérification des droits, l'ensemble des <quote>rôles applicables</quote>
   est appliqué, ce qui pourrait être plus important que l'ensemble des rôles
   activés. Donc, généralement, il est mieux d'utiliser la vue
   <literal>applicable_roles</literal> à la place de celles-ci&nbsp;; voir aussi
   ici.
  </para>

  <table>
   <title>Colonnes de <literal>enabled_roles</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom d'un rôle</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-key-column-usage">
  <title><literal>key_column_usage</literal></title>

  <para>
   La vue <literal>key_column_usage</literal> identifie toutes les colonnes de
   la base de données courante restreintes par une contrainte unique, clé primaire
   ou clé étrangère. Les contraintes de vérification ne sont pas inclues dans
   cette vue. Seules sont affichées les colonnes auxquelles l'utilisateur a accès,
   soit parce qu'il est le propriétaire de la table ou parce qu'il dispose de
   droits.
  </para>

  <table>
   <title>Colonnes de <literal>key_column_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la colonne restreinte par la
       contrainte (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant la table qui contient la colonne restreinte par
       la contrainte
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table contenant la colonne restreinte par la contrainte
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la colonne restreinte par une contrainte
      </entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Position ordinal de la colonne dans la clé de contrainte (la numérotation
       commence à 1)
      </entry>
     </row>

     <row>
      <entry><literal>position_in_unique_constraint</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Pour une contrainte de type clé étrangère, la position ordinale de la
       colonne référencée dans sa contrainte unique (le compteur commence à
       1)&nbsp;; sinon null
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-parameters">
  <title><literal>parameters</literal></title>

  <para>
   La vue <literal>parameters</literal> contient des informations sur les
   paramètres (arguments) de toutes les fonctions de la base de données
   courante. Seules sont affichées les fonctions auxquelles l'utilisateur
   courant a accès (soit en étant le propriétaire soit en ayant quelques
   droits).
  </para>

  <table>
   <title>Colonnes de <literal>parameters</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la fonction (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Position ordinale du paramètre dans la liste des arguments de la fonction
       (la numérotation commence à 1)
      </entry>
     </row>

     <row>
      <entry><literal>parameter_mode</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>IN</literal> pour les paramètres en entrée,
       <literal>OUT</literal> pour les paramètres en sortie ou
       <literal>INOUT</literal> pour les paramètres en entrée/sortie.
      </entry>
     </row>

     <row>
      <entry><literal>is_result</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>parameter_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du paramètre ou NULL si le paramètre n'a pas de nom</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données du paramètre s'il s'agit d'un type interne, ou
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
       vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié dans
       <literal>udt_name</literal> et dispose de colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données où est défini le paramètre (toujours la base
       de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma où est défini le type de données du paramètre
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données du paramètres
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux types
       de données dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur de type de données du paramètre, unique
       parmi les descripteurs de type de données restant dans la fonction. Ceci
       est principalement utile pour réaliser une jointure avec les autres
       instances de tels identifiants (le format spécifique de l'identifiant
       n'est pas défini et il n'est pas garanti qu'il reste identique dans les
       prochaines versions).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-referential-constraints">
  <title><literal>referential_constraints</literal></title>

  <para>
   La vue <literal>referential_constraints</literal> contient toutes les
   contraintes référentielles (clés étrangères) dans la base de données
   actuelle, appartenant à une table possédée par un rôle actuellement
   activé.
  </para>

  <table>
   <title>Colonnes de <literal>referential_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base de données contenant la contrainte
       (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>unique_constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Nom de la base de données contenant la contrainte unique ou de clé
       primaire que la contrainte de clé étrangère référence (toujours la base
       de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Nom du schéma contenant la contrainte unique ou de clé primaire que
       la contrainte de clé étrangère référence
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Nom de la contrainte unique ou de clé primaire que la contrainte de clé
       étrangère référence
      </entry>
     </row>

     <row>
      <entry><literal>match_option</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Correspond aux options de la contrainte de clé étrangère&nbsp;:
       <literal>FULL</literal>, <literal>PARTIAL</literal> ou
       <literal>NONE</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>update_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Règle de mise à jour de la contrainte de clé étrangère&nbsp;:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal> ou
       <literal>NO ACTION</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>delete_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Règle de suppression de la contrainte de clé étrangère&nbsp;:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal> ou
       <literal>NO ACTION</literal>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-column-grants">
  <title><literal>role_column_grants</literal></title>

  <para>
   La vue <literal>role_column_grants</literal> identifie tous les droits
   donnés sur les colonnes dont le donneur du droit ou le receveur de ce droit
   est un rôle actuellement activé. Plus d'informations sont disponibles avec
   <literal>column_privileges</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>role_column_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a donné le droit</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a reçu le droit</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table qui contient la
       colonne (toujours la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table qui contient la colonne</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table contenant la colonne</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de droit&nbsp;: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal> ou
       <literal>REFERENCES</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être accordé,
<literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-routine-grants">
  <title><literal>role_routine_grants</literal></title>

  <para>
   La vue <literal>role_routine_grants</literal> identifie tous les droits
   donnés sur des fonctions  dont le donneur du droit ou le receveur de ce droit
   est un rôle actuellement activé. Plus d'informations sont disponibles dans
   <literal>routine_privileges</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>role_routine_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a donné le droit</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a reçu le droit</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la fonction (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la fonction (pourrait être dupliqué en cas de
       surchargement)</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>EXECUTE</literal> (le seul type de droit des
       fonctions)</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être accordé,
       <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-table-grants">
  <title><literal>role_table_grants</literal></title>

  <para>
   La vue <literal>role_table_grants</literal> identifie tous les droits
   donnés sur des tables ou vues  dont le donneur du droit ou le receveur de ce droit
   est un rôle actuellement activé. Plus d'informations sont disponibles dans
   <literal>table_privileges</literal>.
  </para>

  <table>
   <title>Colonnes de <literal>role_table_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a donné le droit</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a reçu le droit</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de droit&nbsp;: <literal>SELECT</literal>,
       <literal>DELETE</literal>, <literal>INSERT</literal>,
       <literal>UPDATE</literal>, <literal>REFERENCES</literal>
       ou <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être accordé,
<literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-usage-grants">
  <title><literal>role_usage_grants</literal></title>

  <para>
   La vue <literal>role_usage_grants</literal> est utilisée pour identifier
   les droits d'<literal>USAGE</literal> donnés à différents types d'objets
   à un rôle actuellement activé ou par un rôle actuellement activé. Avec
   <productname>PostgreSQL</productname>, ceci s'applique seulement aux domaines
   et, comme les domaines n'ont pas de vrais droits dans
   <productname>PostgreSQL</productname>, cette vue est vide. Plus
   d'informations sont disponibles dans <literal>usage_privileges</literal>.
   Dans le futur, cette vue pourrait contenir plus d'informations utiles.
  </para>

  <table>
   <title>Colonnes de <literal>role_usage_grants</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Dans le futur, le nom du rôle qui a donné le droit</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Dans le futur, le nom du rôle qui a reçu le droit</entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant l'objet (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant l'objet</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'objet</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Dans le futur, le type de l'objet</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être accordé,
       <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-privileges">
  <title><literal>routine_privileges</literal></title>

  <para>
   La vue <literal>routine_privileges</literal> identifie tous les droits
   donnés aux fonctions d'un rôle actuellement activé ou par un rôle actuellement
   activé.
   Il existe une ligne pour chaque combinaison de fonctions, de donneur de
   droits et de receveur de droits.
  </para>

  <table>
   <title>Colonnes de <literal>routine_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a donné le droit</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle à qui a été donné le droit</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir la <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la fonction (pourrait être dupliqué en cas de
       surchargement)</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>EXECUTE</literal> (le seul type de droit pour
       les fonctions)</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être accordé,
       <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-routines">
  <title><literal>routines</literal></title>

  <para>
   La vue <literal>routines</literal> contient toutes les fonctions de la base
   de données courante. Seules sont affichées les fonctions auxquelles
   l'utilisateur courant a accès (soit parce qu'il en est le propriétaire, soit
   parce qu'il possède des droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>routines</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Ce nom identifie de
       façon unique la fonction dans le schéma, même si le nom réel de la
       fonction est surchargé. Le format du nom spécifique n'est pas défini, il
       devrait seulement être utilisé pour le comparer à d'autres instances de
       noms de routines spécifiques.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la fonction (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la fonction (pourrait être dupliqué en cas de
       surchargement)</entry>
     </row>

     <row>
      <entry><literal>routine_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours <literal>FUNCTION</literal> (dans le futur, il pourrait y avoir
       d'autres types de routines)
      </entry>
     </row>

     <row>
      <entry><literal>module_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>module_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>module_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données de retour de la fonction s'il est interne,
       <literal>ARRAY</literal> s'il s'agit d'un tableau (dans ce cas, voir la
       vue <literal>element_types</literal>), sinon
       <literal>USER-DEFINED</literal> (dans ce cas, le type est identifié
       dans <literal>type_udt_name</literal> et dispose de colonnes associées).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées avec <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées par <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées par <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées par <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées par <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       aux types de données renvoyées par <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées par <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL car cette information n'est pas appliquée aux
       types de données renvoyées par <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données où est défini le type de données en retour
       de la fonction (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma où est défini le type de données en retour
       de la fonction
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du type de données en retour de la fonction
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Toujours NULL car les tableaux ont une cardinalité maximum
       illimitée dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Un identifiant du descripteur de type de données du type de données en
       retour, unique parmi les descripteurs de type de données restant dans la
       fonction. Ceci est principalement utile pour la jointure avec d'autres
       instances de tels identifiants (le format spécifique de l'identifiant
       n'est pas défini et il n'est pas certain qu'il restera identique dans les
       versions futures).
      </entry>
     </row>

     <row>
      <entry><literal>routine_body</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction est une fonction SQL, alors
       <literal>SQL</literal>, sinon <literal>EXTERNAL</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>routine_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le texte source de la fonction (NULL si un rôle actuellement activé n'est pas
       le propriétaire de la fonction)... (suivant le standard SQL, cette colonne
       est seulement applicable si <literal>routine_body</literal> est
       <literal>SQL</literal> mais, avec <productname>PostgreSQL</productname>,
       il contiendra tout texte source qui a été spécifié à la création de la
       fonction).
      </entry>
     </row>

     <row>
      <entry><literal>external_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction est une fonction C, alors le nom externe (link
       symbol) de la fonction&nbsp;; sinon NULL (ceci fonctionne de telle
       façon qu'il s'agit de la même valeur montrée dans
       <literal>routine_definition</literal>).
      </entry>
     </row>

     <row>
      <entry><literal>external_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Le langage dans lequel est écrit la fonction</entry>
     </row>

     <row>
      <entry><literal>parameter_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours <literal>GENERAL</literal> (le standard SQL définit d'autres
       styles de paramètres qui ne sont pas disponibles avec
       <productname>PostgreSQL</productname>).
      </entry>
     </row>

     <row>
      <entry><literal>is_deterministic</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction est déclarée immutable (appelée déterministe dans le
       standard SQL), alors <literal>YES</literal>, sinon
       <literal>NO</literal> (vous ne pouvez pas connaître les autres
       niveaux de volatilité disponible dans <productname>PostgreSQL</productname> via le schéma
       d'informations).
      </entry>
     </row>

     <row>
      <entry><literal>sql_data_access</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours <literal>MODIFIES</literal> signifiant que la fonction peut
       modifier les données SQL. Cette information n'est pas utile pour
       <productname>PostgreSQL</productname>.
      </entry>
     </row>

     <row>
      <entry><literal>is_null_call</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction renvoie automatiquement NULL si un de ces arguments est
       NULL, alors <literal>YES</literal>, sinon <literal>NO</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>schema_level_routine</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours <literal>YES</literal> (l'opposé serait une méthode d'un type
       défini par l'utilisateur, fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>).
      </entry>
     </row>

     <row>
      <entry><literal>max_dynamic_result_sets</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_user_defined_cast</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_implicitly_invocable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>security_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la fonction est exécutée avec les droits de l'utilisateur courant,
       alors <literal>INVOKER</literal>. Si la fonction est exécutée avec les
       droits de l'utilisateur l'ayant défini, alors <literal>DEFINER</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>last_altered</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>new_savepoint_level</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>is_udt_dependent</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_from_data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_as_locator</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_max_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_octet_length</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_char_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_datetime_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>result_cast_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans <productname>PostgreSQL</productname></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-schemata">
  <title><literal>schemata</literal></title>

  <para>
   La vue <literal>schemata</literal> contient tous les schémas de la base de
   données courante dont un rôle actuellement activé est propriétaire.
  </para>

  <table>
   <title>Colonnes de <literal>schemata</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données dans lequel se trouve le schéma (toujours
       la base de données courante)</entry>
     </row>

     <row>
      <entry><literal>schema_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma</entry>
     </row>

     <row>
      <entry><literal>schema_owner</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du propriétaire du schéma</entry>
     </row>

     <row>
      <entry><literal>default_character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>default_character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>default_character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sequences">
  <title><literal>sequences</literal></title>

  <para>
   La vue <literal>sequences</literal> contient toutes les séquences définies
   dans la base en cours. Seules sont montrées les séquences auxquelles
   l'utilisateur a accès (soit parce qu'il en est le propriétaire soit
   parce qu'il a un droit).
  </para>

  <table>
   <title>Colonnes de <literal>sequences</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sequence_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base contenant la séquence (toujours la base en cours)</entry>
     </row>

     <row>
      <entry><literal>sequence_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la séquence</entry>
     </row>

     <row>
      <entry><literal>sequence_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la séquence</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de données de la séquence. Dans
       <productname>PostgreSQL</productname>, c'est toujours
       <literal>bigint</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Cette colonne contient la précision (déclarée ou implicite) du type de
       données de la séquence (voir ci-dessus). La précision indique le
       nombre de chiffres significatifs. Elle peut être exprimée en décimal
       (base 10) ou en binaire (base 2), suivant ce qui est indiqué dans la
       colonne <literal>numeric_precision_radix</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Cette colonne indique dans quelle base les valeurs de la colonne
       <literal>numeric_precision</literal> et <literal>numeric_scale</literal>
       sont exprimées. Ce sera soit 2 soit 10.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Cette colonne contient l'échelle (déclarée ou implicite) du type de
       données de la séquence (voir ci-dessus). L'échelle indique le nombre
       de chiffres significatifs à droite du point décimale. Elle peut être
       exprimée en décimal (base 10) ou en binaire (base 2), suivant ce qui
       est indiqué dans la
       colonne <literal>numeric_precision_radix</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>maximum_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Pas encore implémentée</entry>
     </row>

     <row>
      <entry><literal>minimum_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Pas encore implémentée</entry>
     </row>

     <row>
      <entry><literal>increment</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Pas encore implémentée</entry>
     </row>

     <row>
      <entry><literal>cycle_option</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Pas encore implémentée</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-features">
  <title><literal>sql_features</literal></title>

  <para>
   La table <literal>sql_features</literal> contient des informations sur les
   fonctionnalités formelles définies dans le standard SQL et supportées par
   <productname>PostgreSQL</productname>. Ce sont les mêmes informations que
   celles présentées dans l'<xref linkend="features"/>. Là, vous pouvez aussi
   trouver des informations de fond supplémentaires.
  </para>

  <table>
   <title>Colonnes de <literal>sql_features</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant de la fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de la fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>sub_feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant de la sous-fonctionnalité ou une chaîne de
       longueur NULL s'il ne s'agit pas d'une sous-fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>sub_feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de la sous-fonctionnalité ou une chaîne de
       longueur NULL s'il ne s'agit pas d'une sous-fonctionnalité</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si la fonctionnalité est complètement supportée
       par la version actuelle de <productname>PostgreSQL</productname>, <literal>NO</literal> sinon
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours NULL car le groupe de développement <productname>PostgreSQL</productname> ne réalise pas
       de tests formels sur la conformité des fonctionnalités
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un commentaire, si possible, sur le statut supporté de la
       fonctionnalité</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-implementation-info">
  <title><literal>sql_implementation_info</literal></title>

  <para>
   La table <literal>sql_inplementation_info</literal> contient des
   informations sur différents aspects qui sont laissés à la définition de 
   l'implémentation par le standard SQL. Cette information a pour but principal
   d'être utilisé dans le contexte de l'interface ODBC&nbsp;; les utilisateurs
   des autres interfaces trouveront certainement peu d'utilité à cette
   information. Pour cette raison, les éléments d'informations d'implémentation
   individuelle ne sont pas décrits ici&nbsp;; vous les trouverez dans la
   description de l'interface ODBC.
  </para>

  <table>
   <title>Colonnes de <literal>sql_implementation_info</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>implementation_info_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant de l'élément d'information
       d'implémentation</entry>
     </row>

     <row>
      <entry><literal>implementation_info_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de l'élément d'information
       d'implémentation</entry>
     </row>

     <row>
      <entry><literal>integer_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Valeur de l'élément d'information d'implémentation, ou NULL si la valeur
       est contenue dans la colonne <literal>character_value</literal>
      </entry>
     </row>

     <row>
      <entry><literal>character_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Valeur de l'élément d'information d'implémentation, ou NULL si la valeur
       est contenue dans la colonne
       <literal>integer_value</literal>
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un possible commentaire restant dans l'élément d'information
       d'implémentation</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-languages">
  <title><literal>sql_languages</literal></title>

  <para>
   La table <literal>sql_languages</literal> contient une ligne pour chaque
   langage lié SQL supporté par <productname>PostgreSQL</productname>.
   <productname>PostgreSQL</productname> supporte directement le SQL et le SQL
   intégré dans le C&nbsp;; c'est tout ce que vous apprendrez de cette table.
  </para>

  <table>
   <title>Colonnes de <literal>sql_languages</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.4*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.0*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sql_language_source</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le nom de la source de la définition du langage&nbsp;; toujours
       <literal>ISO 9075</literal>, c'est-à-dire le standard SQL
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_year</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       L'année de l'approbation du standard dans
       <literal>sql_language_source</literal>&nbsp;; actuellement
       <literal>2003</literal>
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_conformance</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le niveau de conformité au standard pour le langage. Pour ISO 9075:2003,
       c'est toujours <literal>CORE</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_integrity</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL (cette valeur n'a d'intérêt que pour les versions
       précédentes du standard SQL).</entry>
     </row>

     <row>
      <entry><literal>sql_language_implementation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours NULL</entry>
     </row>

     <row>
      <entry><literal>sql_language_binding_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le style de lien du langage, soit <literal>DIRECT</literal> soit
       <literal>EMBEDDED</literal>
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_programming_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Le langage de programmation si le style de lien est
       <literal>EMBEDDED</literal>, sinon NULL. <productname>PostgreSQL</productname> supporte uniquement
       le langage C.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-packages">
  <title><literal>sql_packages</literal></title>

  <para>
   La table <literal>sql_packages</literal> contient des informations sur les
   paquets de fonctionnalités définis dans le standard SQL et supportés par
   <productname>PostgreSQL</productname>. Référez-vous à l'<xref
   linkend="features"/> pour des informations d'arrière-plan sur les paquets de
   fonctionnalités.
  </para>

  <table>
   <title>Colonnes de <literal>sql_packages</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant du paquet</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif du paquet</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si le paquet est complètement supporté par la
       version actuelle, <literal>NO</literal> sinon
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours NULL car le groupe de développement de <productname>PostgreSQL</productname> ne réalise
       pas de tests formels pour la conformité des fonctionnalités
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un possible commentaire sur l'état supporté par le paquet</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-parts">
  <title><literal>sql_parts</literal></title>

  <para>
   La table <literal>sql_parts</literal> contient des informations sur les
   parties du standard SQL supportées par <productname>PostgreSQL</productname>.
  </para>

  <table>
   <title>Colonnes de <literal>sql_parts</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Une chaîne d'identification contenant le numéro de la partie</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de la partie</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si cette partie est complètement supportée par la
       version actuelle de <productname>PostgreSQL</productname>,
       <literal>NO</literal> dans le cas contraire
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Toujours NULL, car les développeurs <productname>PostgreSQL</productname>
       ne font pas de tests officiels sur la conformité des fonctionnalités
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Commentaires sur le statut supporté de la partie</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing">
  <title><literal>sql_sizing</literal></title>

  <para>
   La table <literal>sql_sizing</literal> contient des informations sur les
   différentes limites de tailles et valeurs maximales dans
   <productname>PostgreSQL</productname>. Cette information a pour but principal
   d'être utilisée dans le contexte de l'interface ODBC&nbsp;; les utilisateurs
   des autres interfaces trouveront probablement peu d'utilité à cette
   information. Pour cette raison, les éléments de taille individuelle ne sont
   pas décrits ici&nbsp;; vous les trouverez dans la description de l'interface
   ODBC.
  </para>

  <table>
   <title>Colonnes de <literal>sql_sizing</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Identifiant de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>supported_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Valeur de l'élément de taille, ou 0 si la taille est illimitée ou ne
       peut pas être déterminée, ou NULL si les fonctionnalités pour lesquelles
       l'élément de taille est applicable ne sont pas supportées
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un possible commentaire restant dans l'élément de taille</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing-profiles">
  <title><literal>sql_sizing_profiles</literal></title>

  <para>
   La table <literal>sql_sizing_profiles</literal> contient des informations
   sur les valeurs <literal>sql_sizing</literal> requises par plusieurs profiles
   du standard SQL. <productname>PostgreSQL</productname> ne garde pas trace des profiles SQL, donc la
   table est vide.
  </para>

  <table>
   <title>Colonnes de <literal>sql_sizing_profiles</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Identifiant de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Nom descriptif de l'élément de taille</entry>
     </row>

     <row>
      <entry><literal>profile_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Chaîne identifiant d'un profile</entry>
     </row>

     <row>
      <entry><literal>required_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       La valeur requise par le profile SQL pour l'élément de taille, ou 0 si
       le profile ne place aucune limite sur l'élément de taille, ou NULL si le
       profile ne requiert aucune fonctionnalité pour laquelle l'élément de
       style est applicable
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Un possible commentaire restant dans l'élément de taille 
       à l'intérieur du profile</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-constraints">
  <title><literal>table_constraints</literal></title>

  <para>
   La vue <literal>table_constraints</literal> contient toutes les contraintes
   appartenant aux tables possédées par l'utilisateur courant ou pour lesquelles
   l'utilisateur courant dispose de certains droits.
  </para>

  <table>
   <title>Colonnes de <literal>table_constraints</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la contrainte (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la contrainte</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la contrainte</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>constraint_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de contrainte&nbsp;: <literal>CHECK</literal>,
       <literal>FOREIGN KEY</literal>, <literal>PRIMARY KEY</literal>
       ou <literal>UNIQUE</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si la contrainte est déferrable,
       <literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si la contrainte est déferrable et
       initialement déférrée, <literal>NO</literal> sinon</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-privileges">
  <title><literal>table_privileges</literal></title>

  <para>
   La vue <literal>table_privileges</literal> identifie tous les droits donnés
   sur des tables ou vues d'un rôle actuellement activé ou par un rôle actuellement
   activé.
   Il y a une ligne pour chaque combinaison de table, de donneur de droits et de
   receveur de droits.
  </para>

  <table>
   <title>Colonnes de <literal>table_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle qui a donné le droit</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du rôle à qui le droit a été donné</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de droit&nbsp;: <literal>SELECT</literal>,
       <literal>DELETE</literal>, <literal>INSERT</literal>,
       <literal>UPDATE</literal>, <literal>REFERENCES</literal>
       ou <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> si le droit peut être accordé,
       <literal>NO</literal> sinon</entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-tables">
  <title><literal>tables</literal></title>

  <para>
   La vue <literal>tables</literal> contient toutes les tables et vues définies
dans la base de données courantes. Seules sont affichées les tables et vues
auxquelles l'utilisateur courant a accès (soit parce qu'il en est le
propriétaire soit parce qu'il possède certains droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>tables</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la table (toujours la base de
       données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table</entry>
     </row>

     <row>
      <entry><literal>table_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type de table&nbsp;: <literal>BASE TABLE</literal> pour une table de
       base persistante (le type de table normal), <literal>VIEW</literal> pour
       une vue ou <literal>LOCAL TEMPORARY</literal> pour une table temporaire
      </entry>
     </row>

     <row>
      <entry><literal>self_referencing_column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>reference_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> s'il est possible d'insérer des données dans la
       table, <literal>NO</literal> dans le cas contraire (les tables de base
       sont toujours dans ce cas, les vues pas forcément.)
      </entry>
     </row>

     <row>
      <entry><literal>is_typed</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>commit_action</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Si la table est temporaire, alors <literal>PRESERVE</literal> sinon NULL.
       (Le standard SQL définit d'autres actions de validation pour les tables
       temporaires, actions qui ne sont pas supportées par
       <productname>PostgreSQL</productname>.)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggers">
  <title><literal>triggers</literal></title>

  <para>
   La vue <literal>triggers</literal> contient tous les déclencheurs définis
   dans la base de données courante dont un rôle actuellement activé est le
   propriétaire ou dispose de certains droits sur ces objets.
  </para>

  <table>
   <title>Colonnes de <literal>triggers</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant le déclencheur (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant le déclencheur</entry>
     </row>

     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du déclencheur</entry>
     </row>

     <row>
      <entry><literal>event_manipulation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Événement qui a exécuté le déclencheur (<literal>INSERT</literal>,
       <literal>UPDATE</literal> ou <literal>DELETE</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la table où est défini le déclencheur
       (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la table où est défini le
       déclencheur</entry>
     </row>

     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la table où est défini le déclencheur</entry>
     </row>

     <row>
      <entry><literal>action_order</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Pas encore implémenté</entry>
     </row>

     <row>
      <entry><literal>action_condition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>action_statement</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Instruction exécutée par le déclencheur (actuellement toujours
       <literal>EXECUTE PROCEDURE
       <replaceable>function</replaceable>(...)</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>action_orientation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Identifie si le déclencheur a été exécuté une fois pour chaque ligne
       traitée ou une fois par instruction (<literal>ROW</literal> ou
       <literal>STATEMENT</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>condition_timing</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Moment de l'exécution du déclencheur (<literal>BEFORE</literal> ou
       <literal>AFTER</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>condition_reference_old_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>condition_reference_new_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>condition_reference_old_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>condition_reference_new_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>

     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les déclencheurs dans <productname>PostgreSQL</productname> ont deux
   incompatibilités avec le standard SQL qui affectent la représentation dans le
   schéma d'information. Tout d'abord, les noms de déclencheurs sont locaux à la
   table avec <productname>PostgreSQL</productname>, plutôt qu'indépendant des
   objets schéma. Du coup, il pourrait y avoir des noms de déclencheurs
   dupliqués dans un schéma s'ils s'occupent de tables différentes
   (<literal>trigger_catalog</literal> et <literal>trigger_schema</literal> sont
   réellement les valeurs restant dans la table sur laquelle est défini le
   déclencheur.) Deuxièmement, les déclencheurs peuvent être définis pour
   s'exécuter sur plusieurs événements dans
   <productname>PostgreSQL</productname> (c'est-à-dire <literal>ON INSERT OR
   UPDATE</literal>) alors que le standard SQL n'en autorise qu'un. Si un
   déclencheur est défini pour s'exécuter sur plusieurs événements, il est
   représenté sur plusieurs lignes dans le schéma d'information, une pour chaque
   type d'événement. Comme conséquence de ces deux problèmes, la clé primaire de
   la vue <literal>triggers</literal> est en fait
   <literal>(trigger_catalog, trigger_schema, trigger_name, event_object_table,
   event_manipulation)</literal> au lieu de <literal>(trigger_catalog,
   trigger_schema, trigger_name)</literal>, ce que spécifie le standard SQL.
   Néanmoins, si vous définissez les déclencheurs d'une manière conforme au
   standard SQL (des noms de déclencheurs uniques dans le schéma et seulement un
   type d'événement par déclencheur), ceci ne vous concernera pas.
  </para>
 </sect1>

 <sect1 id="infoschema-usage-privileges">
  <title><literal>usage_privileges</literal></title>

  <para>
   La vue <literal>usage_privileges</literal> est utile pour identifier les
   droits <literal>USAGE</literal> donnés sur différents objets d'un rôle
   actuellement activé ou par un rôle actuellement activé. Dans
   <productname>PostgreSQL</productname>, ceci s'applique uniquement aux
   domaines et, comme les domaines n'ont pas de vrais droits avec
   <productname>PostgreSQL</productname>, cette vue affiche les droits
   <literal>USAGE</literal> implicites données par <literal>PUBLIC</literal>
   pour tous les domaines. Dans le futur, cette vue pourrait contenir plus
   d'informations utiles.
  </para>

  <table>
   <title>Colonnes de <literal>usage_privileges</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Actuellement initialisé avec le nom du propriétaire de
       l'objet</entry>
     </row>

     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Actuellement toujours <literal>PUBLIC</literal></entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant l'objet (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant l'objet</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de l'objet</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Actuellement toujours <literal>DOMAIN</literal></entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Toujours <literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Actuellement toujours <literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-column-usage">
  <title><literal>view_column_usage</literal></title>

  <para>
   La vue <literal>view_column_usage</literal> identifie toutes les colonnes
   utilisées dans l'expression de la requête d'une vue (l'instruction
   <command>SELECT</command> définissant la vue). Une colonne est seulement
   inclue si la table contenant la colonne appartient à un rôle actuellement
   activé.
  </para>

  <note>
   <para>
    Les colonnes des tables système ne sont pas inclues. Ceci devra être corrigé.
   </para>
  </note>

  <table>
   <title>Colonnes de <literal>view_column_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la vue (toujours la
       base de données courante)</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la vue</entry>
     </row>

     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la table, qui contient la colonne
       utilisée par la vue (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant la table contenant la colonne utilisée par la vue
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table contenant la colonne utilisée par la vue
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la colonne utilisée par la vue</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-routine-usage">
  <title><literal>view_routine_usage</literal></title>

  <para>
   La vue <literal>view_routine_usage</literal> identifie toutes les
   routines (fonctions et procédures) qui sont utilisées dans la requête de la
   vue (l'instruction <command>SELECT</command> qui définit la vue). Une routine
   est aussi incluse si la routine appartient à un rôle actuellement activé.
  </para>

  <table>
   <title>Colonnes de <literal>view_routine_usage</literal></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base contenant la vue (toujours la base en cours)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la vue</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom de la base contenant la fonction (toujours la base en cours)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Nom du schéma contenant la fonction</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Le <quote>nom spécifique</quote> de la fonction. Voir <xref
       linkend="infoschema-routines"/> pour plus d'informations.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-table-usage">
  <title><literal>view_table_usage</literal></title>

  <para>
   La vue <literal>view_table_usage</literal> identifie toutes les tables
   utilisées dans l'expression de la requête d'une vue (l'instruction
   <command>SELECT</command> définissant la vue). Une table est inclue
   seulement si un rôle actuellement activé est le propriétaire de cette table.
  </para>

  <note>
   <para>
    Les tables système ne sont pas inclues. Ceci devra être corrigé.
   </para>
  </note>

  <table>
   <title>Colonnes de <literal>view_table_usage</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la vue (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la vue</entry>
     </row>

     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la base de données contenant la table utilisée par la vue
       (toujours la base de données courante)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom du schéma contenant la table utilisée par la vue
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Nom de la table utilisée par la vue
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-views">
  <title><literal>views</literal></title>

  <para>
   La vue <literal>views</literal> contient toutes les vues définies dans la
   base de données courantes. Seules sont affichées les vues auxquelles
   l'utilisateur a accès (parce qu'il en est le propriétaire ou parce qu'il
   possède quelques droits dessus).
  </para>

  <table>
   <title>Colonnes de <literal>views</literal></title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.1*"/>
    <colspec colnum="2" colwidth="0.6*"/>
    <colspec colnum="3" colwidth="1.5*"/>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type de données</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la base de données contenant la vue (toujours la base
       de données courante)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom du schéma contenant la vue</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Nom de la vue</entry>
     </row>

     <row>
      <entry><literal>view definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Expression de la requête définissant la vue (NULL si un rôle actuellement
       activé n'est pas le propriétaire de la vue)
      </entry>
     </row>

     <row>
      <entry><literal>check_option</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>S'applique à une fonctionnalité non disponible dans
       <productname>PostgreSQL</productname>.</entry>
     </row>

     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> si la vue est modifiable (autorise
       <command>UPDATE</command> et <command>DELETE</command>),
       <literal>NO</literal> dans le cas contraire
      </entry>
     </row>

     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> s'il est possible d'insérer des données dans la
       vue (autorise <command>INSERT</command>), <literal>NO</literal> dans le
       cas contraire
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

</chapter>
