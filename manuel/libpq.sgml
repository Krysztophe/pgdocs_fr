<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/libpq.sgml,v 1.6.2.8 2005/07/15 06:33:42 guillaume Exp $
-->

 <chapter id="libpq">
  <title><application>libpq</application> - Bibliothèque C</title>

  <indexterm zone="libpq">
   <primary>libpq</primary>
  </indexterm>

  <indexterm zone="libpq">
   <primary>C</primary>
  </indexterm>

  <para>
   <application>libpq</application> est l'interface de programmation pour les
   applications <acronym>C</acronym> avec
   <productname>PostgreSQL</productname>. <application>libpq</application> est
   un ensemble de fonctions permettant aux programmes clients d'envoyer des 
   requêtes au serveur <productname>PostgreSQL</productname> et de recevoir les
   résultats de ces requêtes. <application>libpq</application> est aussi le
   moteur sous-jacent de plusieurs autres interfaces de programmation de
   <productname>PostgreSQL</productname> comme
   <application>libpq++</application> (C++), <application>libpgtcl</application>
   (Tcl), <productname>Perl</productname> et <application>ECPG</application>.
   Donc, certains aspects du comportement de <application>libpq</> seront
   importants pour vous si vous utilisez un de ces paquets.
  </para>

  <para>
   Quelques petits programmes sont inclus à la fin de ce chapitre (<xref
   linkend="libpq-example">) pour montrer comment écrire des programmes
   utilisant <application>libpq</application>. Il existe aussi quelques exemples
   complets d'applications <application>libpq</application> dans le répertoire
   <filename>src/test/examples</filename> venant avec la distribution des
   sources.
  </para>

  <para>
   Les programmes clients utilisant <application>libpq</application> doivent
   inclure le fichier d'en-tête
   <filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</></> et
   doivent être liés avec la bibliothèque <application>libpq</application>.
  </para>

 <sect1 id="libpq-connect">
  <title>Fonctions de contrôle de connexion à la base de données</title>

  <para>
   Les fonctions suivantes concernent la réalisation d'une connexion avec un
   serveur <productname>PostgreSQL</productname>. Un programme peut avoir
   plusieurs connexions ouvertes sur des serveurs à un même moment. (Une raison
   de la faire est d'accéder à plusieurs bases de données.) Chaque connexion
   est représentée par un objet
   <structname>PGconn</><indexterm><primary>PGconn</></>, obtenu avec la
   fonction <function>PQconnectdb</> ou <function>PQsetdbLogin</>. Notez que
   ces fonctions renverront toujours un pointeur d'objet non nul, sauf peut-être
   dans un cas de manque de mémoire pour l'allocation de l'objet
   <structname>PGconn</>. La fonction <function>PQstatus</> doit être appelée
   pour vérifier si la connexion s'est bien effectuée avant de lancer des
   requêtes via l'objet de connexion.

   <variablelist>
    <varlistentry>
     <term><function>PQconnectdb</function><indexterm><primary>PQconnectdb</></></term>
     <listitem>
      <para>
       Crée une nouvelle connexion au serveur de bases de données.
<synopsis>
PGconn *PQconnectdb(const char *conninfo);
</synopsis>
</para>

  <para>
   Cette fonction ouvre une nouvelle connexion à la base de données en utilisant
   les paramètres à partir de la chaîne <literal>conninfo</literal>.
   Contrairement à <function>PQsetdbLogin</> ci-dessous, l'ensemble de
   paramètres peut être étendu sans changer la signature de la fonction, donc
   utiliser cette fonction (ou son analogue non bloquant,
   <function>PQconnectStart</> et <function>PQconnectPoll</function>) est
   préféré pour la programmation de nouvelles applications.
   </para>

   <para>
    La chaîne passée peut être vide pour utiliser tous les paramètres par défaut
    ou elle peut contenir un ou plusieurs paramétrages séparés par des espaces
    blancs. Chaque paramètre est de la forme <literal>motclé = valeur</literal>.
    (Pour écrire une valeur vide ou une valeur contenant des espaces,
    entourez-les de guillemets simples, c'est-à-dire <literal>motclé = 'une
    valeur'</literal>. Des guillemets simples et des anti-slashs à l'intérieur
    de la valeur peuvent être échappés avec un antislash, par exemple
    <literal>\'</literal> et <literal>\\</literal>.) Les espaces autour du signe
    égal sont optionnels.
    </para>

   <para>
   Les mots clés actuellement reconnus sont&nbsp;:

   <variablelist>
    <varlistentry>
     <term><literal>host</literal></term>
     <listitem>
     <para>
      Nom de l'hôte sur lequel se connecter.<indexterm><primary>host name</></>
      S'il commence avec un slash, il spécifie une communication par domaine
      Unix plutôt qu'une communication TCP/IP&nbsp;; la valeur est le nom du
      répertoire où le fichier socket est stocké. Par défaut, il s'agit d'une
      communication par socket de domaine Unnix dans
      <filename>/tmp</filename>.<indexterm><primary>socket de domaine Unix</></>
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostaddr</literal></term>
     <listitem>
     <para>
      Adresse IP numérique de l'hôte de connexion. Elle devrait être au format
      d'adresse standard IPv4, c'est-à-dire <literal>172.28.40.9</>. Si votre
      machine supporte IPv6, vous pouvez aussi utiliser ces adresses. La
      communication TCP/IP est toujours utilisée lorsqu'une chaîne non vide est
      spécifiée pour ce paramètre.
     </para>
     <para>
      Utiliser <literal>hostaddr</> au lieu de <literal>host</> permet à
      l'application d'éviter une recherche de nom d'hôte, qui pourrait être
      importante pour les applications ayant des contraintes de temps.
      Néanmoins, l'authentification Kerberos requiert un nom d'hôte. 
      Du coup, la recherche s'effectue comme suit: si <literal>host</> est 
      indiqué sans <literal>hostaddr</>, une recherche de nom d'hôte a lieu. 
      Si <literal>hostaddr</> est spécifié sans <literal>host</>, la valeur de
      <literal>hostaddr</> donne l'adresse distante. Lorsque Kerberos est
      utilisée, une recherche de nom inverse est effectuée pour obtenir le nom
      d'hôte pour Kerberos. Si à la fois <literal>host</> et
      <literal>hostaddr</> sont spécifiés, la valeur de <literal>hostaddr</>
      donne l'adresse distante&nbsp;; la valeur de <literal>host</> est ignorée
      sauf si Kerberos est utilisé, auquel cas il s'agit de la valeur utilisée
      pour l'authentification Kerberos. (Notez que l'authentification a des
      chances d'échouer si <application>libpq</application> se voit donner un
      nom qui n'est pas le nom de la machine sur <literal>hostaddr</>.)  De
      même, <literal>host</> plutôt que <literal>hostaddr</> est utilisé pour
      identifier la connexion dans <filename>$HOME/.pgpass</>.
     </para>
     <para>
      Sans un nom ou une adresse d'hôte, <application>libpq</application> se
      connectera en utilisant une socket locale de domaine Unix.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>port</literal></term>
     <listitem>
     <para>
      Numéro de port pour la connexion au serveur ou extension du nom de
      fichier pour des connexions de domaine Unix.<indexterm><primary>port</></>
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>dbname</literal></term>
     <listitem>
     <para>
      Le nom de la base de données. Par défaut, la même que le nom d'utilisateur.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>user</literal></term> 
     <listitem>
     <para>
      Nom de l'utilisateur <productname>PostgreSQL</productname> qui se
      connecte.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>password</literal></term>
     <listitem>
     <para>
      Mot de passe à utiliser si le serveur demande une authentification par
      mot de passe.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>connect_timeout</literal></term>
     <listitem>
     <para>
      Attente maximum pour une connexion, en secondes (saisie comme une
      chaîne d'entier décimaux). Zéro ou non spécifié signifie une attente
      infinie. Utiliser une attente de moins de deux secondes n'est pas
      recommandé.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>options</literal></term>
     <listitem>
      <para>
       Options en ligne de commande à envoyer au serveur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>tty</literal></term>
     <listitem>
     <para>
      Ignoré (auparavant, ceci indiquait où envoyer les traces de débogage du
      serveur).
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>sslmode</literal></term>
     <listitem>
      <para>
       Cette option détermine si ou avec quelle priorité une connexion
       <acronym>SSL</> sera négociée avec le serveur. Il existe quatre
       modes&nbsp;: <literal>disable</> essaie uniquement une connexion non
       cryptée <acronym>SSL</>&nbsp;; <literal>allow</> négocie, en essayant
       tout d'abord une connexion sans <acronym>SSL</> puis, si cela échoue, une
       connexion <acronym>SSL</>&nbsp;; <literal>prefer</> (la valeur par
       défaut) négocie en essayant d'abord une connexion <acronym>SSL</> puis,
       en cas d'échec, une connexion non <acronym>SSL</>&nbsp;;
       <literal>require</> essaie uniquement une connexion <acronym>SSL</>.
      </para>

      <para>
       Si <productname>PostgreSQL</> est compilé sans le support de SSL,
       l'utilisation de l'option <literal>require</> cause une erreur et les
       options <literal>allow</> et <literal>prefer</> sont tolérées mais
       <application>libpq</> est incapable de négorctier une connexion
       <acronym>SSL</>.<indexterm><primary>SSL</><secondary
       sortas="libpq">avec libpq</></indexterm>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>requiressl</literal></term>
     <listitem>
      <para>
       Cette option est obsolète et remplacée par l'option <literal>sslmode</>.
      </para>

      <para>
       Si initialisée à 1, une connexion <acronym>SSL</acronym> au serveur est
       requise (ce qui est équivalent à un <literal>sslmode</>
       <literal>require</>). <application>libpq</> refuse alors de se
       connecter si le serveur n'accepte pas une connexion
       <acronym>SSL</acronym>. Si initialisée à 0 (la valeur par défaut),
       <application>libpq</> négocie le type de connexion avec le serveur
       (équivalent à un <literal>sslmode</> <literal>prefer</>). Cette option
       est seulement disponible si <productname>PostgreSQL</> est compilé avec
       le support SSL.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>service</literal></term>
     <listitem>
     <para>
      Nom du service à utiliser pour des paramètres supplémentaires. Il indique
      un nom de service dans <filename>pg_service.conf</filename> contenant
      des paramètres de connexion supplémentaires. Ceci permet aux
      applications de ne spécifier qu'un nom de service afin de permettre
      une maintenance centralisée des paramètres de connexion. Voir
      <filename><replaceable>PREFIX</>/share/pg_service.conf.sample</> pour plus
      d'informations sur le configuration de ce fichier.
     </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Si un paramètre manque, alors la variable d'environnement correspondante
   (voir <xref linkend="libpq-envars">) est testée. Si elle n'est pas
   disponible, alors la valeur par défaut est utilisée.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><function>PQsetdbLogin</function><indexterm><primary>PQsetdbLogin</></></term>
  <listitem>
   <para>
       Crée une nouvelle connexion sur le serveur de bases de données.
<synopsis>
PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);
</synopsis>
</para>

<para>
   C'est le prédécesseur de <function>PQconnectdb</function> avec un ensemble
   de paramètres fixe. Cette fonction a les mêmes fonctionnalités sauf que les
   paramètres manquants seront toujours initialisées avec leur valeurs par
   défaut. Écrire <symbol>NULL</symbol> ou un chaîne vide pour un de ces
   paramètres fixes dont vous souhaitez utiliser la valeur par défaut.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><function>PQsetdb</function><indexterm><primary>PQsetdb</></></term>
  <listitem>
   <para>
   Crée une nouvelle connexion sur le serveur de bases de données.
<synopsis>
PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);
</synopsis>
</para>

<para>
   C'est une macro faisant appel à <function>PQsetdbLogin</function> avec des
   pointeurs nuls pour les paramètres <parameter>login</> et <parameter>pwd</>.
   Elle est fournie pour une compatibilité ascendante des très vieux programmes.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><function>PQconnectStart</function><indexterm><primary>PQconnectStart</></></term>
  <term><function>PQconnectPoll</function><indexterm><primary>PQconnectPoll</></></term>
  <listitem>
  <para>
   <indexterm><primary>connexion non bloquante</primary></indexterm>
   Crée une connexion au serveur de bases de données d'une façon non bloquante.
<synopsis>
PGconn *PQconnectStart(const char *conninfo);
</synopsis>
<synopsis>
PostgresPollingStatusType PQconnectPoll(PGconn *conn);
</synopsis>
</para>
<para>
   Ces deux fonctions sont utilisées pour ouvrir une connexion au serveur de 
   bases de données d'une façon telle que le thread de votre application n'est
   pas bloqué sur les entrées/sorties distantes en demandant la connexion. Le
   principe de cette approche est que l'attente de la fin des entrées/sorties se
   fait dans la boucle principale de l'application plutôt qu'à l'intérieur de
   <function>PQconnectdb</>, ce qui permet à l'application de gérer cette opération
   en parallèle d'autres activités.
  </para>
  <para>
   La connexion à la base de données est faite en utilisant les paramètres pris
   dans la chaîne <literal>conninfo</literal>, passée à
   <function>PQconnectStart</function>. Cette chaîne est du même format que
   celle décrite pour <function>PQconnectdb</function>.
  </para>
  <para>
   Ni <function>PQconnectStart</function> ni <function>PQconnectPoll</function>
   ne sont bloquantes, si les restictions suivantes sont respectées&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      Les paramètres <literal>hostaddr</> et <literal>host</> sont utilisés de
      façon appropriée pour vous assurer que la requête de nom et la requête
      inverse ne soient pas lancées. Voir la documentation de ces paramètres avec
      <function>PQconnectdb</function> ci-dessus pour les détails.
     </para>
    </listitem>

    <listitem>
     <para>
      Si vous appelez <function>PQtrace</function>, assurez-vous que l'objet de
      flux dans lequel vous enregistrez les traces ne bloque pas.
     </para>
    </listitem>

    <listitem>
     <para>
      Assurez-vous que la socket soit dans l'état approprié avant d'appeler
      <function>PQconnectPoll</function>, comme décrit ci-dessous.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Pour commencer une demande de connexion non bloquante, appelez <literal>conn
   = PQconnectStart("<replaceable>connection_info_string</>")</literal>.
   Si <varname>conn</varname> est nul, alors <application>libpq</> a été
   incapable d'allouer une nouvelle structure <structname>PGconn</>. Sinon, un
   pointeur valide vers une structure <structname>PGconn</> est renvoyé (bien
   qu'il ne représente pas encore une connexion valide vers la base de
   données). Au retour de <function>PQconnectStart</function>, appelez
   <literal>status = PQstatus(conn)</literal>. Si <varname>status</varname> vaut
   <symbol>CONNECTION_BAD</symbol>, <function>PQconnectStart</function> a
   échoué.
  </para>
  <para>
   Si <function>PQconnectStart</> réussit, la prochaine étape est d'appeler
   souvent <application>libpq</> de façon à ce qu'il continue la séquence de
   connexion. Utilisez <function>PQsocket(conn)</function> pour obtenir le
   descripteur de socket de la connexion à la base de données. Du coup, une
   boucle&nbsp;: si le dernier retour de
   <function>PQconnectPoll(conn)</function> est
   <symbol>PGRES_POLLING_READING</symbol>, attendez que la socket soit prête
   pour lire (comme indiqué par <function>select()</>, <function>poll()</> ou
   une fonction système similaire). Puis, appelez de nouveau
   <function>PQconnectPoll(conn)</function>. Par contre, si le dernier retour de
   <function>PQconnectPoll(conn)</function> est
   <symbol>PGRES_POLLING_WRITING</symbol>, attendez que la socket soit prête
   pour écrire, puis appelez de nouveau
   <function>PQconnectPoll(conn)</function>. Si vous devez encore appeler
   <function>PQconnectPoll</function>, c'est-à-dire juste après l'appel de
   <function>PQconnectStart</function>, continuez comme si il avait renvoyé
   <symbol>PGRES_POLLING_WRITING</symbol>. Continuez cette boucle jusqu'à ce que
   <function>PQconnectPoll(conn)</function> renvoie
   <symbol>PGRES_POLLING_FAILED</symbol>, indiquant que la procédure de
   connexion a échoué ou, ou <symbol>PGRES_POLLING_OK</symbol>, indiquant le
   succès de la procédure de connexion.
  </para>

  <para>
    À tout moment pendant la connexion, le statut de cette connexion peut 
    être vérifié en appelant <function>PQstatus</>. Si le résultat est
    <symbol>CONNECTION_BAD</>, alors la procédure de connexion a échoué&nbsp;;
    si, au contraire, elle renvoie <function>CONNECTION_OK</>, alors la
    connexion est prête. Ces deux états sont détectables à partir de la valeur
    de retour de <function>PQconnectPoll</>, décrite ci-dessus. D'autres états
    pourraient survenir lors (et seulement dans ce cas) d'une procédure de
    connexion asynchrone. Ils indiquent l'état actuel de la procédure de
    connexion et peuvent être utile pour fournir un retour à l'utilisateur.
    Ces statuts sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term><symbol>CONNECTION_STARTED</symbol></term>
      <listitem>
       <para>
        Attente que la connexion se fasse.
       </para>
      </listitem>
     </varlistentry> 

     <varlistentry>
      <term><symbol>CONNECTION_MADE</symbol></term>
      <listitem>
       <para>
        Connexion OK&nbsp;; attente d'un envoi.
       </para>
      </listitem>
     </varlistentry>  

     <varlistentry>
      <term><symbol>CONNECTION_AWAITING_RESPONSE</symbol></term>
      <listitem>
       <para>
        Attente d'une réponse du serveur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><symbol>CONNECTION_AUTH_OK</symbol></term>
      <listitem>
       <para>
        Authentification reçue&nbsp;; attente de la fin du lancement du moteur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><symbol>CONNECTION_SSL_STARTUP</symbol></term>
      <listitem>
       <para>
        Négociation du cryptage SSL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><symbol>CONNECTION_SETENV</symbol></term>
      <listitem>
       <para>
        Négociation des paramétrages liés à l'environnement.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Notez que, bien que ces constantes resteront (pour maintenir une
    compatibilité), une application ne doit jamais se baser sur leur ordre d'aparition
    ou ni croire que seules ces valeurs documentées sont susceptibles d'aparaitre.
    Une application devrait au contraire faire quelque chose comme ça&nbsp;:
<programlisting>
switch(PQstatus(conn))
{
    case CONNECTION_STARTED:
        feedback = "Connexion en cours...";
        break;

    case CONNECTION_MADE:
        feedback = "Connecté au serveur...";
        break;
.
.
.
    default:
        feedback = "Connexion...";
}
</programlisting>
  </para>

  <para>
   Le paramètre de connexion <literal>connect_timeout</literal> est ignoré lors
   de l'utilisation de <function>PQconnectPoll</function>&nbsp;; c'est de la
   responsabilité de l'application de décider quand une période de temps
   excessive s'est écoulée. Sinon, <function>PQconnectStart</function> suivi par
   une boucle <function>PQconnectPoll</function> est équivalent à
   <function>PQconnectdb</function>.
  </para>

  <para>
   Notez que si <function>PQconnectStart</function> renvoie un pointeur non
   nul, vous devez appeler <function>PQfinish</function> lorsque vous en avez
   terminé avec lui, pour supprimer la structure et tous les blocs mémoires qui
   lui sont associés. Ceci doit être fait même si la tentative de connexion
   échoue ou est abandonnée.
  </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><function>PQconndefaults</function><indexterm><primary>PQconndefaults</></></term>
  <listitem>
   <para>
   Renvoie les options de connexion par défaut.
<synopsis>
PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* Le mot clé de l'option */
    char   *envvar;    /* Nom de la variable d'environnement équivalente */
    char   *compiled;  /* Valeur par défaut interne */
    char   *val;       /* Valeur actuelle de l'option ou NULL */
    char   *label;     /* Label du champ pour la dialogue de connexion */
    char   *dispchar;  /* Caractère à afficher pour ce champ
                        * dans un dialogue de connexion. Les valeurs sont :
                        * ""        Affiche la valeur entrée sans modification
                        * "*"       Champ de mot de passe - cache la valeur
                        * "D"       Option de débogage - non affiché par défaut
                        */
    int     dispsize;  /* Taille du champ en caractère pour le dialogue */
} PQconninfoOption;
</synopsis>
</para>

<para>
   Renvoie un tableau d'options de connexion. Ceci pourrait être utiliser pour
   déterminer toutes les options possibles de <function>PQconnectdb</function>
   et leur valeur par défaut. La valeur de retour pointe vers un tableau de
   structures <structname>PQconninfoOption</structname> qui se termine avec une
   entrée utilisant un pointeur nul pour <structfield>keyword</>. Notez que les
   valeurs par défaut actuelles (champs <structfield>val</structfield>)
   dépendront des variables d'environnement et d'autres contextes. Les
   demandeurs doivent traiter les données des options de connexion en lecture
   seule.
   </para>

   <para>
    Après le traitement du tableau d'options, libérez-le en le passant à la
    fonction <function>PQconninfoFree</function>. Si cela n'est pas fait, un
    petit bloc de mémoire est perdu à chaque appel de
    <function>PQconndefaults</function>.
   </para>

  </listitem>
 </varlistentry>

 <varlistentry>
  <term><function>PQfinish</function><indexterm><primary>PQfinish</></></term>
  <listitem>
   <para>
   Ferme la connexion au serveur. Libère aussi la mémoire utilisée par l'objet
   <structname>PGconn</structname>.
<synopsis>
void PQfinish(PGconn *conn);
</synopsis>
</para>

<para>
   Notez que même si la connexion au serveur a échoué (d'après l'indication 
   de <function>PQstatus</function>), l'application doit appeler
   <function>PQfinish</function> pour libérer la mémoire utilisée par l'objet
   <structname>PGconn</structname>. Le pointeur <structname>PGconn</> ne doit
   plus être utilisé après l'appel à <function>PQfinish</function>.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><function>PQreset</function><indexterm><primary>PQreset</></></term>
  <listitem>
   <para>
   Réinitialise le canal de communication avec le serveur.
<synopsis>
void PQreset(PGconn *conn);
</synopsis>
</para>

<para>
   Cette fonction ferme la connexion au serveur et tente le rétablissement
   d'une nouvelle connexion au même serveur en utilisant tous les paramètres
   utilisés précédemment. Ceci peut être utile pour récupérer une erreur 
   en cas de perte de connexion.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><function>PQresetStart</function><indexterm><primary>PQresetStart</></></term>
  <term><function>PQresetPoll</function><indexterm><primary>PQresetPoll</></></term>
  <listitem>
   <para>
   Réinitialise la canal de communication avec le serveur d'une façon non
   bloquante.
<synopsis>
int PQresetStart(PGconn *conn);
</synopsis>
<synopsis>
PostgresPollingStatusType PQresetPoll(PGconn *conn);
</synopsis>
</para>

<para>
    Ces fonctions ferment la connexion au serveur et tentent de rétablir
    une nouvelle connexion au même serveur en utilisant les mêmes paramètres
    que précédemment. Ceci peut être utile en cas de récupération après une
    erreur si une connexion est perdue. Elles diffèrent de
    <function>PQreset</function> (ci-dessus) car elles agissent d'une façon non
    bloquante. Ces fonctions souffrent des mêmes restrictions que
    <function>PQconnectStart</> et <function>PQconnectPoll</>.
   </para>
   <para>
    Pour initier une réinitialisation de la connexion, appelez
    <function>PQresetStart</function>. S'il renvoie 0, la réinitialisation a
    échoué. S'il renvoie 1, activez la réinitialisation en utilisant
    <function>PQresetPoll</function> exactement de la même façon que vous
    créeriez la connexion en utilisant <function>PQconnectPoll</function>.
   </para>
  </listitem>
 </varlistentry>

 </variablelist>
</para>
</sect1>

<sect1 id="libpq-status">
<title>Fonctions de statut de connexion</title>

  <para>
   Ces fonctions sont utilisées pour interroger le statut d'un objet de
   connexion existant.
  </para>

<tip>
<para>
<indexterm><primary>libpq-fe.h</></>
<indexterm><primary>libpq-int.h</></>
Les développeurs d'application <application>libpq</application> devraient être
attentif au maintien de leur abstraction <structname>PGconn</structname>.
Utilisez les fonctions d'accès décrites ci-dessous pour obtenir le 
contenu de <structname>PGconn</structname>. Évitez de référencer directement les
champs de la structure <structname>PGconn</> parce qu'ils sont sujet à
modification dans le futur. (À partir de <productname>PostgreSQL</productname>
version 6.4, la définition de la structure (<type>struct</type>) derrière
<structname>PGconn</> n'est même plus fournie dans
<filename>libpq-fe.h</filename>. Si vous avez un vieux code qui accède
directement aux champs de <structname>PGconn</structname>, vous pouvez le
conserver en incluant en plus <filename>libpq-int.h</filename> mais vous êtes
encouragé à corriger le code rapidement.)
</para>
</tip>

<para>
Les fonctions suivantes renvoient les valeurs des paramètres utilisées
pour la connexion. Ces valeurs sont fixes pour la durée de vie de l'objet
<structname>PGconn</>.

<variablelist>
<varlistentry>
<term><function>PQdb</function><indexterm><primary>PQdb</></></term>
<listitem>
<para>
         Renvoie le nom de la base de données de la connexion.
<synopsis>
char *PQdb(const PGconn *conn);
</synopsis>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQuser</function><indexterm><primary>PQuser</></></term>
<listitem>
<para>
         Renvoie le nom d'utilisateur utilisé pour la connexion.
<synopsis>
char *PQuser(const PGconn *conn);
</synopsis>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQpass</function><indexterm><primary>PQpass</></></term>
<listitem>
<para>
         Renvoie le mot de passe utilisé pour la connexion.
<synopsis>
char *PQpass(const PGconn *conn);
</synopsis>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQhost</function><indexterm><primary>PQhost</></></term>
<listitem>
<para>
         Renvoie le nom d'hôte du serveur utilisé pour la connexion.
<synopsis>
char *PQhost(const PGconn *conn);
</synopsis>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQport</function><indexterm><primary>PQport</></></term>
<listitem>
<para>
         Renvoie le numéro de port utilisé pour la connexion.
<synopsis>
char *PQport(const PGconn *conn);
</synopsis>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQtty</function><indexterm><primary>PQtty</></></term>
<listitem>
<para>
         Renvoie le <acronym>TTY</acronym> de débogage pour la connexion.
         (Ceci est obsolète car le serveur ne fait plus attention au
         paramétrage du <acronym>TTY</acronym> mais les fonctions restent pour
         des raisons de compatibilité ascendante.)
<synopsis>
char *PQtty(const PGconn *conn);
</synopsis>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQoptions</function><indexterm><primary>PQoptions</></></term>
<listitem>
<para>
       Renvoie les options en ligne de commande passées lors de la demande de
       connexion.
<synopsis>
char *PQoptions(const PGconn *conn);
</synopsis>
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
Les fonctions suivantes renvoient le statut car il peut changer suite à
 l'exécution d'opérations sur l'objet <structname>PGconn</>.

<variablelist>
<varlistentry>
<term><function>PQstatus</function><indexterm><primary>PQstatus</></></term>
<listitem>
<para>
         Renvoie l'état de la connexion. 
<synopsis>
ConnStatusType PQstatus(const PGconn *conn);
</synopsis>
</para>

      <para>
       Le statut peut faire partie d'un certain nombre de valeurs. Néanmoins,
       seules deux ne concernent pas les procédures de connexion
       asynchrone&nbsp;: <literal>CONNECTION_OK</literal> et
       <literal>CONNECTION_BAD</literal>. Une bonne connexion de la base de
       données a l'état <literal>CONNECTION_OK</literal>. Une tentative échouée
       de connexion est signalée par le statut
       <literal>CONNECTION_BAD</literal>. D'habitude, un état OK reste ainsi
       jusqu'à <function>PQfinish</function> mais un problème de communications
       pourrait prématurément changer le statut en 
       <literal>CONNECTION_BAD</literal>. Dans ce cas, l'application peut
       essayer de se récupérer en appelant <function>PQreset</function>.
      </para>

      <para>
       Voir <function>PQconnectStart</> ete
       <function>PQconnectPoll</> pour connaître les autres statuts possibles.
      </para>
     </listitem>
    </varlistentry>

<varlistentry>
<term><function>PQtransactionStatus</function><indexterm><primary>PQtransactionStatus</></></term>
<listitem>
<para>
         Renvoie l'état actuel de la transaction du serveur.
<synopsis>
PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
</synopsis>

Le statut peut être <literal>PQTRANS_IDLE</literal> (actuellement inactif),
<literal>PQTRANS_ACTIVE</literal> (une commande est en cours),
<literal>PQTRANS_INTRANS</literal> (inactif, dans un bloc valide de
transaction) ou <literal>PQTRANS_INERROR</literal> (inactif, dans un bloc de
transaction échoué). <literal>PQTRANS_UNKNOWN</literal> est reporté si la
connexion est mauvaise. <literal>PQTRANS_ACTIVE</literal> est reporté seulement
quand une requête a été envoyée au serveur mais qu'elle n'est pas terminée.
</para>
<caution>
<para>
<function>PQtransactionStatus</> donne des résultats incorrects lors de
l'utilisation d'un serveur <productname>PostgreSQL</> 7.3 qui a désactivé le
paramètre <literal>autocommit</>. La fonctionnalité autocommit, côté serveur,
est obsolète et n'existe pas dans les versions ultérieures du serveur.
</para>
</caution>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQparameterStatus</function><indexterm><primary>PQparameterStatus</></></term>
<listitem>
<para>
         Recherche un paramétrage actuel du serveur.
<synopsis>
const char *PQparameterStatus(const PGconn *conn, const char *paramName);
</synopsis>

Certaines valeurs de paramètres sont reportées par le serveur automatiquement ou
lorsque leur valeurs changent. <function>PQparameterStatus</> peut être utilisé
pour interroger ces paramétrages. Il renvoie la valeur actuelle d'un
paramètre s'il est connu et <symbol>NULL</symbol> dans le cas contraire.
</para>

<para>
Les paramètres reportés pour la version actuelle incluent
<literal>server_version</> (ne peut pas changer après le lancement du
serveur)&nbsp;;
<literal>client_encoding</>,
<literal>is_superuser</>,
<literal>session_authorization</literal> et
<literal>datestyle</>.
</para>

<para>
Les serveurs utilisant un protocole antérieur à la version 3.0 ne reportent pas la
configuration des paramètres mais <application>libpq</> inclut la logique pour
obtenir des valeurs pour <literal>server_version</> et
<literal>client_encoding</>. Les applications sont encouragées à utiliser
<function>PQparameterStatus</> plutôt qu'un code ad-hoc modifiant ces valeurs.
(Néanmoins, attention, les connexions pré-3.0, un changement de 
<literal>client_encoding</> via <command>SET</> après le lancement de la
connexion n'est pas reflété par <function>PQparameterStatus</>.)
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQprotocolVersion</function><indexterm><primary>PQprotocolVersion</></></term>
<listitem>
<para>
         Demande la version du protocole client/serveur utilisé.
<synopsis>
int PQprotocolVersion(const PGconn *conn);
</synopsis>
Les applications peuvent souhaiter utiliser ceci pour déterminer si certaines
fonctionnalités sont supportées. Actuellement, les seules valeurs possible sont
2 (protocole 2.0), 3 (protocole 3.0) ou zéro (mauvaise connexion). Ceci ne
change pas après la fin du lancement de la connexion mais peut théoriquement
être changé après une réinitialisation. Le protocole 3.0 est
normalement utilisé lors de la communication avec les serveurs
<productname>PostgreSQL</> 7.4 ou ultérieures&nbsp;; les serveurs
antérieurs à la 7.4 supportent uniquement le protocole 2.0. (Le protocole 1.0
est obsolète et non supporté par <application>libpq</application>.)
</para>
</listitem>
</varlistentry>

    <varlistentry>
     <term><function>PQerrorMessage</function><indexterm><primary>PQerrorMessage</></></term>
     <listitem>
      <para>
       <indexterm><primary>Message d'erreur</></>
       Renvoie le dernier message d'erreur généré par une opération sur la
       connexion.
<synopsis>
char *PQerrorMessage(const PGconn* conn);
</synopsis>
      </para>

      <para>
       Pratiquement toutes les fonctions <application>libpq</> initialisent
       un message pour <function>PQerrorMessage</function> en cas d'échec.
       Notez que par convention, dans <application>libpq</application>, un résultat
       non vide de <function>PQerrorMessage</function> inclue un retour
       chariot à la fin.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PQsocket</function><indexterm><primary>PQsocket</></></term>
     <listitem>
      <para>
       Obtient le descripteur de fichier de la socket de la connexion au serveur. 
       Un descripteur valide est plus grand ou égal à 0&nbsp;; un résultat de
       -1 indique qu'aucune connexion au serveur n'est actuellement ouverte.
       (Ceci ne change pas lors de l'opération normale mais peut changer
       lors de l'initialisation ou de la réinitialisation d'une connexion.)
<synopsis>
int PQsocket(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PQbackendPID</function><indexterm><primary>PQbackendPID</></></term>
     <listitem>
      <para>
       Renvoie l'identifiant du processus
       (<acronym>PID</acronym>)<indexterm><primary>PID</><secondary>déterminer
       le PID du processus du serveur</><tertiary>dans libpq</></> du serveur
       gérant cette connexion.
<synopsis>
int PQbackendPID(const PGconn *conn);
</synopsis>
</para>

<para>
       Le <acronym>PID</acronym> du moteur est utile pour des raisons de
       débogage et pour la comparaison avec les messages
       <command>NOTIFY</command> (qui indiquent le <acronym>PID</acronym> du
       processus serveur lançant la notification). Notez que le
       <acronym>PID</acronym> appartient à un processus exécuté sur l'hôte du
       serveur de bases de données et non pas sur l'hôte local&nbsp;!
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PQgetssl</function><indexterm><primary>PQgetssl</></></term>
     <listitem>
      <para>
       <indexterm><primary>SSL</><secondary sortas="libpq">dans
       libpq</secondary></indexterm>
       Retourne la structure SSL utilisée dans la connexion ou NULL si SSL
       n'est pas utilisé.
<synopsis>
SSL *PQgetssl(const PGconn *conn);
</synopsis>
</para>

<para>
       Cette structure peut être utilisée pour vérifier les niveaux de cryptage,
       pour vérifier les certificats du serveur, et plus. Référez-vous à la
       documentation d'<productname>OpenSSL</> pour plus d'informations sur
       cette structure.
      </para>
      <para>
       Vous pouvez définir <symbol>USE_SSL</symbol> pour obtenir le prototype
       de cette fonction. Faire cela inclura automatiquement
       <filename>ssl.h</filename> à partir de
       <productname>OpenSSL</productname>.
      </para>
     </listitem>
    </varlistentry>

</variablelist>
</para>

</sect1>

<sect1 id="libpq-exec">
<title>Fonctions de commandes d'exécution</title>

<para>
Une fois qu'une connexion au serveur de la base de données a été établie avec
succès, les fonctions décrites ici sont utilisées pour exécuter les requêtes
SQL et les commandes.
</para>

<sect2 id="libpq-exec-main">
  <title>Fonctions principales</title>

<para>
<variablelist>
<varlistentry>
<term><function>PQexec</function><indexterm><primary>PQexec</></></term>
<listitem>
<para>
          Soumet une commande au serveur et attend le résultat.
<synopsis>
PGresult *PQexec(PGconn *conn, const char *command);
</synopsis>
</para>

<para>
          Renvoie un pointeur <structname>PGresult</structname> ou peut-être un
          pointeur NULL.
          Un pointeur non NULL est généralement renvoyé sauf dans des
          conditions de manque de mémoire ou d'erreurs sérieuses telles que
          l'incapacité à envoyer la commande au serveur. Si un pointeur NULL est
          renvoyé, il devrait être traité comme un résultat
          <symbol>PGRES_FATAL_ERROR</symbol>. Utilisez
          <function>PQerrorMessage</function> pour obtenir plus d'informations
          sur l'erreur.
</para>
</listitem>
</varlistentry>
</variablelist>

Il est possible d'inclure plusieurs commandes SQL (séparées par des
points virgules) dans la chaîne de commande. Les requêtes multiples envoyées
dans un simple appel à <function>PQexec</> sont exécutées dans une seule
transaction sauf s'il y a des commandes explicites
<command>BEGIN</command>/<command>COMMIT</command> incluses dans la chaîne de
requête pour la diviser en plusieurs transactions. Notez, néanmoins
que la structure <structname>PGresult</structname> renvoyée, décrit seulement
le résultat de la dernière commande exécutée à partir de la chaîne. Si une des
commandes échoue, l'exécution de la chaîne s'arrête et le
<structname>PGresult</structname> renvoyé décrit la condition d'erreur.
</para>

<para>
<variablelist>
<varlistentry>
<term><function>PQexecParams</function><indexterm><primary>PQexecParams</></></term>
<listitem>
<para>
          Soumet une commande au serveur et attend le résultat, avec la
          possibilité de passer des paramètres séparément du texte de la
          commande SQL.
<synopsis>
PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);
</synopsis>
</para>

<para>
<function>PQexecParams</> est identique à <function>PQexec</> mais offre des
fonctionnalités supplémentaires&nbsp;: des valeurs de paramètres peuvent être
spécifiées séparément de la chaîne de commande et les résultats de la requête
peuvent être demandés soit au format texte soit au format binaire.
<function>PQexecParams</> est supportée seulement dans les connexion avec le
protocole 3.0 et ultérieurs&nbsp;; elle échouera lors de l'utilisation du
protocole 2.0.
</para>

<para>
Si les paramètres sont utilisés, ils sont référencés dans la chaîne de commande
avec <literal>$1</>, <literal>$2</>, etc. <parameter>nParams</> correspond au
nombre de paramètres fournis&nbsp;; il a la longueur des tableaux
<parameter>paramTypes[]</>, <parameter>paramValues[]</>,
<parameter>paramLengths[]</> et <parameter>paramFormats[]</>.  (Les pointeurs
de tableaux peuvent être <symbol>NULL</symbol> lorsque <parameter>nParams</>
vaut zéro.) <parameter>paramTypes[]</> spécifie, par OID, les types de données
à affecter aux symboles de paramètres. Si <parameter>paramTypes</> est
<symbol>NULL</symbol> ou si tout autre élément du tableau vaut zéro, le serveur
assigne un type de données au symbole de paramètre de la même façon qu'il le
ferait pour une chaîne littérale non typée. <parameter>paramValues[]</>
spécifie les valeurs réelles des paramètres. Un pointeur nul dans ce tableau
signifie que le paramètre correspondant est nul&nbsp;; sinon, le pointeur
pointe vers une chaîne textuelle terminée avec un zéro (pour le format texte)
ou des données binaires dans le format attendu par le serveur (pour le format
binaire). <parameter>paramLengths[]</> spécifie les longueurs réelles des
données des paramètres au format binaire. Il est ignoré pour les paramètres
NULL et les paramètres au format texte. Le pointeur de tableau peut être
NULL lorsqu'il n'y a pas de paramètres binaires. <parameter>paramFormats[]</>
spécifie si les paramètres sont de type texte (place un zéro dans le tableau )
ou binaire (place un un dans le tableau ). Si le pointeur de tableau est NULL,
alors tous les paramètres sont supposés être du type texte.
<parameter>resultFormat</> vaut zéro pour obtenir les résultats au format texte
ou un pour obtenir des résultats au format binaire. (Il n'existe actuellement
aucune méthode pour obtenir des colonnes de résultats différents dans des
formats différents bien que cela soit possible dans le protocole sous-jacent.)
</para>
</listitem>
</varlistentry>
</variablelist>

Le principal avantage de <function>PQexecParams</> sur <function>PQexec</> est
que les valeurs de paramètres peuvent être séparés de la chaîne de
commande, évitant ainsi le fastidieux besoin de guillemets et d'échappements.

Contrairement à <function>PQexec</>, <function>PQexecParams</> autorise au plus
une commande SQL dans une chaîne donnée. (Il peut y avoir des points virgules
mais pas plus d'une commande non vide.) C'est une limitation du protocole
sous-jacent mais cela a quelque utilité comme défense supplémentaire contre les
attaques d'injection de SQL.
</para>

<para>
<variablelist>
<varlistentry>
<term><function>PQexecPrepared</function><indexterm><primary>PQexecPrepared</></></term>
<listitem>
<para>
          Envoie une requête pour exécuter une instruction séparée avec les
          paramètres donnés, et attend le résultat.
<synopsis>
PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);
</synopsis>
</para>

<para>
<function>PQexecPrepared</> est identique à <function>PQexecParams</>, mais la
commande à exécuter est spécifiée en nommant une instruction précédemment préparée
au lieu de donner une chaîne de requête. Cette fonctionnalité permet aux
commandes qui seront utilisées de façon répétée de n'être analysées et
planifiées qu'une seule fois plutôt qu'à chaque fois qu'elles sont exécutées.
<function>PQexecPrepared</> est supporté seulement dans les connexions 
du protocole 3.0 et ultérieur&nbsp;; elle échouera lors de l'utilisation du
protocole 2.0.
</para>

<para>
Les paramètres sont identiques à <function>PQexecParams</>, sauf que le nom
d'une instruction préparée est donné au lieu d'une chaîne de requête et le
paramètre <parameter>paramTypes[]</> n'est pas présente (il n'est pas
nécessaire car les types des paramètres de l'instruction préparée ont été
déterminés à la création).
</para>
</listitem>
</varlistentry>
</variablelist>

Actuellement, les instructions préparées, à utiliser avec
<function>PQexecPrepared</> doivent être initialisées en exécutant la commande
SQL <command>PREPARE</>, qui est typiquement envoyé par <function>PQexec</>
(bien que toutes les fonctions d'envoi de requêtes de <application>libpq</>
pourraient être utilisées). Une interface de plus bas niveau pour les instructions
préparées pourrait être proposée dans une version future.
</para>

<para>
La structure
<structname>PGresult</structname><indexterm><primary>PGresult</></>
encapsule le résultat renvoyé par le serveur. Les développeurs d'applications
<application>libpq</application> doivent faire attention à maintenir
l'abstraction de <structname>PGresult</structname>. Utilisez les fonctions
d'accès ci-dessous pour obtenir le contenu de <structname>PGresult</structname>.
Évitez la référence directe aux champs de la structure
<structname>PGresult</structname> car ils sont sujets à des changements dans le
futur.

<variablelist>
<varlistentry>
<term><function>PQresultStatus</function><indexterm><primary>PQresultStatus</></></term>
<listitem>
<para>
          Renvoie l'état du résultat d'une commande.
<synopsis>
ExecStatusType PQresultStatus(const PGresult *res);
</synopsis>
</para>

<para>
<function>PQresultStatus</function> peut renvoyer une des valeurs
suivantes&nbsp;:

<variablelist>
 <varlistentry>
  <term><literal>PGRES_EMPTY_QUERY</literal></term>
  <listitem>
   <para>La chaîne envoyée au serveur était vide.</para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><literal>PGRES_COMMAND_OK</literal></term>
  <listitem>
   <para>Fin avec succès d'une commande ne renvoyant aucune donnée.</para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><literal>PGRES_TUPLES_OK</literal></term>
  <listitem>
   <para>Fin avec succès d'une commande renvoyant des données (telle que
   <command>SELECT</> ou <command>SHOW</>).</para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><literal>PGRES_COPY_OUT</literal></term>
  <listitem>
   <para>Début de l'envoi (à partir du serveur) d'un flux de données.</para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><literal>PGRES_COPY_IN</literal></term>
  <listitem>
   <para>Début de la réception (sur le serveur) d'un flux de
    données.</para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><literal>PGRES_BAD_RESPONSE</literal></term>
  <listitem>
   <para>La réponse du serveur n'a pas été comprise.</para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><literal>PGRES_NONFATAL_ERROR</literal></term>
  <listitem>
   <para>Une erreur non fatale (une note ou un avertissement) est
    survenue.</para>
  </listitem>
 </varlistentry>

 <varlistentry>
  <term><literal>PGRES_FATAL_ERROR</literal></term>
  <listitem>
   <para>Une erreur fatale est survenue.</para>
  </listitem>
 </varlistentry>
</variablelist>

Si le statut du résultat est <literal>PGRES_TUPLES_OK</literal>, alors les
fonctions décrites ci-dessous peuvent être utilisées pour récupérer les lignes
renvoyées pas la requête. Notez qu'une commande <command>SELECT</command> qui
ne récupère aucune ligne affichera toujours
<literal>PGRES_TUPLES_OK</literal>. <literal>PGRES_COMMAND_OK</literal> est
utilisé par les commandes qui ne peuvent jamais renvoyer de lignes
(<command>INSERT</command>, <command>UPDATE</command>, etc.). Une réponse
<literal>PGRES_EMPTY_QUERY</literal> pourrait indiquer un bogue dans le
logiciel client.
</para>

<para>
Un résultat de statut <symbol>PGRES_NONFATAL_ERROR</symbol> ne sera jamais
renvoyé directement par <function>PQexec</function> ou d'autres fonctions
d'exécution de requêtes&nbsp;; les résultats de ce type sont passés au
processeur de notifications (voir <xref linkend="libpq-notice-processing">).
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQresStatus</function><indexterm><primary>PQresStatus</></></term>
<listitem>
<para>
        Convertit le type énuméré renvoyé par <function>PQresultStatus</> en
        une constante de type chaîne décrivant le code d'état.
<synopsis>
char *PQresStatus(ExecStatusType status);
</synopsis>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQresultErrorMessage</function><indexterm><primary>PQresultErrorMessage</></></term>
<listitem>
<para>
Renvoie le message d'erreur associé à la commande ou une chaîne vide s'il
n'y a pas eu d'erreurs.
<synopsis>
char *PQresultErrorMessage(const PGresult *res);
</synopsis>
S'il y a eu une erreur, la chaîne renvoyée inclue un retour chariot en fin.
</para>

<para>
Suivant immédiatement un appel à <function>PQexec</function> ou
<function>PQgetResult</function>, <function>PQerrorMessage</function> (sur la
connexion) renvoie la même chaîne que <function>PQresultErrorMessage</function>
(sur le résultat). Néanmoins, un <structname>PGresult</structname> conserve
son message d'erreur jusqu'à destruction alors que le message d'erreur de la 
connexion change lorsque des opérations suivantes sont réalisées. Utilisez
<function>PQresultErrorMessage</function> quand vous voulez connaître le statut
associé à un <structname>PGresult</structname> particulier&nbsp;; utilisez
<function>PQerrorMessage</function> lorsque vous souhaitez connaître le statut
de la dernière opération sur la connexion.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQresultErrorField</function><indexterm><primary>PQresultErrorField</></></term>
<listitem>
<para>
Renvoie un champ individuel d'un rapport d'erreur.
<synopsis>
char *PQresultErrorField(const PGresult *res, int fieldcode);
</synopsis>
<parameter>fieldcode</> est un identifiant de champ d'erreur&nbsp;; voir les
symboles listés ci-dessous. <symbol>NULL</symbol> est renvoyé si
<structname>PGresult</structname> n'est pas un résultat d'erreur ou
d'avertissement, ou n'inclue pas le champ spécifié. Les valeurs de champ
n'incluent normalement pas un retour chariot en fin.
</para>

<para>
Les codes de champs suivants sont disponibles&nbsp;:
<variablelist>

<varlistentry>
<term><symbol>PG_DIAG_SEVERITY</></term>
<listitem>
<para>
La sévérité&nbsp;; le contenu du champ peut être <literal>ERROR</>,
<literal>FATAL</> ou <literal>PANIC</> (dans un message d'erreur), ou
<literal>WARNING</>, <literal>NOTICE</>, <literal>DEBUG</>,
<literal>INFO</>ou <literal>LOG</> (dans un message de notification), ou une
traduction localisée de ceux-ci. Toujours présent.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><symbol>PG_DIAG_SQLSTATE</>
</term>
<listitem>
<para>
Le code SQLSTATE de l'erreur (voir <xref linkend="errcodes-appendix">).
Non localisable. Toujours présent.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><symbol>PG_DIAG_MESSAGE_PRIMARY</></term>
<listitem>
<para>
Le principal message d'erreur, compréhensible par un humain (typiquement sur
une ligne). Toujours présent.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><symbol>PG_DIAG_MESSAGE_DETAIL</></term>
<listitem>
<para>
Détail&nbsp;: un message d'erreur secondaire et optionnel proposant plus
d'informations sur le problème. Peut être composé de plusieurs lignes.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><symbol>PG_DIAG_MESSAGE_HINT</></term>
<listitem>
<para>
Astuce&nbsp;: une suggestion supplémentaire sur ce qu'il vaut faire suite à
ce problème. Elle diffère du détail dans le fait qu'elle
offre un conseil (potentiellement inapproprié) plutôt que des faits bruts.
Peut être composé de plusieurs lignes.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><symbol>PG_DIAG_STATEMENT_POSITION</></term>
<listitem>
<para>
Une chaîne contenant un entier décimal indiquant le position du curseur d'erreur
comme index dans la chaîne d'instruction originale. Le premier caractère se
trouve à l'index 1 et les positions sont mesurées en caractères, et non pas en
octets.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><symbol>PG_DIAG_CONTEXT</></term>
<listitem>
<para>
Une indication du contexte dans lequel l'erreur est apparue. Actuellement, cela
inclut une trace de la pile d'appels des fonctions PL actives. La trace a une
entrée par ligne, la plus récente se trouvant au début.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><symbol>PG_DIAG_SOURCE_FILE</></term>
<listitem>
<para>
Le nom du fichier contenant le code source où l'erreur a été rapportée.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><symbol>PG_DIAG_SOURCE_LINE</></term>
<listitem>
<para>
Le numéro de ligne dans le code source où l'erreur a été rapportée.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><symbol>PG_DIAG_SOURCE_FUNCTION</></term>
<listitem>
<para>
Le nom de la fonction dans le code source où l'erreur a été rapportée.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
Le client est responsable du formatage des informations affichées pour
correspondre à ses besoins&nbsp;; en particulier, il doit supprimer les longues
lignes si nécessaires. Les caractères de retour chariot apparaissant dans les
champs de message d'erreur doivent être traités comme des changements de
paragraphes, pas comme des changements de lignes.
</para>

<para>
Les erreurs générées en interne par <application>libpq</application> ont une
sévérité et un message principal mais aucun autre champ. Les erreurs renvoyées
par un serveur utilisant un protocole antérieure à la 3.0 incluent la
sévérité et le message principal, et quelques fois un message détaillé, mais
aucun autre champ.
</para>

<para>
Notez que les champs d'erreurs sont seulement disponibles pour les objets
<structname>PGresult</structname>, et non pas pour les objets
<structname>PGconn</structname>&nbsp;; il n'existe pas de fonction
<function>PQerrorField</function>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQclear</function><indexterm><primary>PQclear</></></term>
<listitem>
<para>
          Libère le stockage associé à un <structname>PGresult</structname>.
          Chaque résultat de commande doit être libéré via
          <function>PQclear</function> lorsqu'il n'est plus nécessaire.
<synopsis>
void PQclear(PQresult *res);
</synopsis>
</para>

<para>
          Vous pouvez conserver un objet <structname>PGresult</structname>
          aussi longtemps que vous en avez besoin&nbsp;; il ne disparait pas 
          lorsque vous lancez une nouvelle commande, même pas si vous fermez la
          connexion. Pour vous en débarrasser, vous devez appeler
          <function>PQclear</function>. En cas d'oubli, votre application
          souffrira de fuites de mémoire.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQmakeEmptyPGresult</function><indexterm><primary>PQmakeEmptyPGresult</></></term>
<listitem>
<para>
          Construit un objet <structname>PGresult</structname> vide avec le
          statut donné.
<synopsis>
PGresult* PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
</synopsis>
</para>

<para>
Il s'agit d'une fonction interne de <application>libpq</> pour allouer et
initialiser un objet <structname>PGresult</structname> vide. Elle est exportée car
certaines applications la trouvent utiles pour générer eux-même des objets
résultats (particulièrement des objets avec des statuts d'erreur). Si
<parameter>conn</parameter> n'est pas NULL et que <parameter>status</> indique
une erreur, le message d'erreur actuel pour la connexion spécifiée est copié
dans <structname>PGresult</structname>. Notez que <function>PQclear</function>
doit être appelée sur l'objet, comme avec un
<structname>PGresult</structname> renvoyé par <application>libpq</application>
elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</sect2>

<sect2 id="libpq-exec-select-info">
  <title>Récupérer l'informations provenant des résultats des requêtes</title>

<para>
Ces fonctions sont utilisées pour extraire des informations provenant d'un objet
<structname>PGresult</structname> représentant un résultat valide pour une
requête (il a le statut <literal>PGRES_TUPLES_OK</literal>). Pour les objets
ayant d'autres valeurs de statut, elles agissent comme si le résultat n'avait
aucune ligne et aucune colonne.
</para>

<variablelist>
<varlistentry>
<term><function>PQntuples</function><indexterm><primary>PQntuples</></></term>
<listitem>
<para>
          Renvoie le nombre de lignes (tuples) du résultat de la requête.
<synopsis>
int PQntuples(const PGresult *res);
</synopsis>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQnfields</function><indexterm><primary>PQnfields</></></term>
<listitem>
<para>
          Renvoie le nombre de colonnes (champs) de chaque ligne du résultat de
          la requête.
<synopsis>
int PQnfields(const PGresult *res);
</synopsis>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQfname</function><indexterm><primary>PQfname</></></term>
<listitem>
<para>
          Renvoie le nom de la colonne associée avec le numéro de colonne donnée.
          Les numéros de colonnes commencent à zéro.
<synopsis>
char *PQfname(const PGresult *res,
              int column_number);
</synopsis>
</para>

<para>
<symbol>NULL</symbol> est renvoyé si le numéro de colonne est en dehors de la
plage.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQfnumber</function><indexterm><primary>PQfnumber</></></term>
<listitem>
<para>
          Renvoie le numéro de colonne associé au nom de la colonne donné.
<synopsis>
int PQfnumber(const PGresult *res,
              const char *column_name);
</synopsis>
</para>

<para>
        -1 est renvoyé si le nom donné ne correspond à aucune colonne.
</para>

<para>
        Le nom donné est traité comme un identifiant dans une commande SQL,
        c'est-à-dire qu'il est mis en minuscule sauf s'il est entre des
        guillemets doubles. Par exemple, pour le résultat de la requête
        suivante
<programlisting>
select 1 as FOO, 2 as "BAR";
</programlisting>
        nous obtenons les résultats suivants&nbsp;:
<programlisting>
PQfname(res, 0)              <lineannotation>foo</lineannotation>
PQfname(res, 1)              <lineannotation>BAR</lineannotation>
PQfnumber(res, "FOO")        <lineannotation>0</lineannotation>
PQfnumber(res, "foo")        <lineannotation>0</lineannotation>
PQfnumber(res, "BAR")        <lineannotation>-1</lineannotation>
PQfnumber(res, "\"BAR\"")    <lineannotation>1</lineannotation>
</programlisting>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQftable</function><indexterm><primary>PQftable</></></term>
<listitem>
<para>
 Renvoie l'OID de la table à partir de laquelle la colonne donnée a été
 récupérée. Les numéros de colonnes commencent à zéro.
<synopsis>
Oid PQftable(const PGresult *res,
             int column_number);
</synopsis>
</para>

<para>
<literal>InvalidOid</> est renvoyé si le numéro de colonne est en dehors de la
plage ou si la colonne spécifiée n'est pas une référence simple à une colonne de
table, ou lors de l'utilisation d'un protocole antérieur à la version 3.0. Vous
pouvez lancer des requêtes vers la table système <literal>pg_class</literal>
pour déterminer exactement quelle table est référencée.
</para>

<para>
          Le type <type>Oid</type> et la constante
          <literal>InvalidOid</literal> sont définis lorsque vous incluez le
          fichier d'en-tête <application>libpq</application>. Ils ont le même
          type entier.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQftablecol</function><indexterm><primary>PQftablecol</></></term>
<listitem>
<para>
 Renvoie le numéro de colonne (à l'intérieur de la table) de la colonne
 correspondant à la colonne spécifiée de résultat de la requête. Les numéros de
 colonnes resultat commencent à 0.
<synopsis>
int PQftablecol(const PGresult *res,
                int column_number);
</synopsis>
</para>

<para>
Zéro est renvoyé si le numéro de colonne est en dehors de la plage, ou si la 
colonne spécifiée n'est pas une simple référence à une colonne de table, ou
lors de l'utilisation d'un protocole antérieur à la version 3.0.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQfformat</function><indexterm><primary>PQfformat</></></term>
<listitem>
<para>
 Renvoie le code de format indiquant le format de la colonne donné. Les numéros
 de colonnes commencent à zéro.
<synopsis>
int PQfformat(const PGresult *res,
              int column_number);
</synopsis>
</para>

<para>
Le code de format zéro indique une représentation textuelle des données
alors qu'un code de format un indique une représentation binaire. (Les
autres codes sont réservés pour des définitions futures.)
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQftype</function><indexterm><primary>PQftype</></></term>
<listitem>
<para>
          Renvoie le type de données associé avec le numéro de colonne donné.
          L'entier renvoyé est le numéro OID interne du type. Les numéros de
          colonnes commencent à zéro.
<synopsis>
Oid PQftype(const PGresult *res,
            int column_number);
</synopsis>
</para>

<para>
Vous pouvez lancer des requêtes sur la table système <literal>pg_type</literal>
pour obtenir les noms et propriétés des différents types de données.
Les <acronym>OID</acronym> des types de données intégrés sont définis dans le
fichier <filename>src/include/catalog/pg_type.h</filename> de la distribution
des sources.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQfmod</function><indexterm><primary>PQfmod</></></term>
<listitem>
<para>
          Renvoie le modifieur de type de la colonne associée avec le numéro 
          de colonne donné. Les numéros de colonnes commencent à zéro.
<synopsis>
int PQfmod(const PGresult *res,
           int column_number);
</synopsis>
</para>

<para>
L'interprétation des valeurs du modificateur est spécifique au type&nbsp;;
elles indiquent la précision ou les limites de taille. La valeur -1 est
utilisée pour indiquer qu'<quote>aucune information n'est disponible</>. La
plupart des types de données n'utilisent pas les modificateurs, auquel cas la
valeur est toujours -1.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQfsize</function><indexterm><primary>PQfsize</></></term>
<listitem>
<para>
          Renvoie la taille en octets de la colonne associée avec le numéro de
          colonne donné. Les numéros de colonnes commencent à zéro.
<synopsis>
int PQfsize(const PGresult *res,
            int column_number);
</synopsis>
</para>

<para>
<function>PQfsize</> renvoie l'espace alloué pour cette colonne dans une ligne
de la base de données, en d'autres termes la taille de la représentation
interne du serveur du type de données. (De façon cohérente, ce n'est pas
réellement utile pour les clients.) Une valeur négative indique que les types de
données ont une longueur variable.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQbinaryTuples</function><indexterm><primary>PQbinaryTuples</></></term>
<listitem>
<para>
Renvoie 1 si <structname>PGresult</> contient des données binaires et 0 s'il
contient des données texte.
<synopsis>
int PQbinaryTuples(const PGresult *res);
</synopsis>
</para>

<para>
Cette fonction est obsolète (sauf dans le cas d'une utilisation en relation avec
<command>COPY</>) car un <structname>PGresult</> peut contenir du texte
dans certaines colonnes et des données binaires dans d'autres.
<function>PQfformat</> est la fonction préférée. <function>PQbinaryTuples</>
renvoie 1 seulement si toutes les colonnes du résultat sont dans un format
binaire (format 1).
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQgetvalue</function><indexterm><primary>PQgetvalue</></></term>
<listitem>
<para>
            Renvoie la valeur d'un seul champ d'une (seule) ligne d'un
            <structname>PGresult</structname>. Les numéros de lignes et de
            colonnes commencent à zéro.
<synopsis>
char* PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);
</synopsis>
</para>

<para>
Pour les données au format texte, la valeur renvoyée par
<function>PQgetvalue</function> est une représentation au format chaîne de
caractères terminée par un octet nul de la valeur du champ. Pour les données au
format binaire, la valeur est dans la représentation binaire déterminée par les
fonctions <function>typsend</> et <function>typreceive</> de la donnée. 
(La valeur est en fait suivie d'un octet zéro dans ce
cas aussi mais ce n'est pas réellement utile car la valeur elle même peut
contenir des octets nuls.)
</para>

<para>
Une chaîne vide est renvoyée si la valeur du champ est nulle. Voir
<function>PQgetisnull</> pour distinguer les valeurs nulles des valeurs de
chaîne vide.
</para>

<para>
Le pointeur renvoyé par <function>PQgetvalue</function> pointe vers un espace 
mémoire de la structure <structname>PGresult</structname>. 
Il ne faut pas modifier les données vers lesquelles il pointe.
Il faut recopier ces données si on souhaite les utiliser après la disparition
de la structure <structname>PGresult</structname>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQgetisnull</function><indexterm><primary>PQgetisnull</></></term>
<indexterm><primary>valeur nulle</><secondary sortas="libpq">dans
libpq</></indexterm><listitem>
<para>
           Teste un champ pour savoir s'il est nul. Les numéros de lignes et de
           colonnes commencent à zéro.
<synopsis>
int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
</para>

<para>
Cette fonction renvoie 1 si le champ est nul et 0 s'il contient une valeur non
nulle. (Notez que <function>PQgetvalue</function> renvoie une chaîne vide, et
non pas un pointeur nul, pour un champ nul.)
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQgetlength</function><indexterm><primary>PQgetlength</></></term>
<listitem>
<para>
          Renvoie la longueur réelle de la valeur d'un champ en octet. Les
          numéros de lignes et de colonnes commencent à zéro.
<synopsis>
int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
</para>

<para>
C'est la longueur réelle des données pour la valeur particulière des données,
c'est-à-dire la taille de l'objet pointé par <function>PQgetvalue</function>.
Pour le format textuel, c'est identique à <function>strlen()</>. Pour le format
binaire, c'est une information essentielle. Notez qu'il ne faut <emphasis>pas</>
se fier à <function>PQfsize</function> pour obtenir la taille réelle des données.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQprint</function><indexterm><primary>PQprint</></></term>
<listitem>
<para>
          Affiche toutes les lignes et, optionnellement, les noms des colonnes
          dans le flux de sortie spécifié.
<synopsis>
void PQprint(FILE* fout,      /* flux de sortie */
             const PGresult *res,
             const PQprintOpt *po);

typedef struct {
    pqbool  header;      /* affiche le en-têtes des champs et le nombre de
                            lignes */
    pqbool  align;       /* aligne les champs */
    pqbool  standard;    /* vieux format (mort) */
    pqbool  html3;       /* affiche les tables en HTML */
    pqbool  expanded;    /* étend les tables */
    pqbool  pager;       /* utilise le paginateur pour la sortie si nécessaire
                            */
    char    *fieldSep;   /* séparateur de champ */
    char    *tableOpt;   /* attributs des éléments de table HTML */
    char    *caption;    /* titre de la table HTML */
    char    **fieldName; /* Tableau terminé par un NULL des noms de remplacement
                            des champs */
} PQprintOpt;
</synopsis>
</para>

<para>
Cette fonction était auparavant utilisée par <application>psql</application>
pour afficher les résultats des requêtes mais ce n'est plus le cas. Notez
qu'elle suppose que les données sont dans un format textuel.
</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="libpq-exec-nonselect">
  <title>Récupérer les informations de résultats pour les autres
   commandes</title>

<para>
Ces fonctions sont utilisées pour extraire des informations des objets
<structname>PGresult</structname> qui ne sont pas les résultats d'instructions
<command>SELECT</>.
</para>

<variablelist>
<varlistentry>
<term><function>PQcmdStatus</function><indexterm><primary>PQcmdStatus</></></term>
<listitem>
<para>
          Renvoie l'état de la commande depuis l'instruction SQL qui a généré le
          <structname>PGresult</structname>.
<synopsis>
char * PQcmdStatus(PGresult *res);
</synopsis>
</para>
<para>
souvent, c'est juste le nom de la commande mais elle peut inclure des
données supplémentaires comme le nombre de lignes traitées.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQcmdTuples</function><indexterm><primary>PQcmdTuples</></></term>
<listitem>
<para>
          Renvoie le nombre de lignes affectées par la commande SQL.
<synopsis>
char * PQcmdTuples(PGresult *res);
</synopsis>
</para>

<para>
          Si la commande <acronym>SQL</acronym> qui a généré
          <structname>PGresult</structname> était une instruction
          <command>INSERT</>, <command>UPDATE</>, <command>DELETE</command>,
          <command>MOVE</> ou <command>FETCH</>, cette fonction renvoie une
          chaîne contenant le nombre de lignes affectées. Si la commande était
          autre chose, elle renvoie une chaîne vide.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQoidValue</function><indexterm><primary>PQoidValue</></></term>
<listitem>
<para>
          Renvoie l'OID<indexterm><primary>OID</><secondary>dans
          libpq</></> de la ligne insérée, si la commande
          <acronym>SQL</acronym> était une instruction
          <command>INSERT</command> qui a inséré exactement une ligne dans un
          table comprenant des OIDs. Sinon, renvoie
          <literal>InvalidOid</literal>.
<synopsis>
Oid PQoidValue(const PGresult *res);
</synopsis>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQoidStatus</function><indexterm><primary>PQoidStatus</></></term>
<listitem>
<para>
          Renvoie une chaîne avec l'OID de la ligne insérée si la commande
          <acronym>SQL</acronym> était une instruction
          <command>INSERT</command>. (La chaîne vaut <literal>0</> si
          l'instruction <command>INSERT</command> a inséré plusieurs lignes
          ou si la table cible n'a pas d'OIDs.)  Si la commande n'était pas un
          <command>INSERT</command>, renvoie une chaîne vide.
<synopsis>
char * PQoidStatus(const PGresult *res);
</synopsis>
</para>

<para>
Cette fonction est obsolète et remplacée par <function>PQoidValue</function>.
Elle n'est pas compatible avec les threads.
</para>
</listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2 id="libpq-exec-escape-string">
  <title>Chaînes d'échappement à inclure dans les commandes SQL</title>

   <indexterm zone="libpq-exec-escape-string"><primary>PQescapeStringConn</></>
   <indexterm zone="libpq-exec-escape-string"><primary>PQescapeString</></>
   <indexterm zone="libpq-exec-escape-string"><primary>chaînes
d'échappement</></>

<para>
<function>PQescapeStringConn</function> échappe une chaîne à utiliser dans une
commande SQL. Ceci est utile lors de l'insertion de valeurs en tant que constantes
littérales. Certains caractères (tels que les guillemets et les anti-slashs "\")
doivent être échappés pour ne pas être interprétés par
l'analyseur SQL. <function>PQescapeStringConn</> réalise cette opération.
</para>

<tip>
<para>
Il est tout particulièrement important de faire cet échappement proprement lors
de la gestion de chaînes reçues d'une source non sûre. Sinon, il existe un
risque de sécurité&nbsp;: vous êtes vulnérable à une attaque par
<quote>injection de SQL</> où des commandes SQL non souhaitées
sont injectées dans votre base de données.
</para>
</tip>

<para>
Notez qu'il n'est ni nécessaire ni correct de faire un échappement
lorsque une valeur est passée comme paramètre séparé dans
<function>PQexecParams</> ou ses routines similaires.

<synopsis>
size_t PQescapeStringConn (PGconn *conn,
                           char *to, const char *from, size_t length,
                           int *error);
</synopsis>
</para>

<para>
<function>PQescapeStringConn</> écrit une version échappée de la chaîne
<parameter>from</> dans le tampon <parameter>to</>, en échappant les
caractères spéciaux de façon à ce qu'ils ne puissent causer aucun problème.
et en ajoutant un octet nul de terminaison. Les guillemets simples qui
doivent entourer les chaînes <productname>PostgreSQL</> ne sont pas
incluses dans la chaîne résultante&nbsp;; ils doivent être fournis dans la
commande SQL où le résultat sera inséré.
Le paramètre <parameter>from</> pointe le premier caractère d'une chaîne à
échapper et le paramètre <parameter>length</> donne le nombre d'octets
dans cette chaîne. Un octet de terminaison, zéro, n'est pas requis et ne
doit pas être compté dans <parameter>length</>. (Si un octet de terminaison
est trouvé avant que <parameter>length</> octets ne soient traités,
<function>PQescapeStringConn</> s'arrête au zéro&nbsp;; le comportement ressemble
donc à <function>strncpy</>.) <parameter>to</> doit pointer vers un tampon
capable de contenir au moins un octet de plus que le double de la valeur de
<parameter>length</>, sinon le comportement est indéfini. Le comportement est
indéfini si les chaînes <parameter>to</> et <parameter>from</> se recouvrent.
</para>
<para>
Si le paramètre <parameter>error</> n'est pas NULL, alors <literal>*error</>
est initialisé à zéro en cas de succès et à une valeur différente de zéro dans
le cas contraire. Actuellement, les seules conditions d'erreurs possibles
impliquent un codage multi-octets invalide dans la chaîne en entrée. La chaîne
en sortie est toujours générée en cas d'erreur mais il est probable que le
serveur la rejettera en indiquant qu'elle est malformée. En cas d'erreur, un
message adéquat est stocké dans l'objet <parameter>conn</>, que <parameter>error</>
soit NULL ou non.
</para>
<para>
<function>PQescapeStringConn</> renvoie le nombre d'octets écrits dans
<parameter>to</>, sans l'octet de terminaison.
</para>

<para>
<synopsis>
size_t PQescapeString (char *to, const char *from, size_t length);
</synopsis>
</para>

<para>
<function>PQescapeString</> est une version obsolète de
<function>PQescapeStringConn</>&nbsp;; la différence réside dans le fait
qu'elle ne prend pas de paramètres <parameter>conn</> ou <parameter>error</>.
À cause de ceci, elle ne peut ajuster son comportement suivant les propriétés
de la connexion comme le codage des caractères et donc <emphasis>elle pourrait
renvoyer des résultats faux</>. De plus, il n'existe aucun moyen de renvoyer
les conditions de l'erreur.
</para>
<para>
<function>PQescapeString</> peut être utilisé sereinement dans les programmes
clients à un seul thread et fonctionnant avec une seule connexion
<productname>PostgreSQL</> à la fois (dans ce cas, il peut trouver les informations
qui l'intéressent <quote>en arrière-plan</>). Les autres contextes devraient être
évités et <function>PQescapeStringConn</> devrait être utilisé à la place.
</para>
</sect2>


 <sect2 id="libpq-exec-escape-bytea">
  <title>Échapper des chaînes binaires pour une inclusion dans des commandes
   SQL</title>

  <indexterm zone="libpq-exec-escape-bytea">
   <primary>bytea</>
   <secondary sortas="libpq">dans libpq</>
  </indexterm>

  <variablelist>
  <varlistentry>
  <term><function>PQescapeByteaConn</function><indexterm><primary>PQescapeByteaConn</></></term>
  <listitem>
  <para>
   Échappe des données binaires à utiliser à l'intérieur d'une commande SQL avec
   le type <type>bytea</type>. Comme avec <function>PQescapeStringConn</function>,
   <function>PQescapeBytea</function> est seulement utilisée pour insérer des 
   données directement dans une chaîne de commande SQL.
<synopsis>
unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);
</synopsis>
</para>

<para>
   Certaines valeurs d'octets <emphasis>doivent</emphasis> être échappées (mais
   toutes les valeurs d'octets <emphasis>peuvent</emphasis> être échappées)
   lorsqu'elles font partie d'un littéral <type>bytea</type> dans une
   instruction <acronym>SQL</acronym>. En général, pour échapper un octet, il
   est converti dans en un nombre à trois chiffres correspondant à sa valeur
   octale et précédé par un ou deux anti-slashs. Le guillemet simple et caractère
   anti-slash ont des séquences d'échappements alternatives. Voir <xref
   linkend="datatype-binary"> pour plus d'informations.
   <function>PQescapeByteaConn</function> réalise cette opération en échappant
   seulement les octets requis.
  </para>

  <para>
   Le paramètre <parameter>from</parameter> pointe sur le premier octet de la
   chaîne à échapper et le paramètre <parameter>from_length</parameter> donne le
   nombre d'octets de cette chaîne binaire. (Un octet zéro de terminaison n'est
   ni nécessaire ni compté.) Le paramètre <parameter>to_length</parameter>
   pointe vers une variable qui contiendra la longueur de la chaîne échappée
   résultante. Cette longueur inclue l'octet zéro de terminaison.
  </para>

  <para>
   <function>PQescapeByteaConn</> renvoie une version échappée du paramètre
   <parameter>from</parameter> dans de la mémoire allouée avec
   <function>malloc()</>. Cette mémoire doit être libérée avec
   <function>PQfreemem</> lorsque le résultat n'est plus nécessaire. Tous les
   caractères spéciaux de la chaîne de retour sont remplacés de façon à ce
   qu'ils puissent être traités proprement par l'analyseur de chaînes littérales
   de <productname>PostgreSQL</productname> et par l'entrée
   <type>bytea</type> de la fonction. Un octet zéro de terminaison est aussi
   ajouté. Les guillemets simples qui englobent les chaînes littérales de
   <productname>PostgreSQL</productname> ne font pas partie de la chaîne
   résultante.
  </para>

  <para>
   En cas d'erreur, un pointeur NULL est renvoyé et un message d'erreur adéquat
   est stocké dans l'objet <parameter>conn</>. Actuellement, la seule erreur
   possible est une mémoire insuffisante pour stocker la chaîne résultante.
  </para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><function>PQescapeBytea</function><indexterm><primary>PQescapeBytea</></></term>
  <listitem>
  <para>
   <function>PQescapeBytea</> est une version obsolète de
   <function>PQescapeByteaConn</>.
<synopsis>
unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);
</synopsis>
</para>

<para>
   La seule différence avec <function>PQescapeByteaConn</> est que
   <function>PQescapeBytea</> ne prend pas de paramètre
   <structname>PGconn</>. À cause de ceci, il ne peut ajuster son comportement
   suivant les propriétés de la connexion (en particulier si les chaînes
   conformes au standard sont activées) et, du coup, <emphasis>il pourrait
   donner de mauvais résultats</>. De plus, il n'a aucun moyen de renvoyer un
   message d'erreur en cas d'échec.
  </para>

  <para>
   <function>PQescapeBytea</> peut être utilisé en toute sécurité dans les
   programmes clients avec un seul thread et fonctionnant avec une seule
   connexion <productname>PostgreSQL</> en même temps (dans ce cas, il peut
   trouver ce dont il a besoin de savoir <quote>en arrière-plan</>). Dans
   d'autres contextes, il devrait être remplacé par <function>PQescapeByteaConn</>.
  </para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><function>PQunescapeBytea</function><indexterm><primary>PQunescapeBytea</></></term>
  <listitem>
  <para>
   Convertit une représentation de la chaîne en donnés binaires --
   l'inverse de <function>PQescapeBytea</function>. Ceci est nécessaire lors de
   la récupération de données <type>bytea</type> en format texte, mais pas lors
   de leur récupération au format binaire.

<synopsis>
unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
</synopsis>
</para>

<para>
   Le paramètre <parameter>from</parameter> pointe vers une chaîne de
   telle façon qu'elle pourrait provenir de <function>PQgetvalue</function>
   lorsque la colonne est de type <type>bytea</type>.
   <function>PQunescapeBytea</function> convertit cette représentation de la
   chaîne en sa représentation binaire. Elle renvoie une pointeur vers un tampon
   alloué avec <function>malloc()</function>, ou NULL en cas d'erreur, et place
   la taille du tampon dans <parameter>to_length</parameter>. Le résultat doit
   être libéré en utilisant <function>PQfreemem</> lorsqu'il n'est plus
   nécessaire.
  </para>

  <para>
   La conversion n'est pas l'inverse exacte de <function>PQescapeBytea</function>
   car la chaîne n'est pas échappée avec <function>PQgetvalue</function>. Cela
   signifie en particulier qu'il n'y a pas besoin de réfléchir à la mise entre
   guillemets de la chaîne, et donc pas besoin d'un paramètre <structname>PGconn</>.
  </para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><function>PQfreemem</function><indexterm><primary>PQfreemem</></></term>
  <listitem>
  <para>
   Libère la mémoire allouée par <application>libpq</>.
<synopsis>
void PQfreemem(void *ptr);
</synopsis>
</para>

<para>
   Libère la mémoire allouée par <application>libpq</>, particulièrement
   <function>PQescapeByteaConn</function>,
   <function>PQescapeBytea</function>,
   <function>PQunescapeBytea</function>,
   et <function>PQnotifies</function>.
   C'est nécessaire pour Microsoft Windows, qui ne peut pas libérer la mémoire
   des DLL, sauf dans le cas où des DLL multithreadés (<option>/MD</option> dans
   VC6) sont utilisées. Pour les autres plateformes, cette fonction est
   identique à la fonction <function>free()</> de la bibliothèque standard.
  </para>
  </listitem>
  </varlistentry>
  </variablelist>
   
 </sect2>
</sect1>

<sect1 id="libpq-async">
<title>Traitement des commandes asynchrones</title>

  <indexterm zone="libpq-async"><primary>connexion non bloquante</></>

<para>
La fonction <function>PQexec</function> est parfaite pour soumettre des
commandes aux applications standards, synchrones. Néanmoins, elle a quelques
déficiences qui peuvent être importantes pour certaines utilisateurs&nbsp;:

<itemizedlist>
<listitem>
<para>
<function>PQexec</function> attend que la commande se termine. L'application
pourrait avoir d'autres travaux à réaliser (comme le rafraichissement de
l'interface utilisateur), auquel cas il ne voudra pas être bloqué en attente
de la réponse.
</para>
</listitem>
<listitem>
<para>
Comme l'exécution de l'application cliente est suspendue en attendant le
résultat, il est difficile pour l'application de décider qu'elle voudrait
annuler la commande en cours. (C'est possible avec un gestionnaire de signaux
mais pas autrement.)
</para>
</listitem>
<listitem>
<para>
<function>PQexec</function> ne peut renvoyer qu'une structure
<structname>PGresult</structname>. Si la chaîne de commande soumise contient
plusieurs commandes <acronym>SQL</acronym>, toutes les structures
<structname>PGresult</structname> sont annulées par
<function>PQexec</function>, sauf la dernière.
</para>
</listitem>
</itemizedlist>
</para>

<para>
Les applications qui n'apprécient pas ces limitations peuvent utiliser à la
place les fonctions sous-jacentes à partir desquelles
<function>PQexec</function> est construite&nbsp;:
<function>PQsendQuery</function> et <function>PQgetResult</function>. Il existe
aussi <function>PQsendQueryParams</function> et
<function>PQsendQueryPrepared</function>, pouvant être utilisées avec
<function>PQgetResult</function> pour dupliquer les fonctionnalités de
respectivement <function>PQexecParams</function> et
<function>PQexecPrepared</function>.

<variablelist>
<varlistentry>
<term><function>PQsendQuery</function><indexterm><primary>PQsendQuery</></></term>
<listitem>
<para>
          Soumet une commande au serveur sans attendre le(s) résultat(s). 1 est
          renvoyé si la commande a été correctement envoyée et 0 sinon (dans ce
          cas, utilisez la fonction <function>PQerrorMessage</> pour obtenir
          plus d'informations sur l'échec).
<synopsis>
int PQsendQuery(PGconn *conn, const char *command);
</synopsis>

          Après un appel réussi à <function>PQsendQuery</function>, appelez
          <function>PQgetResult</function> une ou plusieurs fois pour obtenir
          les résultats. <function>PQsendQuery</function> ne peut être appelée
          de nouveau (sur la même connexion) tant que 
          <function>PQgetResult</function> n'a pas renvoyé un pointeur nul,
          indiquant que la commande est terminée.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQsendQueryParams</function><indexterm><primary>PQsendQueryParams</></></term>
<listitem>
<para>
          Soumet une commande et des paramètres séparés au serveur sans
          attendre le(s) résultat(s).
<synopsis>
int PQsendQueryParams(PGconn *conn,
                      const char *command,
                      int nParams,
                      const Oid *paramTypes,
                      const char * const *paramValues,
                      const int *paramLengths,
                      const int *paramFormats,
                      int resultFormat);
</synopsis>

        Ceci est équivalent à <function>PQsendQuery</function> sauf que les
        paramètres de requêtes peuvent être spécifiés séparément de la chaîne de
        requête. Les paramètres de la fonction sont gérés de façon identique à
        <function>PQexecParams</function>. Comme
        <function>PQexecParams</function>, <function>PQsendQueryParams</function>
        ne fonctionne pas pour les connexions utilisant le protocole 2.0 et 
        ne permet qu'une seule commande dans la chaîne de requête.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQsendQueryPrepared</function><indexterm><primary>PQsendQueryPrepared</></></term>
<listitem>
<para>
          Envoie une requête pour exécuter une instruction préparée, avec les
          paramètres donnés, sans attendre le(s) résultat(s).
<synopsis>
int PQsendQueryPrepared(PGconn *conn,
                        const char *stmtName,
                        int nParams,
                        const char * const *paramValues,
                        const int *paramLengths,
                        const int *paramFormats,
                        int resultFormat);
</synopsis>

        Cette fonction est similaire à <function>PQsendQueryParams</function> mais la
        commande à exécuter est spécifiée en nommant une instruction
        précédemment préparée au lieu de donner une chaîne contenant la
        requête. Les paramètres de la fonction sont gérés de façon identique à
        <function>PQexecPrepared</function>. Comme
        <function>PQexecPrepared</function>, <function>PQsendQueryPrepared</function>
        ne fonctionne pas pour les connexions utilisant le protocole 2.0.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQgetResult</function><indexterm><primary>PQgetResult</></></term>
<listitem>
<para>
          Attend le prochain résultat d'un appel précédent à
          <function>PQsendQuery</function>,
          <function>PQsendQueryParams</function> ou
          <function>PQsendQueryPrepared</function>, et le renvoie. Un pointeur
          nul est renvoyé quand la commande est terminée et qu'il n'y aura plus
          de résultats.
<synopsis>
PGresult *PQgetResult(PGconn *conn);
</synopsis>
</para>

<para>
          <function>PQgetResult</function> doit être appelée de façon répétée
          jusqu'à ce qu'elle retourne un pointeur nul indiquant que la commande
          s'est terminée. (Si elle est appelée à un moment où aucune commande n'est
          active, <function>PQgetResult</function> renvoie un
          pointeur nul dès la première fois.) Chaque résultat non nul provenant de
          <function>PQgetResult</function> doit être traité en utilisant les
          mêmes fonctions d'accès à <structname>PGresult</> que celles
          précédemment décrites. N'oubliez pas de libérer chaque objet résultat
          avec <function>PQclear</function> une fois que vous en avez terminé.
          Notez que <function>PQgetResult</function> bloque seulement si la
          commande est active et que les données nécessaires en réponse n'ont
          pas encore été lues par <function>PQconsumeInput</function>.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
Utiliser <function>PQsendQuery</function> et <function>PQgetResult</function>
résout un des problèmes de <function>PQexec</function>&nbsp;: si une chaîne de
commande contient plusieurs commandes <acronym>SQL</acronym>, les résultats de
ces commandes peuvent être obtenus individuellement. (Ceci permet une forme
simple de traitement en parallèle&nbsp;: le client peut gérer les résultats
d'une commande alors que le serveur travaille sur d'autres requêtes de la même
chaîne de commandes.) Néanmoins, appeler <function>PQgetResult</function>
cause toujours un blocage du client jusqu'à la fin de la prochaine commande
<acronym>SQL</acronym>. Ceci est évitable en utilisant proprement deux
fonctions supplémentaires&nbsp;:

<variablelist>
<varlistentry>
<term><function>PQconsumeInput</function><indexterm><primary>PQconsumeInput</></></term>
<listitem>
<para>
          Si une entrée est disponible à partir du serveur, elle est consommée.
<synopsis>
int PQconsumeInput(PGconn *conn);
</synopsis>
</para>

<para>
<function>PQconsumeInput</function> renvoie normalement 1 ce qui indique
<quote>aucune erreur</quote>, mais renvoie zéro s'il y a eu une erreur (auquel
cas <function>PQerrorMessage</function> peut être consultée). Notez que le
résultat ne dit pas si des données ont été récupérées en entrées. Après avoir
appelé <function>PQconsumeInput</function>, l'application doit vérifier
<function>PQisBusy</function> et/ou <function>PQnotifies</function> pour voir
si leur état a changé.
</para>
<para>
<function>PQconsumeInput</function> peut être appelée même si l'application
n'est pas encore préparé à gérer un résultat ou une notification. La fonction
lit les données disponibles et les sauvegarde dans un tampon, ce qui remet à zéro 
l'indication qu'une lecture de <function>select()</function> est disponible.
L'application peut donc utiliser <function>PQconsumeInput</function> pour
effacer la condition <function>select()</function> immédiatement, puis 
examiner les résultats plus tard à sa guise.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQisBusy</function><indexterm><primary>PQisBusy</></></term>
<listitem>
<para>
Renvoie 1 si une commande est occupée, c'est-à-dire si
<function>PQgetResult</function> bloquerait en attendant une entrée. Un zéro
indique que <function>PQgetResult</function> peut être appelée avec
l'assurance de ne pas être bloquée.
<synopsis>
int PQisBusy(PGconn *conn);
</synopsis>
</para>

<para>
<function>PQisBusy</function> ne tente pas elle-même de lire les données à
partir du serveur&nbsp;; du coup, <function>PQconsumeInput</function> doit être
appelée d'abord, sans quoi l'état occupé ne s'arrêtera jamais.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
Une application typique de l'utilisation des ces fonctions a une boucle
principale utilisant <function>select()</function> ou <function>poll()</> pour
attendre toutes les conditions auxquelles elle doit répondre. Une des conditions
est que des données sont disponibles à partir du serveur, ce qui signifie pour
<function>select()</function> des données lisibles sur le descripteur de
fichier identifié par <function>PQsocket</function>. Lorsque la boucle
principale détecte la disponibilité de données, elle doit appeler
<function>PQconsumeInput</function> pour lire l'entête. Elle peut ensuite appeler
<function>PQisBusy</function> puis <function>PQgetResult</function> si
<function>PQisBusy</function> renvoie false (0). Elle peut aussi appeler 
<function>PQnotifies</function> pour détecter les messages <command>NOTIFY</> 
(voir <xref linkend="libpq-notify">).
</para>

<para>
Un client qui utilise
<function>PQsendQuery</function>/<function>PQgetResult</function> peut aussi
tenter d'annuler une commande en cours de traitement par le
serveur.<indexterm><primary>annulation</><secondary>de commande SQL</></>

<variablelist>
<varlistentry>
<term><function>PQrequestCancel</function><indexterm><primary>PQrequestCancel</></></term>
<listitem>
<para>
          Demande au serveur d'abandonner le traitement de la commande
          en cours.
<synopsis>
int PQrequestCancel(PGconn *conn);
</synopsis>
</para>

<para>
Le code de retour est 1 si la demande d'annulation a été correctement envoyée
et 0 sinon. (Si non, <function>PQerrorMessage</function> dira pourquoi.) Un
envoi correct ne garantit pas que la demande aura un effet. Quel que soit le
code de retour de <function>PQrequestCancel</function>, l'application doit
continuer la séquence normale de lecture/résultat en utilisant
<function>PQgetResult</function>. Si l'annulation est réelle, la commande
en cours se termine rapidement et renvoie un résultat d'erreur. Si l'annulation
échoue (par exemple parce que le serveur a déjà terminé l'exécution de la
commande), aucun résultat n'est visible.
</para>

<para>
Notez que si la commande en cours fait partie d'un bloc de transaction,
l'annulation est effective pour la transaction complète.
</para>

<para>
<function>PQrequestCancel</function> peut être appelée en toute sécurité depuis
un gestionnaire de signaux. Donc, il est aussi possible de l'utiliser avec des
<function>PQexec</function>, si la décision d'annuler doit être faite dans un
gestionnaire de signaux. Par exemple, <application>psql</application> appelle
<function>PQrequestCancel</function> à partir du gestionnaire du signal
<symbol>SIGINT</>, autorisant du coup l'annulation interactive des commandes
qu'il envoie via <function>PQexec</function>.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
En utilisant les fonctions décrites ci-dessus, il est possible d'éviter le
blocage pendant l'attente de données du serveur. Néanmoins, il est toujours
possible que l'application se bloque en attendant l'envoi vers le serveur.
C'est relativement peu fréquent mais cela peut arriver si de très longues
commandes SQL ou données sont envoyées. (C'est bien plus probable si
l'application envoie des données via <command>COPY IN</command>.)  Pour
empêcher cette possibilité et réussir des opérations de bases de données
totalement non bloquantes, les fonctions supplémentaires suivantes peuvent
être utilisées.

<variablelist>
<varlistentry>
 <term><function>PQsetnonblocking</function><indexterm><primary>PQsetnonblocking</></></term>
 <listitem>
   <para>
    Initialise le statut non bloquant de la connexion.
<synopsis>
int PQsetnonblocking(PGconn *conn, int arg);
</synopsis>
</para>

<para>
    Initialise l'état de la connexion à non bloquant si   
    <parameter>arg</parameter> vaut 1 et à bloquant si
    <parameter>arg</parameter> vaut 0. Renvoie 0 si OK, -1 en cas d'erreur.
   </para>
   <para>
    Dans l'état non bloquant, les appels à
    <function>PQsendQuery</function>,
    <function>PQputline</function>, <function>PQputnbytes</function>,
    et <function>PQendcopy</function> ne bloquent pas mais renvoient à la
    place une erreur s'ils ont besoin d'être de nouveau appelés.
   </para>
   <para>
    Notez que <function>PQexec</function> n'honore pas le mode non
    bloquant&nbsp;; si elle est appelée, elle agira d'une façon bloquante 
    malgré tout.
   </para>
 </listitem>
</varlistentry>

<varlistentry>
<term><function>PQisnonblocking</function><indexterm><primary>PQisnonblocking</></></term>
<listitem>
<para>
       Renvoie le statut bloquant ou non de la connexion à la base de données.
<synopsis>
int PQisnonblocking(const PGconn *conn);
</synopsis>
</para>

<para>
       Renvoie 1 si la connexion est en mode non bloquant, 0 dans le 
       cas contraire.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQflush</function><indexterm><primary>PQflush</></></term>
<listitem>
<para>
Tente de vider les données en attente d'envoi vers le serveur. Renvoie 0 en cas de
succès (ou si la queue d'envoi est vide), -1 en cas d'échec quelle que soit la
raison ou 1 si elle n'a pas encore pu envoyer toutes les données dans la
queue d'envoi (ce cas arrive seulement si la connexion est non bloquante).
<synopsis>
int PQflush(PGconn *conn);
</synopsis>
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
Après avoir envoyé une commande ou des données dans une connexion non bloquante,
appelez <function>PQflush</function>. Si elle renvoie 1, attendez que la socket
soit disponible en écriture et appelez-la de nouveau&nbsp;; répétez cela jusqu'à
ce qu'elle renvoie 0. Une fois que <function>PQflush</function> renvoie 0,
attendez que la socket soit disponible en lecture puis lisez la réponse comme
décrit ci-dessus.
</para>

</sect1>

<sect1 id="libpq-fastpath">
<title>Interface à chemin rapide</title>

<indexterm zone="libpq-fastpath"><primary>fast path</></>

<indexterm zone="libpq-fastpath"><primary>chemin rapide</></>

<para>
<productname>PostgreSQL</productname> fournit une interface rapide pour
envoyer des appels de fonctions simples au serveur.
</para>

<tip>
<para>
Cette interface est quelque peu obsolète car vous pourriez obtenir des
performances similaires et plus de fonctionnalités en initialisant une
instruction préparée pour définir l'appel de fonction, puis en exécutant
l'instruction avec une transmission binaire des paramètres et des 
de résultats.
</para>
</tip>

<para>
La fonction <function>PQfn</function><indexterm><primary>PQfn</></> demande
l'exécution d'une fonction du serveur via l'interface de chemin rapide&nbsp;:
<synopsis>
PGresult* PQfn(PGconn* conn,
               int fnid,
               int *result_buf,
               int *result_len,
               int result_is_int,
               const PQArgBlock *args,
               int nargs);

typedef struct {
    int len;
    int isint;
    union {
        int *ptr;
        int integer;
    } u;
} PQArgBlock;
</synopsis>
</para>

<para>
     L'argument <parameter>fnid</> est l'OID de la fonction à exécuter.
     <parameter>args</> et <parameter>nargs</> définissent les paramètres à
passer à la fonction&nbsp;; ils doivent correspondre à la liste des arguments
déclarés de la fonction. Quand le champ <parameter>isint</> d'une structure est
vrai, la valeur de <parameter>u.integer</> est envoyée au serveur en tant
qu'entier de la longueur indiquée (qui doit être 1, 2 ou 4 octets)&nbsp;; les
bons échanges d'octets se passent. Quand <parameter>isint</> est faux, le
nombre d'octets indiqué sur <parameter>*u.ptr</> est envoyé au
traitement&nbsp;; les données doivent être dans le format attendu par le
serveur pour la transmission binaire du type de données de l'argument de la
fonction. <parameter>result_buf</parameter> est le tampon dans lequel sera placé le
code de retour. L'appelant doit avoir alloué suffisamment d'espace pour stocker
le code de retour. (Il n'y a pas de vérification&nbsp;!) La longueur réelle
du résultat est renvoyé dans l'entier pointé par
<parameter>result_len</parameter>. Si un résultat sur un entier de 1, 2 ou
4 octets est attendu, initialisez <parameter>result_is_int</parameter> à 1,
sinon initialisez-le à 0. Initialiser <parameter>result_is_int</parameter> à 1
fait que <application>libpq</> échange les octets de la valeur si nécessaire,
de façon à ce que la bonne valeur <type>int</type> soit délivrée pour la
machine cliente. Quand <parameter>result_is_int</> vaut 0, la chaîne d'octets
au format binaire envoyée par le serveur est renvoyée non modifiée.
</para>

<para>
<function>PQfn</function> renvoie toujours un pointeur
<structname>PGresult</structname> valide. L'état du résultat doit être
vérifié avant que le résultat ne soit utilisé. Le demandeur est responsable de
la libération de la structure <structname>PGresult</structname>  avec
<function>PQclear</function> lorsque celle-ci n'est plus nécessaire.
</para>

<para>
Notez qu'il n'est pas possible de gérer les arguments nuls, les résultats nuls
et les résultats d'ensembles nuls en utilisant cette interface.
</para>

</sect1>

<sect1 id="libpq-notify">
<title>Notification asynchrone</title>

  <indexterm zone="libpq-notify">
   <primary>NOTIFY</primary>
   <secondary>dans libpq</secondary>
  </indexterm>

<para>
<productname>PostgreSQL</productname> propose des notifications asynchrone via
les commandes <command>LISTEN</command> and <command>NOTIFY</command>. Une
session cliente enregistre son intérêt pour une notification particulière avec 
la commande <command>LISTEN</command> (et peut arrêter son écoute avec la
commande <command>UNLISTEN</command>). Toutes les sessions écoutant une
condition particulière sont notifiées de façon asynchrone lorsqu'une commande
<command>NOTIFY</command> avec ce nom de condition est exécutée par une
session. Aucune autre information n'est passée du notifieur au notifié. Du
coup, souvent, toute donnée qui a besoin d'être communiquée est transférée
via une table de la base. D'habitude, le nom de la condition est identique à la
table associée mais il n'est pas nécessaire d'avoir une table associée.
</para>

<para>
Les applications <application>libpq</application> soumettent les commandes
<command>LISTEN</command> et <command>UNLISTEN</command> comme des commandes
SQL ordinaires. L'arrivée des messages <command>NOTIFY</command> peut être
détectée ensuite en appelant
<function>PQnotifies</function>.<indexterm><primary>PQnotifies</></>
</para>

<para>
La fonction <function>PQnotifies</function> renvoie la prochaine notification à
partir d'une liste de messages de notification encore non gérés reçus à du
serveur. Elle renvoie un pointeur nul s'il n'existe pas de notifications en
attente. Une fois qu'une notification est renvoyée par
<function>PQnotifies</>, elle est considérée comme traitée et est supprimée
de la liste des notifications.
<synopsis>
PGnotify* PQnotifies(PGconn *conn);

typedef struct pgNotify {
    char *relname;              /* nom de la condition de la notification */
    int  be_pid;                /* ID du processus serveur */
    char *extra;                /* paramètre de notification */
} PGnotify;
</synopsis>
Après avoir traité un objet <structname>PGnotify</structname> renvoyé par
<function>PQnotifies</function>, assurez-vous de le libérer avec
<function>PQfreemem</function>. Il est suffisant de libérer le pointeur
<structname>PGnotify</structname>&nbsp;; les champs
<structfield>relname</structfield> et <structfield>extra</structfield> ne
représentent pas des allocations séparées.
(Actuellement, le champ <structfield>extra</structfield> est inutilisé et
pointe toujours vers une chaîne vide.)
</para>

<note>
<para>
 Avec <productname>PostgreSQL</productname> 6.4 et ultérieur,
 le champ <structfield>be_pid</structfield> est celui du processus serveur
 ayant lancé la notification alors que, pour les versions précédentes il
 s'agissait toujours du <acronym>PID</acronym> de votre propre processus
 serveur.
</para>
</note>

<para>
<xref linkend="libpq-example-2"> donne un programme d'exemple illustrant
l'utilisation d'une notification asynchrone.
</para>

<para>
<function>PQnotifies</function> ne lit pas réellement les données à partir du
serveur&nbsp;; il renvoie simplement les messages précédemment absorbés par une
autre fonction de <application>libpq</application>. Dans les précédentes
versions de <application>libpq</application>, la seule façon de s'assurer d'une
réception à temps des messages <command>NOTIFY</> consistait à soumettre
constamment des commandes, même vides, puis de vérifier
<function>PQnotifies</function> après chaque <function>PQexec</function>.
Cette méthode fonctionne toujours, mais elle est dépréciée à cause de sa 
consommation inutile de puissance de calcul.
</para>

<para>
Une meilleure façon de vérifier les messages <command>NOTIFY</> lorsque vous
n'avez pas de commandes utiles à exécuter est d'appeler
<function>PQconsumeInput</function> puis de vérifier
<function>PQnotifies</function>. Vous pouvez utiliser
<function>select()</function> pour attendre l'arrivée des données à partir du
serveur, ce qui ne consomme aucune puissance du <acronym>CPU</acronym> sauf
lorsqu'il y a quelque chose à faire. (Voir <function>PQsocket</function> pour
obtenir le numéro du descripteur de fichiers à utiliser avec
<function>select()</function>.) Notez que ceci fonctionne bien, que vous
soumettiez les commandes avec
<function>PQsendQuery</function>/<function>PQgetResult</function> ou que vous
utilisiez simplement <function>PQexec</function>. Néanmoins, vous devez vous
rappeler de vérifier <function>PQnotifies</function> après chaque
<function>PQgetResult</function> ou <function>PQexec</function>, pour savoir si
des notifications sont arrivées lors du traitement de la commande.
</para>

</sect1>

<sect1 id="libpq-copy">
<title>Fonctions associées avec la commande <command>COPY</command></title>

<indexterm zone="libpq-copy">
 <primary>COPY</primary>
 <secondary>avec libpq</secondary>
</indexterm>

<para>
 La commande <command>COPY</command> dans
 <productname>PostgreSQL</productname> a des options pour lire ou écrire à
 partir de la connexion réseau utilisée par <application>libpq</application>.
 Les fonctions décrites dans cette section permettent aux applications 
 d'utiliser cette capacité en apportant ou en consommant des données copiées.
</para>

<para>
 Le processus complet de <command>COPY</command> est le suivant: 
 L'application lance tout d'abord la commande SQL
 <command>COPY</command> via <function>PQexec</function> ou une des fonctions
 équivalentes. La réponse à ceci (s'il n'y a pas d'erreur dans la commande) est
 un objet <structname>PGresult</> avec un code de retour
 <literal>PGRES_COPY_OUT</literal> ou <literal>PGRES_COPY_IN</literal> (suivant
 la direction spécifiée pour la copie). L'application doit alors utiliser les
 fonctions de cette section pour recevoir ou transmettre des lignes de données.
 Quand le transfert de données est terminé, un autre objet
 <structname>PGresult</> est renvoyé pour indiquer le succès ou l'échec du
 transfert. Son statut est <literal>PGRES_COMMAND_OK</literal> en cas de succès
 et <literal>PGRES_FATAL_ERROR</literal> si un problème a été rencontré. À ce
 moment seulement, une autre commande SQL peut être lancée via
 <function>PQexec</function>. (Il n'est pas possible d'exécuter d'autres
 commandes SQL en utilisant la même connexion tant que l'opération
 <command>COPY</command> est en cours.)
</para>

<para>
 Si une commande <command>COPY</command> est lancée via
 <function>PQexec</function> dans une chaîne qui pourrait contenir d'autres 
 commandes supplémentaires, l'application doit continuer à récupérer les
 résultats via <function>PQgetResult</> après avoir terminé la séquence
 <command>COPY</command>. C'est seulement quand <function>PQgetResult</> renvoie
 <symbol>NULL</symbol> que vous pouvez être certain que la chaîne de commandes
 <function>PQexec</function> est terminée et qu'il est possible de lancer
 d'autres commandes.
</para>

<para>
 Les fonctions de cette section ne doivent être exécutées qu'après avoir obtenu
 un statut de résultat <literal>PGRES_COPY_OUT</literal> ou
 <literal>PGRES_COPY_IN</literal> à partir de <function>PQexec</function> ou
 <function>PQgetResult</function>.
</para>

<para>
 Un objet <structname>PGresult</> contenant un de ces statuts comporte quelques
 données supplémentaires sur l'opération <command>COPY</command> qui commence.
 La données supplémentaire est disponible en utilisant les fonctions qui sont
 aussi utilisées en relation avec les résultats de requêtes&nbsp;:

<variablelist>
<varlistentry>
<term><function>PQnfields</function><indexterm><primary>PQnfields</><secondary>with COPY</></></term>
<listitem>
<para>
          Renvoie le nombre de colonnes (champs) à copier.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQbinaryTuples</function><indexterm><primary>PQbinaryTuples</><secondary>with COPY</></></term>
<listitem>
<para>
                0 indique que le format de copie complet est textuel (lignes
                séparées par des retours chariots, colonnes séparées par des
                caractères de séparation, etc).
                1 indique que le format de copie complet est binaire. Voir
                <xref linkend="sql-copy" endterm="sql-copy-title"> pour plus
                d'informations.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQfformat</function><indexterm><primary>PQfformat</><secondary>with COPY</></></term>
<listitem>
<para>
          Renvoie le code de format (0 pour le texte, 1 pour le binaire)
          associé à chaque colonne de l'opération de copie. Les codes de
          format par colonne sont toujours zéro si le format de copie complet
          est textuel mais le format binaire supporte à la fois des colonnes
          textuelles et des colonnes binaires. (Néanmoins, avec l'implémentation
          actuelle de <command>COPY</>, seules des colonnes binaires
          apparaissent dans une copie binaire&nbsp; donc actuellement, les 
          formats par colonnes correspondent toujours au format complet.)
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<note>
<para>
Ces valeurs de données supplémentaires sont seulement disponibles en
utilisant le protocole 3.0. Lors de l'utilisation du protocole 2.0, toutes ces
fonctions renvoient 0.
</para>
</note>

<sect2 id="libpq-copy-send">
  <title>Fonctions d'envoi de données pour <command>COPY</command></title>

<para>
 Ces fonctions sont utilisées pour envoyer des données lors d'un <literal>COPY
 FROM STDIN</>. Elles échouent si elles sont appelées alors que la connexion
 ne se trouve pas dans l'état <literal>COPY_IN</>.
</para>

<variablelist>
<varlistentry>
<term><function>PQputCopyData</function><indexterm><primary>PQputCopyData</></></term>
<listitem>
<para>
 Envoie des données au serveur pendant un état <literal>COPY_IN</>.
<synopsis>
int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);
</synopsis>
</para>

<para>
Transmet les données de <command>COPY</command> du <parameter>buffer</>
spécifié, sur <parameter>nbytes</>octets, au serveur. Le résultat vaut 1 si les
données ont été envoyées, zéro si elles n'ont pas été envoyées car la tentative
pourrait bloquer (ce cas n'est possible que dans le cas d'une connexion en mode
non bloquant) ou -1 si une erreur s'est produite. (Utilisez
<function>PQerrorMessage</function> pour récupérer des détails si la valeur de
retour vaut -1. Si la valeur vaut zéro, attendez que la connexion soit disponible
en écriture et ré-essayez.)
</para>

<para>
L'application peut diviser le flux de données de <command>COPY</command>
en tampons de taille quelconque. Les tailles de tampons n'ont pas de
signification sémantique lors de l'envoi. Le contenu du flux de données doit
correspondre au format de données attendu par la commande
<command>COPY</>&nbsp;; voir <xref linkend="sql-copy" endterm="sql-copy-title">
pour des détails.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQputCopyEnd</function><indexterm><primary>PQputCopyEnd</></></term>
<listitem>
<para>
 Envoie une indication de fin de transfert au serveur lors de l'état
 <literal>COPY_IN</>.
<synopsis>
int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);
</synopsis>
</para>

<para>
Termine l'opération <literal>COPY_IN</> avec succès si <parameter>errormsg</>
est <symbol>NULL</symbol>. Si <parameter>errormsg</> n'est pas
<symbol>NULL</symbol> alors <command>COPY</> échoue, la chaîne pointée par
<parameter>errormsg</> étant utilisée comme message d'erreur. Il ne faut pas
supposer que ce message d'erreur précis reviendra du
serveur car le serveur peut avoir déjà échouée sur la commande
<command>COPY</> pour des raisons qui lui sont propres. Notez aussi que 
l'option forçant l'échec ne fonctionne pas lors de l'utilisation de
connexions avec un protocole pre-3.0.
</para>

<para>
Le résultat est 1 si les données de fin ont été envoyées, zéro si elles ne l'ont
pas été car cette tentative serait bloquante (ce cas est uniquement possible
si la connexion est dans un mode non bloquant) ou -1 si une erreur est survenue.
(Utilisez <function>PQerrorMessage</function> pour récupérer les détails si le
code de retour est -1. Si la valeur vaut zéro, attendez que le serveur 
soit prêt en écriture et ré-essayez de nouveau.)
</para>

<para>
Après un appel réussi à <function>PQputCopyEnd</>, appelez
<function>PQgetResult</> pour obtenir le statut de résultat final de la commande
<command>COPY</>. Vous pourriez attendre que le résultat soit disponible de la
même façon. Puis, retournez aux opérations normales.
</para>
</listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2 id="libpq-copy-receive">
  <title>Fonctions pour recevoir des données de <command>COPY</command></title>

<para>
 Ces fonctions sont utilisées pour recevoir des données lors d'un <literal>COPY
 TO STDOUT</>. Elles échouent si elles sont appelées alors que la connexion
 n'est pas dans l'état <literal>COPY_OUT</>
</para>

<variablelist>
<varlistentry>
<term><function>PQgetCopyData</function><indexterm><primary>PQgetCopyData</></></term>
<listitem>
<para>
 Reçoit des données du serveur lors d'un état <literal>COPY_OUT</>.
<synopsis>
int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);
</synopsis>
</para>

<para>
Tente d'obtenir une autre ligne de données du serveur lors d'une
opération <command>COPY</command>. Les données ne sont renvoyées qu'une ligne à
la fois&nbsp;; si seule une ligne partielle est disponible, elle n'est pas
renvoyée. Le retour d'une ligne avec succès implique l'allocation d'une portion
de mémoire pour contenir les données. Le paramètre <parameter>buffer</> ne doit
pas être <symbol>NULL</symbol>. <parameter>*buffer</> est initialisé pour
pointer vers la mémoire allouée ou vers <symbol>NULL</symbol> au cas où aucun
tampon n'est renvoyé. Un tampon résultat non <symbol>NULL</symbol> doit être
libéré en utilisant <function>PQfreemem</> lorsqu'il n'est plus utile.
</para>

<para>
Lorsqu'une ligne est renvoyée avec succès, le code de retour est le 
nombre d'octets de la donnée dans la ligne (et est donc supérieur
à zéro). La chaîne renvoyée est toujours terminée par un octet nul bien que ce
ne soit utile que pour les <command>COPY</command> textuels. Un résultat
zéro indique que la commande <command>COPY</command> est toujours en cours mais
qu'aucune ligne n'est encore disponible (ceci n'est possible que lorsque
<parameter>async</> est vrai). Un résultat de -1 indique que
<command>COPY</command> a terminé. Un résultat de -2 indique qu'une erreur est
survenue (consultez <function>PQerrorMessage</> pour en connaître la raison).
</para>

<para>
Lorsque <parameter>async</> est vrai (différent de zéro),
<function>PQgetCopyData</> ne bloque pas en attente d'entrée&nbsp;; elle
renvoie zéro si <command>COPY</command> est toujours en cours mais qu'aucune
ligne n'est encore disponible. Dans ce cas, attendez que le connexion soit prête
en lecture puis appelez <function>PQconsumeInput</function> avant d'appeler de
nouveau <function>PQgetCopyData</>). Quand <parameter>async</> est faux (zéro),
<function>PQgetCopyData</> bloque tant que les données ne sont pas disponibles
ou tant que l'opération n'est pas terminée.
</para>

<para>
Après que <function>PQgetCopyData</> ait renvoyé -1, appelez
<function>PQgetResult</> pour obtenir le statut de résultat final de la commande
<command>COPY</>. Vous pourriez attendre la disponibilité de ce résultat, comme
d'habitude. Puis, retournez aux opérations habituelles.
</para>
</listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2 id="libpq-copy-deprecated">
  <title>Fonctions obsolètes pour <command>COPY</command></title>

<para>
 Ces fonctions représentent d'anciennes méthodes de gestion de
 <command>COPY</>. Bien qu'elles fonctionnent toujours, elles sont obsolètes à
 cause de leur médiocre gestion des erreurs, des méthodes peu commodes de
 détection d'une fin de transmission, et de l'absence de support des transferts
 binaires et des transferts non bloquants.
</para>

<variablelist>
<varlistentry>
<term><function>PQgetline</function><indexterm><primary>PQgetline</></></term>
<listitem>
<para>
          Lit une ligne de caractères terminée par un retour chariot (transmise
          par le serveur) dans un tampon de taille <parameter>length</>.
<synopsis>
int PQgetline(PGconn *conn,
              char *buffer,
              int length);
</synopsis>
</para>

<para>
Cette fonction copie jusqu'à <parameter>length</>-1 caractères dans le tampin
et convertit le retour chariot en un octet nul. <function>PQgetline</function>
renvoie <symbol>EOF</symbol> à la fin de l'entrée, 0 si la ligne entière a été
lu et 1 si le tampon est complet mais que le retour chariot à la fin n'a pas
encore été lu.
</para>
<para>
Notez que l'application doit vérifier si un retour chariot est constitué de
deux caractères <literal>\.</literal>, ce qui indique que le serveur a terminé
l'envoi des résultats de la commande <command>COPY</command>. Si l'application
peut recevoir des lignes de plus de <parameter>length</>-1 caractères, une
attention toute particulière est nécessaire pour s'assurer qu'elle reconnaisse
la ligne <literal>\.</literal> correctement (et ne la confonde pas, par exemple,
avec la fin d'une longue ligne de données).
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQgetlineAsync</function><indexterm><primary>PQgetlineAsync</></></term>
<listitem>
<para>
          Lit une ligne de données <command>COPY</command>
          (transmise par le serveur) dans un tampon sans blocage.
<synopsis>
int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);
</synopsis>
</para>

<para>
Cette fonction est similaire à <function>PQgetline</function> mais elle peut
être utilisée par des applications qui doivent lire les données de
<command>COPY</command> de façon asynchrone, c'est-à-dire sans blocage. Après
avoir lancé la commande <command>COPY</command> et obtenu une réponse
<literal>PGRES_COPY_OUT</literal>, l'application doit appeler
<function>PQconsumeInput</function> et
<function>PQgetlineAsync</function> jusqu'à ce que le signal de fin de données
soit détecté.
</para>
<para>
Contrairement à <function>PQgetline</function>, cette fonction prend la
responsabilité de détecter la fin de données.
</para>
<para>
À chaque appel, <function>PQgetlineAsync</function> renvoie des données si une
ligne de données complète est disponible dans le tampon d'entrée de
<application>libpq</>. Sinon, aucune ligne n'est renvoyée jusqu'à l'arrivée du
reste de la ligne. La fonction renvoie -1 si le marqueur de fin de copie des
données a été reconnu ou 0 si aucune donnée n'est disponible ou un nombre
positif indiquant le nombre d'octets renvoyés. Si -1 est renvoyé, l'appeleur
doit ensuite appeler <function>PQendcopy</function> puis retourner aux
traitements habituels.
</para>
<para>
Les données renvoyées ne renvoie pas plus d'une ligne à la fois.
Si possible, une ligne complète est retournée en une fois. Mais si le tampon
offert par l'appelant est trop petit pour contenir une ligne envoyée par le
serveur, alors une ligne de données partielle est renvoyée. Avec des données
textuelles, ceci peut être détecté en testant si le dernier octet renvoyé est
<literal>\n</literal> ou non. (Dans un <command>COPY</> binaire, l'analyse
réelle du format de données <command>COPY</> est nécessaire pour faire la
détermination équivalente.) La chaîne renvoyée n'est pas terminée par un
octet nul. (Si vous voulez ajouter un octet nul de terminaison, assurez-vous de
passer un <parameter>bufsize</parameter> inférieur de 1 par rapport à l'espace
réellement disponible.)
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQputline</function><indexterm><primary>PQputline</></></term>
<listitem>
<para>
Envoie une chaîne terminée par un octet nul au serveur. Renvoie 0 si tout va
bien et <symbol>EOF</symbol> s'il est incapable d'envoyer la chaîne.
<synopsis>
int PQputline(PGconn *conn,
              const char *string);
</synopsis>
</para>

<para>
Le flux de données de <command>COPY</command> envoyé par une série d'appels à
<function>PQputline</function> a le même format que celui renvoyé par
<function>PQgetlineAsync</function>, sauf que les applications ne sont pas
obligées d'envoyer exactement une ligne de données par appel à
<function>PQputline</function>&nbsp;; il est possible d'envoyer une ligne
partielle ou plusieurs lignes par appel.
</para>

<note>
<para>
Avant le protocole 3.0 de <productname>PostgreSQL</productname>, il était
nécessaire que l'application envoie explicitement les deux caractères
<literal>\.</literal> comme ligne finale pour indiquer la fin de l'envoi
des données du <command>COPY</> data. Bien que ceci fonctionne toujours, cette
méthode est abandonnée et la signification spéciale de <literal>\.</literal>
pourrait être supprimée dans une prochaine version. Il est suffisant d'appeler
<function>PQendcopy</function> après avoir envoyé les vraies données.
</para>
</note>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQputnbytes</function><indexterm><primary>PQputnbytes</></></term>
<listitem>
<para>
Envoie une chaîne non terminée par un octet nul au serveur. Renvoie 0 si tout
va bien et <symbol>EOF</symbol> s'il n'a pas été possible d'envoyer la chaîne.
<synopsis>
int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);
</synopsis>
</para>

<para>
C'est exactement comme <function>PQputline</function> sauf que le tampon de
données n'a pas besoin d'être terminé avec un octet nul car le nombre d'octets
envoyés est indiqué directement. Utilisez cette procédure pour envoyer des
données binaires.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQendcopy</function><indexterm><primary>PQendcopy</></></term>
<listitem>
<para>
 Se synchronise avec le serveur.
<synopsis>
int PQendcopy(PGconn *conn);
</synopsis>
 Cette fonction attend jusqu'à ce que le serveur ait terminé la copie. 
 Elle doit être appelée
 pour indiquer quand la dernière chaîne a été envoyée au serveur en utilisant
 <function>PQputline</function> ou quand la dernière chaîne a été reçue
 du serveur en utilisant <function>PGgetline</function>. Si 
 <function>PQendcopy</function> est omise, le serveur se <quote>désynchronisera</quote>
 du client. Au retour de cette fonction, le serveur est
 prêt à recevoir la prochaine commande SQL. Le code de retour 0 indique un
 succès et est différent de zéro dans le cas contraire. (Utilisez
 <function>PQerrorMessage</function> pour récupérer des détails sur l'échec.)
</para>

<para>
Lors de l'utilisation de <function>PQgetResult</function>, l'application
doit répondre à un résultat <literal>PGRES_COPY_OUT</literal> en exécutant
<function>PQgetline</function> de façon répétée, suivie par un
<function>PQendcopy</function> une fois la ligne de terminaison reçue.
Il doit ensuite retourner à la boucle <function>PQgetResult</function>
jusqu'à ce que <function>PQgetResult</function> renvoie un pointeur nul. De
façon similaire un résultat <literal>PGRES_COPY_IN</literal> est traité par une
série d'appels à <function>PQputline</function> suivis par un
<function>PQendcopy</function>, ensuite retour à la boucle
<function>PQgetResult</function>. Cette vous assure qu'une commande
<command>COPY</command> intégrée dans une série de commandes
<acronym>SQL</acronym> est exécutée correctement.
</para>

<para>
Les anciennes applications soumettaient un <command>COPY</command> via
<function>PQexec</function> et assument que la transaction est terminée après un
<function>PQendcopy</function>. Ceci fonctionne toujours correctement 
si et seulement si 
<command>COPY</command> est la seule commande <acronym>SQL</acronym> dans la
chaîne de commandes.
</para>
</listitem>
</varlistentry>
</variablelist>

</sect2>

</sect1>

<sect1 id="libpq-control">
<title>Fonctions de contrôle</title>

<para>
Ces fonctions contrôlent divers détails du comportement de
<application>libpq</>.
</para>

<variablelist>
<varlistentry>
<term><function>PQsetErrorVerbosity</function><indexterm><primary>PQsetErrorVerbosity</></></term>
<listitem>
<para>
Détermine la verbosité des messages renvoyés par
<function>PQerrorMessage</> et <function>PQresultErrorMessage</>.
<synopsis>
typedef enum {
    PQERRORS_TERSE,
    PQERRORS_DEFAULT,
    PQERRORS_VERBOSE
} PGVerbosity;

PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
</synopsis>
<function>PQsetErrorVerbosity</> initialise le mode de verbosité et retourne le
paramétrage précédent de cette connexion. Dans le mode <firstterm>terse</>, les
messages renvoyés incluent seulement la sévérité, le texte principal et la
position&nbsp;; ceci tient normalement sur une seule ligne. Le mode par
défaut produit des messages qui inclut ces champs ainsi que les champs détail,
astuce ou contexte (ils peuvent être sur plusieurs lignes). Le mode
<firstterm>VERBOSE</> inclut tous les champs disponibles. Modifier la verbosité
n'affecte pas les messages disponibles à partir d'objets
<structname>PGresult</> déjà existants, seulement ceux créés après.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQtrace</function><indexterm><primary>PQtrace</></></term>
<listitem>
<para>
          Active les traces de communication entre client et serveur vers un
          flux fichier de débogage.
<synopsis>
void PQtrace(PGconn *conn, FILE *stream);
</synopsis>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><function>PQuntrace</function><indexterm><primary>PQuntrace</></></term>
<listitem>
<para>
          Désactive les traces activées avec <function>PQtrace</function>.
<synopsis>
void PQuntrace(PGconn *conn);
</synopsis>
</para>
</listitem>
</varlistentry>
</variablelist>

</sect1>

<sect1 id="libpq-notice-processing">
<title>Traitement des messages</title>

<indexterm zone="libpq-notice-processing">
 <primary>traitement des messages</primary>
 <secondary>dans libpq</secondary>
</indexterm>

<para>
Les messages d'information et d'avertissement générés par le serveur ne sont pas
renvoyés par les fonctions d'exécution des requêtes car elles n'impliquent pas
d'échec dans la requête. À la place, elles sont passées à la fonction de
gestion des messages et l'exécution continue normalement après le retour du
gestionnaire. La fonction par défaut de gestion des messages affiche le message
sur <filename>stderr</filename> mais l'application peut surcharger ce
comportement en proposant sa propre fonction de gestion.
</para>

<para>
Pour des raisons historiques, il existe deux niveaux de gestion de messages,
appelés la réception des messages et le traitement. Pour la réception, le
comportement par défaut est de formater le message et de passer une chaîne au
traitement pour affichage. Néanmoins, une application qui choisit de
fournir son propre récepteur de messages ignore habituellement la couche de traitement
de messages et fait tout travail au niveau du récepteur.
</para>

<para>
La fonction <function>PQsetNoticeReceiver</function>
<indexterm><primary>récepteur
de message</></><indexterm><primary>PQsetNoticeReceiver</></>
initialise ou examine le récepteur actuel de messages pour un objet de
connexion. De la même façon, <function>PQsetNoticeProcessor</function>
<indexterm><primary>processeur de messages</></><indexterm><primary>
PQsetNoticeProcessor</></> initialise ou examine le processeur actuel de messages.

<synopsis>
typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);

PQnoticeReceiver
PQsetNoticeReceiver(PGconn *conn,
                    PQnoticeReceiver proc,
                    void *arg);

typedef void (*PQnoticeProcessor) (void *arg, const char *message);

PQnoticeProcessor
PQsetNoticeProcessor(PGconn *conn,
                     PQnoticeProcessor proc,
                     void *arg);
</synopsis>

Chacune de ces fonctions retourne le pointeur de fonction du précédent récepteur
ou du processeur de messages et configure la nouvelle valeur. Si vous fournissez un
pointeur de fonction nul, aucun changement n'est réalisé mais le pointeur actuel
est renvoyé.
</para>

<para>
Quand un message de note ou d'avertissement est reçu du serveur ou généré de
façon interne par <application>libpq</application>, la fonction de réception du
message est appelée. Le message lui est passé sous la forme d'un
<structname>PGresult</structname> de type <symbol>PGRES_NONFATAL_ERROR</symbol>. 
(Ceci permet au récepteur d'extraire les champs individuels en utilisant
<function>PQresultErrorField</> ou le message complet préformaté en utilisant
<function>PQresultErrorMessage</>.) Le même pointeur void passé à
<function>PQsetNoticeReceiver</function> est aussi passé. (Ce pointeur peut
être utilisé pour accéder à un état spécifique de l'application si nécessaire.)
</para>

<para>
Le récepteur de messages par défaut extrait simplement le message (en utilisant
<function>PQresultErrorMessage</>) et le passe au système de traitement du
message.
</para>

<para>
Ce dernier est responsable de la gestion du message de note ou d'avertissement
donné au format texte. La chaîne texte du message est passée avec un retour
chariot, plus un pointeur sur void identique à celui passé à
<function>PQsetNoticeProcessor</function>. (Ce pointeur peut être utilisé pour
accéder à un état spécifique de l'application si nécessaire.)
</para>

<para>
Le traitement des messages par défaut est simplement
<programlisting>
static void
defaultNoticeProcessor(void * arg, const char * message)
{
    fprintf(stderr, "%s", message);
}
</programlisting>
</para>

<para>
Une fois que vous avez initialisé un récepteur ou une fonction de traitement des
messages, vous devez vous attendre à ce que la fonction soit appelée aussi
longtemps que l'objet <structname>PGconn</> ou qu'un objet
<structname>PGresult</> réalisé à partir de celle-ci existent. À la création
d'un <structname>PGresult</>, les pointeurs de gestion actuels de
<structname>PGconn</> sont copiés dans <structname>PGresult</> pour une
éventuelle utilisation par des fonctions comme <function>PQgetvalue</function>.
</para>

</sect1>

<sect1 id="libpq-envars">
<title>Variables d'environnement</title>

<indexterm zone="libpq-envars">
 <primary>variable d'environnement</primary>
</indexterm>

<para>
Les variables d'environnement suivantes peuvent être utilisées pour
sélectionner des valeurs par défaut de paramètres de connexion. Elles sont
utilisées par <function>PQconnectdb</>, <function>PQsetdbLogin</> et
<function>PQsetdb</> si aucune valeur n'est directement spécifiée par
le code d'appel. Elles sont en particulier utiles pour éviter de coder
en dur les informations de connexion à la base de données dans les 
applications clients.

<itemizedlist>
<listitem>
<para>
<indexterm>
 <primary><envar>PGHOST</envar></primary>
</indexterm>
<envar>PGHOST</envar> initialise le nom du serveur de la base de données. S'il
commence avec une barre oblique, il indique une communication de domaine Unix
plutôt qu'une communication TCP/IP&nbsp;; la valeur est le nom du répertoire où
le fichier socket est stocké (par défaut <filename>/tmp</filename>).
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGHOSTADDR</envar></primary>
</indexterm>
<envar>PGHOSTADDR</envar> indique l'adresse IP numérique du serveur de la base
de données. Elle peut être initialisée avec <envar>PGHOST</envar> pour éviter
la surcharge des recherches DNS. Voir la documentation de ces paramètres, dans
<function>PQconnectdb</function> ci-dessus, pour des détails sur leur
interaction.
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGPORT</envar></primary>
</indexterm>
<envar>PGPORT</envar> initialise le numéro de port TCP ou l'extension du
fichier socket domaine Unix pour la communication avec le serveur
<productname>PostgreSQL</productname>.
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGDATABASE</envar></primary>
</indexterm>
<envar>PGDATABASE</envar> initialise le nom de la base de données
<productname>PostgreSQL</productname>.
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGUSER</envar></primary>
</indexterm>
<envar>PGUSER</envar> initialise le nom de l'utilisateur se connectant à la
base de données.
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGPASSWORD</envar></primary>
</indexterm>
<envar>PGPASSWORD</envar> initialise le mot de passe utilisé si le serveur
demande une authentification par mot de passe. Cette variable d'environnement
est obsolète pour des raisons de sécurité&nbsp;; il est conseillé de migrer vers
l'utilisation du fichier <filename>$HOME/.pgpass</> (voir <xref
linkend="libpq-pgpass">).
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGSERVICE</envar></primary>
</indexterm>
<envar>PGSERVICE</envar> initialise le nom du service à rechercher dans
<filename>pg_service.conf</filename>. Cela offre un raccourci pour la
configuration de tous les paramètres.
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGREALM</envar></primary>
</indexterm>
<envar>PGREALM</envar> initialise le domaine Kerberos à utiliser avec
<productname>PostgreSQL</productname> s'il est différent du domaine local. Si
<envar>PGREALM</envar> est initialisé, les applications
<application>libpq</application> tentent une authentification avec les
serveurs avec ce domaine et utilisent des fichiers tickets séparés pour éviter
les conflits avec les fichiers tickets locaux. Cette variable d'environnement
n'est utilisée que si l'authentification Kerberos est sélectionnée par le
serveur.
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGOPTIONS</envar></primary>
</indexterm>
<envar>PGOPTIONS</envar> initialise des options d'exécution supplémentaires
pour le serveur <productname>PostgreSQL</productname>.
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGSSLMODE</envar></primary>
</indexterm>
<envar>PGSSLMODE</envar> détermine si et avec quelle priorité une connexion
<acronym>SSL</> est négociée avec le serveur. Il existe quatre modes&nbsp;:
<literal>disable</> tente uniquement une connexion non cryptée, donc sans
<acronym>SSL</>&nbsp;; <literal>allow</> négocie en commençant par une
connexion non <acronym>SSL</> puis, s'il échoue, essaie une connexion
<acronym>SSL</>&nbsp;; <literal>prefer</> (la valeur par défaut) négociera en
commençant par une connexion <acronym>SSL</> puis, en cas d'échec, essaie
une connexion non <acronym>SSL</>&nbsp;; <literal>require</> essaie seulement
une connexion <acronym>SSL</>. Si <productname>PostgreSQL</> est compilé sans
le support de SSL, utiliser l'option <literal>require</> génère une erreur et
les options <literal>allow</> et <literal>prefer</> sont tolérées mais
<application>libpq</> est incapable de gérer une connexion <acronym>SSL</>.
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGREQUIRESSL</envar></primary>
</indexterm>
<envar>PGREQUIRESSL</envar> initialise une connexion via
<acronym>SSL</acronym>. Si elle est initialisée à
<quote>1</quote>, <application>libpq</> refuse de se connecter si le serveur
n'accepte pas de connexion <acronym>SSL</acronym> (équivalent à un
<literal>sslmode</> <literal>prefer</>). Cette option est obsolète.
Elle est remplacée par le paramétrage <literal>sslmode</> et est seulement disponible
si <productname>PostgreSQL</> est compilé avec le support de SSL.
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGCONNECT_TIMEOUT</envar></primary>
</indexterm>
<envar>PGCONNECT_TIMEOUT</envar> initialise le nombre de secondes maximum que
<application>libpq</application> attend pour une connexion au serveur
<productname>PostgreSQL</productname>. Si elle n'est pas initialisée ou si 
elle vaut zéro,
<application>libpq</application> attend indéfiniment. Il n'est pas recommandé
d'initialiser le délai à moins de deux secondes.
</para>
</listitem>
</itemizedlist>
</para>

<para>
Les variables d'environnement par défaut peuvent être utilisées pour
spécifier le comportement par défaut de chaque session
<productname>PostgreSQL</productname>. (Voir aussi les commandes <command>ALTER
USER</> et <command>ALTER DATABASE</> pour des moyens d'initialiser le
comportement par défaut par utilisateur ou par base de données.)

<itemizedlist>
<listitem>
<para>
<indexterm>
 <primary><envar>PGDATESTYLE</envar></primary>
</indexterm>
<envar>PGDATESTYLE</envar>
initialise le style par défaut de la représentation de la date et de l'heure.
(Équivalent à <literal>SET datestyle TO ...</literal>.)
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGTZ</envar></primary>
</indexterm>
<envar>PGTZ</envar> initialise le fuseau horaire par défaut
(Équivalent à <literal>SET timezone TO ...</literal>.)
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGCLIENTENCODING</envar></primary>
</indexterm>
<envar>PGCLIENTENCODING</envar> initialise le codage par défaut 
du jeu de caractères client.
(Équivalent à <literal>SET client_encoding TO ...</literal>.)
</para>
</listitem>
<listitem>
<para>
<indexterm>
 <primary><envar>PGGEQO</envar></primary>
</indexterm>
<envar>PGGEQO</envar>
initialise le mode par défaut pour l'optimiseur génétique de requêtes.
(Équivalent à <literal>SET geqo TO ...</literal>.)
</para>
</listitem>
</itemizedlist>

Référez-vous à la commande <acronym>SQL</acronym> <command>SET</command> pour
optenir plus d'informations sur les valeurs admises pour ces variables
d'environnement.
</para>

</sect1>


<sect1 id="libpq-pgpass">
<title>Fichier de mots de passe</title>

<indexterm zone="libpq-pgpass">
 <primary>fichier de mots de passe</primary>
</indexterm>
<indexterm zone="libpq-pgpass">
 <primary>.pgpass</primary>
</indexterm>

<para>
Le fichier <filename>.pgpass</filename>, situé dans le répertoire personnel de
l'utilisateur est un fichier contenant les mots de passe à utiliser si la
connexion nécessite un mot de passe (et si aucun mot de passe n'a été indiqué).
Ce fichier doit être composé de lignes du format&nbsp;:
<synopsis><replaceable>nomhote</replaceable>:<replaceable>port</replaceable>:<replaceable>database</replaceable>:<replaceable>nomutilisateur</replaceable>:<replaceable>motdepasse </replaceable></synopsis>
Chacun des quatre premiers champs peut être une valeur littérale ou
<literal>*</literal>, qui correspond à tout. Le champ de mot de passe de
la première ligne qui correspond aux paramètres de connexion actuels est
utilisé. (Du coup, placez les entrées plus précises en premier lorsque vous
utilisez des jokers.) Si une entrée a besoin de contenir <literal>:</literal> ou
<literal>\</literal>, échappez ce caractère avec <literal>\</literal>.
</para>
<para>
Les droits sur <filename>.pgpass</filename> doivent interdire l'accès aux
autres utilisateurs et au groupe&nbsp;; réalisez ceci avec la commande
<command>chmod 0600 ~/.pgpass</command>.
Si les droits sont moins stricts que ça, le fichier est ignoré.
</para>
</sect1>

<sect1 id="libpq-threading">
      <title>Comportement des programmes threadés</title>

<indexterm zone="libpq-threading">
 <primary>threads</primary>
 <secondary>avec libpq</secondary>
</indexterm>

<para>
<application>libpq</application> est réentrante et sûre avec les threads si
l'option <literal>--enable-thread-safety</> de <filename>configure</filename>
a été utilisée lors de la compilation de
PostgreSQL. Il se peut que vous ayez aussi besoin d'utiliser des options de
compilation spécifiques lorsque vous compiler le code de votre
application pour utiliser les threads. Référez-vous à la documentation de 
votre système pour savoir comment construire des applications utilisant 
les threads.
</para>

<para>
Une restriction est qu'il ne doit pas y avoir deux threads
manipulant le même objet <structname>PGconn</> à la fois. En particulier, vous
ne pouvez pas lancer des commandes concurrentes à partir de threads différents
à travers le même objet de connexion. (Si vous avez besoin de lancer des
commandes concurrentes, lancez plusieurs connexions.)
</para>

<para>
Les objets <structname>PGresult</> sont en lecture seule après leur création
et, du coup, ils peuvent être passés librement entre les threads.
</para>

<para>
Les fonctions obsolètes <function>PQoidStatus</function> et
<function>fe_setauthsvc</function> ne gèrent pas les threads et ne doivent 
pas être utilisées dans des programmes multithread.
<function>PQoidStatus</function> peut être remplacée par
<function>PQoidValue</function>. Il n'existe plus aucune bonne raison
d'appeler <function>fe_setauthsvc</function>.
</para>

<para>
Les applications <application>libpq</application> qui utilisent la méthode
d'authentification <literal>crypt</literal> sont liés à la fonction
<literal>crypt()</literal> du système d'exploitation, qui est souvent non
sûre avec les
threads.<indexterm><primary>crypt</><secondary>conformité aux threads</></> Il
est préférable d'utiliser la méthode <literal>md5</literal>, qui est compatible avec
les threads sur toutes les plateformes.
</para>
</sect1>


 <sect1 id="libpq-build">
  <title>Construire des applications avec
<application>libpq</application></title>

  <indexterm zone="libpq-build">
   <primary>compilation</primary>
   <secondary>d'applications libpq</secondary>
  </indexterm>

  <para>
   Pour construire (c'est-à-dire compiler et lier) vos programmes
   <application>libpq</application>, vous avez besoin de faire tout ce qui
   suit&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Incluez le fichier d'en-tête <filename>libpq-fe.h</filename>&nbsp;:
<programlisting>
#include &lt;libpq-fe.h&gt;
</programlisting>
      Si vous ne le faites pas, alors vous obtiendrez normalement des messages
      d'erreurs similaires à ceci
<screen>
foo.c: In function `main':
foo.c:34: `PGconn' undeclared (first use in this function)
foo.c:35: `PGresult' undeclared (first use in this function)
foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)
foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)
foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      Pointez votre compilateur sur le répertoire où les fichiers d'en-tête 
      de <productname>PostgreSQL</> ont été installés, en fournissant l'option
      <literal>-I<replaceable>répertoire</replaceable></literal> à votre
      compilateur. (Dans certains cas, le compilateur cherche dans le
      répertoire en question par défaut, donc vous pouvez omettre cette
      option.) Par exemple, votre ligne de commande de compilation devrait
      ressembler à ceci&nbsp;:
<programlisting>
cc -c -I/usr/local/pgsql/include testprog.c
</programlisting>
      Si vous utilisez des makefiles, alors ajoutez l'option à la variable
      <varname>CPPFLAGS</varname>&nbsp;:
<programlisting>
CPPFLAGS += -I/usr/local/pgsql/include
</programlisting>
     </para>

     <para>
      S'il existe possibilité que votre programme soit compilé par
      d'autres utilisateurs, alors vous ne devriez pas coder en dur
      l'emplacement du répertoire. À la place, vous pouvez exécuter l'outil
      <command>pg_config</command><indexterm><primary>pg_config</><secondary
      sortas="libpq">avec libpq</></> pour trouver où sont placés les fichiers
      d'en-tête sur le système local&nbsp;:
<screen>
<prompt>$</prompt> pg_config --includedir
<computeroutput>/usr/local/include</computeroutput>
</screen>
     </para>

     <para>
      Un échec sur la spécification de la bonne option au compilateur
      donner un message d'erreur tel que
<screen>
testlibpq.c:8:22: libpq-fe.h: No such file or directory
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      Lors de l'édition des liens du programme final, spécifiez l'option
      <literal>-lpq</literal> de façon à ce que 
      les bibliothèques <application>libpq</application> soient intégrées, ainsi
      que l'option <literal>-L<replaceable>répertoire</replaceable></literal>
      pour pointer le compilateur vers le répertoire où les bibliothèques
      <application>libpq</application> résident. (De nouveau, le compilateur
      cherchera certains répertoires par défaut.) Pour une portabilité maximale,
      placez l'option <option>-L</option> avant l'option <option>-lpq</option>.
      Par exemple&nbsp;:
<programlisting>
cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq
</programlisting>
     </para>

     <para>
      Vous pouvez aussi récupérer le répertoire des bibliothèques en utilisant
      <command>pg_config</command>&nbsp;:
<screen>
<prompt>$</prompt> pg_config --libdir
<computeroutput>/usr/local/pgsql/lib</computeroutput>
</screen>
     </para>

     <para>
      Les messages d'erreurs pointant vers des problèmes de ce style,
      ressemblent à ce qui suit.
<screen>
testlibpq.o: In function `main':
testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'
testlibpq.o(.text+0x71): undefined reference to `PQstatus'
testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'
</screen>
      Ceci signifie que vous avez oublié <option>-lpq</option>.
<screen>
/usr/bin/ld: cannot find -lpq
</screen>
      Ceci signifie que vous avez oublié l'option <option>-L</option> ou que
      vous n'avez pas indiqué le bon répertoire.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   <indexterm><primary>libpq-int.h</></>
   Si votre code référence le fichier d'en-tête
   <filename>libpq-int.h</filename> et que vous refusez de corriger votre code
   pour ne pas l'utiliser, à partir de <productname>PostgreSQL</> 7.2, ce
   fichier est disponible dans
<filename><replaceable>includedir</replaceable>/postgresql/internal/libpq-int.h</filename>,
   donc vous aurez besoin d'ajouter l'option <option>-I</option> à votre ligne
   de commande pour le compilateur.
  </para>

 </sect1>


 <sect1 id="libpq-example">
  <title>Exemples de programmes</title>

  <para>
   Ces exemples et d'autres sont disponibles dans le répertoire
   <filename>src/test/examples</filename> de la distribution des sources.
  </para>

  <example id="libpq-example-1">
   <title>Premier exemple de programme pour
    <application>libpq</application></title>

<programlisting>
/*
 * testlibpq.c
 *
 *              Test the C version of LIBPQ, the POSTGRES frontend library.
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
        PQfinish(conn);
        exit(1);
}

int
main(int argc, char **argv)
{
        const char *conninfo;
        PGconn     *conn;
        PGresult   *res;
        int                     nFields;
        int                     i,
                                j;

        /*
         * If the user supplies a parameter on the command line, use it as
         * the conninfo string; otherwise default to setting dbname=template1
         * and using environment variables or defaults for all other connection
         * parameters.
         */
        if (argc &gt; 1)
                conninfo = argv[1];
        else
                conninfo = "dbname = template1";

        /* Make a connection to the database */
        conn = PQconnectdb(conninfo);

        /* Check to see that the backend connection was successfully made */
        if (PQstatus(conn) != CONNECTION_OK)
        {
                fprintf(stderr, "Connection to database '%s' failed.\n", PQdb(conn));
                fprintf(stderr, "%s", PQerrorMessage(conn));
                exit_nicely(conn);
        }

        /*
         * Our test case here involves using a cursor, for which we must be
         * inside a transaction block.  We could do the whole thing with a
         * single PQexec() of "select * from pg_database", but that's too
         * trivial to make a good example.
         */

        /* Start a transaction block */
        res = PQexec(conn, "BEGIN");
        if (PQresultStatus(res) != PGRES_COMMAND_OK)
        {
                fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
                PQclear(res);
                exit_nicely(conn);
        }

        /*
         * Should PQclear PGresult whenever it is no longer needed to avoid
         * memory leaks
         */
        PQclear(res);

        /*
         * Fetch rows from pg_database, the system catalog of databases
         */
        res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
        if (PQresultStatus(res) != PGRES_COMMAND_OK)
        {
                fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
                PQclear(res);
                exit_nicely(conn);
        }
        PQclear(res);

        res = PQexec(conn, "FETCH ALL in myportal");
        if (PQresultStatus(res) != PGRES_TUPLES_OK)
        {
                fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
                PQclear(res);
                exit_nicely(conn);
        }

        /* first, print out the attribute names */
        nFields = PQnfields(res);
        for (i = 0; i &lt; nFields; i++)
                printf("%-15s", PQfname(res, i));
        printf("\n\n");

        /* next, print out the rows */
        for (i = 0; i &lt; PQntuples(res); i++)
        {
                for (j = 0; j &lt; nFields; j++)
                        printf("%-15s", PQgetvalue(res, i, j));
                printf("\n");
        }

        PQclear(res);

        /* close the portal ... we don't bother to check for errors ... */
        res = PQexec(conn, "CLOSE myportal");
        PQclear(res);

        /* end the transaction */
        res = PQexec(conn, "END");
        PQclear(res);

        /* close the connection to the database and cleanup */
        PQfinish(conn);

        return 0;
}
</programlisting>
  </example>

  <example id="libpq-example-2">
   <title>Deuxième exemple de programme pour
    <application>libpq</application></title>

<programlisting>
/*
 * testlibpq2.c
 *              Test of the asynchronous notification interface
 *
 * Start this program, then from psql in another window do
 *   NOTIFY TBL2;
 * Repeat four times to get this program to exit.
 *
 * Or, if you want to get fancy, try this:
 * populate a database with the following commands
 * (provided in src/test/examples/testlibpq2.sql):
 *
 *   CREATE TABLE TBL1 (i int4);
 *
 *   CREATE TABLE TBL2 (i int4);
 *
 *   CREATE RULE r1 AS ON INSERT TO TBL1 DO
 *     (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
 *
 * and do this four times:
 *
 *   INSERT INTO TBL1 VALUES (10);
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/time.h&gt;
#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
        PQfinish(conn);
        exit(1);
}

int
main(int argc, char **argv)
{
        const char *conninfo;
        PGconn     *conn;
        PGresult   *res;
        PGnotify   *notify;
        int                     nnotifies;

        /*
         * If the user supplies a parameter on the command line, use it as
         * the conninfo string; otherwise default to setting dbname=template1
         * and using environment variables or defaults for all other connection
         * parameters.
         */
        if (argc &gt; 1)
                conninfo = argv[1];
        else
                conninfo = "dbname = template1";

        /* Make a connection to the database */
        conn = PQconnectdb(conninfo);

        /* Check to see that the backend connection was successfully made */
        if (PQstatus(conn) != CONNECTION_OK)
        {
                fprintf(stderr, "Connection to database '%s' failed.\n", PQdb(conn));
                fprintf(stderr, "%s", PQerrorMessage(conn));
                exit_nicely(conn);
        }

        /*
         * Issue LISTEN command to enable notifications from the rule's NOTIFY.
         */
        res = PQexec(conn, "LISTEN TBL2");
        if (PQresultStatus(res) != PGRES_COMMAND_OK)
        {
                fprintf(stderr, "LISTEN command failed: %s", PQerrorMessage(conn));
                PQclear(res);
                exit_nicely(conn);
        }

        /*
         * should PQclear PGresult whenever it is no longer needed to avoid
         * memory leaks
         */
        PQclear(res);

        /* Quit after four notifies are received. */
        nnotifies = 0;
        while (nnotifies &lt; 4)
        {
                /*
                 * Sleep until something happens on the connection.  We use select(2)
                 * to wait for input, but you could also use poll() or similar
                 * facilities.
                 */
                int                     sock;
                fd_set          input_mask;

                sock = PQsocket(conn);

                if (sock &lt; 0)
                        break;                          /* shouldn't happen */

                FD_ZERO(&amp;input_mask);
                FD_SET(sock, &amp;input_mask);

                if (select(sock + 1, &amp;input_mask, NULL, NULL, NULL) &lt; 0)
                {
                        fprintf(stderr, "select() failed: %s\n", strerror(errno));
                        exit_nicely(conn);
                }

                /* Now check for input */
                PQconsumeInput(conn);
                while ((notify = PQnotifies(conn)) != NULL)
                {
                        fprintf(stderr,
                                        "ASYNC NOTIFY of '%s' received from backend pid %d\n",
                                        notify-&gt;relname, notify-&gt;be_pid);
                        PQfreemem(notify);
                        nnotifies++;
                }
        }

        fprintf(stderr, "Done.\n");

        /* close the connection to the database and cleanup */
        PQfinish(conn);

        return 0;
}
</programlisting>
  </example>

  <example id="libpq-example-3">
   <title>Troisième exemple de programme pour
    <application>libpq</application></>

<programlisting>
/*
 * testlibpq3.c
 *              Test out-of-line parameters and binary I/O.
 *
 * Before running this, populate a database with the following commands
 * (provided in src/test/examples/testlibpq3.sql):
 *
 * CREATE TABLE test1 (i int4, t text, b bytea);
 *
 * INSERT INTO test1 values (1, 'joe''s place', '\\000\\001\\002\\003\\004');
 * INSERT INTO test1 values (2, 'ho there', '\\004\\003\\002\\001\\000');
 *
 * The expected output is:
 *
 * tuple 0: got
 *  i = (4 bytes) 1
 *  t = (11 bytes) 'joe's place'
 *  b = (5 bytes) \000\001\002\003\004
 *
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include "libpq-fe.h"

/* for ntohl/htonl */
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;


static void
exit_nicely(PGconn *conn)
{
        PQfinish(conn);
        exit(1);
}

int
main(int argc, char **argv)
{
        const char *conninfo;
        PGconn     *conn;
        PGresult   *res;
        const char *paramValues[1];
        int                     i,
                                j;
        int                     i_fnum,
                                t_fnum,
                                b_fnum;

        /*
         * If the user supplies a parameter on the command line, use it as
         * the conninfo string; otherwise default to setting dbname=template1
         * and using environment variables or defaults for all other connection
         * parameters.
         */
        if (argc &gt; 1)
                conninfo = argv[1];
        else
                conninfo = "dbname = template1";

        /* Make a connection to the database */
        conn = PQconnectdb(conninfo);

        /* Check to see that the backend connection was successfully made */
        if (PQstatus(conn) != CONNECTION_OK)
        {
                fprintf(stderr, "Connection to database '%s' failed.\n", PQdb(conn));
                fprintf(stderr, "%s", PQerrorMessage(conn));
                exit_nicely(conn);
        }

        /*
         * The point of this program is to illustrate use of PQexecParams()
         * with out-of-line parameters, as well as binary transmission of
         * results.  By using out-of-line parameters we can avoid a lot of
         * tedious mucking about with quoting and escaping.  Notice how we
         * don't have to do anything special with the quote mark in the
         * parameter value.
         */

        /* Here is our out-of-line parameter value */
        paramValues[0] = "joe's place";

        res = PQexecParams(conn,
                                           "SELECT * FROM test1 WHERE t = $1",
                                           1,           /* one param */
                                           NULL,        /* let the backend deduce param type */
                                           paramValues,
                                           NULL,        /* don't need param lengths since text */
                                           NULL,        /* default to all text params */
                                           1);          /* ask for binary results */

        if (PQresultStatus(res) != PGRES_TUPLES_OK)
        {
                fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
                PQclear(res);
                exit_nicely(conn);
        }

        /* Use PQfnumber to avoid assumptions about field order in result */
        i_fnum = PQfnumber(res, "i");
        t_fnum = PQfnumber(res, "t");
        b_fnum = PQfnumber(res, "b");

        for (i = 0; i &lt; PQntuples(res); i++)
        {
                char       *iptr;
                char       *tptr;
                char       *bptr;
                int                     blen;
                int                     ival;

                /* Get the field values (we ignore possibility they are NULL!) */
                iptr = PQgetvalue(res, i, i_fnum);
                tptr = PQgetvalue(res, i, t_fnum);
                bptr = PQgetvalue(res, i, b_fnum);

                /*
                 * The binary representation of INT4 is in network byte order,
                 * which we'd better coerce to the local byte order.
                 */
                ival = ntohl(*((uint32_t *) iptr));

                /*
                 * The binary representation of TEXT is, well, text, and since
                 * libpq was nice enough to append a zero byte to it, it'll work
                 * just fine as a C string.
                 *
                 * The binary representation of BYTEA is a bunch of bytes, which
                 * could include embedded nulls so we have to pay attention to
                 * field length.
                 */
                blen = PQgetlength(res, i, b_fnum);

                printf("tuple %d: got\n", i);
                printf(" i = (%d bytes) %d\n",
                           PQgetlength(res, i, i_fnum), ival);
                printf(" t = (%d bytes) '%s'\n",
                           PQgetlength(res, i, t_fnum), tptr);
                printf(" b = (%d bytes) ", blen);
                for (j = 0; j &lt; blen; j++)
                        printf("\\%03o", bptr[j]);
                printf("\n\n");
        }

        PQclear(res);

        /* close the connection to the database and cleanup */
        PQfinish(conn);

        return 0;
}
</programlisting>
  </example>

 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
