<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/mvcc.sgml,v 1.11 2005/09/15 07:03:20 guillaume Exp $
-->

 <chapter id="mvcc">
  <title>Contrôle d'accès simultané</title>

  <indexterm>
   <primary>concurrence</primary>
  </indexterm>

  <para>
   Ce chapitre décrit le comportement du système de bases de données
   <productname>PostgreSQL</productname> lorsque deux sessions, ou plus,
   essaient d'accéder aux mêmes données au même moment. Le but dans cette
   situation est de permettre un accès efficace pour toutes les sessions tout 
   en maintenant une intégrité stricte des données. Chaque développeur
   d'applications utilisant des bases de données devrait être familier avec les
   thèmes couverts dans ce chapitre.
  </para>

  <sect1 id="mvcc-intro">
   <title>Introduction</title>

   <indexterm>
    <primary>MVCC</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> fournit un ensemble riche d'outils
    pour les développeurs qui gèrent des accès parallèles aux données.
    En interne, la cohérence des données est atteinte avec l'utilisation d'un
    modèle multiversion (Multiversion Concurrency Control, <acronym>MVCC</acronym>).
    Ceci signifie que, lors d'une requête à la
    base de données, chaque transaction voit une image des données (une
    <firstterm>version de la base de données</firstterm>) telle qu'elles
    étaient quelque temps auparavant, quelque soit l'état actuel des données
    sous-jacentes. Ceci protège la transaction des données incohérentes,
    causées par les mises à jour effectuées par une (autre) transaction
    concurrente sur les mêmes lignes de données, fournissant ainsi une
    <firstterm>isolation des transactions</firstterm> pour chaque session de la
    base de données. <acronym>MVCC</acronym>, en évitant les méthodes de verrous
    explicites des systèmes de bases de données traditionnels, minimise la
    conservation des verrous pour permettre des performances raisonnables dans
    des environnements multiutilisateurs.
   </para>

   <para>
    Le principal avantage de l'utilisation du modèle <acronym>MVCC</acronym> 
    pour le contrôle des accès simultanés, contrairement au verrouillage, est que, dans
    les verrous acquis par <acronym>MVCC</acronym> pour récupérer (en lecture)
    des données, aucun conflit n'intervient avec les verrous acquis pour écrire
    des données. Du coup, lire ne bloque jamais l'écriture et écrire ne bloque
    jamais la lecture.
   </para>

   <para>
    Les capacités de verrouillage des tables ou des lignes sont aussi disponibles
    dans <productname>PostgreSQL</productname> pour les applications ne pouvant
    pas s'adapter facilement au comportement de <acronym>MVCC</acronym>. Néanmoins,
    un bon usage de <acronym>MVCC</acronym> fournira généralement de
    meilleures performances que les verrous. De plus, les verrous informatifs
    définis par l'utilisateur fournissent un mécanisme d'acquisition de verrous
    qui n'est pas lié à une transaction.
   </para>
  </sect1>

  <sect1 id="transaction-iso">
   <title>Isolation des transactions</title>

   <indexterm>
    <primary>isolation des transactions</primary>
   </indexterm>

   <para>
    Le standard <acronym>SQL</acronym> définit quatre niveaux d'isolation de
    transaction pour empêcher trois phénomènes de se produire lors de
    transactions concurrentes. Ces phénomènes indésirables sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>
       lecture sale
       <indexterm><primary>lecture sale</primary></indexterm>
      </term>
     <listitem>
      <para>
	Une transaction lit des données écrites par une transaction concurrente
	non validée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lecture non reproductible
       <indexterm><primary>lecture non reproductible</primary></indexterm>
      </term>
     <listitem>
      <para>
	Une transaction relit des données qu'elle a lu
	précédemment et trouve que les données ont été modifiées par une autre
	transaction (validée depuis la lecture initiale).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       lecture fantôme
       <indexterm><primary>lecture fantôme</primary></indexterm>
      </term>
     <listitem>
      <para>
	Une transaction ré-exécute une requête renvoyant un ensemble de lignes
	satisfaisant une condition de recherche et trouve que l'ensemble des
	lignes satisfaisant la condition a changé du fait d'une autre transaction
	récemment validée.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <indexterm>
     <primary>niveau d'isolation de transaction</primary>
    </indexterm>
    Les quatre niveaux d'isolation de transaction et les comportements
    correspondants sont décrits dans le <xref linkend="mvcc-isolevel-table"/>.
   </para>

    <table tocentry="1" id="mvcc-isolevel-table">
     <title>Niveaux d'isolation des transactions <acronym>SQL</acronym></title>
     <tgroup cols="4">
     <colspec colnum="1" colwidth="2.2*"/>
     <colspec colnum="2" colwidth="0.6*"/>
     <colspec colnum="3" colwidth="0.6*"/>
     <colspec colnum="4" colwidth="0.6*"/>
      <thead>
       <row>
	<entry>
         Niveau d'isolation
	</entry>
	<entry>
	 Lecture sale
	</entry>
	<entry>
	 Lecture non reproductible
	</entry>
	<entry>
	 Lecture fantôme
	</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>
	 Uncommited Read (en français, <quote>Lecture de données non validées</quote>)
	</entry>
	<entry>
	 Possible
	</entry>
	<entry>
	 Possible
	</entry>
	<entry>
	 Possible
	</entry>
       </row>

       <row>
	<entry>
	 Commited Read (en français, <quote>Lecture de données validées</quote>)
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Possible
	</entry>
	<entry>
	 Possible
	</entry>
       </row>

       <row>
	<entry>
	 Repeatable Read (en français, <quote>Lecture répétée</quote>)
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Possible
	</entry>
       </row>

       <row>
	<entry>
	 Serializable (en français, <quote>Sérialisable</quote>)
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Impossible
	</entry>
	<entry>
	 Impossible
	</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
    Dans <productname>PostgreSQL</productname>, vous pouvez demander un des
    quatre niveaux standards d'isolation de transaction. Mais, en interne,
    il existe seulement deux niveaux distincts d'isolation, qui correspondent
    aux niveaux Read Committed et Serializable. Lorsque vous sélectionnez le
    niveau Read Uncommitted, vous obtenez réellement Read Committed, et quand
    vous sélectionnez Repeatable Read, vous obtenez réellement Serializable,
    donc le niveau d'isolation actuel pourrait être plus strict que ce que vous
    sélectionnez. Ceci est permis par le standard SQL. Les quatre niveaux
    d'isolation définissent seulement quel phénomène ne doit pas survenir, ils
    ne définissent pas ce qui doit arriver. La raison pour laquelle
    <productname>PostgreSQL</productname> fournit seulement deux niveaux d'isolation est
    qu'il s'agit de la seule façon raisonnable de faire correspondre les niveaux
    d'isolation standards avec l'architecture de contrôle des accès simultanés
    multiversion. Le comportement des niveaux standards d'isolation est détaillé
    dans les sous-sections suivantes.
    </para>

    <para>
    Pour initialiser le niveau d'isolation d'une transaction, utilisez la
    commande <xref linkend="sql-set-transaction"
    endterm="sql-set-transaction-title"/>.
    </para>

  <sect2 id="xact-read-committed">
   <title>Niveau d'isolation Read committed (lecture des seules données validées)</title>

   <indexterm>
    <primary>niveau d'isolation de transaction</primary>
    <secondary>lecture validée</secondary>
   </indexterm>

   <para>
    <firstterm>Read Commited</firstterm>
    est le niveau d'isolation par défaut de
    <productname>PostgreSQL</productname>. Lorsqu'une transaction fonctionne
    avec ce niveau d'isolation, une requête <command>SELECT</command> voit
    uniquement les données validées avant que la requête soit lancée&nbsp;;
    elle ne voit jamais, lors de l'exécution de la requête, ni les données 
    non validées ni les modifications validées par les transactions concurrentes
    (néanmoins, le <command>SELECT</command> voit les effets des
    précédentes mises à jour dans sa propre transaction, et ce même si elles ne
    sont pas validées). Dans les faits, une requête <command>SELECT</command> voit
    une image de la base de données à l'instant où la requête a été lancée.
    Notez que des commandes <command>SELECT</command> successives peuvent voir
    des données différentes, y compris si elles font partie de la même
    transaction, si d'autres transactions valident des modifications de données
    pendant l'exécution du premier <command>SELECT</command>.
   </para>

   <para>
    Les commandes <command>UPDATE</command>, <command>DELETE</command>,
    <command>SELECT FOR UPDATE</command> et <command>SELECT FOR SHARE</command>
    se comportent de la même façon que
    <command>SELECT</command> en ce qui concerne la recherche des lignes
    cibles&nbsp;: elles ne trouveront que les lignes cibles qui ont été validées
    avant le début de la commande. Néanmoins, une telle ligne cible pourrait
    avoir déjà été mise à jour (ou supprimée ou verrouillée) par
    une autre transaction concurrente au moment où elle est découverte. Dans ce
    cas, le processus de mise à jour attendra que la première transaction 
    soit validée ou annulée (si elle est toujours en cours). Si la
    première mise à jour est annulée, alors ses effets sont niés et le
    deuxième processus peut exécuter la mise à jour des lignes originellement
    trouvées. Si la première mise à jour est validée, la deuxième mise à jour
    ignorera la ligne si la première mise à jour l'a supprimée, sinon elle
    essaiera d'appliquer son opération à la version mise à jour de la ligne. La
    condition de recherche de la commande (la clause <literal>WHERE</literal>) est
    ré-évaluée pour savoir si la version mise à jour de la ligne correspond
    toujours à la condition de recherche. Dans ce cas, la deuxième mise à jour
    continue son opération en commençant par la version mise à jour de la
    ligne (dans le cas des commandes <command>SELECT FOR UPDATE</command> et
    <command>SELECT FOR SHARE</command>, cela signifie que la version mise à
    jour de la ligne est verrouillée et renvoyée au client).
   </para>

   <para>
    À cause de la règle ci-dessus, une commande de mise à jour a la
    possibilité de voir une image non cohérente&nbsp;: elle peut voir les effets
    de commandes de mises à jour concurrentes affectant les mêmes lignes que
    celles qu'elle essaie de mettre à jour mais elle ne voit pas les effets de
    ces commandes sur les autres lignes de la base de données. Ce comportement
    rend le mode de lecture validée non convenable pour les commandes qui
    impliquent des conditions de recherche complexes. Néanmoins, il est correct pour
    les cas simples. Par exemple, considérons la mise à jour de balances de
    banque avec des transactions comme

<screen>BEGIN;
UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 12345;
UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 7534;
COMMIT;</screen>

    Si deux transactions comme celle-ci essaient de modifier en même temps la balance du
    compte 12345, nous voulons clairement que la deuxième transaction commence à
    partir de la version mise à jour de la ligne du compte. Comme chaque commande 
    n'affecte qu'une ligne prédéterminée, la laisser voir la
    version mise à jour de la ligne ne crée pas de soucis de cohérence.
   </para>

   <para>
    Comme dans le mode de lecture validée, chaque nouvelle commande commence
    avec une nouvelle image incluant toutes les transactions validées jusque là,
    les commandes suivantes dans la transaction verront les effets
    de la transaction concurrente validée dans tous les cas. La problématique
    ici est de savoir si à l'intérieur d'une <emphasis>même</emphasis> commande, nous
    avons ou non une vision totalement cohérente de la base de données.
   </para>

   <para>
    L'isolation partielle de la transaction fournie par le mode de lecture
    validée est adéquate pour de nombreuses applications et ce mode est rapide
    et simple à utiliser. Néanmoins, pour les applications réalisant des
    requêtes et mises à jour complexes, il pourrait être nécessaire de garantir
    une vue plus cohérente de la base de données que ce que fournit le mode
    Read Commited.
   </para>
  </sect2>

  <sect2 id="xact-serializable">
   <title>Niveau d'isolation sérialisable</title>

   <indexterm>
    <primary>niveau d'isolation de transaction</primary>
    <secondary>sérialisable</secondary>
   </indexterm>

   <para>
    Le niveau <firstterm>sérialisable</firstterm> est le niveau d'isolation
    de transaction le plus strict. Ce niveau émule l'exécution de la
    transaction en série, comme si les transactions avaient été exécutées l'une
    après l'autre, en série plutôt que parallèlement. Néanmoins, les applications
    utilisant ce niveau doivent être préparées à tenter de nouveau les
    transactions suite aux échecs de la sérialisation.
   </para>

   <para>
    Quand une transaction est dans le niveau sérialisable, une requête
    <command>SELECT</command> voit seulement les données validées avant le début
    de la transaction&nbsp;; elle ne voit jamais les données non validées et les
    modifications validées lors de l'exécution de la transaction par des
    transactions concurrentes (néanmoins, le <command>SELECT</command> voit
    bien les effets des mises à jour précédentes exécutées à l'intérieur de sa
    propre transaction même si elles ne sont pas encore validées). C'est
    différent du niveau Read Commited dans la mesure où <command>SELECT</command>
    voit une image du début de la transaction et non pas du début de la requête
    en cours à l'intérieur de la transaction. Du coup, les commandes
    <command>SELECT</command> successives à l'intérieur d'une même transaction
    voit toujours les mêmes données.
   </para>

   <para>
    Les commandes <command>UPDATE</command>, <command>DELETE</command>,
    <command>SELECT FOR UPDATE</command> et <command>SELECT FOR SHARE</command>
    se comportent de la même façon que
    <command>SELECT</command> en ce qui concerne la recherche de lignes
    cibles&nbsp;: elles trouveront seulement les lignes cibles qui ont été
    validées avant le début de la transaction. Néanmoins, une telle ligne cible
    pourrait avoir été mise à jour (ou supprimée ou verrouillée)
    par une autre transaction concurrente au moment où elle est utilisée. Dans
    ce cas, la transaction sérialisable attendra que la première transaction de
    mise à jour soit validée ou annulée (si celle-ci est toujours en
    cours). Si la première mise à jour est annulée, les effets sont inversés et
    la transaction sérialisable peut continuer avec la mise à jour de la ligne
    trouvée à l'origine. Mais si le processus de mise à jour est validé (et que
    la ligne est mise à jour ou supprimée, pas simplement verrouillée),
    alors la transaction sérialisable sera annulée avec le message

<screen>ERROR:  could not serialize access due to concurrent update</screen>

    parce qu'une transaction sérialisable ne peut pas modifier ou verrouiller
    les lignes changées par d'autres transactions après que la transaction
    sérialisable ait commencé.
   </para>

   <para>
    Quand l'application reçoit ce message d'erreurs, elle devrait annuler la
    transaction actuelle et ré-essayer la transaction complète. La seconde fois,
    la transaction voit les modifications déjà validées comme faisant partie de
    sa vue initiale de la base de données, donc il n'y a pas de conflit logique
    en utilisant la nouvelle version de la ligne comme point de départ pour la
    mise à jour de la nouvelle transaction.
   </para>

   <para>
    Notez que seules les transactions de modifications ont besoin d'être
    tentées de nouveau&nbsp;; les transactions en lecture seule n'auront jamais
    de conflits de sérialisation.
   </para>

   <para>
    Le mode sérialisable fournit une garantie rigoureuse que chaque transaction
    accède à une vue totalement cohérente de la base de données. Néanmoins,
    l'application doit être prête à tenter de nouvelles transactions lorsque des
    mises à jour concurrentes rendent impossibles de soutenir l'illusion d'une
    exécution en série. Comme le coût de re-lancement de transactions complexes
    pourrait être significatif, ce mode est seulement recommandé lors de mise à
    jour contenant une logique suffisamment complexe pour donner de
    mauvaises réponses dans le mode de lecture validée. Plus communément, le
    mode sérialisable est nécessaire quand une transaction exécute plusieurs
    commandes successives qui doivent avoir des vues identiques de la base de
    données.
   </para>

   <sect3 id="mvcc-serializability">
     <title>Isolation sérialisable contre vraie sérialisation</title>

     <indexterm>
       <primary>sérialisation</primary>
     </indexterm>

     <indexterm>
       <primary>verrouillage des prédicats</primary>
     </indexterm>

     <para>
      La signification intuitive (et la définition mathématique) de l'exécution
      <quote>sérialisable</quote> est que toute paire de transactions
      concurrentes validées avec succès apparaîtra comme ayant été exécutée
      en série, l'une après l'autre &mdash; bien que celle survenant en premier
      n'est pas prévisible. Il est important de réaliser qu'interdire les
      comportements indésirables listés dans le <xref
      linkend="mvcc-isolevel-table"/> n'est pas suffisant pour garantir une 
      vraie exécution en série et, en fait, le mode sérialisable de
      <productname>PostgreSQL</productname> <emphasis>ne garantit pas
      une exécution en série dans ce sens</emphasis>. Comme exemple, considérez
      une table <structname>ma_table</structname>, contenant initialement
   <screen> classe | valeur
--------+-------
     1  |    10
     1  |    20
     2  |   100
     2  |   200</screen>
      Supposons que la transaction sérialisable A traite
   <screen>SELECT SUM(valeur) FROM ma_table WHERE classe = 1;</screen>
      puis insère le résultat (30) comme <structfield>valeur</structfield> dans une
      nouvelle ligne avec <structfield>classe</structfield> = 2. En concurrence, la
      transaction serialisable B traite
<screen>SELECT SUM(valeur) FROM ma_table WHERE classe = 2;</screen>
      et obtient le résultat 300, qu'il insère dans une nouvelle ligne avec
      <structfield>classe</structfield> = 1.  Donc, les deux transactions valident.
      Aucun des comportements indiqués comme non désirables n'est survenu, pourtant
      nous avons un résultat qui n'aurait pû arriver dans tout ordre sériel.
      Si A a été exécuté avant B, B aurait trouvé la somme 330, et non pas 300.
      De façon similaire, l'autre ordre aurait eu comme résultat une somme
      différente pour le calcul par A.
     </para>

     <para>
      Pour garantir une vraie sérialisation mathématique, il est nécessaire que
      le système de bases de données force le <firstterm>verrouillage du
      prédicat</firstterm>, ce qui signifie qu'une transaction ne peut pas insérer ou
      modifier une ligne qui aurait correspondue à la condition
      <literal>WHERE</literal> d'une requête dans une autre transaction concurrente.
      Par exemple, une fois que la transaction A a exécuté la requête
      <literal>SELECT ... WHERE classe = 1</literal>, un système à verrouillage de
      prédicat aurait interdit l'insertion de toute ligne de classe 1 par la
      transaction B jusqu'à la validation de la transaction A.
      <footnote>
       <para>
        En fait, un système de verrouillage de prédicat empêche les lectures
        fantômes en restreignant ce qui est écrit alors que MVCC les empêche
        de restreindre ce qui est lu.
       </para>
      </footnote>
      Un tel système de verrous est complexe à implémenter et extrêmement
      coûteux à l'exécution car toutes les sessions doivent être conscientes
      des détails de chaque requête exécutée par chaque transaction
      concurrente. Et cette grande dépense est pratiquement complètement perdue
      car, en pratique, la plupart des applications ne posent pas ce genre de
      problèmes (l'exemple ci-dessus est assez petit et a peu de chance de
      représenter de vrais logiciels). Pour ces raisons,
      <productname>PostgreSQL</productname> n'implémente pas le verrouillage
      de prédicat.
     </para>

     <para>
      Dans ces cas où la possibilité d'une exécution non sérialisable est un
      vrai hasard, les problèmes peuvent être prévenus par l'utilisation
      appropriée d'un verrou explicite. Les sections suivantes comprennent plus
      de discussion sur ce sujet.
     </para>
   </sect3>
  </sect2>
 </sect1>

  <sect1 id="explicit-locking">
   <title>Verrouillage explicite</title>

   <indexterm>
    <primary>verrou</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> fournit de nombreux modes de verrous
    pour contrôler les accès concurrents aux données des tables. Ces modes
    peuvent être utilisés pour contrôler le verrouillage par l'application dans
    des situations où <acronym>MVCC</acronym> n'a pas le comportement désiré. De
    plus, la plupart des commandes <productname>PostgreSQL</productname>
    acquièrent automatiquement des verrous avec les modes appropriés pour
    s'assurer que les tables référencées ne sont pas supprimées ou modifiées de
    façon incompatible lorsque la commande s'exécute (par exemple,
    <command>ALTER TABLE</command> ne peut pas être exécuté de façon sûr en
    même temps que d'autres opérations sur la même table, donc il obtient un
    verrou exclusif sur la table pour s'assurer d'une bonne exécution).
   </para>

   <para>
    Pour examiner une liste des verrous actuels dans un serveur de base de
    données, utilisez la vue système <link
    linkend="view-pg-locks"><structname>pg_locks</structname></link>. Pour plus
    d'informations sur la surveillance du statut du sous-système de gestion des
    verrous, référez-vous au <xref linkend="monitoring"/>.
   </para>

  <sect2 id="locking-tables">
   <title>Verrous de niveau table</title>

   <indexterm zone="locking-tables">
    <primary>LOCK</primary>
   </indexterm>

   <para>
    La liste ci-dessous affiche les modes de verrous disponibles et les
    contextes dans lesquels ils sont automatiquement utilisés par
    <productname>PostgreSQL</productname>. Vous pouvez aussi acquérir
    explicitement n'importe lequel de ces verrous avec la commande <xref
    linkend="sql-lock" endterm="sql-lock-title"/>. Rappelez-vous que tous ces modes de
    verrous sont des verrous au niveau table, même si le nom contient le mot
    <quote>row</quote> (NdT&nbsp;: ligne)&nbsp;; les noms des modes de verrous
    sont historiques. Dans une certaine mesure, les noms reflètent l'utilisation
    typique de chaque mode de verrou &mdash; mais la sémantique est identique. La
    seule vraie différence entre un mode verrou et un autre est l'ensemble des
    modes verrous avec lesquels ils rentrent en conflit. Deux transactions ne
    peuvent pas conserver des verrous de modes en conflit sur la même table au
    même moment (néanmoins, une transaction n'entre jamais en conflit avec
    elle-même. Par exemple, elle pourrait acquérir un verrou <literal>ACCESS
    EXCLUSIVE</literal> et acquérir plus tard un verrou <literal>ACCESS
    SHARE</literal> sur la même table). Des modes de verrou sans conflit
    pourraient être détenus en même temps par plusieurs transactions. Notez, en
    particulier, que certains modes de verrous sont en conflit avec eux-même (par
    exemple, un verrou <literal>ACCESS EXCLUSIVE</literal> ne peut pas être
    détenu par plus d'une transaction à la fois) alors que d'autres n'entrent
    pas en conflit avec eux-même (par exemple, un verrou <literal>ACCESS
    SHARE</literal> peut être détenu par plusieurs transactions).
   </para>

     <variablelist>
      <title>Modes de verrous au niveau table</title>
      <varlistentry>
       <term>
	<literal>ACCESS SHARE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec le mode verrou <literal>ACCESS EXCLUSIVE</literal>.
	</para>

	<para>
	 Les commandes <command>SELECT</command> acquièrent un verrou sur ce
	 mode avec les tables référencées. En général, tout requête lisant
	 seulement une table et ne la modifiant pas obtiendra ce mode de verrou.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>ROW SHARE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>EXCLUSIVE</literal> et
	 <literal>ACCESS EXCLUSIVE</literal>.
	</para>

	<para>
	 La commande <command>SELECT FOR UPDATE</command> et <command>SELECT
	 FOR SHARE</command> acquièrent un verrou de ce mode
	 avec la table cible (en plus des verrous <literal>ACCESS
	 SHARE</literal> des autres tables référencées mais pas
	 sélectionnées <option>FOR UPDATE/FOR SHARE</option>).
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>ROW EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>SHARE</literal>,
	 <literal>SHARE ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>,
	 et <literal>ACCESS EXCLUSIVE</literal>.
	</para>

	<para>
	 Les commandes <command>UPDATE</command>,
	 <command>DELETE</command> et <command>INSERT</command> acquièrent ce
	 mode de verrou sur la table cible (en plus des verrous <literal>ACCESS
	 SHARE</literal> sur toutes les autres tables référencées). En général,
	 ce mode de verrouillage sera acquis par toute commande modifiant des
	 données de la table.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>SHARE UPDATE EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>SHARE UPDATE
	 EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE ROW
	 EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
	 <literal>ACCESS EXCLUSIVE</literal>. Ce mode protège une table contre
	 les modifications concurrentes de schéma et l'exécution d'un
	 <command>VACUUM</command>.
	</para>

	<para>
	 Acquis par <command>VACUUM</command> (sans <option>FULL</option>),
	 <command>ANALYZE</command> et <command>CREATE INDEX CONCURRENTLY</command>.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>SHARE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>ROW EXCLUSIVE</literal>,
	 <literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE ROW
	 EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
	 <literal>ACCESS EXCLUSIVE</literal>. Ce mode protège une table contre
	 les modifications de données concurrentes.
	</para>

	<para>
	 Acquis par <command>CREATE INDEX</command> (sans <option>CONCURRENTLY</option>).
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>SHARE ROW EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>ROW EXCLUSIVE</literal>,
	 <literal>SHARE UPDATE EXCLUSIVE</literal>,
	 <literal>SHARE</literal>, <literal>SHARE ROW
	 EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
	 <literal>ACCESS EXCLUSIVE</literal>.
	</para>

	<para>
         Ce mode de verrouillage n'est automatiquement acquis par aucune
	 commande <productname>PostgreSQL</productname>.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 En conflit avec les modes de verrous <literal>ROW SHARE</literal>,
	<literal>ROW EXCLUSIVE</literal>, <literal>SHARE UPDATE
	 EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
	 ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
	 <literal>ACCESS EXCLUSIVE</literal>. Ce mode autorise uniquement les
	verrous <literal>ACCESS SHARE</literal> concurrents, c'est-à-dire que seules les lectures à
	partir de la table peuvent être effectuées en parallèle avec une transaction
	contenant ce mode de verrouillage.
	</para>

	<para>
         Ce mode de verrouillage n'est pas automatiquement acquis sur les tables
	 utilisateur par une commande <productname>PostgreSQL</productname>.
	 Néanmoins, c'est acquis sur certains catalogues systèmes pour certaines
	 opérations.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
	<literal>ACCESS EXCLUSIVE</literal>
       </term>
       <listitem>
	<para>
	 Entre en conflit avec tous les modes (<literal>ACCESS
	 SHARE</literal>, <literal>ROW SHARE</literal>, <literal>ROW
	 EXCLUSIVE</literal>, <literal>SHARE UPDATE
	 EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
	 ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> et
	 <literal>ACCESS EXCLUSIVE</literal>).
	 Ce mode garantit que le détenteur est la seule transaction à accéder à
	 la table de quelque façon que ce soit.
	</para>

	<para>
	 Acquis par les commandes <command>ALTER TABLE</command>, <command>DROP
	 TABLE</command>, <command>TRUNCATE</command>, <command>REINDEX</command>,
	 <command>CLUSTER</command> et <command>VACUUM FULL</command>. C'est
	 aussi le mode de verrou par défaut des instructions <command>LOCK
	 TABLE</command> qui ne spécifient pas explicitement de mode de verrouillage.
	</para>
       </listitem>
      </varlistentry>
     </variablelist>

     <tip>
      <para>
       Seul un verrou <literal>ACCESS EXCLUSIVE</literal> bloque une instruction
       <command>SELECT</command> (sans <option>FOR UPDATE/SHARE</option>).
      </para>
     </tip>

   <para>
    Une fois acquis, un verrou est normalement détenu jusqu'à la fin de la
    transaction. Mais si un verrou est acquis après l'établissement d'un point
    de sauvegarde, le verrou est relâché immédiatement si le point de sauvegarde
    est annulé. Ceci est cohérent avec le principe que <command>ROLLBACK</command>
    annule tous les effets des commandes depuis le dernier point de sauvegarde.
    Il se passe la même chose pour les verrous acquis à l'intérieur d'un bloc
    d'exception <application>PL/pgSQL</application>&nbsp;: un échappement
    d'erreur à partir du bloc lâche les verrous acquis dans le bloc.
   </para>

   </sect2>

   <sect2 id="locking-rows">
    <title>Verrous au niveau ligne</title>

    <para>
     En plus des verrous au niveau table, il existe des verrous au niveau
     ligne, qui peuvent être des verrous exclusifs ou partagés. Un verrou
     exclusif sur une ligne spécifique est automatiquement acquis
     lorsque la ligne est mise à jour ou supprimée. Le verrou est détenu jusqu'à
     la fin de la transaction, que ce soit une validation ou une annulation, de
     la même façon que les verrous de niveau table. Les verrous au niveau ligne
     n'affectent pas les requêtes sur les données&nbsp;; ils bloquent seulement
     les <emphasis>modifieurs d'une même ligne</emphasis>.
    </para>

    <para>
     Pour acquérir un verrou exclusif
     au niveau ligne sans modifier réellement la ligne, sélectionnez la ligne
     avec <command>SELECT FOR UPDATE</command>. Notez qu'une fois le verrou au
     niveau ligne acquis, la transaction pourrait mettre à jour la ligne
     plusieurs fois sans peur des conflits.
    </para>

    <para>
     Pour acquérir un verrou partagé niveau ligne sur une ligne spécifique,
     sélectionnez la ligne avec <command>SELECT FOR SHARE</command>.  Un verrou
     partagé n'empêche pas les autres transactions d'obtenir le même verrou
     partagé. Néanmoins, aucune transaction n'est autorisée à mettre à jour,
     supprimer ou verrouiller exclusivement une ligne dont une autre
     transaction a obtenu un verrou partagé. Toute tentative de le faire
     bloquera tant que les verrous partagés n'auront pas été enlevés.
    </para>

    <para>
     <productname>PostgreSQL</productname> ne garde en mémoire aucune information
     sur les lignes modifiées, il n'y a donc aucune limite sur le
     nombre de lignes verrouillées à un moment donné. Néanmoins, verrouiller une
     ligne peut causer une écriture disque&nbsp;; ainsi, par exemple,
     <command>SELECT FOR UPDATE</command> modifiera les lignes sélectionnées
     pour les marquer verrouillées et cela résultera en des écritures disques.
    </para>

    <para>
     En plus des verrous tables et lignes, les verrous partagés/exclusifs sur
     les pages sont utilisés pour contrôler la lecture et l'écriture des pages
     de table dans l'ensemble de tampons partagées. Ces verrous sont
     immédiatement relâchés une fois la ligne récupérée ou mise à jour. Les
     développeurs d'application ne sont normalement pas concernés par les
     verrous au niveau page mais nous les mentionnons dans un souci d'exhaustivité.
    </para>

   </sect2>

   <sect2 id="locking-deadlocks">
    <title>Verrous morts (blocage)</title>

    <indexterm zone="locking-deadlocks">
     <primary>verrou mort</primary>
    </indexterm>

    <indexterm zone="locking-deadlocks">
     <primary>blocage de verrous</primary>
    </indexterm>

    <para>
     L'utilisation de verrous explicites accroît le risque de
     <firstterm>verrous morts</firstterm> lorsque deux transactions (voire plus) détiennent
     chacune un verrou que l'autre convoite. Par exemple, si la transaction 1 a
     acquis un verrou exclusif sur la table A puis essaie d'acquérir un verrou
     exclusif sur la table B alors que la transaction 2 possède déjà un verrou
     exclusif sur la table B et souhaite maintenant un verrou exclusif sur la
     table A, alors aucun des deux ne peut continuer.
     <productname>PostgreSQL</productname> détecte automatiquement ces
     situations de blocage et les résout en annulant une des transactions
     impliquées, permettant ainsi à l'autre (aux autres) de se terminer
     (quelle est exactement la transaction annulée est difficile à prévoir mais
     vous ne devriez pas vous en préoccuper).
    </para>

    <para>
     Notez que les verrous morts peuvent aussi se produire en résultat à des verrous
     de niveau ligne (et du coup, ils peuvent se produire même si le
     verrouillage explicite n'est pas utilisé). Considérons le cas où il
     existe deux transactions concurrentes modifiant une table. La première
     transaction exécute&nbsp;:

<screen>UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 11111;</screen>

     Elle acquiert un verrou au niveau ligne sur la ligne spécifiée par 
     le numéro de compte (no_compte). Ensuite, la deuxième transaction
     exécute&nbsp;:

<screen>UPDATE comptes SET balance = balance + 100.00 WHERE no_compte = 22222;
UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 11111;</screen>

     La première instruction <command>UPDATE</command> acquiert avec succès un
verrou au niveau ligne sur la ligne spécifiée, donc elle réussit à mettre à jour
la ligne. Néanmoins, la deuxième instruction <command>UPDATE</command> trouve
que la ligne qu'elle essaie de mettre à jour a déjà été verrouillée, alors elle
attend la fin de la transaction ayant acquis le verrou. Maintenant, la première
transaction exécute&nbsp;:

<screen>UPDATE comptes SET balance = balance - 100.00 WHERE no_compte = 22222;</screen>

     La première transaction essaie d'acquérir un verrou au niveau ligne sur 
     la ligne spécifiée mais ne le peut pas&nbsp;: la deuxième transaction
     détient déjà un verrou. Donc, elle attend la fin de la transaction deux. Du
     coup, la première transaction est bloquée par la deuxième et la deuxième
     est bloquée par la première&nbsp;: une condition de blocage, un verrou
     mort. <productname>PostgreSQL</productname> détectera cette situation et
     annulera une des transactions.
    </para>

    <para>
     La meilleure défense contre les verrous morts est généralement de les
     éviter en s'assurant que toutes les applications utilisant une base de
     données acquièrent des verrous sur des objets multiples dans un ordre
     cohérent. Dans l'exemple ci-dessus, si les deux transactions avaient mis
     à jour les lignes dans le
     même ordre, aucun blocage n'aurait eu lieu. Vous devriez vous assurer que
     le premier verrou acquis sur un objet dans une transaction est dans
     le plus haut mode qui sera nécessaire pour cet objet. S'il n'est pas possible de
     vérifier ceci à l'avance, alors les blocages devront être gérés à
     l'exécution en ré-essayant les transactions annulées à cause de blocage.
    </para>

    <para>
     Tant qu'aucune situation de blocage n'est détectée, une transaction
     cherchant soit un verrou de niveau table soit un verrou de niveau ligne
     attendra indéfiniment que les verrous en conflit soient relâchés. Ceci
     signifie que maintenir des transactions ouvertes sur une longue période
     de temps (par exemple en attendant une saisie de l'utilisateur) est
     parfois une mauvaise idée.
    </para>
   </sect2>

   <sect2 id="advisory-locks">
    <title>Verrous informatifs</title>

    <indexterm zone="advisory-locks">
     <primary>lock</primary>
     <secondary>advisory</secondary>
    </indexterm>

    <indexterm zone="advisory-locks">
     <primary>verrou</primary>
     <secondary>informatif</secondary>
    </indexterm>

    <para>
     <productname>PostgreSQL</productname> fournit un moyen pour créer des
     verrous qui ont une signification définie par l'application. Elles sont
     qualifiés d'<firstterm>informatifs</firstterm> car le système ne force
     pas leur utilisation &mdash; c'est à l'application de les utiliser
     correctement. Les verrous informatifs peuvent être utiles pour
     verrouiller des stratégies qui sont un peu étranges pour le modèle
     MVCC. Une fois acquis, un verrou informatif est détenu jusqu'à ce qu'il
     soit relâché ou que la session se termine. Contrairement aux verrous
     standards, les verrous informatifs n'honorent pas de sémantiques de
     transactions&nbsp;: un verrou informatif acquis lors d'une
     transaction qui sera par la suite annulée sera toujours détenu après
     l'annulation, et de la même façon un déverrouillage sera toujours vrai
     même si la transaction appelante échoue. Le même verrou peut être acquis
     plusieurs fois par le processus qui le détient&nbsp;: à chaque demande de
     verrou doit correspondre une demande de déverrouillage avant que le verrou
     ne soit réellement supprimé. (Si une session détient déjà un verrou donné,
     les demandes suivantes réussiront même si d'autres sessions attendent le
     verrou.) Comme tous les verrous de <productname>PostgreSQL</productname>,
     une liste complète des verrous informatifs détenus actuellement par une
     session est visible dans la vue système <structname>pg_locks</structname>.
    </para>

    <para>
     Les verrous informatifs sont alloués à partir d'une portion de mémoire
     partagée dont la taille est définie par les variables de configuration
     <xref linkend="guc-max-locks-per-transaction"/> et
     <xref linkend="guc-max-connections"/>. Attention à ne pas vider cette
     mémoire, sinon le serveur ne sera plus capable d'accorder des verrous.
     Ceci impose une limite supérieure au nombre de verrous informatifs que le
     serveur peut accorder, typiquement entre des dizaines et des centaines de
     milliers suivant la façon dont le serveur est configuré.
    </para>

    <para>
     Une utilisation commune des verrous informatifs est d'émuler des stratégies
     de verrou pessimiste, typiques des systèmes de gestion de données sur
     <quote>fichier plat</quote>. Alors qu'une option stocké dans une table
     pourrait être utilisée dans le même but, les verrous informatifs sont plus
     rapides, éviter le grossissement de MVCC et sont automatiquement nettoyés
     par le serveur à la fin d'une session. Dans certains cas qui utilisent
     cette méthode, tout spécialement les requêtes impliquant un tri explicite
     et des clauses <literal>LIMIT</literal>, une grande attention doit être
     portée au contrôle des verrous acquis à cause de l'ordre dans lequel les
     expressions SQL sont évaluées. Par exemple&nbsp;:
<screen>SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- danger !
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100;
) q; -- ok
</screen>
     Dans les requêtes ci-dessus, la deuxième forme est dangereuse parce que
     l'application de <literal>LIMIT</literal> n'est pas garantie avant que la
     fonction du verrou soit exécutée. Ceci pourrait être la cause de l'acquisition
     de certains verrous que l'application n'attendait pas et, du coup, qu'elle
     ne pourrait pas relâcher (sauf à la fin de la session). Du point de vue de
     l'application, de tels verrous sont en attente, bien qu'ils soient visibles dans
     <structname>pg_locks</structname>.
    </para>

    <para>
     Les fonctions fournies pour manipuler les verrous informatifs sont décrits dans
     <xref linkend="functions-advisory-locks"/>.
    </para>
   </sect2>

  </sect1>

  <sect1 id="applevel-consistency">
   <title>Vérification de cohérence des données au niveau de
l'application</title>

   <para>
    Comme les lecteurs ne verrouillent pas les données avec
    <productname>PostgreSQL</productname>, quelque soit le niveau d'isolation,
    les données lues par une transaction peuvent être surchargées par une autre
    transaction concurrente. En d'autres termes, si une ligne est renvoyée par
    <command>SELECT</command>, cela ne signifie pas que la ligne est toujours
    courante au moment où elle est renvoyée (c'est-à-dire, quelque temps après
    que la requête courante n'ait commencé). La ligne pourrait avoir été
    modifiée ou supprimée par une transaction validée après
    le lancement de cette requête. Même si la ligne est toujours valide
    <quote>maintenant</quote>, elle pourrait être modifiée ou supprimée avant que
    la transaction courante ne soit validée ou annulée.
   </para>

   <para>
    Une autre façon de penser à ceci est que chaque transaction voit une image
    du contenu de la base de données et les transactions concurrentes en cours
    d'exécution pourraient très bien voir des images différentes. Donc, le
    concept entier de <quote>maintenant</quote> est quelque peu mal défini. Ceci
    n'est habituellement pas un gros problème si les applications clientes sont
    isolées les unes des autres, mais si les clients peuvent communiquer via des
    canaux externes à la base de données, de sérieuses confusions pourraient
    survenir.
   </para>

   <para>
    Pour s'assurer de la validité actuelle d'une ligne et pour la protéger
    contre les modifications concurrentes, vous devez utiliser <command>SELECT
    FOR UPDATE</command>, <command>SELECT FOR SHARE</command> ou une instruction
    <command>LOCK TABLE</command> appropriée (<command>SELECT FOR
    UPDATE</command> et <command>SELECT FOR SHARE</command> verrouillent uniquement les
    lignes renvoyées contre les mises à jours concurrentes alors que <command>LOCK
    TABLE</command> verrouille la table entière). Ceci doit être pris en compte
    lors du portage d'applications vers <productname>PostgreSQL</productname>
    depuis d'autres environnements.
   </para>

   <para>
    Des vérifications globales de validité requièrent une réflexion
    supplémentaire avec <acronym>MVCC</acronym>. Par exemple, une application
    bancaire pourrait souhaiter vérifier que la somme de tous les crédits d'une
    table est équivalente à la somme des débits d'une autre table lorsque les
    deux tables sont activement mises à jour. Comparer les résultats de deux
    commandes <literal>SELECT sum(...)</literal> successives ne fonctionnera pas
    correctement avec le mode de lecture validée car la deuxième requête a des
    chances d'inclure les résultats de transactions non comptabilisées dans la
    première. Faire les deux sommes dans une seule transaction sérialisée
    donnera une image plus précise des effets des transactions validées avant
    le début de la transaction sérialisable &mdash; mais vous pourriez vous
    demander si la réponse est toujours juste au moment où elle est fournie. Si
    la transaction sérialisable a elle-même appliqué des modifications avant de
    tenter la vérification de cohérence, l'utilité de la vérification devient
    bien plus discutable car, maintenant, elle inclut des modifications apparues
    après le début de la transaction mais
    pas toutes. Dans de tels cas, une personne attentionnée pourrait souhaiter
    verrouiller toutes les tables nécessaires à la vérification pour obtenir
    une image indiscutable de la réalité. Un verrou de mode <literal>SHARE</literal>
    (ou plus important) garantit qu'il n'y a aucune modification non validée
    dans la table verrouillée, autres que celles de la transaction.
   </para>

   <para>
    Il est à noter que si vous voulez vous reposer sur les verrous explicites
    pour éviter les changements concurrents, vous devriez utiliser le mode
    Read Commited, ou alors, dans le mode sérialisable, être attentif à l'obtention
    des verrous avant d'effectuer des requêtes. Un verrou obtenu par une
    transaction sérialisable garantit qu'aucune autre transaction modifiant la
    table n'est en cours d'exécution mais si l'image vue par la transaction est
    antérieure à l'obtention du verrou, elle pourrait être antérieure aux quelques
    modifications maintenant validées dans la table. Une image de la transaction
    sérialisable est généralement gelée au début de la première requête ou de
    la première commande de modification de données (<literal>SELECT</literal>,
    <literal>INSERT</literal>, <literal>UPDATE</literal> ou <literal>DELETE</literal>). Du coup, il
    est possible d'obtenir des verrous de façon explicite avant que l'image ne soit
    gelée.
   </para>
  </sect1>

  <sect1 id="locking-indexes">
   <title>Verrouillage et index</title>

   <indexterm zone="locking-indexes">
    <primary>index</primary>
    <secondary>verrous</secondary>
   </indexterm>

   <para>
    Bien que <productname>PostgreSQL</productname> fournisse des accès non bloquant en
    lecture/écriture aux données de la table, un accès non bloquant
    en lecture/écriture n'est pas fourni pour chaque méthode d'accès aux index
    implémentée dans <productname>PostgreSQL</productname>. Les différents
    types d'index sont gérés ainsi&nbsp;:

    <variablelist>
     <varlistentry>
      <term>
       Index B-tree et <acronym>GiST</acronym>
      </term>
      <listitem>
       <para>
	    Les verrous partagés/exclusifs de court terme au niveau page sont
	    utilisés pour les accès en lecture/écriture. Les verrous sont
	    immédiatement relâchés après le parcours ou l'insertion de chaque 
	    ligne d'index. Ces types d'index fournissent le plus haut niveau de
	    concurrence sans conditions de blocage.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       Index hachés
      </term>
      <listitem>
       <para>
        Les verrous partagés/exclusifs au niveau hash-bucket sont utilisés
        pour des accès en lecture/écriture. Les verrous sont relâchés après
        la fin des traitements sur le bucket. Les verrous au niveau bucket
        fournissent un meilleur accès concurrent que les verrous au niveau
        index mais sont sensibles aux blocages car les verrous sont détenus
        plus longtemps que pour une opération sur un index.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       Index <acronym>GIN</acronym>
      </term>
      <listitem>
       <para>
        Les verrous partagés/exclusifs à court terme et de niveau page sont
	utilisés pour les accès en lecture/écriture. Les verrous sont relâchés
	immédiatement après chaque récupération ou insertion de ligne d'index.
	Mais notez que l'insertion d'une valeur indexée par GIN produit
	habituellement plusieurs de clés d'index par ligne, donc GIN peut faire
	un travail substantiel pour l'insertion d'une simple valeur.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Actuellement, les index B-tree offrent la meilleure performance pour les
    applications concurrentes&nbsp;; comme ils ont aussi plus de
    fonctionnalités que les index hachés, ils constituent le type d'index
    recommandé pour les applications concurrentes nécessitant des index sur
    des données scalaires. Pour les données non scalaires, les index B-trees
    ne sont pas utiles et les index GIN et GiST devraient être utilisés à leur place.
   </para>
  </sect1>
 </chapter>
