<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/plhandler.sgml,v 1.5 2005/06/13 06:25:42 guillaume Exp $
-->

 <chapter id="plhandler">
   <title>Écrire un gestionnaire de langage procédural</title>

   <indexterm zone="plhandler">
    <primary>langage procédural</primary>
    <secondary>gestionnaire</secondary>
   </indexterm>

   <para>
    Tous les appels vers des fonctions écrites dans un langage autre que celui
    de l'interface <quote>version 1</quote> pour les langages compilés (ceci
    inclut les fonctions dans les langages procéduraux définis par
    l'utilisateur, les fonctions écrites en SQL et les fonctions utilisant
    l'interface de langage compilé version 0), passent par une fonction du
    <firstterm>gestionnaire d'appels</firstterm> spécifique au langage.
    Il est de la responsabilité du gestionnaire d'appels d'exécuter la fonction 
    de manière significative, comme par exemple en interprétant le texte source 
    fourni. Ce chapitre indique comment le gestionnaire d'appels d'un nouveau langage
    procédural peut être écrit.
   </para>

   <para>
    Le gestionnaire d'appel d'un langage procédural est une fonction
    <quote>normale</quote> qui doit être écrite dans un langage compilé tel que
    le C, en utilisant l'interface version-1, et enregistré avec
    <productname>PostgreSQL</productname> comme ne prenant aucun argument
    et retournant le type <type>language_handler</type>. Ce pseudo-type spécial
    identifie la fonction en tant que gestionnaire d'appel et l'empêche d'être
    appelée directement à partir des commandes SQL.
   </para>

   <para>
    Le gestionnaire d'appels est appelé de la même façon que n'importe quelle
    autre fonction&nbsp;: il reçoit un pointeur vers une <type>structure</>
    <structname>FunctionCallInfoData</structname> contenant des valeurs en
    argument et une information sur la fonction appelée. Il doit renvoyer un
    résultat <type>Datum</type> (et, si possible, initialiser le champ
    <structfield>isnull</structfield> de la structure
    <structname>FunctionCallInfoData</structname> s'il souhaite renvoyer un
    résultat SQL NULL). La différence entre un gestionnaire d'appels et une
    fonction ordinaire est que le champ
    <structfield>flinfo-&gt;fn_oid</structfield> de la structure
    <structname>FunctionCallInfoData</structname> contiendra l'OID
    de la fonction à appeler, et non pas celui du gestionnaire d'appels lui-même.
    Le gestionnaire d'appels doit utiliser ce champ pour déterminer la
    fonction à exécuter. De plus, la liste d'arguments passée a été configurée 
    en accord avec la déclaration de la fonction cible, et non pas en
    fonction du gestionnaire d'appels.
   </para>

   <para>
    C'est au gestionnaire d'appels de récupérer l'entrée de la
    fonction à partir de la table système <classname>pg_proc</classname> et
    d'analyser les types des arguments et de la valeur de retour de la fonction
    appelée. La clause <literal>AS</> de la commande
    <command>CREATE FUNCTION</command> de la fonction sera trouvée dans la
    colonne <literal>prosrc</literal> de
    <classname>pg_proc</classname>. Cela peut être le texte du source du
    langage procédural lui-même (comme pour PL/Tcl) mais, en théorie, cela
    peut être un chemin vers un fichier ou tout autre chose qui indique
    en détails au gestionnaire d'appels ce qu'il doit faire.
   </para>

   <para>
    Souvent, la même fonction est appelée plusieurs fois par instruction SQL.
    Un gestionnaire d'appels peut éviter des recherches d'informations répétées
    sur la fonction appelée en utilisant le champ
    <structfield>flinfo-&gt;fn_extra</structfield>. Il sera initialement à
    <symbol>NULL</> mais pourra être configuré par le gestionnaire d'appels pour
    pointer vers l'information de la fonction appelée. Pour les appels
    suivants, si <structfield>flinfo-&gt;fn_extra</structfield> est déjà
    différent de <symbol>NULL</>, alors il peut être utilisé et l'étape de
    recherche d'information pourra être évitée. Le gestionnaire d'appels doit
    s'assurer que <structfield>flinfo-&gt;fn_extra</structfield> pointe sur une 
    zone mémoire qui restera allouée au moins jusqu'à la fin de la requête en cours
    car il se peut qu'une structure de données <structname>FmgrInfo</structname> soit
    conservée aussi longtemps. Une façon de le faire est d'allouer les données
    supplémentaires dans le contexte mémoire spécifié par
    <structfield>flinfo-&gt;fn_mcxt</structfield>&nbsp;; de telles données
    auront normalement la même espérance de vie que
    <structname>FmgrInfo</structname> lui-même. Mais le gestionnaire pourrait
    également choisir d'utiliser un contexte mémoire de plus longue durée de façon à
    mettre en cache sur plusieurs
    requêtes des informations sur les définitions des fonctions.
   </para>

   <para>
    Lorsqu'une fonction en langage procédural est appelée via un déclencheur,
    aucun argument ne lui est passé de façon habituelle mais le champ
    <structfield>context</structfield> de
    <structname>FunctionCallInfoData</structname> pointe sur une structure
    <structname>TriggerData</structname>, et n'est pas
    <symbol>NULL</> comme c'est le cas dans les appels de fonctions standard.
    Le gestionnaire d'un langage devrait fournir des mécanismes pour que les
    fonctions de langages procéduraux obtiennent des informations du
    déclencheur.
   </para>

   <para>
    Voici un modèle de gestionnaire de langage procédural écrit en C&nbsp;:
<programlisting>
#include "postgres.h"
#include "executor/spi.h"
#include "commands/trigger.h"
#include "fmgr.h"
#include "access/heapam.h"
#include "utils/syscache.h"
#include "catalog/pg_proc.h"
#include "catalog/pg_type.h"

PG_FUNCTION_INFO_V1(plsample_call_handler);

Datum
plsample_call_handler(PG_FUNCTION_ARGS)
{
    Datum          retval;

    if (CALLED_AS_TRIGGER(fcinfo))
    {
        /*
         * Appelé en tant que procédure d'un déclencheur
         */
        TriggerData    *trigdata = (TriggerData *) fcinfo-&gt;context;

        retval = ...
    }
    else
    {
        /*
         * Appelé en tant que fonction
         */

        retval = ...
    }

    return retval;
}
</programlisting>
    Seules quelques milliers de lignes de codes devront être ajoutées à la place des
    points pour compléter ce modèle.
   </para>

   <para>
    Après avoir compilé la fonction du gestionnaire dans un module chargeable
    (voir <xref linkend="dfunc">), les commandes suivantes enregistrent le langage
    procédural défini dans l'exemple&nbsp;:
<programlisting>
CREATE FUNCTION plsample_call_handler() RETURNS language_handler
    AS '<replaceable>nomfichier</replaceable>'
    LANGUAGE C;
CREATE LANGUAGE plsample
    HANDLER plsample_call_handler;
</programlisting>
   </para>

   <para>
    Les langages de procédures inclus dans la distribution standard sont de
    bonnes références lorsque vous essayez d'écrire votre propre gestionnaire
    d'appels. Regardez dans le sous-répertoire <filename>src/pl</> des sources.
   </para>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
