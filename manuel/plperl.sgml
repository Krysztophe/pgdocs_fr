<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/plperl.sgml,v 1.6.2.2 2005/06/13 06:24:04 guillaume Exp $
-->

 <chapter id="plperl">
  <title>PL/Perl - Langage de procédures Perl</title>

  <indexterm zone="plperl">
   <primary>PL/Perl</primary>
  </indexterm>

  <indexterm zone="plperl">
   <primary>Perl</primary>
  </indexterm>

  <para>
   PL/Perl est un langage de procédures chargeable qui vous permet d'écrire des
   fonctions <productname>PostgreSQL</productname> dans le langage de
   programmation <ulink url="http://www.perl.com">Perl</ulink>.
  </para>

  <para>
   Pour installer PL/Perl dans une base de données spécifique, utilisez la
   commande <literal>createlang plperl <replaceable>nombase</></literal>.
  </para>

  <tip>
   <para>
    Si un langage est installé dans <literal>template1</>, toutes les
    bases de données créées ultérieurement disposeront automatiquement de ce
    langage.
   </para>
  </tip>

  <note>
   <para>
    Les utilisateurs des paquetages sources doivent explicitement autoriser la
    construction de PL/Perl pendant le processus d'installation. (Se référer aux
    instructions d'installation pour plus d'informations.) Les utilisateurs des
    paquetages binaires peuvent trouver PL/Perl dans un sous-paquetage séparé.
   </para>
  </note>

 <sect1 id="plperl-funcs">
  <title>Fonctions et arguments PL/Perl</title>

  <para>
   Pour créer une fonction dans le langage PL/Perl, utilisez la syntaxe
   standard&nbsp;:
<programlisting>
CREATE FUNCTION <replaceable>nomfonction</replaceable>
(<replaceable>types-arguments</replaceable>) RETURNS
<replaceable>type-retour</replaceable> AS '
    # Corps de la fonction PL/Perl
' LANGUAGE plperl;
</programlisting>
   Le corps de la fonction est du code Perl normal.
  </para>

  <para>
   Les arguments et les résultats sont manipulés comme dans n'importe quel
   routine Perl&nbsp;: les arguments sont passés au tableau
   <varname>@_</varname> et une valeur de retour
   est indiquée par <literal>return</> ou par la dernière expression
   évaluée dans la fonction.
  </para>

  <para>
   Par exemple, une fonction retournant le plus grand de deux entiers
   peut être définie comme suit&nbsp;:

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS '
    if ($_[0] > $_[1]) { return $_[0]; }
    return $_[1];
' LANGUAGE plperl;
</programlisting>
  </para>

  <para>
   Si une valeur nulle en SQL<indexterm><primary>valeur NULL</><secondary
   sortas="PL/Perl">en PL/Perl</></indexterm> est passée à une fonction,
   cet argument apparaîtra comme <quote>undefined</> en Perl. La
   fonction définie ci-dessus ne se comportera pas correctement avec des
   arguments NULL (en fait, tout se passera comme s'ils avaient été des zéros).
   Nous aurions pu ajouter <literal>STRICT</> à la définition de la fonction
   pour forcer <productname>PostgreSQL</productname> à faire quelque chose de
   plus raisonnable&nbsp;: si une valeur NULL est passée en argument, la
   fonction ne sera pas du tout appelée mais retournera automatiquement un
   résultat NULL. D'une autre façon, nous aurions pu vérifier dans le corps de
   la fonction la présence d'arguments NULL. Par exemple, supposons que nous
   voulions que <function>perl_max</function> avec un argument NULL et un autre
   non NULL retourne une valeur non NULL plutôt qu'une valeur NULL, on aurait
   écrit&nbsp;:

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS '
    my ($a,$b) = @_;
    if (! defined $a) {
        if (! defined $b) { return undef; }
        return $b;
    }
    if (! defined $b) { return $a; }
    if ($a > $b) { return $a; }
    return $b;
' LANGUAGE plperl;
</programlisting>
  </para>

  <para>
   Comme le montre l'exemple ci-dessus, passer une valeur NULL en SQL
   à une fonction en PL/Perl retourne une valeur non définie. Et ceci,
   que la fonction soit déclarée stricte ou non.
  </para>

  <para>
   Les arguments de type composite sont passés à la fonction en tant que
   références d'un tableau de découpage, les clés du tableau de découpage étant
   les noms des attributs du type composé. Voici un exemple&nbsp;:

<programlisting>
CREATE TABLE employe (
    nom text,
    basesalaire integer,
    bonus integer
);

CREATE FUNCTION empcomp(employe) RETURNS integer AS '
    my ($emp) = @_;
    return $emp->{''basesalaire''} + $emp->{''bonus''};
' LANGUAGE plperl;

SELECT nom, empcomp(employe) FROM employee;
</programlisting>
  </para>

  <para>
   Actuellement, il n'y a pas la possibilité de retourner
   des valeurs de type composite.
  </para>

  <tip>
   <para>
    Parce que le corps de la fonction est passé en tant que littéral de chaîne
    SQL à <command>CREATE FUNCTION</command>, vous devez échapper les
    guillemets simples et les barres obliques inverses à l'intérieur de votre
    code Perl, généralement en les doublant comme c'est montré dans l'exemple
    ci-dessus. Une autre approche possible consiste à éviter d'écrire les
    guillemets simples en utilisant les opérateurs de citation étendu
(<literal>q[]</literal>,
    <literal>qq[]</literal>, <literal>qw[]</literal>).
   </para>
  </tip>
 </sect1>

 <sect1 id="plperl-data">
  <title>Données en PL/Perl</title>

  <para>
   Les valeurs des arguments fournis au code d'une fonction PL/Perl sont
   simplement les arguments d'entrée convertis en une chaîne de caractères (simplement
   comme s'ils avaient été affichés par une commande <literal>SELECT</literal>).
   Réciproquement, la commande <literal>return</> acceptera n'importe quelle chaîne
   dont le format d'entrée est conforme pour les types de retour déclarés de la
   fonction. Ainsi, le développeur PL/Perl peut manipuler les données comme si
   elles étaient simplement du texte.
  </para>
 </sect1>

 <sect1 id="plperl-database">
  <title>Accès à la base de données depuis PL/Perl</title>

  <para>
   L'accès à la base de données à l'intérieur de vos fonctions écrites en Perl peut se faire à partir
   du module expérimental <ulink
   url="http://www.cpan.org/modules/by-module/DBD/APILOS/"><literal>DBD::PgSPI</literal></ulink>
   (aussi disponible sur un miroir du <ulink url="http://www.cpan.org/SITES.html"><acronym>CPAN</></ulink>).
   Ce module rend accessible un descripteur de base de données conforme à
   <acronym>DBI</> nommé
   <varname>$pg_dbh</varname> qui peut-être utilisé pour exécuter des requêtes en utilisant
   la syntaxe habituelle de <acronym>DBI</>.<indexterm><primary>DBI</></indexterm>
  </para>

  <para>
   Actuellement, PL/Perl fournit une seule commande Perl supplémentaire&nbsp;:

   <variablelist>
    <varlistentry>
     <indexterm>
      <primary>elog</primary>
      <secondary>en PL/Perl</secondary>
     </indexterm>

     <term><function>elog</> <replaceable>level</replaceable>, <replaceable>msg</replaceable></term>
     <listitem>
      <para>
       Produit un message de trace ou d'erreur. Les niveaux possibles sont
       <literal>DEBUG</>, <literal>LOG</>, <literal>INFO</>,
       <literal>NOTICE</>, <literal>WARNING</> et <literal>ERROR</>.
       <literal>ERROR</> lève une condition d'erreur&nbsp;: la suite de
       l'exécution de la fonction est abandonnée et la transaction en cours
       annulée.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect1>

 <sect1 id="plperl-trusted">
  <title>Niveaux de confiance de PL/Perl</title>

  <indexterm zone="plperl-trusted">
   <primary>trusted</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>

  <para>
   Normalement, PL/Perl est installé en tant que langage de programmation de
   <quote>confiance</>, de nom <literal>plperl</>. Durant cette installation,
   certaines commandes Perl sont désactivées pour préserver la sécurité. En
   général, les commandes qui interagissent avec l'environnement sont
   restreintes. Cela inclut les commandes sur les descripteurs de fichiers,
   <literal>require</literal> et <literal>use</literal> (pour les modules
   externes). Il n'est pas possible d'accéder aux fonctions et variables
   internes du processus du serveur de base de données ou d'obtenir un accès au
   niveau du système d'exploitation avec les droits du processus serveur, tel
   qu'une fonction C peut le faire. Ainsi, n'importe quel utilisateur sans
   droits sur la base de données est autorisé à utiliser ce langage.
  </para>

  <para>
   Voici l'exemple d'une fonction qui ne fonctionnera pas car les commandes système
   ne sont pas autorisées pour des raisons de sécurité&nbsp;:
<programlisting>
CREATE FUNCTION badfunc() RETURNS integer AS '
    open(TEMP, ">/tmp/mauvaisfichier");
    print TEMP "Je t'ai eu !\n";
    return 1;
' LANGUAGE plperl;
</programlisting>
   La création de cette fonction va réussir, mais pas son exécution.
  </para>

  <para>
   Il est parfois souhaitable d'écrire des fonctions Perl qui ne sont pas
   restreintes. Par exemple, on peut souhaiter vouloir envoyer des courriers
   électroniques. Pour supporter ce cas de figure, PL/Perl peut aussi être
   installé comme un langage <quote>douteux</> (habituellement nommé
   <application>PL/PerlU</application>
   <indexterm><primary>PL/PerlU</></indexterm>).
   Dans ce cas, la totalité du langage Perl est accessible. Si la commande
   <command>createlang</command> est utilisée pour installer le langage, le nom
   du langage <literal>plperlu</literal> sélectionnera la version douteuse de
   PL/Perl.
  </para>

  <para>
   Les auteurs des fonctions <application>PL/PerlU</> doivent faire attention au
   fait que celles-ci ne puissent être utilisées pour faire quelque chose de non
   désiré car cela donnera la possibilité d'agir comme si l'on possédait les
   privilèges d'administrateur de la base de données. Il est à noter que le
   système de base de données ne permet qu'aux super-utilisateurs de créer des
   fonctions dans un langage douteux.
  </para>

  <para>
   Si la fonction ci-dessus a été créée par un super-utilisateur en utilisant le
   langage <literal>plperlu</>, l'exécution de celle-ci réussira.
  </para>

  <note>
   <para>
    Bien que les fonctions <application>PL/Perl</> s'exécutent dans un
    interpréteur Perl séparé pour chaque rôle SQL, toutes les fonctions
    <application>PL/PerlU</> exécutées dans la même session s'exécutent avec
    un seul interpréteur Perl (qui ne correspond à aucun de ceux utilisés pour
    les fonctions <application>PL/Perl</>). Ceci permet aux fonctions
    <application>PL/PerlU</> de partager librement des données, mais aucune
    communication ne peut intervenir entre des fonctions
    <application>PL/Perl</> et <application>PL/PerlU</>.
   </para>
  </note>

  <note>
   <para>
    Perl ne supporte pas l'utilisation de plusieurs interpréteurs dans un
    même processus sauf s'il a été construit avec les options appropriées,
    c'est-à-dire soit <literal>usemultiplicity</> soit <literal>useithreads</>.
    (<literal>usemultiplicity</> est préférée sauf si vous avez réellement
    besoin des threads. Pour plus de détails, voir la page man
    <citerefentry><refentrytitle>perlembed</></citerefentry>.)
    Si <application>PL/Perl</> est utilisé avec une copie de Perl qui n'a pas
    été construite de cette façon, alors il est seulement possible d'avoir un
    interpréteur Perl par session, et donc une session ne peut seulement
    exécuter que des fonctions <application>PL/PerlU</> ou que des fonctions
    <application>PL/Perl</> qui sont toutes appelées par le même rôle SQL.
   </para>
  </note>
  
 </sect1>

 <sect1 id="plperl-missing">
  <title>Fonctionnalités absentes</title>

  <para>
   Les fonctionnalités suivantes ne sont actuellement pas implémentées dans PL/Perl, mais peuvent faire
   l'objet de contributions généreuses de votre part.

   <itemizedlist>
    <listitem>
     <para>
      Les fonctions PL/Perl ne peuvent pas s'appeler entre elles (parce
      qu'elles sont considérées comme des sous-routines anonymes au sein de
      Perl). Actuellement, il ne leur est pas possible de partager des variables
      globales entre elles.
     </para>
    </listitem>

    <listitem>
     <para>
      PL/Perl ne peut pas être utilisé pour écrire des
      déclencheurs.<indexterm><primary>déclencheur</><secondary>en
      PL/Perl</></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      <application>DBD::PgSPI</applicatioN> ou une application équivalente
      devra être intégrée dans la distribution
      <productname>PostgreSQL</productname> standard.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Pour des raisons de sécurité, PL/Perl exécute des fonctions appelées par
   un rôle SQL dans un interpréteur Perl séparé pour ce rôle. Ceci empêche
   l'interférence accidentelle ou malicieuse d'un utilisateur avec le
   comportement des fonctions PL/Perl d'un autre utilisateur. Chaque
   interprétateur a sa propre valeur de la variable
   <varname>%_SHARED</varname> et des autres états globaux. Du coup, deux
   fonctions PL/Perl partageront la même valeur de <varname>%_SHARED</varname>
   si et seulement si elles sont exécutées par le même rôle SQL. Dans une
   application où une session seule exécute du code sous plusieurs rôles SQL
   (via des fonctions <literal>SECURITY DEFINER</>, l'utilisation de
   <command>SET ROLE</>, etc), vous pouvez avoir besoin de mettre en place des
   étapes explicites pour vous assurer que les fonctions PL/Perl peuvent
   partager des données <varname>%_SHARED</varname>. Pour cela, assurez-vous
   que les fonctions qui doivent communiquer ont pour propriétaire le même
   utilisateur et marquez les comme <literal>SECURITY DEFINER</>. Bien sûr,
   vous devez faire attention à ce que ces fonctions ne puissent pas être
   utilisées pour faire des choses qu'elles ne sont pas sensées faire.
  </para>
 </sect1>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
