<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/plpython.sgml,v 1.10 2005/09/15 07:03:20 guillaume Exp $ -->

<chapter id="plpython">
 <title>PL/Python - Langage de procédures Python</title>

 <indexterm zone="plpython"><primary>PL/Python</primary></indexterm>
 <indexterm zone="plpython"><primary>Python</primary></indexterm>

 <para>
  Le langage de procédures <application>PL/Python</application> permet l'écriture
  de fonctions <productname>PostgreSQL</productname> avec le
  <ulink url="http://www.python.org">langage Python</ulink>.
 </para>

 <para>
  Pour installer PL/Python dans une base de données particulières, utilisez
  <literal>createlang plpythonu <replaceable>nom_base</replaceable></literal>.
 </para>

  <tip>
   <para>
    Si un langage est installé dans <literal>template1</literal>, toutes les bases
    nouvellement créées se verront installées ce langage automatiquement.
   </para>
  </tip>

 <para>
  Depuis <productname>PostgreSQL</productname> 7.4, PL/Python est seulement
  disponible en tant que langage <quote>sans confiance</quote> (ceci signifiant
  qu'il n'offre aucun moyen de restreindre ce que les utilisateurs en font). Il
  a donc été renommé en <literal>plpythonu</literal>. La variante de confiance
  <literal>plpython</literal> pourrait être de nouveau disponible dans le futur, si un
  nouveau mécanisme sécurisé d'exécution est développé dans Python.
 </para>

 <note>
  <para>
   Les utilisateurs des paquets sources doivent activer spécifiquement la
   construction de PL/Python lors des étapes d'installation (référez-vous aux
   instructions d'installation pour plus d'informations). Les utilisateurs de
   paquets binaires pourront trouver PL/Python dans un paquet séparé.
  </para>
 </note>

 <sect1 id="plpython-funcs">
  <title>Fonctions PL/Python</title>

  <para>
   Les fonctions PL/Python sont déclarées via la syntaxe habituelle <xref
   linkend="sql-createfunction" endterm="sql-createfunction-title"/>. Par exemple
<programlisting>CREATE FUNCTION ma_fonction(text) RETURNS text
    AS 'return args[0]'
    LANGUAGE plpythonu;
</programlisting>

   Le code Python donné comme corps de la définition de fonction est transformé
   en fonction Python. Par exemple, le code ci-dessus devient

<programlisting>def __plpython_procedure_ma_fonction_23456():
        return args[0]
</programlisting>

   en supposant que 23456 est l'OID affecté à la fonction par
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   Si vous ne fournissez pas de valeur de retour,
   <application>PL/Python</application> renvoie par défaut
   <symbol>None</symbol>. Le module du langage traduit le
   <symbol>None</symbol> de Python en la valeur NULL en SQL.
   <indexterm><primary>valeur NULL</primary><secondary
   sortas="PL/Python">en PL/Python</secondary></indexterm>
  </para>

  <para>
   Les paramètres de fonctions avec <productname>PostgreSQL</productname> sont disponibles
   dans la liste globale <varname>args</varname>. Dans l'exemple
   <function>ma_fonction</function>, <varname>args[0]</varname> contient ce qui a été
   passé dans l'argument texte. Pour
   <literal>ma_fonction2(text, integer)</literal>, <varname>args[0]</varname>
   contiendrait l'argument de type <type>text</type> et
   <varname>args[1]</varname> l'argument de type <type>integer</type>.
  </para>

  <para>
   Le dictionnaire global <varname>SD</varname> est disponible pour stocker des
   données entres les appels de fonctions. Cette variable est une donnée
   statique privée. Le dictionnaire global <varname>GD</varname> est une donnée
   publique disponible pour toutes les fonctions Python à l'intérieur d'une
   session. À utiliser avec précaution.<indexterm><primary>données
   globales</primary><secondary>en PL/Python</secondary></indexterm>
  </para>

  <para>
   Chaque fonction obtient son propre environnement d'exécution dans
   l'interpréteur Python, de façon à ce que les données globales et les
   arguments de fonction provenant de <function>ma_fonction</function> ne soient
   pas disponibles depuis <function>ma_fonction2</function>. L'exception
   concerne les données du dictionnaire <varname>GD</varname> comme indiqué
   ci-dessus.
  </para>
 </sect1>

 <sect1 id="plpython-trigger">
  <title>Fonctions de déclencheurs</title>

  <indexterm zone="plpython-trigger">
   <primary>déclencheur</primary>
   <secondary>en PL/Python</secondary>
  </indexterm>

  <para>
   Quand une fonction est utilisée comme un déclencheur, le dictionnaire
   <literal>TD</literal> contient des valeurs relatives au déclencheur. Les
   lignes du déclencheur sont dans <literal>TD["new"]</literal> et/ou
   <literal>TD["old"]</literal> suivant l'événement ayant lancé le déclencheur.
   <literal>TD["event"]</literal> contient l'événement en tant que chaîne
   (<literal>INSERT</literal>, <literal>UPDATE</literal>,
   <literal>DELETE</literal> ou <literal>UNKNOWN</literal>).
   <literal>TD["when"]</literal> contient soit <literal>BEFORE</literal>, soit
   <literal>AFTER</literal> soit <literal>UNKNOWN</literal>.
   <literal>TD["level"]</literal> contient une valeur parmi <literal>ROW</literal>,
   <literal>STATEMENT</literal> et <literal>UNKNOWN</literal>.
   <literal>TD["name"]</literal> contient le nom du déclencheur et
   <literal>TD["relid"]</literal> l'OID de la table sur lequel le déclencheur a été
   activé. Si la commande <command>CREATE TRIGGER</command> incluait des
   arguments, ils sont disponibles dans les variables de
   <literal>TD["args"][0]</literal> à
   <literal>TD["args"][(<replaceable>n</replaceable>-1)]</literal>.
  </para>

  <para>
   Si <literal>TD["when"]</literal> vaut <literal>BEFORE</literal>, vous pourriez
   renvoyer <literal>None</literal> ou <literal>"OK"</literal> à partir de la
   fonction Python pour indiquer que la ligne n'est pas modifiée,
   <literal>"SKIP"</literal> pour annuler l'événement ou <literal>"MODIFY"</literal> pour
   indiquer que vous avez modifié la ligne.
  </para>
 </sect1>

 <sect1 id="plpython-database">
  <title>Accès à la base de données</title>

  <para>
   Le module du langage PL/Python importe automatiquement un module Python
   appelé <literal>plpy</literal>. Les fonctions et constantes de ce module
   vous sont accessibles dans le code Python via
   <literal>plpy.<replaceable>foo</replaceable></literal>. Actuellement,
   <literal>plpy</literal> implémente les fonctions
   <literal>plpy.debug(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.log(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.info(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.notice(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.warning(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.error(<replaceable>msg</replaceable>)</literal> et
   <literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>.
   <indexterm><primary>elog</primary><secondary>dans PL/Python</secondary></indexterm>
   <function>plpy.error</function> et <literal>plpy.fatal("msg")</literal>
   lèvent une exception Python qui, si non attrapée, se propage à la requête
   appelante causant l'annulation de la transaction ou sous-transaction en
   cours.  <literal>raise plpy.ERROR(<replaceable>msg</replaceable>)</literal> et
   <literal>raise plpy.FATAL(<replaceable>msg</replaceable>)</literal> sont équivalent à
   appeler, respectivement, <function>plpy.error</function> et
   <function>plpy.fatal</function>. Les autres fonctions génèrent uniquement
   des messages de
   niveaux de priorité différents. Que les messages d'une priorité particulière
   soient reportés au client, écrit dans les journaux du serveur ou les deux,
   cette configuration est contrôlée par les variables <xref
   linkend="guc-log-min-messages"/> et <xref linkend="guc-client-min-messages"/>.
   Voir le <xref linkend="runtime-config"/> pour plus d'informations.
  </para>

  <para>
   De plus, le module <literal>plpy</literal> fournit deux fonctions appelées
   <function>execute</function> et <function>prepare</function>. Appeler
   <function>plpy.execute</function> avec une chaîne de requête et un argument
   de limite optionnel fait que la requête est lancée et que le résultat est
   renvoyé dans un objet résultat. L'objet résultat émule une liste ou un objet
   dictionnaire. L'objet résultat est accessible par le numéro de ligne et le
   nom de la colonne. Il a plusieurs méthodes supplémentaires&nbsp;:
   <function>nrows</function> qui renvoie le nombre de lignes retournées par la
   requête et <function>status</function> qui est le code de retour de
   <function>SPI_execute()</function>. L'objet résultat peut être modifié.
  </para>

  <para>
   Par exemple,
<programlisting>rv = plpy.execute("SELECT * FROM ma_table", 5)
</programlisting>
   renvoie cinq lignes de <literal>ma_table</literal>. Si
   <literal>ma_table</literal> dispose d'une colonne
   <literal>ma_colonne</literal>, elle sera accessible avec
<programlisting>foo = rv[i]["ma_colonne"]
</programlisting>
  </para>

  <para>
   <indexterm><primary>préparer une requête</primary><secondary>en
PL/Python</secondary></indexterm>
   La seconde fonction, <function>plpy.prepare</function>, prépare le plan
   d'exécution pour une requête. Il est appelé avec une chaîne contenant la
   requête et une liste des types de paramètres si vous avez des références de
   paramètres dans la requête. Par exemple&nbsp;:
<programlisting>plan = plpy.prepare("SELECT nom FROM mes_utilisateurs WHERE prenom = $1", [
"text" ])
</programlisting>
   <literal>text</literal> est le type de la variable que vous voulez passer via
   <literal>$1</literal>. Après avoir préparé une instruction, vous utilisez la
   fonction <function>plpy.execute</function> pour l'exécuter&nbsp;:
<programlisting>rv = plpy.execute(plan, [ "nom" ], 5)
</programlisting>
   Le troisième argument est la limite et est optionnelle.
  </para>

  <para>
   Lorsque vous préparez un plan en utilisant le module PL/Python, il est
   automatiquement sauvegardé. Lisez la documentation SPI (<xref
   linkend="spi"/>) pour une description de ce que cela signifie. Pour faire
   réellement usage de ceci dans les appels de fonction, vous avez besoin
   d'utiliser un des dictionnaires à stockage permanent
   <literal>SD</literal> ou <literal>GD</literal> (voir le
   <xref linkend="plpython-funcs"/>). Par exemple&nbsp;:
<programlisting>CREATE FUNCTION utiliseplansauvegarde() RETURNS trigger AS $$
    if SD.has_key("plan"):
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # reste de la fonction
$$ LANGUAGE plpythonu;
</programlisting>
  </para>
 </sect1>

<!-- [IGNORE[ NOT CURRENTLY SUPPORTED

 <sect1 id="plpython-trusted">
  <title>Restricted Environment</title>

  <para>
   The current version of <application>PL/Python</application>
   functions as a trusted language only; access to the file system and
   other local resources is disabled.  Specifically,
   <application>PL/Python</application> uses the Python restricted
   execution environment, further restricts it to prevent the use of
   the file <function>open</function> call, and allows only modules from a
   specific list to be imported.  Presently, that list includes:
   <literal>array</literal>, <literal>bisect</literal>, <literal>binascii</literal>,
   <literal>calendar</literal>, <literal>cmath</literal>, <literal>codecs</literal>,
   <literal>errno</literal>, <literal>marshal</literal>, <literal>math</literal>, <literal>md5</literal>,
   <literal>mpz</literal>, <literal>operator</literal>, <literal>pcre</literal>,
   <literal>pickle</literal>, <literal>random</literal>, <literal>re</literal>, <literal>regex</literal>,
   <literal>sre</literal>, <literal>sha</literal>, <literal>string</literal>, <literal>StringIO</literal>,
   <literal>struct</literal>, <literal>time</literal>, <literal>whrandom</literal>, and
   <literal>zlib</literal>.
  </para>
 </sect1>

-->

</chapter>
