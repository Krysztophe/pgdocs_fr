<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/queries.sgml,v 1.8.2.3 2005/07/15 06:33:45 guillaume Exp $ -->

<chapter id="queries">
 <title>Requêtes</title>

 <indexterm zone="queries">
  <primary>requête</primary>
 </indexterm>

 <indexterm zone="queries">
  <primary>SELECT</primary>
 </indexterm>

 <para>
  Les précédents chapitres expliquaient comme créer des tables, comment
  les remplir avec des données et comment manipuler ces données.
  Il est temps d'aborder maintenant la façon de récupérer ces données
  depuis la base de données.
 </para>


 <sect1 id="queries-overview">
  <title>Survol</title>

  <para>
   Le processus de récupération des données et la commande elle-même sont appelés
   <firstterm>requête</firstterm>. En SQL, la commande
   <command>SELECT</command> est utilisée pour spécifier des requêtes. La
   syntaxe générale de la commande <command>SELECT</command> est <synopsis>
SELECT <replaceable>liste_select</replaceable> FROM <replaceable>expression_table</replaceable> <optional><replaceable>specification_tri</replaceable></optional>
</synopsis>
   Les sections suivantes décrivent en détails la liste de sélection,
   l'expression de tables et la spécification du tri.
  </para>

  <para>
   Le type de requête le plus simple est de la forme
<programlisting>
SELECT * FROM table1;
</programlisting>
  En supposant qu'il existe une table appelée <literal>table1</literal>, cette
  commande récupérera toutes les lignes et toutes les colonnes de
  <literal>table1</literal>. (La méthode de récupération dépend de l'application
  client. Par exemple, le programme <application>psql</application> affichera
  une table, façon art ASCII, alors que les bibliothèques client offriront
  des fonctions d'extraction de valeurs individuelles à partir du résultat de
  la requête.) <literal>*</literal> utilisé comme liste de sélection désigne toutes
  les colonnes que l'expression de la table fournie. Une liste de sélection
  peut aussi sélectionner un sous-ensemble des colonnes disponibles ou effectuer
  un calcul en utilisant les colonnes. Par exemple, si <literal>table1</literal>
  dispose des colonnes nommées <literal>a</>, <literal>b</> et <literal>c</> (et
  peut-être d'autres), la requête suivante peut être effectuée&nbsp;:
<programlisting>
SELECT a, b + c FROM table1;
</programlisting>
  (en supposant que <literal>b</> et <literal>c</> soient de type numérique).
  Voir <xref linkend="queries-select-lists"> pour plus de détails.
 </para>

 <para>
  <literal>FROM table1</literal> est un type très simple d'expression de
  tables&nbsp;: il lit une seule table. En général, les expressions de tables
  sont des constructions complexes de tables de base, de jointures et de
  sous-requêtes. Il est également possible d'omettre l'expression de table
  et d'utiliser la commande <command>SELECT</command> comme une calculatrice&nbsp;:
<programlisting>
SELECT 3 * 4;
</programlisting>
  Ceci est plus utile si les expressions de la liste de sélection renvoient des
  résultats variables. Il est, par exemple, possible d'appeler une fonction de cette
  façon&nbsp;:
<programlisting>
SELECT random();
</programlisting>
  </para>
 </sect1>


 <sect1 id="queries-table-expressions">
  <title>Expressions de table</title>

  <indexterm zone="queries-table-expressions">
   <primary>expression de table</primary>
  </indexterm>

  <para>
   Une <firstterm>expression de table</firstterm> calcule une table.
   L'expression de table contient une clause <literal>FROM</> qui peut être
   suivie des clauses <literal>WHERE</>, <literal>GROUP BY</> et
   <literal>HAVING</>. Les expressions de table triviales font simplement référence à
   une table sur le disque, appelée table de base, mais des expressions plus
   complexes peuvent être utilisées pour modifier ou combiner des tables de base
   de différentes façons.
  </para>

  <para>
   Les clauses optionnelles <literal>WHERE</>, <literal>GROUP BY</> et
   <literal>HAVING</> dans l'expression de table spécifient un enchaînement de
   transformations successives réalisées sur la table dérivée de la
   clause <literal>FROM</>. Toutes ces transformations produisent une table
   virtuelle fournissant les lignes à passer à la liste de sélection qui
   choisira les lignes à afficher en sortie de la requête.
  </para>
	
  <sect2 id="queries-from">
   <title>La clause <literal>FROM</literal></title>
 
   <para>
    La clause <literal>FROM</> dérive une table à partir d'une ou plusieurs
    tables, spécifiées dans une liste de référence dont le séparateur est une virgule.
<synopsis>
FROM <replaceable>reference_table</replaceable> <optional>,
<replaceable>reference_table</replaceable> <optional>, ...</optional></optional>
</synopsis>

    Une référence de table peut être un nom de table (optionnellement préfixé par
    le nom du schéma) ou une table dérivée. Une table dérivée peut-être une sous-requête,
    une jointure de tables ou toute combinaison complexe de celles-ci. Si plusieurs
    références de tables sont listées dans la clause <literal>FROM</>, elles sont
    jointes (voir plus bas) pour former la table virtuelle intermédiaire, sujet possible de
    transformations par les clauses <literal>WHERE</>, <literal>GROUP BY</> et
    <literal>HAVING</>. et qui est finalement le résultat de l'expression des tables globale.
   </para>

   <indexterm>
    <primary>ONLY</primary>
   </indexterm>

   <para>
    Lorsqu'une référence de table fait référence à une table supertable d'une
    hiérarchie d'héritage, la référence de table produit les
    lignes non seulement de la table mais aussi des successeurs de cette table
    sauf si le mot clé <literal>ONLY</> précède le nom de la table. Toutefois,
    la référence produit seulement les colonnes qui apparaissent dans la table
    nommée --- toute colonne ajoutée dans une sous-table est ignorée.
   </para>

   <sect3 id="queries-join">
    <title>Tables jointes</title>

    <indexterm zone="queries-join">
     <primary>join</primary>
    </indexterm>

    <para>
     Une table jointe est une table dérivée de deux autres tables (réelles ou
     dérivées) suivant les règles du type de jointure particulier. Les
     jointures internes (inner), externes (outer) et croisées (cross) sont
     disponibles.
    </para>

    <variablelist>
     <title>Types de jointures</title>

     <varlistentry>
      <term>Jointure croisée (cross join)</term>

      <indexterm>
       <primary>jointure</primary>
       <secondary>croisée</secondary>
      </indexterm>

      <indexterm>
       <primary>join</primary>
       <secondary>cross</secondary>
      </indexterm>

      <indexterm>
       <primary>jointure croisée</primary>
      </indexterm>

      <indexterm>
       <primary>cross join</primary>
      </indexterm>

      <listitem>
<synopsis>
<replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable>
</synopsis>

       <para>
        Pour chaque combinaison de lignes provenant de
        <replaceable>T1</replaceable> et de <replaceable>T2</replaceable>, la
        table dérivée contiendra une ligne constituée de toutes les colonnes de
        <replaceable>T1</replaceable> suivies de toutes les colonnes de
        <replaceable>T2</replaceable>. Si les tables ont respectivement N et M
        lignes, la table jointe en aura N * M.
       </para>

       <para>
        <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
        <replaceable>T2</replaceable></literal> est équivalent à
        <literal>FROM <replaceable>T1</replaceable>,
        <replaceable>T2</replaceable></literal>. C'est aussi équivalent à
        <literal>FROM <replaceable>T1</replaceable> INNER JOIN
        <replaceable>T2</replaceable> ON TRUE</literal> (voir ci-dessous).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Jointures qualifiées (qualified joins)</term>

      <indexterm>
       <primary>join</primary>
       <secondary>outer</secondary>
      </indexterm>

      <indexterm>
       <primary>outer join</primary>
      </indexterm>

      <indexterm>
       <primary>jointure</primary>
       <secondary>externe</secondary>
      </indexterm>

      <indexterm>
       <primary>jointure externe</primary>
      </indexterm>
      
      <listitem>
<synopsis>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> ON <replaceable>boolean_expression</replaceable>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> USING ( <replaceable>join column list</replaceable> )
<replaceable>T1</replaceable> NATURAL { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable>
</synopsis>
        
       <para>
        Les mots <literal>INNER</literal> et
        <literal>OUTER</literal> sont optionnels dans toutes les formes.
        <literal>INNER</literal> est la valeur par défaut&nbsp;;
        <literal>LEFT</literal>, <literal>RIGHT</literal> et
        <literal>FULL</literal> impliquent une jointure externe.
       </para>

       <para>
        La <firstterm>condition de jointure</firstterm> est spécifiée dans
        la clause <literal>ON</> ou <literal>USING</>, ou implicitement par le
        mot <literal>NATURAL</>. La condition de jointure détermine les lignes
        des deux tables sources <quote>correspondantes</quote>,
        comme l'explique le paragraphe ci-dessous.
       </para>

       <para>
        La clause <literal>ON</> est le type le plus général de condition de 
        jointure&nbsp;: elle prend une expression booléenne du même genre que
        celle utilisée dans une clause <literal>WHERE</>. Une paire de lignes
        de <replaceable>T1</> et <replaceable>T2</> correspondent si
        l'expression <literal>ON</> est évaluée à vraie (true) pour ces deux
        lignes.
       </para>

       <para>
        <literal>USING</> est une notation raccourcie&nbsp;: elle prend une
        liste de noms de colonnes, séparés par des virgules, que les tables
        jointes doivent avoir en commun, et forme une condition de jointure spécifiant
        l'égalité de chacune de ces paires de colonnes. De plus, la sortie de
        <literal>JOIN USING</> a une colonne pour chaque paire égalée de
        colonnes en entrée. Ces colonnes sont suivies par toutes les autres colonnes de chaque
        table. De ce fait, <literal>USING (a, b, c)</literal> est équivalent à
        <literal>ON (t1.a = t2.a AND t1.b = t2.b AND t1.c = t2.c)</literal> à
        la différence que si <literal>ON</> est utilisé, il y a deux colonnes
        <literal>a</>, <literal>b</>, puis <literal>c</> dans le résultat, alors
        qu'avec <literal>USING</>, il n'y en aura qu'une de chaque.
       </para>

       <para>
        <indexterm>
	 <primary>join</primary>
	 <secondary>natural</secondary>
	</indexterm>
        <indexterm>
	 <primary>natural join</primary>
	</indexterm>
        <indexterm>
	 <primary>jointure</primary>
	 <secondary>naturelle</secondary>
	</indexterm>
        <indexterm>
	 <primary>jointure naturelle</primary>
	</indexterm>
        Enfin, <literal>NATURAL</> est un format raccourci de
        <literal>USING</>&nbsp;: il forme une liste <literal>USING</>
        constituée exactement des noms des colonnes apparaissant à la fois dans
        les deux tables en entrée. Comme avec <literal>USING</>, ces colonnes
        n'apparaissent qu'une fois dans la table de sortie.
       </para>

       <para>
        Les types possibles de jointures qualifiées sont&nbsp;:

       <variablelist>
        <varlistentry>
         <term><literal>INNER JOIN</></term>

         <listitem>
          <para>
           Pour chaque ligne L1 de T1, la table jointe a une ligne pour chaque
           ligne de T2 satisfaisant la condition de jointure avec L1.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>LEFT OUTER JOIN</></term>

         <indexterm>
          <primary>join</primary>
          <secondary>left</secondary>
         </indexterm>

         <indexterm>
          <primary>left join</primary>
         </indexterm>

         <indexterm>
          <primary>jointure</primary>
          <secondary>gauche</secondary>
         </indexterm>

         <indexterm>
          <primary>jointure gauche</primary>
         </indexterm>

         <listitem>
          <para>
           En premier lieu, une jointure interne est réalisée. Puis, pour chaque
           ligne de T1 qui ne satisfait à la condition de jointure avec aucune
           des lignes de T2, une ligne jointe est ajoutée avec des valeurs
           nulles dans les colonnes de T2. Du coup, la table jointe a au moins
           une ligne pour chaque ligne de T1 quelques soient les conditions.
          </para>
         </listitem>
        </varlistentry>
         
        <varlistentry>
         <term><literal>RIGHT OUTER JOIN</></term>

         <indexterm>
          <primary>join</primary>
          <secondary>right</secondary>
         </indexterm>

         <indexterm>
          <primary>right join</primary>
         </indexterm>

         <indexterm>
          <primary>jointure</primary>
          <secondary>droite</secondary>
         </indexterm>

         <indexterm>
          <primary>jointure droite</primary>
         </indexterm>

         <listitem>
          <para>
           En premier lieu, une jointure interne est réalisée. Puis, pour chaque
           ligne de T2 qui ne satisfait à la condition de jointure avec aucune
           des lignes de T1, une ligne jointe est ajoutée avec des valeurs nulles
           dans les colonnes de T1. C'est l'inverse d'une jointure gauche&nbsp;:
           la table résultante aura une ligne pour chaque ligne de T2 quelques
           soient les conditions.
          </para>
         </listitem>
        </varlistentry>
         
        <varlistentry>
         <term><literal>FULL OUTER JOIN</></term>

         <listitem>
          <para>
           En premier lieu, une jointure interne est réalisée. Puis, pour chaque
           ligne de T1 qui ne satisfait à la condition de jointure avec aucune
           des lignes de T2, une ligne jointe est ajoutée avec des valeurs nulles dans
           les colonnes de T2. Enfin, pour chaque ligne de T2 qui ne satisfait
           à la condition de jointure avec aucune des lignes de T1, une ligne jointe
           est ajoutée avec des valeurs nulles dans les colonnes de T1.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
     Des jointures de tout type peuvent être chaînées ou imbriquées&nbsp;:
     <replaceable>T1</replaceable> et <replaceable>T2</replaceable> peuvent
     être des tables jointes (l'une, l'autre ou les deux).
     Des parenthèses peuvent être utilisées autour des clauses
     <literal>JOIN</> pour contrôler l'ordre de jointure. En l'absence de
     parenthèses, les clauses <literal>JOIN</> s'imbriquent de gauche à
     droite.
    </para>

    <para>
     Pour résumer, supposons que nous ayons une table
     <literal>t1</literal>
<programlisting>
 num | nom
-----+------
   1 | a
   2 | b
   3 | c
</programlisting>
     et une table <literal>t2</literal>
<programlisting>
 num | valeur
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz
</programlisting>
     nous obtenons les résultats suivants pour les différentes jointures&nbsp;:
<screen>
<prompt>=></> <userinput>SELECT * FROM t1 CROSS JOIN t2;</>
 num | nom | num | valeur
-----+-----+-----+-------
   1 | a   |   1 | xxx
   1 | a   |   3 | yyy
   1 | a   |   5 | zzz
   2 | b   |   1 | xxx
   2 | b   |   3 | yyy
   2 | b   |   5 | zzz
   3 | c   |   1 | xxx
   3 | c   |   3 | yyy
   3 | c   |   5 | zzz
(9 rows)

<prompt>=></> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</>
 num | nom | num | valeur
-----+-----+-----+-------
   1 | a   |   1 | xxx
   3 | c   |   3 | yyy
(2 rows)

<prompt>=></> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);</>
 num | nom | valeur
-----+-----+-------
   1 | a   | xxx
   3 | c   | yyy
(2 rows)

<prompt>=></> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</>
 num | nom | valeur
-----+-----+-------
   1 | a   | xxx
   3 | c   | yyy
(2 rows)

<prompt>=></> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</>
 num | nom | num | valeur
-----+-----+-----+-------
   1 | a   |   1 | xxx
   2 | b   |     |
   3 | c   |   3 | yyy
(3 rows)

<prompt>=></> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);</>
 num | nom | valeur
-----+-----+-------
   1 | a   | xxx
   2 | b   |
   3 | c   | yyy
(3 rows)

<prompt>=></> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</>
 num | nom | num | valeur
-----+-----+-----+-------
   1 | a   |   1 | xxx
   3 | c   |   3 | yyy
     |     |   5 | zzz
(3 rows)

<prompt>=></> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</>
 num | nom | num | valeur
-----+-----+-----+-------
   1 | a   |   1 | xxx
   2 | b   |     |
   3 | c   |   3 | yyy
     |     |   5 | zzz
(4 rows)
</screen>
    </para>

    <para>
     La condition de jointure spécifiée avec <literal>ON</> peut aussi contenir
     des conditions sans relation directe avec la jointure. Par exemple&nbsp;:
<screen>
<prompt>=></> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</>
 num | nom | num | valeur
-----+-----+-----+-------
   1 | a   |   1 | xxx
   2 | b   |     |
   3 | c   |     |
(3 rows)
</screen>
    </para>
   </sect3>

   <sect3 id="queries-table-aliases">
    <title>Alias de table et de colonne</title>

    <indexterm zone="queries-table-aliases">
     <primary>alias</primary>
     <secondary>dans la clause FROM</secondary>
    </indexterm>

    <indexterm>
     <primary>label</primary>
     <see>alias</see>
    </indexterm>

    <para>
     Un nom temporaire peut être donné aux tables et aux références de tables
     complexes. Celui-ci sera ensuite utilisé pour faire référence à la table dérivée dans la
     suite de l'exécution. On appelle cela un <firstterm>alias de table</firstterm>.
    </para>

    <para>
     Pour créer un alias de table, il suffit d'écrire
<synopsis>
FROM <replaceable>reference_table</replaceable> AS <replaceable>alias</replaceable>
</synopsis>
     ou
<synopsis>
FROM <replaceable>reference_table</replaceable> <replaceable>alias</replaceable>
</synopsis>
     Le mot clé <literal>AS</literal> n'est pas nécessaire.
     <replaceable>alias</replaceable> peut être n'importe quel identifiant.
    </para>

    <para>
     Une application typique des alias de table est l'affectation d'identifiants
     courts pour les noms de table longs, ce qui permet de garder des clauses de
     jointures lisibles. Par exemple&nbsp;:
<programlisting>
SELECT * FROM nom_de_table_tres_long n JOIN un_autre_nom_assez_long u ON n.id = u.num;
</programlisting>
    </para>

    <para>
     L'alias devient le nouveau nom de la référence de la table pour la requête
     courante -- il n'est plus possible de référencer la table avec son nom
     d'origine. Du coup,
<programlisting>
SELECT * FROM ma_table AS m WHERE ma_table.a > 5;
</programlisting>
     n'est pas une syntaxe SQL valide. En réalité, (c'est une extension du standard
     proposée par <productname>PostgreSQL</productname>) une référence de table
     implicite est ajoutée à la clause <literal>FROM</literal>, de façon à ce
     que la requête soit exécutée comme si elle était écrite ainsi
<programlisting>
SELECT * FROM ma_table AS m, ma_table AS ma_table WHERE ma_table.a > 5;
</programlisting>
     ce qui aboutira à une jointure croisée. Et ce n'est habituellement pas
     ce qui est attendu.
    </para>

    <para>
     Les alias de table sont essentiellement disponibles pour faciliter l'écriture
     de requêtes mais ils apparaissent nécessaires pour joindre une table avec
     elle-même, par exemple
<programlisting>
SELECT * FROM ma_table AS a CROSS JOIN ma_table AS b ...
</programlisting>
     De plus, un alias est requis si la référence de table est une
     sous-requête (voir <xref linkend="queries-subqueries">).
    </para>

    <para>
     Les parenthèses sont utilisées pour lever les ambiguités. L'instruction
     suivante affectera le résultat de la jointure à l'alias <literal>b</literal>,
     contrairement à l'exemple précédent&nbsp;:
<programlisting>
SELECT * FROM (ma_table AS a CROSS JOIN ma_table) AS b ...
</programlisting>
    </para>

    <para>
     Une autre forme d'alias de tables donne des noms temporaires aux colonnes
     des tables&nbsp;:
<synopsis>
FROM <replaceable>reference_table</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> ( <replaceable>colonne1</replaceable> <optional>, <replaceable>colonne2</replaceable> <optional>,...</optional></optional> )
</synopsis>
     Si le nombre d'alias de colonnes spécifiés est plus petit que le nombre
     de colonnes dont dispose la table réelle, les colonnes résiduelles ne sont
     pas renommées. Cette syntaxe est particulièrement utile dans le cas
     d'auto-jointures ou dans le cas de sous-requêtes.
    </para>

    <para>
     Quand un alias est appliqué à la sortie d'une clause <literal>JOIN</>,
     quelqu'en soit la forme, l'alias cache le nom original à l'intérieur du
     <literal>JOIN</>. Par exemple,
<programlisting>
SELECT a.* FROM ma_table AS a JOIN ta_table AS b ON ...
</programlisting>
     est du SQL valide, mais
<programlisting>
SELECT a.* FROM (ma_table AS a JOIN ta_table AS b ON ...) AS c
</programlisting>
     n'est pas valide&nbsp;: l'alias de table <literal>a</> n'est pas visible
     en dehors de l'alias <literal>c</>.
    </para>
   </sect3>

   <sect3 id="queries-subqueries">
    <title>Sous-requêtes</title>

    <indexterm zone="queries-subqueries">
     <primary>sous-requête</primary>
    </indexterm>

    <para>
     Une sous-requête spécifiant une table dérivée doit être écrite entre
     parenthèses et <emphasis>doit</emphasis> se voir affecter un alias
     de table. (Voir <xref linkend="queries-table-aliases">.) Par exemple&nbsp;:
<programlisting>
FROM (SELECT * FROM table1) AS nom_alias
</programlisting>
    </para>

    <para>
     Cet exemple est équivalent à <literal>FROM table1 AS nom_alias</literal>.
     Des cas plus intéressants, qui ne peuvent pas être réduits à une jointure
     pleine, surviennent quand la sous-requête implique un groupement ou un agrégat.
    </para>
   </sect3>

   <sect3 id="queries-tablefunctions">
    <title>Fonctions de table</title>

    <indexterm zone="queries-tablefunctions"><primary>fonction de table</></>

    <indexterm zone="queries-tablefunctions">
     <primary>fonction</>
     <secondary>dans la clause FROM</>
    </indexterm>

    <para>
     Les fonctions de table sont des fonctions produisant un ensemble de
     lignes composées de types de données basiques (types scalaires) ou de types
     de données composites (lignes de table). Elles sont utilisées de la même façon
     qu'une table, une vue ou une sous-requête de la clause <literal>FROM</> d'une
     requête. Les colonnes retournées par les fonctions de table peuvent être
     incluses dans une clause <literal>SELECT</>, <literal>JOIN</> ou
     <literal>WHERE</> de la même manière qu'une colonne de table, vue ou
     sous-requête.
    </para>

    <para>
     Si une fonction de table renvoie un type de données basique, la colonne
     de résultat est nommée comme la fonction. Si la fonction renvoie un type
     composite, les colonnes résultantes ont le même nom que les attributs
     individuels du type.
    </para>

    <para>
     Une fonction de table peut avoir un alias dans la clause <literal>FROM</>.
     Dans le cas contraire, le nom de la fonction est utilisé comme nom de table résultante.
    </para>

    <para>
     Quelques exemples&nbsp;:
<programlisting>
CREATE TABLE truc (trucid int, trucsousid int, trucnom text);

CREATE FUNCTION recuptruc(int) RETURNS SETOF truc AS '
    SELECT * FROM truc WHERE trucid = $1;
' LANGUAGE SQL;

SELECT * FROM recuptruc(1) AS t1;

SELECT * FROM truc
    WHERE trucsousid IN (select trucsousid from recuptruc(truc.trucid) z
                           where z.trucid = truc.trucid);

CREATE VIEW vue_recuptruc AS SELECT * FROM recuptruc(1);
SELECT * FROM vue_recuptruc;
</programlisting>
    </para>

    <para>
     Dans certains cas, il est utile de définir des fonctions de table qui
     renvoient des ensembles de colonnes différents suivant la façon dont elles
     sont appelées. Pour ce faire, la fonction de table est déclarée comme
     renvoyant le pseudotype <type>record</>. Quand une telle fonction est
     utilisée dans une requête, la structure de ligne attendue doit être
     spécifiée dans la requête elle-même. De cette façon, le système saura
     comment analyser et planifier la requête. Par exemple&nbsp;:
<programlisting>
SELECT *
    FROM dblink('dbname=mabd', 'select proname, prosrc from pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>
     La fonction <literal>dblink</> exécute une requête distante (voir
     <filename>contrib/dblink</>). Elle a été déclarée avec un type de retour
     <type>record</>, puisqu'elle peut être utilisée pour tout type de requête.
     L'ensemble de colonnes réelles doit être spécifié dans la requête appelante
     de sorte que l'analyseur sache, par exemple, comment étendre <literal>*</>.
    </para>
   </sect3>
  </sect2>

  <sect2 id="queries-where">
   <title>La clause <literal>WHERE</literal></title>

   <indexterm zone="queries-where">
    <primary>WHERE</primary>
   </indexterm>

   <para>
    La syntaxe de la clause <literal>WHERE</> est
<synopsis>
WHERE <replaceable>condition_recherche</replaceable>
</synopsis>
    où <replaceable>condition_recherche</replaceable> est une expression de
    valeur, telle que définie dans <xref linkend="sql-expressions">, qui retourne
    une valeur de type <type>boolean</type>.
   </para>

   <para>
    Après le traitement de la clause <literal>FROM</>, chaque ligne de la
    table virtuelle dérivée est confrontée à la condition de recherche. Si le
    résultat de la vérification est positif (true), la ligne est conservée dans
    la table de sortie, sinon (c'est-à-dire si le résultat est faux ou nul) la
    ligne est abandonnée. La condition de recherche fait, en général, référence
    à une colonne de la table engendrée dans la clause <literal>FROM</>&nbsp;;
    ceci n'est pas impératif mais, dans le cas contraire, la clause <literal>WHERE</>
    s'avère inutile.
   </para>

   <note>
    <para>
     Avant l'implémentation de la syntaxe <literal>JOIN</>, il était nécessaire
     de placer la condition de jointure d'une jointure interne dans la clause
     <literal>WHERE</>. Les expressions de tables suivantes sont équivalentes&nbsp;:
<programlisting>
FROM a, b WHERE a.id = b.id AND b.val &gt; 5
</programlisting>
     et
<programlisting>
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5
</programlisting>
     ou même
<programlisting>
FROM a NATURAL JOIN b WHERE b.val &gt; 5
</programlisting>
     L'utilisation de l'une par rapport à l'autre est affaire de style. La syntaxe
     <literal>JOIN</> dans la clause <literal>FROM</> n'est pas forcément très
     portable vers les autres systèmes de gestion de bases de données SQL.
     Pour les jointures externes, il n'y qu'une seule possibilité&nbsp;: elles
     doivent être faites dans la clause <literal>FROM</>. Une clause
     <literal>ON</>/<literal>USING</> d'une jointure externe n'est
     <emphasis>pas</> équivalente à une condition <literal>WHERE</> parce
     qu'elle détermine l'ajout de lignes (pour les lignes en entrée sans
     correspondance) ainsi que la suppression de lignes dans le résultat final.
    </para>
   </note>

   <para>
    Voici quelques exemples de clauses <literal>WHERE</literal>&nbsp;:
<programlisting>
SELECT ... FROM fdt WHERE c1 > 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 > fdt.c1)
</programlisting>
    <literal>fdt</literal> est la table dérivée dans la clause
    <literal>FROM</>. Les lignes qui ne correspondent pas à la condition de la
    recherche de la clause <literal>WHERE</> sont éliminées de la table
    <literal>fdt</literal>. On peut noter l'utilisation de sous-requêtes scalaires
    comme expressions de valeurs. A l'instar de n'importe quelle autre requête, les
    sous-requêtes peuvent employer des expressions de tables complexes. On peut
    également noter la façon dont <literal>fdt</literal> est référencée dans les
    sous-requêtes. Qualifier <literal>c1</> sous la forme <literal>fdt.c1</> n'est
    nécessaire que si <literal>c1</> est aussi le nom d'une colonne dans la table
    dérivée en entrée de la sous-requête. Mais qualifier le nom de colonne, même lorsque cela
    n'est pas nécessaire, ajoute à la clarté. Cet exemple montre comment le nommage
    de colonne d'une requête externe est étendu dans les requêtes internes.
   </para>
  </sect2>


  <sect2 id="queries-group">
   <title>Les clauses <literal>GROUP BY</literal> et
<literal>HAVING</literal></title>

   <indexterm zone="queries-group">
    <primary>GROUP BY</primary>
   </indexterm>

   <indexterm zone="queries-group">
    <primary>groupement</primary>
   </indexterm>

   <para>
    Après avoir passé le filtre <literal>WHERE</>, la table d'entrée dérivée
    peut faire l'objet d'un regroupement par l'utilisation de la clause
    <literal>GROUP BY</> et d'une élimination de lignes groupées par la clause
    <literal>HAVING</>.
   </para>

<synopsis>
SELECT <replaceable>liste_selection</replaceable>
    FROM ...
    <optional>WHERE ...</optional>
    GROUP BY <replaceable>reference_colonne_regroupement</replaceable> <optional>, <replaceable>reference_colonne_regroupement</replaceable></optional>...
</synopsis>

   <para>
    La clause <literal>GROUP BY</> est utilisée pour regrouper les lignes d'une
    table qui partagent les mêmes valeurs pour toutes les colonnes précisées.
    L'ordre dans lequel ces colonnes sont indiquées importe peu. Le but est de
    réduire chaque groupe de lignes partageant des valeurs communes en une seule
    ligne de groupe représentative de toutes les lignes du groupe. Ceci est fait
    pour éliminer les redondances dans la sortie et/ou pour calculer les agrégats
    s'appliquant à ces groupes. Par exemple&nbsp;:
<screen>
<prompt>=></> <userinput>SELECT * FROM test1;</>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<prompt>=></> <userinput>SELECT x FROM test1 GROUP BY x;</>
 x
---
 a
 b
 c
(3 rows)
</screen>
   </para>
	  
   <para>
    Dans la seconde requête, il n'est pas possible d'écrire <literal>SELECT *
    FROM test1 GROUP BY x</literal> parce qu'il n'existe pas de valeur unique
    pour la colonne <literal>y</> pouvant être associée avec chaque autre groupe.
    Les colonnes de regroupement peuvent être référencées dans la liste de
    sélection car elles ont une valeur constante connue par groupe.
   </para>

   <para>
    En général, si une table est groupée, il ne peut pas être fait référence aux
    colonnes qui ne sont pas utilisées dans le regroupement sinon dans les
    expressions d'agrégats. Voici un exemple d'expressions d'agrégat&nbsp;:
<screen>
<prompt>=></> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)
</screen>
    Ici, <literal>sum</literal> est une fonction d'agrégat qui calcule une
    valeur unique pour tout le groupe. On pourra touver plus d'informations sur
    les fonctions d'agrégats disponibles dans <xref linkend="functions-aggregate">.
   </para>

   <tip>
    <para>
     Le regroupement sans expression d'agrégats calcule effectivement
     l'ensemble des valeurs distinctes d'une colonne. Le même résultat peut être obtenu
     à l'aide de la clause <literal>DISTINCT</> (voir <xref linkend="queries-distinct">).
    </para>
   </tip>

   <para>
    L'exemple suivant calcule les ventes totales pour chaque produit (plutôt que
    le total des ventes sur tous les produits).
<programlisting>
SELECT produit_id, p.nom, (sum(v.unite) * p.prix) AS ventes
    FROM produits p LEFT JOIN ventes v USING (produit_id)
    GROUP BY produit_id, p.nom, p.prix;
</programlisting>
    Dans cet exemple, les colonnes <literal>produit_id</literal>,
    <literal>p.nom</literal> et <literal>p.prix</literal> doivent se trouver dans la
    clause <literal>GROUP BY</> car elles sont référencées dans la liste de
    sélection de la requête. (Suivant la façon dont est conçue la table
    produits, le nom et le prix peuvent être totalement dépendants de l'ID du
    produit et de ce fait, les regroupements supplémentaires ne sont théoriquement pas
    nécessaires. Mais ceci n'est pas encore implémenté.) La colonne
    <literal>s.unite</> n'a pas besoin d'être dans la liste <literal>GROUP
    BY</> car elle est utilisée uniquement dans l'expression de l'agrégat
    (<literal>sum(...)</literal>) représentant les ventes d'un produit. Pour
    chaque produit, la requête renvoie une ligne de résumé sur les ventes de ce
    produit.
   </para>

   <para>
    La norme SQL standard ne définit pour <literal>GROUP BY</> que le groupement
    par colonnes de la table source. <productname>PostgreSQL</productname> autorise
    également <literal>GROUP BY</> à grouper par colonnes de la liste de
    sélection. Grouper par expressions de valeurs plutôt que par simples noms de
    colonne est également autorisé.
   </para>

   <indexterm>
    <primary>HAVING</primary>
   </indexterm>

   <para>
    Si une table a été groupée en utilisant la clause <literal>GROUP BY</literal>
    mais que seuls certains groupes ont un intérêt, la clause
    <literal>HAVING</literal> peut être utilisée, à l'instar d'une clause
    <literal>WHERE</>, pour éliminer les groupes d'une table groupée. La syntaxe
    est la suivante&nbsp;:
<synopsis>
SELECT <replaceable>liste_selection</replaceable> FROM ... <optional>WHERE ...</optional> GROUP BY ... HAVING <replaceable>expression_booléenne</replaceable>
</synopsis>
    Les expressions de la clause <literal>HAVING</> peuvent faire référence autant
    à des expressions groupées qu'à des expressions non groupées (impliquant
    nécessairement une fonction d'agrégat).
   </para>

   <para>
    Exemple&nbsp;:
<screen>
<prompt>=></> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) > 3;</>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<prompt>=></> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x < 'c';</>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)
</screen>
   </para>

   <para>
    L'exemple suivant est plus réaliste&nbsp;:
<programlisting>
SELECT produit_id, p.nom, (sum(v.unite) * (p.prix - p.cout)) AS profit
    FROM produits p LEFT JOIN ventes v USING (produit_id)
    WHERE v.date > CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY produit_id, p.nom, p.prix, p.cout
    HAVING sum(p.prix * v.unite) > 5000;
</programlisting>
    Dans l'exemple ci-dessus, la clause <literal>WHERE</> sélectionne les
    lignes à partir d'une colonne qui n'est pas groupée (l'expression est vraie
    seulement pour les ventes des quatre dernières semaines) alors que la
    clause <literal>HAVING</> restreint la sortie aux groupes dont le total des
    ventes dépasse 5000. Notez que les expressions d'agrégats n'ont pas besoin
    d'être les mêmes dans toutes les parties d'une requête.
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-select-lists">
  <title>Listes de sélection</title>

  <indexterm>
   <primary>SELECT</primary>
   <secondary>liste de sélection</secondary>
  </indexterm>

  <para>
   Comme cela a été vu dans la section précédente, l'expression de table
   pour la commande <command>SELECT</command> construit une table virtuelle
   intermédiaire en combinant les tables et les vues, en éliminant des lignes, en
   réalisant des groupements, etc. Cette table est finalement transmise pour
   traitement à la <firstterm>liste de sélection</firstterm>.
   Cette liste détermine les <emphasis>colonnes</emphasis> de la table intermédiaire
   à afficher.
  </para>

  <sect2 id="queries-select-list-items">
   <title>Éléments de la liste de sélection</title>

   <indexterm>
    <primary>*</primary>
   </indexterm>

   <para>
    La forme la plus simple de liste de sélection est <literal>*</literal> qui
    émet toutes les colonnes que l'expression de table produit. Sinon, une liste
    de sélection est une liste d'expressions de valeurs séparées par des
    virgules (comme défini dans <xref linkend="sql-expressions">). Cela peut, par
    exemple, être une liste de noms de colonnes&nbsp;:
<programlisting>
SELECT a, b, c FROM ...
</programlisting>
     Les noms de colonnes <literal>a</>, <literal>b</> et <literal>c</> sont,
     soit les noms actuels des colonnes des tables référencées dans la clause
     <literal>FROM</>, soit les alias qui leur ont été donnés (voir l'explication
     dans <xref linkend="queries-table-aliases">). L'espace de nom disponible
     dans la liste de sélection est le même que dans la clause <literal>WHERE</>
     sauf si un regroupement est utilisé, auquel cas c'est le même que dans la
     clause <literal>HAVING</>.
   </para>

   <para>
    Si plusieurs tables ont une colonne du même nom, le nom de la table doit aussi
    être donné, comme dans
<programlisting>
SELECT tbl1.a, tbl2.a, tbl1.b FROM ...
</programlisting>
    En travaillant avec plusieurs tables, il peut aussi être utile de demander
    toutes les colonnes d'une table particulière&nbsp;:
<programlisting>
SELECT tbl1.*, tbl2.a FROM ...
</programlisting>
    (Voir aussi <xref linkend="queries-where">.)
   </para>

   <para>
    Si une expression de valeur arbitraire est utilisée dans la liste de
    sélection, cela ajoute conceptuellement une nouvelle colonne virtuelle à la
    table renvoyée. L'expression de valeur est évaluée une fois pour chaque
    ligne, les valeurs de lignes étant substituées pour chaque référence de
    colonnes. Mais les expressions de la liste de sélection n'ont pas à
    faire référence aux colonnes de l'expression de table issue de la clause
    <literal>FROM</>&nbsp;; elles pourraient, par exemple, aussi bien être des
    expressions arithmétiques constantes.
   </para>
  </sect2>

  <sect2 id="queries-column-labels">
   <title>Labels de colonnes</title>

   <indexterm zone="queries-column-labels">
    <primary>alias</primary>
    <secondary>dans la liste de sélection</secondary>
   </indexterm>

   <para>
    Les entrées dans la liste de sélection peuvent se voir affecter des noms
    pour la suite du traitement. La <quote>suite du traitement</quote> dans le
    cas présent est une spécification optionnelle du tri et l'application client
    (les en-têtes de colonne pour l'affichage, par exemple). Ainsi&nbsp;:
<programlisting>
SELECT a AS value, b + c AS sum FROM ...
</programlisting>
   </para>

   <para>
    Si aucun nom de colonne en sortie n'est spécifié par l'utilisation de <literal>AS</>,
    le système affecte un nom par défaut. Pour les références de colonne simple,
    c'est le nom de la colonne référencée. Pour les appels de
    fonction, il s'agit du nom de la fonction. Pour les expressions complexes,
    le système engendrera un nom générique.
   </para>

   <note>
    <para>
     Le nommage des colonnes en sortie est ici différent de celui qui est fait dans la
     clause <literal>FROM</> (voir <xref linkend="queries-table-aliases">). Ce
     tube vous permettra en fait de renommer deux fois la même colonne, mais le
     nom choisi dans la liste de sélection est celui qui sera retenu.
    </para>
   </note>
  </sect2>

  <sect2 id="queries-distinct">
   <title><literal>DISTINCT</literal></title>

   <indexterm zone="queries-distinct">
    <primary>DISTINCT</primary>
   </indexterm>

   <indexterm zone="queries-distinct">
    <primary>duplication</primary>
   </indexterm>

   <para>
    Après le traitement de la liste de sélection, la table résultante peut
    faire optionnellement l'objet de l'élimination des duplicats. Le mot clé
    <literal>DISTINCT</literal> est écrit directement après
    <literal>SELECT</literal> pour activer cela&nbsp;:
<synopsis>
SELECT DISTINCT <replaceable>liste_selection</replaceable> ...
</synopsis>
    (A la place de <literal>DISTINCT</>, le mot <literal>ALL</literal> peut être
    utilisé pour sélectionner le comportement par défaut, la récupération de
    toutes les lignes.)
   </para>

   <para>
    <indexterm><primary>valeur nulle</><secondary sortas="DISTINCT">avec
    DISTINCT</></indexterm>
    Évidemment, les deux lignes sont considérées distinctes si elles diffèrent
    par au moins une valeur de colonne. Les valeurs nulles sont considérées
    égales dans cette comparaison.
   </para>

   <para>
    Alternativement, une expression arbitraire peut permettre de déterminer les
    lignes à considérer distinctes&nbsp;:
<synopsis>
SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ...</optional>) <replaceable>liste_selection</replaceable> ...
</synopsis>
    Ici, <replaceable>expression</replaceable> est une expression de valeur
    arbitraire, évaluée pour toutes les lignes. Les lignes dont toutes les
    expressions sont égales sont considérées dupliquées et seule la
    première ligne de cet ensemble est conservée dans la sortie. Il est notable
    que la <quote>première ligne</quote> d'un ensemble est imprévisible sauf si la
    requête est triée sur assez de colonnes pour garantir une ordre unique des
    colonnes arrivant dans le filtre <literal>DISTINCT</>. (Le traitement par
    <literal>DISTINCT ON</> survient après le tri par <literal>ORDER BY</>.)
   </para>

   <para>
    La clause <literal>DISTINCT ON</> ne fait pas partie du standard SQL. Elle est
    souvent considérée comme de mauvais style du fait de la nature
    potentiellement indéterminée de ses résultats. L'utilisation judicieuse
    de <literal>GROUP BY</> et de sous-requêtes dans la clause <literal>FROM</>
    permet d'éviter cette construction, mais elle représente souvent l'alternative la
    plus pratique.
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-union">
  <title>Combiner des requêtes</title>

  <indexterm zone="queries-union">
   <primary>UNION</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>INTERSECT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>EXCEPT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set union</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set intersection</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set difference</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set operation</primary>
  </indexterm>

  <para>
   Les résultats de deux requêtes peuvent être combinés en utilisant les 
   opérations ensemblistes&nbsp;: union, intersection et différence. La syntaxe
   est
<synopsis>
<replaceable>requete1</replaceable> UNION <optional>ALL</optional>
<replaceable>requete2</replaceable>
<replaceable>requete1</replaceable> INTERSECT <optional>ALL</optional>
<replaceable>requete2</replaceable>
<replaceable>requete1</replaceable> EXCEPT <optional>ALL</optional>
<replaceable>requete2</replaceable>
</synopsis>
   <replaceable>requete1</replaceable> et
   <replaceable>requete2</replaceable> sont des requêtes pouvant utiliser
   toutes les fonctionnalités discutées jusqu'ici. Les opérations ensemblistes peuvent
   également être combinées et chaînées. Ainsi
<synopsis>
<replaceable>requete1</replaceable> UNION <replaceable>requete2</replaceable> UNION <replaceable>requete3</replaceable>
</synopsis>
   qui signifie réellement
<synopsis>
(<replaceable>requete1</replaceable> UNION <replaceable>requete2</replaceable>) UNION <replaceable>requete3</replaceable>
</synopsis>
  </para>

  <para>
   <literal>UNION</> ajoute simplement le résultat de
   <replaceable>requete2</replaceable> au résultat de
   <replaceable>requete1</replaceable> (il n'y a cependant aucune garantie
   sur l'ordre effectif de retour des lignes). De plus, toutes les lignes dupliquées
   sont éliminées, au sens de <literal>DISTINCT</>, à moins que <literal>UNION ALL</>
   ne soit utilisé.
  </para>

  <para>
   <literal>INTERSECT</> renvoie toutes les lignes qui sont à la fois dans le
   résultat de <replaceable>requete1</replaceable> et dans le résultat de
   <replaceable>requete2</replaceable>. Les lignes dupliquées sont éliminées,
   sauf si <literal>INTERSECT ALL</> est utilisé.
  </para>

  <para>
   <literal>EXCEPT</> renvoie toutes les lignes qui sont dans le résultat de
   <replaceable>requete1</replaceable> mais pas dans celui de
   <replaceable>requete2</replaceable>. (On parle parfois de
   <firstterm>différence</> entre deux requêtes.) Là aussi, les lignes
   dupliquées sont éliminées, sauf si <literal>EXCEPT ALL</> est utilisé.
  </para>

  <para>
   Pour calculer l'union, l'intersection ou la différence de deux requêtes, il est
   impératif que les deux requêtes soient <quote>compatibles pour une union</quote>.
   Cela signifie qu'elles doivent renvoyer le même nombre de colonnes et que les
   colonnes correspondantes doivent avoir des types de données compatibles,
   comme cela est décrit dans <xref linkend="typeconv-union-case">.
  </para>
 </sect1>


 <sect1 id="queries-order">
  <title>Tri de lignes</title>

  <indexterm zone="queries-order">
   <primary>tri</primary>
  </indexterm>

  <indexterm zone="queries-order">
   <primary>ORDER BY</primary>
  </indexterm>
	   
  <para>
   Après qu'une table de sortie ait été produite par une requête (après que la liste de
   sélection ait été traitée), elle peut être optionnellement triée. Dans le cas
   contraire, les lignes sont renvoyées dans un ordre aléatoire.
   L'ordre réel, dans ce cas, dépendra des types de plan de parcours et de
   jointure et de l'ordre des données sur le disque, mais on ne peut s'y fier.
   Seul le tri explicite permet de garantir un ordre particulier en sortie.
  </para>

  <para>
   La clause <literal>ORDER BY</> spécifie l'ordre de tri&nbsp;:
<synopsis>
SELECT <replaceable>liste_selection</replaceable>
    FROM <replaceable>expression_table</replaceable>
    ORDER BY <replaceable>colonne1</replaceable> <optional>ASC | DESC</optional> <optional>, <replaceable>colonne2</replaceable> <optional>ASC | DESC</optional>...</optional>
</synopsis>
   <replaceable>colonne1</replaceable>, etc. font référence aux colonnes de la liste
   de sélection. Il peut s'agir du nom de sortie d'une colonne (voir
   <xref linkend="queries-column-labels">) ou du numéro d'une colonne. Quelques exemples&nbsp;:
<programlisting>
SELECT a, b FROM table1 ORDER BY a;
SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, sum(b) FROM table1 GROUP BY a ORDER BY 1;
</programlisting>
  </para>

  <para>
   En extension au standard SQL, <productname>PostgreSQL</productname>
   autorise aussi le tri par des expressions arbitraires&nbsp;:
<programlisting>
SELECT a, b FROM table1 ORDER BY a + b;
</programlisting>
   Sont également autorisées les références aux noms de colonnes de la clause
   <literal>FROM</> qui sont renommées dans la liste de sélection&nbsp;:
<programlisting>
SELECT a AS b FROM table1 ORDER BY a;
</programlisting>
   Mais ces extensions ne fonctionnent pas dans les requêtes impliquant
   <literal>UNION</>, <literal>INTERSECT</> ou <literal>EXCEPT</>. Elles ne sont,
   de plus, pas portables vers les autres bases de données SQL.
  </para>

  <para>
   Chaque spécification de colonne peut être suivie d'un drapeau optionnel
   <literal>ASC</> ou <literal>DESC</> permettant de préciser la direction du tri
   (ascendant ou descendant). L'ordre <literal>ASC</> est la valeur par défaut.
   L'ordre ascendant place les plus petites valeurs en premier. <quote>Plus petit</quote>
   est défini conformément à l'opérateur <literal>&lt;</literal>. De façon similaire,
   l'ordre descendant est déterminé avec l'opérateur <literal>&gt;</literal>.
    <footnote>
     <para>
      En fait, <productname>PostgreSQL</> utilise la <firstterm>classe
      d'opérateur par défaut, B-tree</> pour le type de données de la colonne.
      Cette classe permet de déterminer l'ordre de tri utilisé par <literal>ASC</>
      et <literal>DESC</>. Par convention, les types de données sont
      initialisés pour que les opérateurs <literal>&lt;</literal> et
      <literal>&gt;</literal> correspondent à cet ordre de tri. Il est cependant
      possible qu'un concepteur de types de données utilisateur choisisse
      de procéder différement.
     </para>
    </footnote>
  </para>

  <para>
   Si plusieurs colonnes de tri sont spécifiées, les dernières entrées seront
   utilisées pour trier les lignes qui seraient égales selon l'ordre imposé par
   les premières colonnes de tri.
  </para>
 </sect1>


 <sect1 id="queries-limit">
  <title><literal>LIMIT</literal> et <literal>OFFSET</literal></title>

  <indexterm zone="queries-limit">
   <primary>LIMIT</primary>
  </indexterm>

  <indexterm zone="queries-limit">
   <primary>OFFSET</primary>
  </indexterm>

  <para>
   <literal>LIMIT</> et <literal>OFFSET</> permettent de ne récupérer qu'une partie
   des lignes engendrées par le reste de la requête&nbsp;:
<synopsis>
SELECT <replaceable>liste_selection</replaceable>
    FROM <replaceable>expression_table</replaceable>
    <optional>LIMIT { <replaceable>numero</replaceable> | ALL }</optional> <optional>OFFSET <replaceable>numero</replaceable></optional>
</synopsis>
  </para>

  <para>
   Si une limite de comptage est donnée, il ne sera pas retourné plus de lignes
   que ce nombre (peut-être moins si la requête complète retourne moins
   de lignes). <literal>LIMIT ALL</> revient à ne pas spécifier la clause <literal>LIMIT</>.
  </para>

  <para>
   <literal>OFFSET</> indique un nombre de lignes à ignorer avant de commencer à
   retourner des lignes. <literal>OFFSET 0</> revient à oublier la clause
   <literal>OFFSET</>. Si <literal>OFFSET</> et <literal>LIMIT</> sont utilisés ensemble,
   <literal>OFFSET</> lignes sont ignorées avant de retourner <literal>LIMIT</> lignes.
  </para>

  <para>
   Lors de l'utilisation de <literal>LIMIT</>, il est nécessaire d'utiliser une
   clause <literal>ORDER BY</> contraignant les lignes résultantes dans un ordre
   unique. Dans le cas contraire, il est impossible de prévoir le sous-ensemble
   de lignes qui sera retourné.
  </para>

  <para>
   L'optimiseur de requêtes tient compte de <literal>LIMIT</> lors de la
   génération d'un plan de requêtes. Ainsi, en fonction des valeurs précisées pour
   <literal>LIMIT</> et <literal>OFFSET</>, différents plans seront obtenus impliquant
   différents ordres de lignes. Sans l'utilisation de la clause <literal>ORDER BY</>
   pour forcer l'ordre des résultats, l'emploi de valeurs <literal>LIMIT</>/<literal>OFFSET</>
   différentes pour sélectionner des sous-ensembles différents du résultat d'une
   requête <emphasis>donnera des résultats incohérents</emphasis>.
   Ceci n'est pas un bogue, le SQL ne promettant pas de délivrer les résultats
   d'une requête dans un ordre particulier en l'absence de spécifications de tri.
  </para>
 </sect1>

</chapter>
