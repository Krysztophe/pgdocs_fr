<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/cluster.sgml,v 1.9 2005/03/14 06:03:51 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060616 -->

<refentry id="sql-cluster">
 <refmeta>
  <refentrytitle id="sql-cluster-title">CLUSTER</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CLUSTER</refname>
  <refpurpose>Réorganiser une table en fonction d'un index</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CLUSTER <replaceable class="parameter">nomindex</replaceable> ON <replaceable class="parameter">nomtable</replaceable>
CLUSTER <replaceable class="parameter">nomtable</replaceable>
CLUSTER
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-cluster">
   <primary>CLUSTER</primary>
  </indexterm>

  <para>
   <command>CLUSTER</command> réorganise (regroupe) la table 
   <replaceable class="parameter">nomtable</replaceable>
   en fonction de l'index <replaceable class="parameter">nomindex</replaceable>. L'index doit avoir été 
   préalablement défini sur <replaceable class="parameter">nomtable</replaceable>.
  </para>

  <para>
   Une table regroupée est physiquement réordonnée en fonction des informations de l'index.
   Ce regroupement est une opération unique&nbsp;:
   les modifications issues de mises à jour postérieures au groupage ne
   sont pas réorganisées. C'est-à-dire qu'aucune tentative n'est
   réalisée pour stocker les données nouvelles ou mises à jour
   d'après l'ordre de l'index. Une réorganisation périodique peut être
   obtenue en relançant la commande aussi souvent que souhaité.
  </para>

  <para>
   Quand une table est groupée, <productname>PostgreSQL</productname> 
   enregistre l'index qui a servi à la réorganisation. La forme
   <command>CLUSTER <replaceable class="parameter">nomtable</replaceable></command>
   regroupe la table suivant ce même index.
  </para>

  <para>
   <command>CLUSTER</command>, sans paramètre, groupe toutes les
   tables de la base de données courante dont l'utilisateur est
   propriétaire, ou toutes les tables s'il s'agit d'un superutilisateur. (Les
   tables qui n'ont jamais été groupées sont ignorées.) Cette forme de
   <command>CLUSTER</command> ne peut pas être appelée à partir d'une
   transaction ou d'une fonction.
  </para>

  <para>
   Quand une table est en cours de regroupement, un verrou
   <literal>ACCESS EXCLUSIVE</literal> est acquis. Cela empêche toute opération
   sur la table (à la fois en lecture et en écriture) pendant l'exécution de 
   <command>CLUSTER</command>.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nomindex</replaceable></term>
    <listitem>
     <para>
      Le nom d'un index.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nomtable</replaceable></term>
    <listitem>
     <para>
      Le nom d'une table (éventuellement qualifié du nom du schéma).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    <command>CLUSTER</command> perd toute visibilité des lignes, ce qui fait
    que la table semble vide à toute image de la base prise avant la fin de
    la commande <command>CLUSTER</command>. Les applications ayant des
    transactions accèdant à une table en cours de clusterisation peuvent donc
    difficilement utiliser la commande <command>CLUSTER</command>. L'impact est
    encore plus important avec les transactions sérialisables car elles prennent
    seulement une image de la base, au début de la transaction. Cela étant dit,
    les transactions «&nbsp;read-committed&nbsp;» sont aussi affectées.
   </para>

   <para>
    Lorsque les lignes d'une table sont accédées aléatoirement et unitairement, 
    l'ordre réel des données dans la table n'a que peu d'importance.
    Toutefois, si certaines données sont plus accédées que d'autres, et qu'un index les groupe, 
    l'utilisation de <command>CLUSTER</command> peut s'avérer bénéfique. 
    Si une requête porte sur un ensemble de valeurs indexées ou sur une seule valeur
    pour laquelle plusieurs lignes de la table correspondent, <command>CLUSTER</command>
    se montre utile. En effet, lorsque l'index identifie la page principale (heap page) 
    pour la première ligne correspondante, toutes les autres lignes correspondantes
    sont déjà probablement sur la même page, ce qui diminue les accès disque et accélère la requête.
   </para>

   <para>
    Lors de l'opération de réorganisation, une copie temporaire de la table 
    est créée qui contient les données de la table dans l'ordre de l'index. Des
    copies temporaires de chaque index de la table sont également créées. De ce fait, 
    un espace libre sur le disque au moins égal à la somme de la taille de la table
    et celles des index est nécessaire.
   </para>

   <para>
    Puisque <command>CLUSTER</command> enregistre les informations de
    réorganisation, il est possible de réorganiser manuellement les tables souhaitées
    la première fois et de planifier une réorganisation, à la façon d'un <command>VACUUM</command>.
    Les tables sont ainsi régulièrement regroupées.
   </para>

   <para>
    Comme le planificateur enregistre les statistiques d'ordonnancement
    des tables, il est conseillé de lancer
    <xref linkend="sql-analyze" endterm="sql-analyze-title"/> sur la table réorganisée.
    Dans le cas contraire, les plans de requêtes peuvent être mal choisis par le planificateur.
   </para>

   <para>
    Il existe une autre façon de grouper les données. En effet, la commande
    <command>CLUSTER</command> réorganise la table originale en utilisant
    l'ordre de l'index spécifié&nbsp;;.cela peut devenir lent sur les grandes
    tables parce que les lignes sont parcourues en mémoire dans
    l'ordre de l'index et, si la table n'est pas ordonnée, les entrées sont
    disséminées
    dans des pages aléatoires. Une page disque est alors lue pour chaque
    ligne déplacée. (<productname>PostgreSQL</productname> dispose d'un cache mais une
    grande table n'y tient généralement pas dans sa totalité.) L'autre moyen de
    réorganiser une table est alors d'utiliser

<programlisting>CREATE TABLE <replaceable class="parameter">nouvelletable</replaceable> AS
    SELECT <replaceable class="parameter">listecolonnes</replaceable> FROM <replaceable class="parameter">table</replaceable> ORDER BY <replaceable class="parameter">listecolonnes</replaceable>;
</programlisting>

    qui utilise le code de tri de <productname>PostgreSQL</productname> dans la
    clause <literal>ORDER BY</literal> pour créer l'ordre désiré&nbsp;; pour des données
    non triées, cela est
    généralement bien plus rapide qu'un parcours d'index. 
    L'ancienne table peut alors être supprimée. <command>ALTER TABLE ... RENAME</command>
    est utilisé pour renommer <replaceable class="parameter">nouvelletable</replaceable>
    en <replaceable class="parameter">table</replaceable>. Il ne reste plus qu'à recréer les index
	de la table. Toutefois, cette approche ne préserve pas les OID,
    les contraintes, les relations de clés étrangères, les droits et
    autres propriétés de la table &mdash; tous ces éléments doivent être
    recréés manuellement.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Grouper la table <literal>employes</literal> sur la base de son index
   <literal>emp_ind</literal>&nbsp;:
<programlisting>CLUSTER emp_ind ON employes;
</programlisting>
  </para>

  <para>
   Grouper la relation <literal>employes</literal> en utilisant le même index
   que précédemment&nbsp;:
<programlisting>CLUSTER employes;
</programlisting>
  </para>

  <para>
   Grouper toutes les tables de la base de données préalablement
   groupées&nbsp;:
<programlisting>CLUSTER;
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas d'instruction <command>CLUSTER</command> dans le standard
   SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="app-clusterdb" endterm="app-clusterdb-title"/></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->

