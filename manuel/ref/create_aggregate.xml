<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_aggregate.sgml,v 1.10 2005/09/15 07:03:26 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060616 : Relecture -->

<refentry id="sql-createaggregate">
 <refmeta>
  <refentrytitle id="sql-createaggregate-title">CREATE AGGREGATE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE AGGREGATE</refname>
  <refpurpose>Définir une nouvelle fonction d'agrégat</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE AGGREGATE <replaceable class="parameter">nom</replaceable> (
    BASETYPE = <replaceable class="parameter">type_donnée_entrée</replaceable>,
    SFUNC = <replaceable class="parameter">sfonc</replaceable>,
    STYPE = <replaceable class="parameter">type_donnée_état</replaceable>
    [ , FINALFUNC = <replaceable class="parameter">ffonc</replaceable> ]
    [ , INITCOND = <replaceable class="parameter">condition_initiale</replaceable> ]
    [ , SORTOP = <replaceable class="parameter">operateur_tri</replaceable> ]
)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createaggregate">
   <primary>CREATE AGGREGATE</primary>
  </indexterm>

  <para>
   <command>CREATE AGGREGATE</command> définit une nouvelle fonction d'agrégat.
   Quelques fonctions d'agrégat basiques et largement utilisées sont fournies
   dans la distribution standard&nbsp;; elles sont documentées dans le 
   <xref linkend="functions-aggregate"/>.
   <command>CREATE AGGREGATE</command> est utilisée pour ajouter des 
   fonctionnalités lors de la définition de nouveaux
   types ou si une fonction d'agrégat n'est pas fournie.
  </para>

  <para>
   Si un nom de schéma est donné (par exemple, <literal>CREATE AGGREGATE
   monschema.monagg ...</literal>), alors la fonction d'agrégat est créée dans le
   schéma précisé. Sinon, elle est créée dans le schéma courant.
  </para>

  <para>
   Une fonction d'agrégat est identifiée par son nom et son type de données en
   entrée. Deux agrégats dans le même schéma peuvent avoir le même nom s'ils
   opèrent sur des types différents en entrée. Le nom et le type de données en
   entrée d'un agrégat doivent aussi être distincts du nom et du type de données
   de toutes les fonctions ordinaires du même schéma.
  </para>

  <para>
   Une fonction d'agrégat est réalisée à partir d'une ou deux fonctions
   ordinaires&nbsp;:
   une fonction de transition d'état
   <replaceable class="parameter">sfonc</replaceable>,
   et une fonction de traitement final optionnelle
   <replaceable class="parameter">ffonc</replaceable>.
   Elles sont utilisées ainsi&nbsp;:
<programlisting><replaceable class="parameter">sfonc</replaceable>( état-interne, nouvel-élément-données ) ---> prochain-état-interne
<replaceable class="parameter">ffonc</replaceable>( état-interne ) ---> valeur-agrégat
</programlisting>
  </para>

  <para>
   <productname>PostgreSQL</productname> crée une variable temporaire de type
   <replaceable class="parameter">stype</replaceable> pour contenir l'état
   interne courant de l'agrégat. À chaque élément de données en entrée, la
   fonction de transition d'état est appelée pour calculer une nouvelle valeur
   de l'état interne. Une fois que toutes les données sont traitées, la fonction
   finale est appelée une seule fois pour calculer la valeur de retour de l'agrégat.
   S'il n'existe pas de fonction finale, alors la valeur d'état final est
   retournée en l'état.
  </para>
  
  <para>
   Une fonction d'agrégat peut fournir une condition initiale, c'est-à-dire une
   valeur initiale pour la valeur de l'état interne. Elle est spécifiée et stockée
   en base comme une colonne de type <type>text</type> mais doit
   être une représentation externe valide d'une constante du type de donnée de
   la valeur d'état. Si elle n'est pas fournie, la valeur d'état est initialement 
   positionnée à NULL.
  </para>
  
  <para>
   Si la fonction de transition d'état est déclarée <quote>strict</quote>,
   alors elle ne peut pas être appelée avec des entrées NULL. Avec une telle
   fonction de transition, l'exécution d'agrégat se comporte comme suit. Les valeurs
   des entrées NULL sont ignorées (la fonction n'est pas appelée et la valeur de
   l'état précédent est conservée). Si la valeur d'état initial est NULL,
   alors la première valeur en entrée non NULL remplace la valeur d'état et
   la fonction de transition est appelée en commençant avec la seconde valeur en
   entrée non NULL. Cela est pratique pour implémenter des agrégats comme
   <function>max</function>. Ce comportement n'est possible que
   quand <replaceable class="parameter">type_donnée_état</replaceable> est
   identique à <replaceable class="parameter">type_donnée_entrée</replaceable>.
   Lorsque ces types sont différents, une condition initiale
   non NULL doit être fournie, ou une fonction de transition non stricte utilisée.
  </para>
  
  <para>
   Si la fonction de transition d'état n'est pas stricte, alors elle sera
   appelée sans condition pour chaque valeur en entrée et devra gérer les
   entrées NULL et les valeurs de transition NULL. Cela permet à l'auteur de
   l'agrégat d'avoir le contrôle complet sur la gestion des valeurs NULL par
   l'agrégat.
  </para>
  
  <para>
   Si la fonction finale est déclarée <quote>strict</quote>, alors elle ne sera
   pas appelée quand la valeur d'état finale est NULL&nbsp;; à la place, un
   résultat NULL sera retourné automatiquement. C'est le
   comportement normal de fonctions strictes. Dans tous les cas, la fonction
   finale peut retourner une valeur NULL. Par exemple, la fonction
   finale pour <function>avg</function> renvoie NULL lorsqu'elle n'a aucune
   lignes en entrée.
  </para>
  
  <para>
   Les agrégats qui se comportent comme  <function>MIN</function> ou <function>MAX</function>
   peuvent parfois être optimisés en cherchant un index au lieu de parcourir
   toutes les lignes en entrée. Si un agrégat peut être optimisé, un 
   <firstterm>opérateur de tri</firstterm> est spécifié. Dans ce cas, il est nécessaire
   que l'agrégat fournisse le premier élément dans l'ordre imposé par
   l'opérateur&nbsp;; en d'autres mots
<programlisting>SELECT agg(col) FROM tab;
</programlisting>
   doit être équivalent à
<programlisting>SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
</programlisting>
   On suppose également que l'agrégat ignore les entrées NULL et qu'il
   fournit un résultat NULL si et seulement s'il n'y a aucune entrée NULL.
   D'ordinaire, l'opérateur <literal>&lt;</literal> d'un type de données est le bon
   opérateur de tri pour <function>MIN</function> et <literal>&gt;</literal> celui
   pour <function>MAX</function>. L'optimisation ne prend
   jamais effet sauf si l'opérateur spécifié est membre de la stratégie
   <quote>less than</quote> (NdT&nbsp;: plus petit que) ou <quote>greater
   than</quote> (NdT&nbsp;: plus grand que) d'une classe d'opérateur pour un
   index B-tree.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction d'agrégat à créer (éventuellement qualifié du nom
      du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_donnée_entrée</replaceable></term>
    <listitem>
     <para>
      Le type de données en entrée sur lequel opère la fonction d'agrégat. 
      <literal>"ANY"</literal> est utilisé pour un agrégat qui n'examine
      pas les valeurs en entrée (un exemple est <function>count(*)</function>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">sfonc</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction de transition de l'état à appeler pour chaque
      valeur en entrée. C'est normalement une fonction à deux arguments, le
      premier étant de type <replaceable
      class="parameter">type_donnée_état</replaceable> et le second de type
      <replaceable class="parameter">type_donnée_entrée</replaceable>.
      Alternativement, pour un agrégat qui n'examine pas les valeurs en entrée, la
      fonction prend un seul argument de type <replaceable
      class="parameter">type_donnée_état</replaceable>. Dans chaque cas, la
      fonction doit renvoyer une valeur de type <replaceable
      class="parameter">type_donnée_état</replaceable>. Cette fonction prend la
      valeur de l'état courant et l'élément de donnée courant et renvoie la
      prochaine valeur d'état.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_donnée_état</replaceable></term>
    <listitem>
     <para>
      Le type de donnée pour la valeur d'état de l'agrégat.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">ffonc</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction finale à appeler pour traiter le résultat de
      l'agrégat une fois que toutes les données en entrée ont été parcourues.
      La fonction prend un seul argument de type <replaceable
      class="parameter">type_donnée_état</replaceable>. Le type de retour de
      l'agrégat de la fonction est défini comme le type de retour de cette
      fonction. Si <replaceable class="parameter">ffonc</replaceable> n'est pas
      spécifiée, alors la valeur d'état finale est utilisée comme résultat de
      l'agrégat et le type de retour est <replaceable
      class="parameter">type_donnée_état</replaceable>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition_initiale</replaceable></term>
    <listitem>
     <para>
      La configuration initiale pour la valeur de l'état. Elle doit être une
      constante de type chaîne de caractères dans la forme acceptée par le type
      de données <replaceable class="parameter">type_donnée_état</replaceable>.
      Si non spécifié, la valeur d'état est initialement positionnée à NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">sort_operator</replaceable></term>
    <listitem>
     <para>
      L'opérateur de tri associé pour un agrégat de type <function>MIN</function> ou
      <function>MAX</function>. C'est seulement le nom de l'opérateur (éventuellement qualifié
      du nom du schéma). L'opérateur est supposé avoir les mêmes
      types de données en entrée que l'agrégat.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les paramètres de <command>CREATE AGGREGATE</command> peuvent être écrits
   dans n'importe quel ordre, pas uniquement dans l'ordre illustré ci-dessus.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Exemples</title>

  <para>
   Voir <xref linkend="xaggr"/>.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>CREATE AGGREGATE</command> est une extension
   <productname>PostgreSQL</productname>. Le standard SQL ne fournit pas de
   fonctions d'agrégat utilisateur.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alteraggregate" endterm="sql-alteraggregate-title"/></member>
   <member><xref linkend="sql-dropaggregate" endterm="sql-dropaggregate-title"/></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
