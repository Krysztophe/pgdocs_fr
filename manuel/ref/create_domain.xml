<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_domain.sgml,v 1.10 2005/07/15 06:14:31 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060618 -->

<refentry id="sql-createdomain">
 <refmeta>
  <refentrytitle id="sql-createdomain-title">CREATE DOMAIN</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE DOMAIN</refname>
  <refpurpose>Définir un nouveau domaine</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE DOMAIN <replaceable class="parameter">nom</replaceable> [AS] <replaceable class="parameter">type_donnee</replaceable>
    [ DEFAULT <replaceable>expression</replaceable> ]
    [ <replaceable class="parameter">contrainte</replaceable> [ ... ] ]

où <replaceable class="parameter">contrainte</replaceable> est&nbsp;:

[ CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> ]
{ NOT NULL | NULL | CHECK (<replaceable class="parameter">expression</replaceable>) }
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createdomain">
   <primary>CREATE DOMAIN</primary>
  </indexterm>

  <para>
   <command>CREATE DOMAIN</command> crée un nouveau domaine de données.
   L'utilisateur définissant un domaine en devient le propriétaire.
  </para>

  <para>
   Si un nom de schéma est donné (par exemple, <literal>CREATE DOMAIN
   monschema.mondomaine ...</literal>), alors le domaine est créé dans le schéma
   spécifié. Sinon, il est créé dans le schéma courant. Le nom du domaine doit
   être unique parmi les types et domaines existant dans son schéma.
  </para>

  <para>
   Les domaines permettent d'extraire des champs communs à plusieurs tables 
   et de les regrouper en un seul emplacement, ce qui en facilite la maintenance.
   Par exemple, une colonne <literal>adresse de courriel</literal> peut être
   utilisée dans plusieurs tables, avec chaque fois les mêmes
   propriétés. La définition d'un domaine et son utilisation permet d'éviter
   de définir les mêmes contraintes sur chaque table.
  </para>

  <caution>
  <para>
   Actuellement, il est risqué de déclarer un domaine comme valeur de retour
   d'une fonction parce qu'aucun langage procédural ne teste les contraintes de domaine
   sur les résultats. C'est au code de la fonction de respecter les contraintes.
   Avec <application>PL/pgSQL</application>, il est possible de contourner cela
   en convertissant explicitement la valeur du résultat vers le type du domaine
   avant de la retourner. <application>PL/pgSQL</application> ne teste pas non plus
   les contraintes de domaine pour les variables locales internes aux fonctions.
  </para>
  </caution>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">nom</replaceable></term>
      <listitem>
       <para>
	Le nom du domaine à créer (éventuellement qualifié du nom du schéma).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">type_donnees</replaceable></term>
      <listitem>
       <para>
        Le type de données sous-jacent au domaine. Il peut contenir des
        spécifications de tableau.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT <replaceable>expression</replaceable></literal></term>

      <listitem>
       <para>
        La clause <literal>DEFAULT</literal> permet de définir une valeur par défaut pour les
        colonnes d'un type de données du domaine. La valeur est une expression quelconque
	sans variable (les sous-requêtes ne sont pas autorisées).
        Le type de données de l'expression par défaut doit correspondre à celui
        du domaine. Si la valeur par défaut n'est pas indiquée, alors
        il s'agit de la valeur NULL.
       </para>

       <para>
        L'expression par défaut est utilisée dans toute opération
        d'insertion qui ne spécifie pas de valeur pour cette colonne. Si une
        valeur par défaut est définie sur une colonne particulière, elle
        surcharge toute valeur par défaut du domaine. De même,
        la valeur par défaut surcharge toute valeur par défaut associée au
        type de données sous-jacent.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CONSTRAINT <replaceable
       class="parameter">nom_contrainte</replaceable></literal></term>
      <listitem>
       <para>
        Un nom optionnel pour une contrainte. S'il n'est pas spécifié, le système en
        engendre un.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT NULL</literal></term>
      <listitem>
       <para>
        Les valeurs de ce domaine ne peuvent pas être NULL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULL</literal></term>
      <listitem>
       <para>
        Les valeurs de ce domaine peuvent être NULL. C'est la valeur par défaut.
       </para>

       <para>
        Cette clause a pour seul but la compatibilité avec les bases de
        données SQL non standard. Son utilisation est découragée dans les
        applications nouvelles.
       </para>
      </listitem>
     </varlistentry>

   <varlistentry>
    <term><literal>CHECK (<replaceable class="parameter">expression</replaceable>)</literal></term>
    <listitem>
     <para>
      Les clauses <literal>CHECK</literal> spécifient des contraintes d'intégrité ou
      des tests que les valeurs du domaine doivent satisfaire. Chaque
      contrainte doit être une expression produisant un résultat booléen. 
      <literal>VALUE</literal> est obligatoirement utilisé pour se référer à la valeur
      testée.
     </para>

     <para>
      Actuellement, les expressions <literal>CHECK</literal> ne peuvent ni
      contenir de sous-requêtes ni se référer à des variables autres que
      <literal>VALUE</literal>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer le type de données <type>code_postal_us</type>, et
   l'utiliser dans la définition d'une table. Un test d'expression rationnelle
   est utilisé pour vérifier que la valeur ressemble à un code postal US valide.

<programlisting>CREATE DOMAIN code_postal_us AS TEXT
CHECK(
   VALUE ~ '^\\d{5}$'
OR VALUE ~ '^\\d{5}-\\d{4}$'
);

CREATE TABLE courrier_us (
  id_adresse SERIAL NOT NULL PRIMARY KEY
, rue1 TEXT NOT NULL
, rue2 TEXT
, rue3 TEXT
, ville TEXT NOT NULL
, code_postal code_postal_us NOT NULL
);
</programlisting>
  </para>
 </refsect1>

 <refsect1 id="sql-createdomain-compatibility">
  <title>Compatibilité</title>

  <para>
   La commande <command>CREATE DOMAIN</command> est conforme au standard SQL.
  </para>
 </refsect1>

 <refsect1 id="sql-createdomain-see-also">
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterdomain"
    endterm="sql-alterdomain-title"/></member>
   <member><xref linkend="sql-dropdomain"
    endterm="sql-dropdomain-title"/></member>
  </simplelist>
 </refsect1>

</refentry>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
