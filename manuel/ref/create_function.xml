<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_function.sgml,v 1.9 2005/09/15 07:03:26 guillaume Exp $
-->
<!-- SAS 20060618 -->

<refentry id="sql-createfunction">
 <refmeta>
  <refentrytitle id="sql-createfunction-title">CREATE FUNCTION</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE FUNCTION</refname>
  <refpurpose>Définir une nouvelle fonction</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ OR REPLACE ] FUNCTION
    <replaceable class="parameter">nom</replaceable> ( [ [ <replaceable class="parameter">modearg</replaceable> ] [ <replaceable class="parameter">nomarg</replaceable> ] <replaceable class="parameter">typearg</replaceable> [, ...] ] )
    [ RETURNS <replaceable class="parameter">type_ret</replaceable> ]
  { LANGUAGE <replaceable class="parameter">nomlang</replaceable>
    | IMMUTABLE | STABLE | VOLATILE
    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
    | [EXTERNAL] SECURITY INVOKER | [EXTERNAL] SECURITY DEFINER
    | AS '<replaceable class="parameter">definition</replaceable>'
    | AS '<replaceable class="parameter">fichier_obj</replaceable>', '<replaceable class="parameter">symbole_lien</replaceable>'
  } ...
    [ WITH ( <replaceable class="parameter">attribut</replaceable> [, ...] ) ]
</synopsis>
 </refsynopsisdiv>
  
 <refsect1 id="sql-createfunction-description">
  <title>Description</title>
  <indexterm zone="sql-createfunction">
   <primary>CREATE FUNCTION</primary>
  </indexterm>

  <para>
   <command>CREATE FUNCTION</command> définit une nouvelle fonction.
   <command>CREATE OR REPLACE FUNCTION</command> crée une nouvelle fonction
   ou la remplace si elle existe déjà.
  </para>

  <para>
   Si un nom de schéma est précisé, la fonction est créée dans le schéma
   spécifié. Sinon, elle est créée dans le schéma courant. Le nom de la nouvelle
   fonction ne doit pas correspondre à celui d'une autre fonction existant avec les
   mêmes types d'arguments dans le même schéma. Néanmoins, les fonctions de types
   d'arguments différents peuvent partager le même nom (ceci est appelé
   <firstterm>surchargement</firstterm>).
  </para>

  <para>
   Pour mettre à jour la définition d'une fonction existante, 
   <command>CREATE OR REPLACE FUNCTION</command> est utilisé. Il n'est pas possible de
   changer le nom ou les types d'argument d'une fonction de cette façon 
   (cela crée une nouvelle fonction distincte). De
   même, <command>CREATE OR REPLACE FUNCTION</command> ne permet pas
   de modifier le type retour d'une fonction existante. Pour cela, il est nécessaire
   de supprimer et de recréer la fonction. (Lors de l'utilisation de paramètres
   <literal>OUT</literal>, cela signifie que le nom ou le
   type d'un paramètre <literal>OUT</literal> ne peut être modifié que par 
   la suppression de la fonction.)
  </para>

  <para>
   En cas de suppression et de recréaction d'une fonction, la nouvelle fonction n'est pas
   la même entité que l'ancienne&nbsp;; il faut supprimer les règles, vues,
   déclencheurs, etc. qui référencent l'ancienne fonction. 
   <command>CREATE OR REPLACE FUNCTION</command> permet de modifier la définition
   d'une fonction sans casser les objets qui s'y réfèrent.
  </para>

  <para>
   L'utilisateur qui crée la fonction en devient le propriétaire.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

   <variablelist>

    <varlistentry>
     <term><replaceable class="parameter">nom</replaceable></term>

     <listitem>
      <para>
       Le nom de la fonction à créer (éventuellement qualifié du nom du schéma).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">modearg</replaceable></term>

     <listitem>
      <para>
       Le mode d'un argument&nbsp;: soit <literal>IN</literal>, soit <literal>OUT</literal>,
       soit <literal>INOUT</literal>. En cas d'omission, la valeur par défaut est
       <literal>IN</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nomarg</replaceable></term>

     <listitem>
      <para>
       Le nom d'un argument. Quelques langages (seul
       PL/pgSQL, en réalité) permettent d'utiliser ce nom dans le corps de la fonction.
       Pour les autres langages, le nom d'un argument en entrée est 
       purement documentaire. En revanche, le nom d'un argument en sortie
       a une utilité car il définit le nom de la colonne dans la ligne résultat.
       (En cas d'omission du nom d'un argument en
       sortie, le système choisit un nom de colonne par défaut.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argtype</replaceable></term>

     <listitem>
      <para>
       Le(s) type(s) de données des arguments de la fonction (éventuellement
       qualifié du nom du schéma), s'il y en a. Les types des arguments
       peuvent être basiques, composites ou de domaines, ou 
       faire référence au type d'une colonne.
      </para>
      <para>
       Suivant le langage d'implémentation, il est possible de
       spécifier des <quote>pseudotypes</quote> tels que des <type>cstring</type>. Les
       pseudotypes indiquent que le type d'argument réel est soit non
       complètement spécifié, soit en dehors de l'ensemble des types de données
       ordinaires du SQL.
      </para>
      <para>
       Il est fait référence au type d'une colonne par
       <literal><replaceable class="parameter">nomtable</replaceable>.<replaceable class="parameter">nomcolonne</replaceable>%TYPE</literal>. 
       Cette fonctionnalité peut servir à rendre une fonction
       indépendante des modifications de la définition d'une table.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">type_ret</replaceable></term>

     <listitem>
      <para>
       Le type de données en retour (éventuellement qualifié du nom du schéma).
       Le type de retour peut être un type de base, composite ou de domaine,
       ou faire référence au type d'une colonne
       existante. En fonction du langage d'implémentation, il est possible de
       spécifier un <quote>pseudotype</quote> tel que <type>cstring</type>.
      </para>
      <para>
       Quand il y a des paramètres <literal>OUT</literal> ou <literal>INOUT</literal>, la
       clause <literal>RETURNS</literal> peut être omise. Si elle est présente, elle
       doit correspondre au type de résultat imposé par les paramètres de
       sortie&nbsp;: <literal>RECORD</literal> s'il y en a plusieurs,
       ou le type du seul paramètre en sortie.
      </para>
      <para>
       Le modificateur <literal>SETOF</literal> indique que la fonction retourne
       un ensemble d'éléments plutôt qu'un seul.
      </para>
      <para>
       Il est fait référence au type d'une colonne par 
       <literal><replaceable class="parameter">nomtable</replaceable>.<replaceable class="parameter">nomcolonne</replaceable>%TYPE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nomlang</replaceable></term>

     <listitem>
      <para>
       Le nom du langage d'écriture de la fonction. Peut
       être <literal>SQL</literal>, <literal>C</literal>,
       <literal>internal</literal> ou le nom d'un langage procédural
       utilisateur. Pour des raisons de compatibilité descendante, le
       nom peut être écrit entre guillemets simples.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>IMMUTABLE</literal></term>
     <term><literal>STABLE</literal></term>
     <term><literal>VOLATILE</literal></term>

     <listitem>
      <para>
       Ces attributs agissent sur l'optimisation en exécution. Ils permettent
       de préciser si plusieurs évaluations de la fonction peuvent sans risque
       être remplacée par une seule. Un seul choix est possible. En son
       absence, <literal>VOLATILE</literal> est utilisé.
      </para>

      <para>
       <literal>IMMUTABLE</literal> indique que, à arguments constants, 
       la fonction renvoie toujours le même résultat&nbsp;;
       c'est-à-dire qu'elle n'effectue pas de recherches dans la base de données,
       ou alors qu'elle utilise des informations non directement présentes
       dans la liste d'arguments. Si cette option est précisée, tout appel de la
       fonction avec des arguments constants peut être immédiatement remplacé
       par la valeur de la fonction.
      </para>

      <para>
       <literal>STABLE</literal> indique qu'à l'intérieur d'un seul parcours de
       la table, à arguments constants, la fonction retourne le même résultat,
       mais celui-ci varie en fonction des instructions SQL.
       Cette option est appropriée pour les fonctions
       dont les résultats dépendent des recherches en base, des
       variables de paramètres (tel que la zone horaire courante), etc. La 
       famille de fonctions <function>current_timestamp</function> est qualifiée
       de stable car les valeurs de ces fonctions ne changent pas à l'intérieur d'une transaction.
      </para>

      <para>
       <literal>VOLATILE</literal> indique que la valeur de la fonction peut
       changer même au cours d'un seul parcours de table. Aucune optimisation ne
       peut donc être réalisée. Relativement peu de fonctions de bases de données
       sont volatiles dans ce sens&nbsp;; quelques exemples sont
       <literal>random()</literal>, <literal>currval()</literal>, <literal>timeofday()</literal>.
       Toute fonction qui a des effets de bord doit être classée
       volatile, même si son résultat est assez prévisible. Cela afin d'éviter
       l'optimisation des appels&nbsp;; <literal>setval()</literal> en est un exemple.
      </para>

      <para>
       Pour des détails supplémenaires, voir <xref linkend="xfunc-volatility"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CALLED ON NULL INPUT</literal></term>
     <term><literal>RETURNS NULL ON NULL INPUT</literal></term>
     <term><literal>STRICT</literal></term>

     <listitem>
      <para>
       <literal>CALLED ON NULL INPUT</literal> (la valeur par défaut) indique
       que la fonction sera appelée normalement si certains de ses arguments
       sont NULL. C'est alors de la responsabilité de l'auteur de la fonction de
       gérer les valeurs NULL.
      </para>

      <para>
       <literal>RETURNS NULL ON NULL INPUT</literal> ou
       <literal>STRICT</literal> indiquent que la fonction renvoie toujours
       NULL si l'un de ses arguments est NULL. Si un de ces paramètres est spécifié, 
       et qu'un des arguments est NULL, la fonction n'est pas exécutée, mais un résultat NULL
       est automatiquement retournée.
      </para>
     </listitem>
    </varlistentry>

   <varlistentry>
    <term><literal><optional>EXTERNAL</optional> SECURITY INVOKER</literal></term>
    <term><literal><optional>EXTERNAL</optional> SECURITY DEFINER</literal></term>

    <listitem>
     <para>
      <literal>SECURITY INVOKER</literal> indique que la fonction est
      exécutée avec les droits de l'utilisateur qui l'appelle. C'est la valeur
      par défaut. <literal>SECURITY DEFINER</literal> spécifie que la fonction
      est exécutée avec les droits de l'utilisateur qui l'a créé.
     </para>

     <para>
      Le mot clé <literal>EXTERNAL</literal> est autorisé pour la conformité SQL
      mais il est optionnel car, contrairement à SQL, cette fonctionnalité
      s'applique à toutes les fonctions, pas seulement celles externes.
     </para>
    </listitem>
   </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">definition</replaceable></term>

     <listitem>
      <para>
       Une constante de type chaîne définissant la fonction&nbsp;; la
       signification dépend du langage. Cela peut être un nom de fonction
       interne, le chemin vers un
       fichier objet, une commande SQL ou du texte en langage procédural.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><replaceable class="parameter">fichier_obj</replaceable>, <replaceable class="parameter">symbole_lien</replaceable></literal></term>

     <listitem>
      <para>
       Cette forme de clause <literal>AS</literal> est utilisée pour les
       fonctions en langage C chargeables dynamiquement lorsque le nom de la
       fonction dans le code source C n'est pas le même que celui de la fonction
       SQL. La chaîne <replaceable class="parameter">fichier_obj</replaceable> est
       le nom du fichier contenant l'objet chargeable dynamiquement et
       <replaceable class="parameter">symbole_lien</replaceable> est le symbole
       de lien de la fonction, c'est-à-dire le nom de la fonction dans le code
       source C. Si ce lien est omis, il est supposé être le même que le nom de
       la fonction SQL définie.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">attribut</replaceable></term>

     <listitem>
      <para>
       Façon historique de spécifier des informations optionnelles
       concernant la fonction. Les attributs suivants peuvent apparaître ici&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>isStrict</literal></term>
        <listitem>
         <para>
          Équivalent à <literal>STRICT</literal> ou <literal>RETURNS NULL ON
          NULL INPUT</literal>
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>isCachable</literal></term>
        <listitem>
         <para>
          <literal>isCachable</literal> est un équivalent obsolète de
          <literal>IMMUTABLE</literal>&nbsp;; il est toujours accepté pour des
          raisons de compatibilité ascendante.
         </para>
        </listitem>
       </varlistentry>

      </variablelist>

      Les noms d'attribut sont insensibles à la casse.
     </para>
    </listitem>
   </varlistentry>

   </variablelist>

 </refsect1>

 <refsect1 id="sql-createfunction-notes">
  <title>Notes</title>

   <para>
    La lecture de <xref linkend="xfunc"/> fournit des informations 
    supplémentaires sur l'écriture de fonctions.
   </para>

   <para>
    Toute la syntaxe des types <acronym>SQL</acronym> est autorisée pour les
    arguments en entrée et la valeur de sortie. Néanmoins, quelques détails
    de spécification de type (le champ précision pour le type
    <type>numeric</type>, par exemple) sont de la responsabilité de l'implantation de la
    fonction sous-jacente et sont silencieusement acceptés (c'est-à-dire non
    reconnus ou vérifiés) par la commande <command>CREATE FUNCTION</command>.
   </para>

   <para>
    <productname>PostgreSQL</productname> autorise le
    <firstterm>surchargement</firstterm> des fonctions&nbsp;; c'est-à-dire que
    le même nom peut être utilisé pour dess fonctions différentes si tant
    est qu'elles aient des types d'arguments distincts. Néanmoins, les noms C de
    toutes les fonctions doivent être différents. Il est donc nécessaire de donner des
    noms différentes aux fonctions C suchargées (on peut, par exemple, utiliser le type
    des arguments dans le nom de la fonction).
   </para>

   <para>
    Deux fonctions sont considérées identiques si elles partagent le même nom
    et les mêmes types d'argument en <emphasis>entrée</emphasis>, sans considération des
    paramètres <literal>OUT</literal>. Les déclarations suivantes sont, de fait, en conflit&nbsp;:
<programlisting>CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, out text) ...
</programlisting>
   </para>

   <para>
    Lors d'appels répétés à <command>CREATE FUNCTION</command> faisant référence
    au même fichier objet, le fichier est chargé une seule fois. Pour décharger
    et recharger le fichier (en phase de développement, par exemple), la
    commande <xref linkend="sql-load" endterm="sql-load-title"/> est utilisée.
   </para>

   <para>
    <xref linkend="sql-dropfunction" endterm="sql-dropfunction-title"/> est utilisé
    pour supprimer les fonctions utilisateur.
   </para>

  <para>
    Les guillemets dollar (voir <xref linkend="sql-syntax-dollar-quoting"/>) peuvent
    s'avérer plus utiles que la syntaxe habituelle à guillemets simples pour écrire
    la chaîne de définition d'une fonction. En l'absence de
    guillemets dollar, tout guillemet simple et tout antislash dans la définition de
    la fonction doit être échappé en le doublant.
  </para>

   <para>
    Pour pouvoir définir une fonction, l'utilisateur doit posséder le droit
    <literal>USAGE</literal> sur le langage.
   </para>

   <para>
    Lorsque <command>CREATE OR REPLACE FUNCTION</command> est utilisé pour
    remplacer une fonction existante, le propriétaire et les droits de la
    fonction ne sont pas changés. Toutes les autres propriétés de la fonction
    sont affectées par les valeurs indiquées ou par les valeurs imploquées par
    la commande. Vous devez être le propriétaire de la fonction pour la
    remplacer (cela inclut aussi les membres du rôle propriétaire).
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-examples">
  <title>Exemples</title>

  <para>
   Voici quelques exemples triviaux pour bien débuter. Pour plus
   d'informations et d'exemples, voir <xref linkend="xfunc"/>.
<programlisting>CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
</programlisting>
  </para>
 
   <para>
   Incrémenter un entier, en utilisant le nom de l'argument, dans
   <application>PL/pgSQL</application>&nbsp;:

<programlisting>CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
</programlisting>
  </para>

  <para>
   Renvoyer un enregistrement contenant plusieurs paramètres en sortie&nbsp;:
<programlisting>CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   La même chose, en plus verbeux, avec un type composite
   nommé explicitement&nbsp;:
<programlisting>CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
  </para>
</refsect1>

 <refsect1 id="sql-createfunction-security">
  <title>Écrire des fonctions <literal>SECURITY DEFINER</literal> en toute
    sécurité</title>

   <para>
    Comme une fonction <literal>SECURITY DEFINER</literal> est exécutée
    avec les droits de l'utilisateur qui l'a créé, une certaine attention
    est nécessaire pour s'assurer que la fonction ne peut pas être
    utilisée de façon maline. Pour des raisons de sécurité,
    <xref linkend="guc-search-path"/> doit être configuré pour exclure tout
    schéma où des utilisateurs qui ne sont pas de confiance pourraient
    écrire. Ceci empêche des utilisateurs malveillants de créer des
    objets qui masqueraient des objets utilisés par la fonction. Dans
    cette idée, le schéma des tables temporaires est particulièrement
    important car il est le premier schéma dans lequel a lieu la recherche
    et il est modifiable par tout utilisateur. Une solution est de forcer
    la recherche à ne prendre en condition ce schéma qu'en dernier lieu.
    Pour cela, écrire <literal>pg_temp</literal> en tant que dernière entrée de
    <varname>search_path</varname>. La fonction suivante illustre une
    utilisation sûre&nbsp;:
   </para>

<programlisting>
CREATE FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT)
RETURNS BOOLEAN AS $$
DECLARE ok BOOLEAN;
        ancien_path TEXT;
BEGIN
        -- Sauvegarder l'ancien search_path ;
        -- remarquez que nous devons qualifier current_setting
        -- pour nous assurer que nous appelons la bonne fonction
        ancien_path := pg_catalog.current_setting('search_path');

        -- Configurer un search_path sécurisé : schémas de confiance, puis 'pg_temp'.
        -- Nous initialisons is_local = true pour que l'ancienne valeur
        -- soit restaurée au cas où une erreur survienne avant que nous
        -- n'atteignons la fin de la fonction.
        PERFORM pg_catalog.set_config('search_path', 'admin, pg_temp', true);

        -- Effectuer le travail sécurisé de la fonction.
        SELECT  (motdepasse = $2) INTO ok
        FROM    motsdepasse
        WHERE   nomutilisateur = $1;

        -- Restaurer le search_path de l'appelant
        PERFORM pg_catalog.set_config('search_path', ancien_path, true);

        RETURN ok;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
</programlisting>

 </refsect1>

 <refsect1 id="sql-createfunction-compat">
  <title>Compatibilité</title>

  <para>
   Une commande <command>CREATE FUNCTION</command> est définie en SQL:1999 et
   ultérieur. La version <productname>PostgreSQL</productname> est similaire
   mais pas entièrement compatible. Les attributs ne sont pas portables, pas
   plus que les différents langages disponibles.
  </para>

  <para>
   Pour des raisons de compatibilité avec d'autres systèmes de bases de données, 
   <replaceable class="parameter">modearg</replaceable> peut être écrit 
   avant ou après <replaceable class="parameter">nomarg</replaceable>. Mais
   seule la première façon est compatible avec le standard.
  </para>
 </refsect1>


 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterfunction"
    endterm="sql-alterfunction-title"/></member>
   <member><xref linkend="sql-dropfunction"
    endterm="sql-dropfunction-title"/></member>
   <member><xref linkend="sql-grant" endterm="sql-grant-title"/></member>
   <member><xref linkend="sql-load" endterm="sql-load-title"/></member>
   <member><xref linkend="sql-revoke" endterm="sql-revoke-title"/></member>
   <member><xref linkend="app-createlang"
    endterm="app-createlang-title"/></member>
  </simplelist>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
