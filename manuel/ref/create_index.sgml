<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_index.sgml,v 1.8 2005/03/14 06:03:51 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-CREATEINDEX">
 <refmeta>
  <refentrytitle id="sql-createindex-title">CREATE INDEX</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE INDEX</refname>
  <refpurpose>définit un nouvel index</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createindex">
  <primary>CREATE INDEX</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE [ UNIQUE ] INDEX <replaceable class="parameter">nom</replaceable> ON <replaceable class="parameter">table</replaceable> [ USING <replaceable
class="parameter">méthode</replaceable> ]
    ( { <replaceable class="parameter">colonne</replaceable> | ( <replaceable
class="parameter">expression</replaceable> ) } [ <replaceable
class="parameter">classeop</replaceable> ] [, ...] )
    [ TABLESPACE <replaceable class="parameter">espacelogique</replaceable> ]
    [ WHERE <replaceable class="parameter">prédicat</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE INDEX</command> construit un index <replaceable
   class="parameter">nom_index</replaceable> sur la table spécifiée. Les index
   sont principalement utilisés pour améliorer les performances de la base de
   données (bien qu'une utilisation inappropriée résultera en des performances
   moindres).
  </para>

  <para>
   Les champs clé pour l'index sont spécifiés par les noms des colonnes ou
   comme des expressions écrites entre parenthèses. Plusieurs champs peuvent
   être spécifiés si la méthode d'indexage supporte les index multi-colonnes.
  </para>

  <para>
   Un champ index peut être une expression calculée à partir des valeurs d'une
   ou plusieurs colonnes d'une ligne d'une table. Cette fonctionnalité peut être
   utilisée pour obtenir un accès rapide aux données basées sur quelques
   transformations des données basiques. Par exemple, un index calculé sur
   <literal>upper(col)</> permettra l'utilisation d'un index par <literal>WHERE
   upper(col) = 'JIM'</>.
  </para>

  <para>
   <productname>PostgreSQL</productname> fournit les méthodes d'indexage
   B-tree, R-tree, hash et GiST. La méthode d'indexage B-tree est une
   implémentation des arbres balancées à haute concurrence de Lehman-Yao. La 
   méthode d'indexage R-tree implémente les R-tree en utilisant l'algorithme
   divisé quadratique de Guttman. La méthode d'indexage hash est une
   implémentation du découpage linaire de Litwin. Les utilisateurs peuvent aussi
   définir leur propre méthode d'indexage mais ceci est particulièrement
   compliqué.
  </para>

  <para>
    Lorsque la clause <literal>WHERE</literal> est présente, un
    <firstterm>index partiel</firstterm> est créé. Un index partiel est un index
    contenant des entrées pour seulement une portion d'une table, habituellement
    une portion qui est plus utile pour l'indexage que le reste de la table. Par
    exemple, si vous disposez d'une table contenant des ordres facturés et non
    facturés où les ordres non facturés prennent une petite fraction du total de
    la table et qu'il s'agit en plus d'une section fréquemment utilisée, vous
    pouvez améliorer les performances en créant un index sur cette portion. Une
    autre application possible est d'utiliser <literal>WHERE</literal> avec
    <literal>UNIQUE</literal> pour renforcer l'unicité sur un sous-ensemble
    d'une table. Voir <xref linkend="indexes-partial"> pour plus de discussions.
  </para>

  <para>
    L'expression utilisée dans la clause <literal>WHERE</literal> pourrait
    référencer seulement les colonnes de la table sous-jacente mais il peut
    utiliser toute les colonnes, pas seulement celles en cours d'indexage.
    Actuellement, les sous-requêtes et les expressions d'agrégats sont aussi
    interdites dans <literal>WHERE</literal>. Les mêmes restrictions
    s'appliquent aux champs d'index qui sont des expressions.
  </para>

  <para>
   Toutes les fonctions et opérateurs utilisés dans la définition d'index
   doivent être <quote>immutable</>, c'est-à-dire que leur résultat doit
   uniquement dépendre de leurs arguments et jamais d'une influence externe
   (telle que le contenu d'une autre table ou l'heure actuelle). Cette
   restriction permet de s'assurer que le comportement de l'index est bien
   défini. Pour utiliser une fonction définie par l'utilisateur dans une
   expression d'index ou dans une clause <literal>WHERE</literal>, rappelez-vous
   de marquer la fonction comme immutable lorsque vous la créez.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

    <variablelist>
     <varlistentry>
      <term><literal>UNIQUE</literal></term>
      <listitem>
       <para>
	Fait que le système vérifie les valeurs dupliquées dans la table à la
	création de l'index (si des données existent déjà) et à chaque fois
	qu'une donnée est ajoutée. Les tentatives d'insertion ou de mises à jour
	qui résulteraient en des entrées dupliquées généreront une erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom</replaceable></term>
      <listitem>
       <para>
        Le nom de l'index à créer. Aucun nom de schéma ne peut être inclus
	ici&nbsp;; l'index est toujours créé dans le même schéma que sa table
	parent.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">table</replaceable></term>
      <listitem>
       <para>
	Le nom de la table à indexer (pouvant être qualifié du nom du schéma).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">méthode</replaceable></term>
      <listitem>
       <para>
        Le nom de la méthode à utiliser pour l'index. Les choix sont
        <literal>btree</literal>, <literal>hash</literal>,
        <literal>rtree</literal> et <literal>gist</literal>. La méthode par
	défaut est <literal>btree</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">colonne</replaceable></term>
      <listitem>
       <para>
	Le nom d'une colonne de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">expression</replaceable></term>
      <listitem>
       <para>
	Une expression basée sur une ou plusieurs colonnes de la table.
	L'expression doit habituellement être écrite en l'entourant de
	parenthèses, comme le montre la syntaxe. Néanmoins, les parenthèses
	peuvent être oubliées si l'expression est de la forme d'un appel de
	fonction.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">classeop</replaceable></term>
      <listitem>
       <para>
	Le nom d'une classe d'opérateur. Voir ci-dessous pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">espacelogique</replaceable></term>
      <listitem>
       <para>
        L'espace logique dans lequel créer l'index. Si non spécifié,
        <xref linkend="guc-default-tablespace"> est utilisé ou l'espace logique
	par défaut de la base de données si <varname>default_tablespace</> est
	une chaîne vide.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">prédicat</replaceable></term>
      <listitem>
       <para>
	L'expression de contrainte pour un index partiel.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Voir <xref linkend="indexes"> pour des informations sur le moment où les
   index sont utilisés, quand ils ne le sont pas et dans quelles situations
   particulières ils peuvent être utiles.
  </para>

  <para>
   Actuellement, seules les méthodes d'indexage B-tree et GiST supportent les
   index multi-colonnes. Jusqu'à 32 champs peuvent être spécifiés par défaut.
   (Cette limite peut être modifiée lors de la construction de
   <productname>PostgreSQL</productname>.) Seul B-tree supporte actuellement les
   index uniques.
  </para>

  <para>
   Une <firstterm>classe d'opérateur</firstterm> peut être spécifiée pour
   chaque colonne d'un index. La classe d'opérateur identifie les opérateurs à
   utiliser par l'index pour cette colonne. Par exemple, un index B-tree sur des
   entiers sur quatre octets utiliserait la classe
   <literal>int4_ops</literal>&nbsp;; cette classe d'opérateur inclut des
   fonctions de comparaison pour les entiers sur quatre octets. En pratique, la
   classe d'opérateur par défaut pour le type de données de la colonne est
   généralement suffisant. Le point principal pour avoir des classes d'opérateur
   est que pour certains types de données, il pourrait y avoir plus d'un
   ordonnancement significatif. Par exemple, nous pourrions vouloir trier un
   type de données <quote>nombre complexe</quote> soit par sa valeur absolue
   soit par sa partie réelle. Nous pourrions le faire en définissant deux
   classes d'opérateur pour le type de données, puis en sélectionnant la bonne
   classe lors de la création d'un index. Plus d'informations sur les classes
   d'opérateurs sont disponibles dans <xref linkend="indexes-opclass"> et dans
   <xref linkend="xindex">.
  </para>

  <para>
   Utilisez <xref linkend="sql-dropindex" endterm="sql-dropindex-title">
   pour supprimer un index.
  </para>

  <para>
   Les index ne sont pas utilisés pour les clauses <literal>IS NULL</> par
   défaut. La meilleure façon d'utiliser des index dans de tels cas est de
   créer un index partiel en utilisant un prédicat <literal>IS NULL</>.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Pour créer un index B-tree sur la colonne <literal>titre</literal> dans la
   table <literal>films</literal>&nbsp;:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title);
</programlisting>
  </para>

  <para>
   Pour créer un index sur la colonne <literal>code</> de la table
   <literal>films</> et donner à l'index l'emplacement de l'espace logique
   <literal>espaceindex</>&nbsp;:
<programlisting>
CREATE INDEX code_idx ON films(code) TABLESPACE espaceindex;
</programlisting>
  </para>

<!--
<comment>
Is this example correct?
</comment>
  <para>
   To create a R-tree index on a point attribute so that we
   can efficiently use box operators on the result of the
   conversion function:
  </para>
  <programlisting>
CREATE INDEX pointloc
    ON points USING RTREE (point2box(location) box_ops);
SELECT * FROM points
    WHERE point2box(points.pointloc) = boxes.box;
  </programlisting>
-->

 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>CREATE INDEX</command> est une extension du langage
   <productname>PostgreSQL</productname>. Les index n'existent pas dans le
   standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterindex"
    endterm="sql-alterindex-title"></member>
   <member><xref linkend="sql-dropindex" endterm="sql-dropindex-title"></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
