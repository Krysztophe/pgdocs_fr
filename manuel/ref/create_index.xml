<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_index.sgml,v 1.8 2005/03/14 06:03:51 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060618 -->

<refentry id="sql-createindex">
 <refmeta>
  <refentrytitle id="sql-createindex-title">CREATE INDEX</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE INDEX</refname>
  <refpurpose>Définir un nouvel index</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ UNIQUE ] INDEX <replaceable class="parameter">nom</replaceable> ON <replaceable class="parameter">table</replaceable> [ USING <replaceable class="parameter">méthode</replaceable> ]
    ( { <replaceable class="parameter">colonne</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">classeop</replaceable> ] [, ...] )
    [ TABLESPACE <replaceable class="parameter">nom_tablespace</replaceable> ]
    [ WHERE <replaceable class="parameter">prédicat</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createindex">
   <primary>CREATE INDEX</primary>
  </indexterm>


  <para>
   <command>CREATE INDEX</command> construit un index
   <replaceable class="parameter">nom_index</replaceable> sur la table spécifiée. Les index
   sont principalement utilisés pour améliorer les performances de la base de
   données (bien qu'une utilisation inappropriée puisse produir l'effet inverse).
  </para>

  <para>
   Les champs clé pour l'index sont spécifiés à l'aide de noms des colonnes ou
   par des expressions écrites entre parenthèses. Plusieurs champs peuvent
   être spécifiés si la méthode d'indexation supporte les index multi-colonnes.
  </para>

  <para>
   Un champ d'index peut être une expression calculée à partir des valeurs d'une
   ou plusieurs colonnes de la ligne de table. Cette fonctionnalité peut être
   utilisée pour obtenir un accès rapide à des données obtenues par 
   transformation des données basiques. Par exemple, un index calculé sur
   <literal>upper(col)</literal> autorise la clause 
   <literal>WHERE upper(col) = 'JIM'</literal> à utiliser un index.
  </para>

  <para>
   <productname>PostgreSQL</productname> fournit les méthodes d'indexation
   B-tree (NDT&nbsp;: arbres balancés), R-tree (NDT&nbsp;: arbres réels), hash (NDT&nbsp;: hachage)
   et GiST (NDT&nbsp;: arbres de recherche généralisés). La méthode B-tree est une
   implantation des arbres-B à haute concurrence de Lehman-Yao. La 
   méthode R-tree implante les arbres-R à l'aide de l'algorithme
   divisé quadratique de Guttman. La méthode hash est une
   implémentation du hachage linaire de Litwin. Il est possible, bien que compliqué,
   de définir des méthodes d'indexation utilisateur.
  </para>

  <para>
    Lorsque la clause <literal>WHERE</literal> est présente, un
    <firstterm>index partiel</firstterm> est créé. Un index partiel est un index
    ne contenant des entrées que pour une portion d'une table, habituellement
    la portion sur laquelle l'indexation est la plus utile. Par
    exemple, si une table contient des ordres facturés et d'autres qui ne le sont pas,
    et que les ordres non facturés n'occupent qu'une petite fraction du total de
    la table, qui plus est fréquemment utilisée, les performances sont
    améliorées par la création d'un index sur cette portion. Une
    autre application possible est l'utilisation de la clause <literal>WHERE</literal> 
    en combinaison avec <literal>UNIQUE</literal> pour assurer l'unicité sur un sous-ensemble
    d'une table. Voir <xref linkend="indexes-partial"/> pour plus de renseignements.
  </para>

  <para>
    L'expression utilisée dans la clause <literal>WHERE</literal> peut ne
    faire référence qu'à des colonnes de la table sous-jacente, mais elle peut
    utiliser toutes les colonnes, pas uniquement celles indexées.
    Actuellement, les sous-requêtes et les expressions d'agrégats sont aussi
    interdites dans la clause <literal>WHERE</literal>. Les mêmes restrictions
    s'appliquent aux champs d'index qui sont des expressions.
  </para>

  <para>
   Toutes les fonctions et opérateurs utilisés dans la définition d'index
   doivent être <quote>immutable</quote> (NDT&nbsp;: immuable), c'est-à-dire que leur résultat ne doit
   dépendre que de leurs arguments et jamais d'une influence externe
   (telle que le contenu d'une autre table ou l'heure). Cette
   restriction permet de s'assurer que le comportement de l'index est strictement
   défini. Pour utiliser une fonction utilisateur dans une
   expression d'index ou dans une clause <literal>WHERE</literal>, cette fonction
   doit être marquée immutable lors de sa création.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

    <variablelist>
     <varlistentry>
      <term><literal>UNIQUE</literal></term>
      <listitem>
       <para>
		Le système vérifie la présence de valeurs dupliquées dans la table à la
	création de l'index (si des données existent déjà) et à chaque fois
	qu'une donnée est ajoutée. Les tentatives d'insertion ou de mises à jour
	qui résultent en des entrées dupliquées engendrent une erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom</replaceable></term>
      <listitem>
       <para>
        Le nom de l'index à créer. Aucun nom de schéma ne peut être inclus
	ici&nbsp;; l'index est toujours créé dans le même schéma que sa table
	parent.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">table</replaceable></term>
      <listitem>
       <para>
	Le nom de la table à indexer (éventuellement qualifié du nom du schéma).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">méthode</replaceable></term>
      <listitem>
       <para>
        Le nom de la méthode à utiliser pour l'index. Les choix sont
        <literal>btree</literal>, <literal>hash</literal>,
        <literal>rtree</literal> et <literal>gist</literal>. La méthode par
	défaut est <literal>btree</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">colonne</replaceable></term>
      <listitem>
       <para>
	Le nom d'une colonne de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">expression</replaceable></term>
      <listitem>
       <para>
	Une expression basée sur une ou plusieurs colonnes de la table.
	L'expression doit habituellement être écrite entre
	parenthèses, comme la syntaxe le précise. Néanmoins, les parenthèses
	peuvent être omises si l'expression a la forme d'un appel de
	fonction.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">classeop</replaceable></term>
      <listitem>
       <para>
	Le nom d'une classe d'opérateur. Voir plus bas pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_tablespace</replaceable></term>
      <listitem>
       <para>
        Le tablespace dans lequel créer l'index. S'il n'est pas précisé,
        <xref linkend="guc-default-tablespace"/> est utilisé ou le tablespace
	par défaut de la base de données si <varname>default_tablespace</varname> est
	une chaîne vide.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">prédicat</replaceable></term>
      <listitem>
       <para>
	L'expression de la contrainte pour un index partiel.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   <xref linkend="indexes"/> présente des informations sur le moment où les
   index peuvent être utilisés, quand ils ne le sont pas et dans quelles situations
   particulières ils peuvent être utiles.
  </para>

  <para>
   Actuellement, seules les méthodes d'indexation B-tree et GiST supportent les
   index multi-colonnes. Jusqu'à 32 champs peuvent être spécifiés par défaut.
   (Cette limite peut être modifiée à la compilation de
   <productname>PostgreSQL</productname>.) Seul B-tree supporte actuellement les
   index uniques.
  </para>

  <para>
   Une <firstterm>classe d'opérateur</firstterm> peut être spécifiée pour
   chaque colonne d'un index. La classe d'opérateur identifie les opérateurs à
   utiliser par l'index pour cette colonne. Par exemple, un index B-tree sur des
   entiers codés sur quatre octets utilise la classe
   <literal>int4_ops</literal>, qui contient des
   fonctions de comparaison pour les entiers sur quatre octets. En pratique, la
   classe d'opérateur par défaut pour le type de données de la colonne est
   généralement suffisant. Les classes d'opérateur trouvent leur intérêt principal 
   dans l'existence, pour certains types de données, de plusieurs
   ordonnancements significatifs. 
  </para>
  <para>
   Soit l'exemple d'un type de données
   <quote>nombre complexe</quote> qui doit être classé par sa valeur absolue
   ou par sa partie réelle. Cela peut être réalisé par la définition de deux
   classes d'opérateur pour le type de données, puis par la sélection de la
   classe appropriée lors de la création d'un index.
  </para>
  <para>
   De plus amples informations sur les classes d'opérateurs sont disponibles
   dans <xref linkend="indexes-opclass"/> et dans <xref linkend="xindex"/>.
  </para>

  <para>
   <xref linkend="sql-dropindex" endterm="sql-dropindex-title"/> est utilisé
   pour supprimer un index.
  </para>

  <para>
   Par défaut, les index ne sont pas utilisés pour les clauses <literal>IS NULL</literal>.
   La meilleure façon d'utiliser des index dans de tels cas est de
   créer un index partiel qui utilise un prédicat <literal>IS NULL</literal>.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer un index B-tree sur la colonne <literal>titre</literal> dans la
   table <literal>films</literal>&nbsp;:
<programlisting>CREATE UNIQUE INDEX title_idx ON films (title);
</programlisting>
  </para>

  <para>
   Créer un index sur la colonne <literal>code</literal> de la table
   <literal>films</literal> et donner à l'index l'emplacement du tablespace
   <literal>espaceindex</literal>&nbsp;:
<programlisting>CREATE INDEX code_idx ON films(code) TABLESPACE espaceindex;
</programlisting>
  </para>

<!--
<comment>
Is this example correct?
</comment>
  <para>
   To create a R-tree index on a point attribute so that we
   can efficiently use box operators on the result of the
   conversion function:
  </para>
  <programlisting>CREATE INDEX pointloc
    ON points USING RTREE (point2box(location) box_ops);
SELECT * FROM points
    WHERE point2box(points.pointloc) = boxes.box;
  </programlisting>
-->

 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>CREATE INDEX</command> est une extension du langage
   <productname>PostgreSQL</productname>. Les index n'existent pas dans le
   standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterindex"
    endterm="sql-alterindex-title"/></member>
   <member><xref linkend="sql-dropindex" endterm="sql-dropindex-title"/></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
