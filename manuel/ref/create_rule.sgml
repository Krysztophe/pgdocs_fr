<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_rule.sgml,v 1.8 2005/03/14 06:03:52 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-CREATERULE">
 <refmeta>
  <refentrytitle id="sql-createrule-title">CREATE RULE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE RULE</refname>
  <refpurpose>définit une nouvelle règle de réécriture</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createrule">
  <primary>CREATE RULE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE [ OR REPLACE ] RULE <replaceable class="parameter">nom</replaceable> AS
ON <replaceable class="parameter">événement</replaceable>
    TO <replaceable class="parameter">table</replaceable> [ WHERE <replaceable class="parameter">condition</replaceable> ]
    DO [ ALSO | INSTEAD ] { NOTHING | <replaceable
class="parameter">commande</replaceable> | ( <replaceable
class="parameter">commande</replaceable> ; <replaceable
class="parameter">commande</replaceable> ... ) }
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE RULE</command> définit une nouvelle règle s'appliquant à une
   table ou à une vue. <command>CREATE OR REPLACE RULE</command> soit créera une
   nouvelle règle soit remplacera une règle existante du même nom pour la même
   table.
  </para>

  <para>
   Le système de règles de <productname>PostgreSQL</productname> autorise la
   définition d'actions alternatives à réaliser sur les insertions, mises à jour
   ou suppressions dans les tables de la base de données. Directement, une règle
   fait que des commandes supplémentaires soient exécutées lorsqu'une commande
   donnée est exécutée sur une table donnée. Autrement dit, une règle
   <literal>INSTEAD</literal> peut
   remplacer une commande donnée par un autre ou faire qu'une commande ne soit
   pas exécutée du tout. Les règles sont aussi utilisées pour implémenter les
   vues de tables. Il est important de réaliser qu'une règle est réellement un
   mécanisme de transformation de commandes. La transformation survient avant le
   début de l'exécution de la commande. Si vous voulez réellement une opération
   qui s'exécute indépendamment pour chaque ligne physique, vous voulez
   probablement utiliser un déclencheur et non pas une règle. Plus
   d'informations sur le système des règles se trouvent dans <xref
   linkend="rules">.
  </para>
  
  <para>
   Actuellement, les règles <literal>ON SELECT</literal> doivent être des règles
   <literal>INSTEAD</literal> sans condition et doivent avoir des actions
   consistant en une simple commande <command>SELECT</command>. Du coup, une
   règle <literal>ON SELECT</literal> transforme réellement la table en une vue
   dont le contenu visible est les lignes renvoyées par la commande
   <command>SELECT</command> de la règle plutôt que les lignes qui sont stockées
   dans la table (si elles existent). Il est mieux considéré d'écrire une
   commande <command>CREATE VIEW</command> plutôt que de créer une vraie table
   et de définir une règle <literal>ON SELECT</literal> sur elle.
  </para>

  <para>
   Vous pouvez créer l'illusion d'une vue pouvant être mise à jour en
   définissant les règles <literal>ON INSERT</literal>, <literal>ON
   UPDATE</literal> et <literal>ON DELETE</literal> (ou tout sous-ensemble de
   celles suffisantes à vos buts) pour remplacer les actions de mises à jour
   sur la vue par des mises à jours appropriées sur les autres tables.
  </para>

  <para>
   Voici une astuce si vous utilisez les règles conditionnelles pour les mises
   à jour de vues&nbsp;: elle <emphasis>doit</> être une règle
   <literal>INSTEAD</literal> sans condition pour chaque action que vous
   souhaitez autoriser sur la vue. Si la règle est conditionnelle ou si elle
   n'est pas <literal>INSTEAD</literal>, alors le système rejettera toutes
   tentatives d'exécution de l'action de mise à jour parce qu'il pense qu'il
   pourrait finir par essayer de réaliser l'action sur la table de la vue dans
   certains cas. Si vous souhaitez gérer tous les cas utiles dans les règles
   conditionnelles, ajoutez une règle <literal>DO
   INSTEAD NOTHING</literal> sans condition pour vous assurer que le système 
   comprend qu'il ne sera jamais appelé pour modifier la table. Puis, rendez les
   règles conditionnelles en non <literal>INSTEAD</literal>&nbsp;; dans les cas
   où cela s'applique, elles ajoutent à l'action <literal>INSTEAD
   NOTHING</literal> par défaut.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom d'une règle à créer. Elle doit être distincte du nom de toute autre
      règle sur la même table. Les règles multiples sur la même table et le même
      type d'événement sont appliquées dans l'ordre alphabétique des noms.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">événement</replaceable></term>
    <listitem>
     <para>
      L'événement est un de ceux-ci&nbsp;: <literal>SELECT</literal>,
      <literal>INSERT</literal>, <literal>UPDATE</literal> ou
      <literal>DELETE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">table</replaceable></term>
    <listitem>
     <para>
      Le nom (pouvant être qualifié par le nom du schéma) de la table ou de la
      vue où s'applique la règle.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
     <para>
      Toute expression <acronym>SQL</acronym> conditionnelle (renvoyant le type
      <type>boolean</type>). L'expression de condition ne peut pas
      référer à une table autre que <literal>NEW</literal> et
      <literal>OLD</literal> et ne peut pas contenir de fonction d'agrégat.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><option>INSTEAD</option></term>
    <listitem>
     <para>
      <literal>INSTEAD</literal> indique que les commandes devraient être
      exécutées <emphasis>à la place de</> la commande originale.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><option>ALSO</option></term>
    <listitem>
     <para>
      <literal>ALSO</literal> indique que les commandes devraient être exécutées
      <emphasis>en plus de</emphasis> la commande originale.
     </para>

     <para>
      Si ni <literal>ALSO</literal> ni <literal>INSTEAD</literal> ne sont
      spécifiés, <literal>ALSO</literal> est la valeur par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">commande</replaceable></term>
    <listitem>
     <para>
      La où les commandes réalisant l'action de la règle. Les commandes valides
      sont <command>SELECT</command>, <command>INSERT</command>,
      <command>UPDATE</command>, <command>DELETE</command> ou
      <command>NOTIFY</command>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   À l'intérieur d'une <replaceable class="parameter">condition</replaceable>
   et d'une  <replaceable class="parameter">commande</replaceable>, les noms de
   tables spéciales <literal>NEW</literal> et <literal>OLD</literal> pourraient
   être utilisés pour se référer aux valeurs de la table référencée.
   <literal>NEW</literal> est valide dans les règles <literal>ON
   INSERT</literal> et <literal>ON UPDATE</literal> pour référencer la nouvelle
   ligne en cours d'insertion ou de mise à jour. <literal>OLD</literal> est
   valide dans les règles <literal>ON UPDATE</literal> et <literal>ON
   DELETE</literal> pour référencer la ligne existante en cours de modification
   ou de suppression.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Vous devez avoir le droit <literal>RULE</literal> sur une table pour être
   autorisé à définir une règle sur elle.
  </para>

  <para>
   Il est très important de faire attention aux règles circulaires. Par
   exemple, bien que chacune des deux définitions de règles est acceptée par
   <productname>PostgreSQL</productname>, la commande <command>SELECT</command>
   fera que <productname>PostgreSQL</productname> rapportera une erreur parce
   que la requête sera en boucle trop longtemps&nbsp;:

<programlisting>
CREATE RULE "_RETURN" AS
    ON SELECT TO t1
    DO INSTEAD 
	SELECT * FROM t2;

CREATE RULE "_RETURN" AS
    ON SELECT TO t2
    DO INSTEAD 
	SELECT * FROM t1;

SELECT * FROM t1;
</programlisting>
  </para>

  <para>
   Actuellement, si l'action d'une règle contient une commande
   <command>NOTIFY</command>, cette commande sera exécutée sans condition,
   c'est-à-dire que le <command>NOTIFY</command> sera envoyé même si aucune
   lignes de la règle ne s'applique. Par exemple, dans
<programlisting>
CREATE RULE notify_me AS ON UPDATE TO matable DO ALSO NOTIFY matable;

UPDATE matable SET name = 'foo' WHERE id = 42;
</programlisting>
   un événement <command>NOTIFY</command> sera lancé durant un
   <command>UPDATE</command>, qu'il y ait ou non des lignes satisfaisant la
   condition <literal>id = 42</literal>. L'implémentation de cette restriction
   pourrait être corrigée dans les prochaines versions.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>CREATE RULE</command> est une extension du langage de
   <productname>PostgreSQL</productname> ainsi que tout le système de
   réécriture de requêtes.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
