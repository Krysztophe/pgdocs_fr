<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_table_as.sgml,v 1.10 2005/04/06 22:38:52 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060618 -->

<refentry id="sql-createtableas">
 <refmeta>
  <refentrytitle id="sql-createtableas-title">CREATE TABLE AS</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TABLE AS</refname>
  <refpurpose>Définir une nouvelle table à partir des résultats d'une
   requête</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE <replaceable>nom_table</replaceable>
    [ (<replaceable>nom_colonne</replaceable> [, ...] ) ] [ [ WITH | WITHOUT ] OIDS ]
    AS <replaceable>requête</replaceable>
</synopsis>
 </refsynopsisdiv>
  
 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createtableas">
   <primary>CREATE TABLE AS</primary>
  </indexterm>

  <para>
   <command>CREATE TABLE AS</command> crée une table et y insère les
   données récupérées par une commande <command>SELECT</command> ou une
   commande <command>EXECUTE</command> qui lance une commande
   <command>SELECT</command> préparée. Les colonnes de la table ont les noms et les types de
   données associés aux colonnes en sortie du <command>SELECT</command>
   (les noms des colonnes peuvent toutefois être surchargés).
  </para>

  <para>
   <command>CREATE TABLE AS</command> semble possèder des similitudes avec la création 
   d'une vue mais est, en fait, assez différente&nbsp;: elle crée une nouvelle
   table et n'évalue la requête qu'une seule fois, pour le chargement initial de la nouvelle table.
   Les modifications ultérieures de la table source ne sont pas prises en compte. Au contraire, 
   une vue réévalue l'instruction <command>SELECT</command> de définition à chaque appel.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><literal>GLOBAL</literal> ou <literal>LOCAL</literal></term>
    <listitem>
     <para>
      Ignoré. Conservé pour la compatibilité
      (cf. <xref linkend="sql-createtable" endterm="sql-createtable-title"/>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TEMPORARY</literal> ou <literal>TEMP</literal></term>
    <listitem>
     <para>
      Si spécifié, la table est temporaire
      (cf. <xref linkend="sql-createtable" endterm="sql-createtable-title"/>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable>nom_table</replaceable></term>
    <listitem>
     <para>
      Le nom de la table à créer (éventuellement qualifié du nom du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable>nom_colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne dans la nouvelle table. Si les noms de colonnes ne
      sont pas précisés, ils sont issus des noms des colonnes en sortie de la
      requête. Les noms des colonnes ne peuvent pas être précisés lorsque la table est créée à partir d'une commande
      <command>EXECUTE</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH OIDS</literal></term>
    <term><literal>WITHOUT OIDS</literal></term>
     <listitem>
      <para>
       Clause optionnelle qui précise si la table est créée avec les OIDs.
       La valeur du paramètre de configuration <xref linkend="guc-default-with-oids"/> est utilisée
       en l'absence de précision.
      </para>
     </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable>requête</replaceable></term>
    <listitem>
     <para>
      Une instruction (c'est-à-dire une commande <command>SELECT</command>
      ou une commande <command>EXECUTE</command> qui
      exécute une requête <command>SELECT</command> préparée). 
      <xref linkend="sql-select" endterm="sql-select-title"/> et
      <xref linkend="sql-execute" endterm="sql-execute-title"/> décrivent
      les syntaxes respectivement autorisées.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Cette commande est fonctionnellement équivalente à
   <xref linkend="sql-selectinto" endterm="sql-selectinto-title"/>. Elle lui est
   cependant préférée car elle présente moins de risques de confusion avec les autres utilisations
   de la syntaxe <command>SELECT INTO</command>. De plus,
   <command>CREATE TABLE AS</command> offre plus de fonctionnalités 
   que <command>SELECT INTO</command>.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 8.0,
   <command>CREATE TABLE AS</command> incluait toujours les OIDs dans la table créée.
   À partir de <productname>PostgresSQL</productname> 8.0, la commande
   <command>CREATE TABLE AS</command> autorise l'utilisateur à spécifier
   explicitement la présence des OID. En l'absence de précision,
   la variable de configuration <xref linkend="guc-default-with-oids"/> est utilisée. À partir de
   <productname>PostgreSQL</productname> 8.1, la valeur par défaut de cette variable est &laquo;&nbsp;faux&nbsp;&raquo;&nbsp;;
   le comportement par défaut n'est donc pas identique à celui des versions
   précédant la 8.0. Il est préférable que les applications qui nécessitent des OID dans la table créée
   par <command>CREATE TABLE AS</command> indiquent explicitement
   <literal>WITH OIDS</literal> pour s'assurer du comportement souhaité.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer une table <literal>films_recent</literal> contenant les
   entrées récentes de la table <literal>films</literal> :

<programlisting>CREATE TABLE films_recent AS
  SELECT * FROM films WHERE date_prod &gt;= '2006-01-01';
</programlisting>
  </para>
 </refsect1>


 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>CREATE TABLE AS</command> est conforme au standard
   <acronym>SQL</acronym>, avec les exceptions suivantes&nbsp;:

   <itemizedlist spacing="compact">
    <listitem>
     <para>
      Le standard requiert des parenthèses autour de la clause de la
      sous-requête&nbsp;; elles sont optionnelles dans <productname>PostgreSQL</productname>.
     </para>
    </listitem>

    <listitem>
     <para>
      Le standard définit une clause <literal>ON COMMIT</literal>&nbsp;; elle
      n'est pas encore implantée dans <productname>PostgreSQL</productname>.
     </para>
    </listitem>

    <listitem>
     <para>
      Le standard définit une clause <literal>WITH [ NO ] DATA</literal>&nbsp;;
      elle n'est pas encore implantée dans <productname>PostgreSQL</productname>.
      Le comportement de <productname>PostgreSQL</productname> est équivalent au cas
      <literal>WITH DATA</literal> du standard.
     </para>
    </listitem>

    <listitem>
     <para>
      <literal>WITH/WITHOUT OIDS</literal> est une extension de
      <productname>PostgreSQL</productname>.
     </para>
    </listitem>

    <listitem>
     <para>
      <productname>PostgreSQL</productname> gère les tables temporaires assez
      différemment du standard. Voir
      <xref linkend="sql-createtable" endterm="sql-createtable-title"/>
      pour plus de renseignements.
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createtable" endterm="sql-createtable-title"/></member>
   <member><xref linkend="sql-execute" endterm="sql-execute-title"/></member>
   <member><xref linkend="sql-select" endterm="sql-select-title"/></member>
   <member><xref linkend="sql-selectinto" endterm="sql-selectinto-title"/></member>
  </simplelist>
 </refsect1>
 
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
