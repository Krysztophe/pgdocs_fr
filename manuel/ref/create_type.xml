<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_type.sgml,v 1.11 2005/09/15 07:03:26 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060618 -->

<refentry id="sql-createtype">
 <refmeta>
  <refentrytitle id="sql-createtype-title">CREATE TYPE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TYPE</refname>
  <refpurpose>Définir un nouveau type de données</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE TYPE <replaceable class="parameter">nom</replaceable> AS
    ( <replaceable class="parameter">nom_attribut</replaceable> <replaceable class="parameter">type_donnée</replaceable> [, ... ] )

CREATE TYPE <replaceable class="parameter">nom</replaceable> (
    INPUT = <replaceable class="parameter">fonction_entrée</replaceable>,
    OUTPUT = <replaceable class="parameter">fonction_sortie</replaceable>
    [ , RECEIVE = <replaceable class="parameter">fonction_réception</replaceable> ]
    [ , SEND = <replaceable class="parameter">fonction_envoi</replaceable> ]
    [ , ANALYZE = <replaceable class="parameter">fonction_analyse</replaceable> ]
    [ , INTERNALLENGTH = { <replaceable class="parameter">longueurinterne</replaceable> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <replaceable class="parameter">alignement</replaceable> ]
    [ , STORAGE = <replaceable class="parameter">stockage</replaceable> ]
    [ , DEFAULT = <replaceable class="parameter">défaut</replaceable> ]
    [ , ELEMENT = <replaceable class="parameter">élément</replaceable> ]
    [ , DELIMITER = <replaceable class="parameter">délimiteur</replaceable> ]
)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createtype">
   <primary>CREATE TYPE</primary>
  </indexterm>

  <para>
   <command>CREATE TYPE</command> enregistre un nouveau type de données 
   utilisable dans la base courante. L'utilisateur qui définit un type
   en devient le propriétaire.
  </para>

  <para>
   Si un nom de schéma est précisé, le type est créé dans ce schéma.
   Sinon, il est créé dans le schéma courant. Le nom du type doit être
   distinct du nom de tout type ou domaine existant dans le même schéma. 
   Les tables possèdent des types de données associés. Il est donc nécessaire
   que le nom du type soit également distinct du nom de toute table existant dans le même schéma.
  </para>

  <refsect2>
   <title>Types composites</title>

  <para>
   La première forme de <command>CREATE TYPE</command> crée un type composite. Le
   type composite est défini par une liste de noms d'attributs et de types de
   données. Pour l'essentiel, il est équivalent au type ligne
   (NDT&nbsp;: <foreignphrase>row type</foreignphrase> en anglais) d'une table,
   mais l'utilisation de <command>CREATE TYPE</command>
   permet d'éviter la création d'une table réelle quand seule la définition d'un type
   est voulue. Un type composite autonome est utile comme type d'argument ou de retour d'une
   fonction.
  </para>
  </refsect2>

  <refsect2>
   <title>Types de base</title>

  <para>
   La seconde forme de <command>CREATE TYPE</command> crée un nouveau type de base
   (type scalaire). L'ordre des paramètres, dont la plupart sont optionnels, n'a aucune
   d'importance. Avant de définir le type, il est nécessaire de définir au moins
   deux fonctions (à l'aide de la commande <command>CREATE FUNCTION</command>).
   Les fonctions de support <replaceable class="parameter">fonction_entrée</replaceable>
   et <replaceable class="parameter">fonction_sortie</replaceable> sont obligatoires. Les
   fonctions <replaceable class="parameter">fonction_réception</replaceable>,
   <replaceable class="parameter">fonction_envoi</replaceable> et
   <replaceable class="parameter">fonction_analyse</replaceable> sont
   optionnelles. Généralement, ces fonctions sont codées en C ou dans un
   autre langage de bas niveau.
  </para>

  <para>
   La <replaceable class="parameter">fonction_entrée</replaceable> convertit la
   représentation textuelle externe du type en représentation interne
   utilisée par les opérateurs et fonctions définis pour le type.
   La <replaceable class="parameter">fonction_sortie</replaceable> réalise la transformation
   inverse. La fonction entrée peut être déclarée avec un
   argument de type <type>cstring</type> ou trois arguments de
   types <type>cstring</type>, <type>oid</type>, <type>integer</type>. Le
   premier argument est le texte en entrée sous la forme d'une chaîne C, le second
   argument est l'OID du type (sauf dans le cas des types tableau où il
   s'agit de l'OID du type de l'élément) et le troisième est le <literal>typmod</literal>
   de la colonne destination, s'il est connu (-1 sinon). La fonction entrée
   doit renvoyer une valeur du nouveau type de données. La fonction sortie
   doit prendre un argument du nouveau type de données, et retourner le type <type>cstring</type>.
  </para>

  <para>
   La <replaceable class="parameter">fonction_réception</replaceable>,
   optionnelle, convertit la représentation binaire externe du type en
   représentation interne.
   <!-- participate in binary input -->
   Si cette fonction n'est pas fournie, le type n'accepte pas
   d'entrée binaire. La représentation binaire est choisie de telle sorte
   que sa conversion en forme interne soit peu coûteuse, tout en restant
   portable. (Par exemple, les types de données
   standard entiers utilisent l'ordre réseau des octets comme représentation
   binaire externe alors que la représentation interne est dans l'ordre natif
   des octets de la machine.) La fonction de réception réalise les
   vérifications adéquates pour s'assurer que la valeur est valide. Elle
   peut être déclarée avec un argument de type
   <type>internal</type> ou trois arguments de types
   <type>internal</type>, <type>integer</type> et <type>oid</type>. Le premier
   argument est un pointeur vers un tampon <type>StringInfo</type>
   qui contient la chaîne d'octets reçue&nbsp;; les arguments optionnels sont les
   mêmes que pour la fonction entrée de type texte. La fonction de réception
   retourne une valeur du type de données. De façon similaire, la
   <replaceable class="parameter">fonction_envoi</replaceable>, optionnelle,
   convertit la représentation interne en représentation
   binaire externe. Si cette fonction n'est pas fournie, le type
   <!-- participate in binary output -->
   n'accepte pas de sortie binaire. La fonction d'envoi doit être déclarée
   avec un argument du nouveau type de données et retourner le type <type>bytea</type>.
  </para>

  <para>
   À ce niveau, la question est de savoir comment déclarer les fonctions
   d'entrée et de sortie avec des arguments et des résultats du nouveau type, alors
   même qu'il n'est pas encore créé. Pour cela, il faut créer la fonction d'entrée
   en premier, puis la fonction de sortie (et les fonctions binaires d'E/S si nécessaire)
   et enfin le type de données. <productname>PostgreSQL</productname> considère
   initialement le nom du nouveau type comme celui de retour de la fonction d'entrée.
   Il crée alors un type <quote>coquille</quote> (<foreignphrase>shell type</foreignphrase>),
   qui n'est qu'une entrée conteneur dans le catalogue système et lie la définition
   de la fonction d'entrée au type coquille. De la même façon, les autres fonctions
   sont liés au type coquille (qui maintenant existe). Enfin, <command>CREATE TYPE</command>
   remplace la coquille par une définition complète du type. Le nouveau type peut alors
   être utilisé.
  </para>

  <para>
   La <replaceable class="parameter">fonction_analyse</replaceable>, optionnelle,
   calcule des statistiques spécifiques au type de données pour les
   colonnes de ce type. Par défaut, <command>ANALYZE</command> tente de
   récupérer des statistiques à l'aide des opérateurs d'<quote>égalité</quote> et
   d'<quote>infériorité</quote> du type, s'il existe une classe d'opérateur B-tree
   par défaut pour le type. Ce comportement est inadapté aux types non-scalaires&nbsp;;
   il peut être surchargé à l'aide d'une fonction
   d'analyse personnalisée. La fonction d'analyse doit être déclarée avec
   un seul argument de type <type>internal</type> et un résultat de type
   <type>boolean</type>. L'API détaillée des fonctions d'analyses est présentée dans
   <filename>src/include/commands/vacuum.h</filename>.
  </para>

  <para>
   Alors que les détails de la représentation interne du nouveau type ne sont
   connus que des fonctions d'entrées/sorties et des fonctions utilisateurs
   d'interaction avec le type, plusieurs propriétés de
   la représentation interne doivent être déclarées à
   <productname>PostgreSQL</productname>. La première est
   <replaceable class="parameter">longueurinterne</replaceable>. Les types de
   données basiques peuvent être de longueur fixe (dans ce cas, 
   <replaceable class="parameter">longueurinterne</replaceable> est un entier positif)
   ou de longueur variable (indiquée par le positionnement de 
   <replaceable class="parameter">longueurinterne</replaceable> à
   <literal>VARIABLE</literal>&nbsp;; en interne, cela est représenté en initialisant
   <literal>typlen</literal> à -1). La représentation interne de tous les types de
   longueur variable doit commencer par un entier de quatre octets indiquant la
   longueur totale de cette valeur.
  </para>

  <para>
   Le drapeau optionnel <literal>PASSEDBYVALUE</literal> indique que les
   valeurs de ce type de données sont passées par valeur plutôt que par
   référence. Les types dont la
   représentation interne est plus grande que la taille du type
   <type>Datum</type> (quatre octets sur la plupart des machines, huit sur
   quelques-unes) ne doivent pas être passés par valeur.
  </para>

  <para>
   Le paramètre <replaceable class="parameter">alignement</replaceable>
   spécifie l'alignement de stockage requis pour le type de données. Les
   valeurs permises sont des alignements sur 1, 2, 4 ou 8 octets.
   Les types de longueurs variables ont un alignement d'au
   moins quatre octets car leur premier composant est nécessairement un <type>int4</type>.
  </para>

  <para>
   Le paramètre <replaceable class="parameter">stockage</replaceable> permet de
   choisir une stratégie de stockage pour les types de données de longueur
   variable. (Seul <literal>plain</literal> est autorisé pour les types de
   longueur fixe.) <literal>plain</literal> indique des données
   stockées en ligne et non compressées.
   Dans le cas d'<literal>extended</literal> le système essaie tout d'abord de
   compresser une valeur longue et déplace la valeur hors de
   la ligne de la table principale si elle est toujours trop longue.
   <literal>external</literal> permet à la valeur d'être déplacée hors de la
   table principale mais le système ne tente pas de la compresser.
   <literal>main</literal> autorise la compression mais ne déplace
   la valeur hors de la table principale qu'en dernier recours.
   (Ils seront déplacés s'il n'est pas possible de placer la ligne 
   dans la table principale, mais
   sont préférentiellement conservés dans la table principale, contrairement aux éléments
   <literal>extended</literal> et <literal>external</literal>.)
  </para>

  <para>
   Une valeur par défaut peut être spécifiée dans le cas où l'utilisateur
   souhaite que cette valeur soit différente de NULL pour les colonnes de ce type.
   La valeur par défaut est précisée à l'aide du mot clé
   <literal>DEFAULT</literal>. (Une telle valeur par défaut peut être surchargée
   par une clause <literal>DEFAULT</literal> explicite attachée à une colonne
   particulière.)
  </para>

  <para>
   Pour indiquer qu'un type est un tableau, le type des éléments du
   tableau est précisé par le mot clé <literal>ELEMENT</literal>. Par exemple, pour
   définir un tableau d'entiers de quatre octets (<type>int4</type>),
   <literal>ELEMENT = int4</literal> est utilisé. Plus de détails sur les types
   tableau apparaissent ci-dessous.
  </para>

  <para>
   Pour préciser le délimiteur de valeurs utilisé dans la
   représentation externe des tableaux de ce type,
   <replaceable class="parameter">délimiteur</replaceable> peut être positionné à un
   caractère particulier. Le délimiteur par défaut est la virgule
   (<literal>,</literal>). Le délimiteur est associé avec le type
   élément de tableau, pas avec le type tableau.
  </para>

  </refsect2>

  <refsect2>
   <title>Types tableau</title>

   <para>
    À chaque fois qu'un type de données utilisateur basique est
    créé, <productname>PostgreSQL</productname> crée automatiquement un type
    tableau associé dont le nom est celui du type précédé d'un
    tiret base (<literal>_</literal>). L'analyseur comprend cette convention de nommage et traduit
    les requêtes sur les colonnes de type <literal>foo[]</literal> en requêtes sur le
    type <literal>_foo</literal>. Le type tableau implicitement créé est de longueur
    variable et utilise les fonctions entrée et sortie intégrées
    <literal>array_in</literal> et <literal>array_out</literal>.
   </para>

   <para>
    Pourquoi existe-t-il une option
    <option>ELEMENT</option> si le système fabrique automatiquement le bon type
    tableau ? 
    La seule utilité d'<option>ELEMENT</option> est la création d'un type de longueur
    fixe représenté en interne par un tableau d'éléments identiques auxquels on souhaite 
    accéder directement par leurs indices (en plus de toute autre opération 
    effectuée sur le type dans sa globalité). Par exemple, le type
    <type>name</type> permet d'accéder ainsi à ses éléments constituants <type>char</type>.
    Un type <type>point</type> en deux dimensions peut autoriser
    l'accès aux deux nombres qui le constitue, 
    <literal>point[0]</literal> et <literal>point[1]</literal>. Cette
    fonctionnalité n'est possible qu'avec les types de longueur fixe dont la
    forme interne est strictement une séquence de champs de longueur fixée.
    Un type de longueur variable est accessible par ses indices
    si sa représentation interne 
    généralisée est celle utilisée par <literal>array_in</literal> et <literal>array_out</literal>.
    Pour des raisons historiques (c'est-à-dire pour de mauvaises raisons, mais
    il est trop tard pour changer) les indices des tableaux de types de longueur
    fixe commencent à zéro et non à un comme c'est le cas pour les tableaux de
    longueur variable.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
     Le nom (éventuellement qualifié du nom du schéma) du type à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_attribut</replaceable></term>
    <listitem>
     <para>
      Le nom d'un attribut (colonne) du type composite.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_données</replaceable></term>
    <listitem>
     <para>
      Le nom d'un type de données existant utilisé comme colonne du type
      composite.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_entrée</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      textuelle externe du type en forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_sortie</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      interne du type en forme textuelle externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_réception</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme binaire externe du type en
      forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_envoi</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      interne du type en forme binaire externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">analyze_function</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction d'analyses statistiques pour le type
      de données.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">longueurinterne</replaceable></term>
    <listitem>
     <para>
      Une constante numérique qui précise la longueur en octets de la
      représentation interne du nouveau type. Supposée variable par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alignement</replaceable></term>
    <listitem>
     <para>
      La spécification d'alignement du stockage du type de données. Peut être
      <literal>char</literal>, <literal>int2</literal>,
      <literal>int4</literal> ou <literal>double</literal>&nbsp;;
      <literal>int4</literal> par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">stockage</replaceable></term>
    <listitem>
     <para>
      La stratégie de stockage du type de données. Peut être <literal>plain</literal>,
      <literal>external</literal>,
      <literal>extended</literal> ou <literal>main</literal>&nbsp;;
      <literal>plain</literal> par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">défaut</replaceable></term>
    <listitem>
     <para>
      La valeur par défaut du type de données. Omise, elle est NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">élément</replaceable></term>
    <listitem>
     <para>
      Type des éléments du type tableau créé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">délimiteur</replaceable></term>
    <listitem>
     <para>
      Le caractère délimiteur des valeurs des tableaux de ce type.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="sql-createtype-notes">
  <title>Notes</title>

  <para>
   Les noms de types utilisateur ne peuvent pas
   commencer par un tiret bas (<literal>_</literal>). Ils ont au plus
   62 caractères (ou en général <symbol>NAMEDATALEN</symbol> - 2,
   et non <symbol>NAMEDATALEN</symbol> - 1 comme les
   autres noms). Les noms de types commençant par un tiret bas sont réservés
   aux noms internes des types tableau.
  </para>

  <para>
   Dans les versions de <productname>PostgreSQL</productname> antérieures à la
   7.3, la création d'un type coquille était habituellement évitée en remplaçant les
   références des fonctions au nom du type par le pseudotype <type>opaque</type>.
   Les arguments <type>cstring</type> et les résultats étaient également déclarés
   <type>opaque</type>. Pour supporter le chargement d'anciens
   fichiers de sauvegarde, <command>CREATE TYPE</command> accepte les fonctions
   déclarées avec le pseudotype <type>opaque</type> mais un message d'avertissement
   est affiché. La déclaration de la fonction est également modifiée pour utiliser les bons types.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer un type composite utilisé dans la définition d'une
   fonction&nbsp;:
<programlisting>CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;
</programlisting>
  </para>

  <para>
   Créer le type de données basique <type>box</type> utilisé dans
   la définition d'une table&nbsp;:
<programlisting>CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = ma_fonction_entree_box,
    OUTPUT = ma_fonction_sortie_box
);

CREATE TABLE myboxes (
    id integer,
    description box
);
</programlisting>
  </para>

  <para>
   Si la structure interne de <type>box</type> est un tableau de quatre
   éléments <type>float4</type>, on peut écrire
<programlisting>CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = ma_fonction_entree_box,
    OUTPUT = ma_fonction_sortie_box,
    ELEMENT = float4
);
</programlisting>
   ce qui permet d'accéder aux nombres composant la valeur d'une boîte par
   les indices. Le comportement du type n'est pas modifié.
  </para>

  <para>
   Créer un objet large utilisé dans la définition d'une table&nbsp;:
<programlisting>CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);
</programlisting>
  </para>

  <para>
   D'autres exemples, intégrant des fonctions utiles 
   d'entrée et de sortie, peuvent être consultés dans <xref linkend="xtypes"/>.
  </para>
 </refsect1>

 <refsect1 id="sql-createtype-compatibility">
  <title>Compatibilité</title>

  <para>
   La commande <command>CREATE TYPE</command> présentée ici est une extension
   <productname>PostgreSQL</productname>. L'instruction
   <command>CREATE TYPE</command> du standard <acronym>SQL</acronym>
   est, dans le détail, assez différente.
  </para>
 </refsect1>

 <refsect1 id="sql-createtype-see-also">
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createfunction" endterm="sql-createfunction-title"/></member>
   <member><xref linkend="sql-droptype" endterm="sql-droptype-title"/></member>
   <member><xref linkend="sql-altertype" endterm="sql-altertype-title"/></member>
  </simplelist>
 </refsect1>

</refentry>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
