<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/reindex.sgml,v 1.7.2.2 2005/07/11 22:19:22 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-REINDEX">
 <refmeta>
  <refentrytitle id="SQL-REINDEX-TITLE">REINDEX</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>REINDEX</refname>
  <refpurpose>reconstruit les index</refpurpose>
 </refnamediv>

 <indexterm zone="sql-reindex">
  <primary>REINDEX</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
REINDEX { DATABASE | TABLE | INDEX } <replaceable
class="PARAMETER">nom</replaceable> [ FORCE ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>REINDEX</command> reconstruit un index basé sur les données stockées
   dans la table, remplaçant l'ancienne copie de l'index. Il y a deux raisons
   principales pour utiliser <command>REINDEX</command>&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Un index a été corrompu et ne contient plus de données valides. Bien 
      qu'en théorie, ceci ne devrait jamais arriver, en pratique, les index
      peuvent se corrompre à cause de bogues dans le logiciel ou d'échecs
      matériels. <command>REINDEX</command> fournit une méthode de récupération.
     </para>
    </listitem>

    <listitem>
     <para>
      L'index en question contient beaucoup de pages d'index mortes qui ne sont
      pas réclamés. Ceci peut arriver avec des index B-tree dans
      <productname>PostgreSQL</productname> sous certains modèles d'accès.
      <command>REINDEX</command> fournit un moyen de réduire la consommation
      d'espace de l'index en écrivant une nouvelle version de l'index sans les
      pages mortes. Voir <xref linkend="routine-reindex"> pour plus
      d'informations.
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </refsect1>
  
 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><literal>DATABASE</literal></term>
    <listitem>
     <para>
      Recrée tous les index système d'une base de données spécifiée. Les index
      sur les tables utilisateur ne sont pas traités. De plus, les index sur
      les catalogues système partagés ne sont pas pris en compte sauf dans le
      mode autonome (voir ci-dessous).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TABLE</literal></term>
    <listitem>
     <para>
      Recrée tous les index d'une table spécifiée. Si la table a une seconde
      table <quote>TOAST</>, elle sera aussi réindexée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INDEX</literal></term>
    <listitem>
     <para>
      Recrée un index spécifié.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">nom</replaceable></term>
    <listitem>
     <para>
      Le nom de la base de données, table ou index spécifique à réindexer. Les
      noms de table et d'index pourraient être qualifiés du nom du schéma.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE</literal></term>
    <listitem>
     <para>
      Ceci est une option obsolète&nbsp;; elle est ignorée si elle est
      spécifiée.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Si vous suspectez une corruption d'un index sur une table utilisateur, vous
   pouvez simplement reconstruire cet index, ou tous les index de la table, en
   utilisant <command>REINDEX INDEX</command> ou <command>REINDEX
   TABLE</command>. Une autre approche pour gérer un index corrompu de table
   utilisateur est de simplement le supprimer et de le recréer. Ceci pourrait en
   fait être préférable si vous souhaitez maintenir un certain état
   d'opérations de base sur la table pendant ce temps. <command>REINDEX</>
   acquiert le verrou exclusif sur la table alors que <command>CREATE INDEX</>
   verrouille seulement l'écriture et non pas les lectures de la table.
  </para>

  <para>
   Les choses sont plus difficiles si vous avez besoin de récupérer de la
   corruption d'un index sur une table système. Dans ce cas, il est important
   pour le système de ne pas avoir utilisé lui-même un des index suspects. (En
   fait, dans ce type de scénario, vous pourriez trouver que les processus
   serveur s'arrêtent brutalement immédiatement au lancement, à cause du besoin
   des index corrompus.) Pour récupérer proprement, le serveur doit être lancé
   avec l'option <option>-P</option>, qui l'empêche d'utiliser les recherches de
   catalogues système.
  </para>

  <para>
   Une façon de faire ceci est d'arrêter le postmaster et de lancer le serveur
   <productname>PostgreSQL</productname> en mode autonome avec l'option
   <option>-P</option> placée sur la ligne de commande. Ensuite,
   <command>REINDEX DATABASE</>, <command>REINDEX TABLE</> ou <command>REINDEX
   INDEX</> peuvent être lancés suivant ce que vous souhaitez reconstruire. En
   cas de doute, utilisez <command>REINDEX DATABASE</> pour sélectionner la
   reconstruction de tous les index système dans la base de données. Enfin,
   quittez la session autonome du serveur et relancez le serveur habituel. Voir
   la page de référence de <xref linkend="app-postgres"> pour plus
   d'informations sur l'interaction avec l'interface du serveur autonome.
  </para>

  <para>
   Autrement, une session standard du serveur peut être lancée avec
   <option>-P</option> inclus dans les options de la ligne de commande. La
   méthode pour ce faire varie entre les clients mais dans tous les clients
   basés sur <application>libpq</>, il est possible de configurer la variable
   d'environnement <envar>PGOPTIONS</envar> à <literal>-P</> avant de lancer le
   client. Notez que, bien que cette méthode ne réclamait pas le verrouillage
   des autres clients, il pourrait être conseillé d'empêcher les autres
   utilisateurs, il pourrait toujours être conseillé d'empêcher les autres
   utilisateurs de se connecter à la base de données endommagée jusqu'à la fin
   des réparations.
  </para>

  <para>
   Si une corruption est suspectée dans les index de tout catalogue système
   partagée (<structname>pg_database</structname>,
   <structname>pg_group</structname> ou
   <structname>pg_shadow</structname>), alors un serveur autonome doit être
   utilisé pour le réparer. <command>REINDEX</> ne traitera pas les catalogues
   partagées dans le mode multiutilisateur.
  </para>

  <para>
   Pour tous les index sauf les catalogues système partagées,
   <command>REINDEX</> est protégé contre les arrêts brutaux et comprend les
   transactions. <command>REINDEX</> n'est pas protégé pour les index partagés,
   ce qui explique pourquoi ce cas est désactivé pendant les opérations
   normales. Si un échec survient lors de la réindexation d'un de ces catalogues
   dans le mode autonome, il ne sera pas possible de relancer le serveur
   régulier jusqu'à ce que le problème soit rectifié. (Le symptome typique d'un
   index partagé reconstruit partiellement est <quote>index n'est pas un
   btree</> errors.)
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 7.4, <command>REINDEX
   TABLE</> ne traitait pas automatiquement les tables TOAST et, du coup, elles
   devaient être réindexées par des commandes séparées. C'est toujours possible
   mais redondant.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Recrée les index sur la table <literal>ma_table</literal>&nbsp;:

<programlisting>
REINDEX TABLE ma_table;
</programlisting>
  </para>

  <para>
   Reconstruit un index simple&nbsp;:

<programlisting>
REINDEX INDEX my_index;
</programlisting>
  </para>

  <para>
   Reconstruit tous les index système d'une base de données particulière sans
   croire qu'elles sont déjà valides&nbsp;:

<programlisting>
$ <userinput>export PGOPTIONS="-P"</userinput>
$ <userinput>psql broken_db</userinput>
...
broken_db=> REINDEX DATABASE broken_db;
broken_db=> \q
</programlisting>
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas de commande <command>REINDEX</command> dans le standard SQL.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
