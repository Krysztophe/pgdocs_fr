<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/update.sgml,v 1.9 2005/04/22 06:38:58 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060228 pour la relecture -->
<!-- SAS 20060327 : tags -->
<!-- SAS 20060523 : Relecture après MAJ -->

<refentry id="sql-update">
 <refmeta>
  <refentrytitle id="sql-update-title">UPDATE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>UPDATE</refname>
  <refpurpose>mettre à jour les lignes d'une table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>UPDATE [ ONLY ] <replaceable class="parameter">table</replaceable> SET <replaceable class="parameter">colonne</replaceable> = { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...]
    [ FROM <replaceable class="parameter">liste_from</replaceable> ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-update">
   <primary>UPDATE</primary>
  </indexterm>


  <para>
   <command>UPDATE</command> modifie les valeurs des colonnes spécifiées pour
   toutes les lignes qui satisfont la condition. Seules les colonnes à
   modifier doivent être mentionnées dans la clause
   <literal>SET</literal>&nbsp;; les autres colonnes conservent leur
   valeur.
  </para>

  <para>
   Par défaut, <command>UPDATE</command> met à jour les lignes de la table
   spécifiée et toutes ses sous-tables. 
   Si seule la table mentionnée doit être mise à jour, la clause
   <literal>ONLY</literal> est utilisée.
  </para>

  <para>
   Il existe deux façons de modifier le contenu d'une table à partir d'informations
   contenues dans d'autres tables de la base de données&nbsp;: à l'aide de
   sous-requêtes ou en spécifiant des tables supplémentaires dans la clause
   <literal>FROM</literal>. Le contexte permet de décider de la technique la plus appropriée.
  </para>

  <para>
   L'utilisateur doit posséder la permission <literal>UPDATE</literal> sur la table pour
   la mettre à jour, ainsi que le droit <literal>SELECT</literal> sur toutes les
   tables dont les valeurs sont lues dans 
   <replaceable class="parameter">expression</replaceable> ou 
   <replaceable class="parameter">condition</replaceable>.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">table</replaceable></term>
    <listitem>
     <para>
      Le nom de la table à mettre à jour (éventuellement qualifié du nom du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne dans <replaceable class="parameter">table</replaceable>.
      Le nom de la colonne peut être qualifié avec un nom de sous-champ ou un
      indice de tableau, si nécessaire.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">expression</replaceable></term>
    <listitem>
     <para>
      Une expression à affecter à la colonne. L'expression peut utiliser
      les anciennes valeurs de cette colonne et d'autres colonnes de la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT</literal></term>
    <listitem>
     <para>
      Réinitialise la colonne à sa valeur par défaut (qui vaut NULL si aucune
      expression par défaut ne lui a été affectée).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">liste_from</replaceable></term>
    <listitem>
     <para>
      Une liste d'expressions de tables, qui permet aux colonnes des autres
      tables d'apparaître dans la condition <literal>WHERE</literal> et dans les
      expressions de mise à jour. Cela est similaire à la liste de tables
      pouvant être spécifiée dans <xref linkend="sql-from" endterm="sql-from-title"/> 
      d'une instruction <command>SELECT</command>.
      La table cible ne doit pas apparaître dans
      <replaceable>liste_from</replaceable>, sauf en cas d'auto-jointure
      (auquel cas elle doit apparaître avec un alias dans
      <replaceable>liste_from</replaceable>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
     <para>
      Une expression qui renvoie une valeur de type <type>boolean</type>.
      Seules les lignes pour lesquelles cette expression renvoie
      <literal>true</literal> sont mises à jour.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Sorties</title>

  <para>
   En cas de succès, une commande <command>UPDATE</command> renvoie un message
   de la forme
<screen>UPDATE <replaceable class="parameter">total</replaceable>
</screen>
   <replaceable class="parameter">total</replaceable> est le nombre de
   lignes mises à jour. S'il
   vaut 0, c'est qu'aucune ligne ne correspondait à <replaceable class="parameter">condition</replaceable> 
   (ce qui n'est pas considéré comme une erreur).
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Lorsqu'une clause <literal>FROM</literal> est précisée, la table cible est jointe
   aux tables mentionnées dans <replaceable>liste_from</replaceable>, et chaque
   ligne en sortie de la jointure représente une opération de mise à jour pour
   la table cible. Lors de l'utilisation de <literal>FROM</literal>, il faut s'assurer
   que la jointure produit au plus une ligne en sortie par
   ligne à modifier. En d'autres termes, une ligne cible ne doit pas être
   jointe à plus d'une ligne des autres tables. Le cas échéant, 
   seule une ligne de jointure est utilisée pour mettre à jour la
   ligne cible, mais il n'est pas possible de prédire laquelle.
  </para>

  <para>
   À cause de ce manque de déterminisme, il est plus sûr de ne référencer 
   les autres tables qu'à l'intérieur de sous-requêtes. Même si c'est plus 
   difficile à lire et souvent plus lent que l'utilisation d'une jointure.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Changer le mot <literal>Drame</literal> en <literal>Dramatique</literal> dans la colonne
   <structfield>genre</structfield> de la table <structname>films</structname>&nbsp;:

<programlisting>UPDATE films SET genre = 'Dramatique' WHERE genre = 'Drame';
</programlisting>
  </para>

  <para>
   Ajuster les entrées de température et réinitialiser la précipitation à sa
   valeur par défaut dans une ligne de la table
   <structname>temps</structname>&nbsp;:

<programlisting>UPDATE temps SET temp_basse = temp_basse+1, temp_haute = temp_basse+15, prcp = DEFAULT
  WHERE ville = 'San Francisco' AND date = '2005-07-03';
</programlisting>
  </para>

  <para>
   Incrémenter le total des ventes de la personne qui gère le compte d'Acme
   Corporation, à l'aide de la clause <literal>FROM</literal>&nbsp;:
<programlisting>UPDATE employes SET total_ventes = total_ventes + 1 FROM comptes
  WHERE compte.nom = 'Acme Corporation'
  AND employes.id = compte.vendeur;
</programlisting>
  </para>

  <para>
   Réaliser la même opération en utilisant une sous-requête dans la clause
   <literal>WHERE</literal>&nbsp;:
<programlisting>UPDATE employes SET total_ventes = total_ventes + 1 WHERE id =
  (SELECT vendeur FROM comptes WHERE nom = 'Acme Corporation');
</programlisting>
  </para>

  <para>
   Tenter d'insérer un nouvel élément dans le stock avec sa quantité. Si
   l'élément existe déjà, mettre à jour le total du stock de l'élément.
   Les points de sauvegarde sont utilisés pour ne pas avoir à annuler
   l'intégralité de la transaction en cas d'erreur.
   <programlisting>BEGIN;
-- autres opérations
SAVEPOINT sp1;
INSERT INTO vins VALUES('Chateau Lafite 2003', '24');
-- A supposer que l'instruction ci-dessus échoue du fait d'une violation de clé
-- unique, les commandes suivantes sont exécutées :
ROLLBACK TO sp1;
UPDATE vins SET stock = stock + 24 WHERE nomvin = 'Chateau Lafite 2003';
-- continuer avec les autres opérations, et finir
COMMIT;
 </programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Cette commande est conforme au standard <acronym>SQL</acronym>, à
   l'exception de la clause <literal>FROM</literal> qui est une extension
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   D'autres systèmes de bases de données offrent une option
   <literal>FROM</literal> dans laquelle la table cible est supposée être à nouveau
   indiquée dans le <literal>FROM</literal>. 
   <productname>PostgreSQL</productname> n'interprète pas la clause <literal>FROM</literal>
   ainsi. Il est important d'en tenir compte lors du portage d'applications qui
   utilisent cette extension.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
