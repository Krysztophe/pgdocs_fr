<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/regress.sgml,v 1.4.2.4 2005/09/13 20:13:13 guillaume Exp $ -->

 <chapter id="regress">
  <title id="regress-title">Tests de régression</title>

  <indexterm zone="regress">
   <primary>tests de régression</primary>
  </indexterm>

  <indexterm zone="regress">
   <primary>test</primary>
  </indexterm>

  <para>
   Les tests de régression composent un ensemble exhaustif de tests de
   l'implémentation du SQL au sein de <productname>PostgreSQL</productname>.
   Ils permettent de tester les opérations SQL standard ainsi que les
   fonctionnalités étendues de <productname>PostgreSQL</productname>.
   Depuis <productname>PostgreSQL</productname> 6.1,
   les tests de régression sont actualisés pour chaque version officielle.
  </para>

  <sect1 id="regress-run">
   <title>Lancer les tests</title>

  <para>
   Les tests de régression peuvent être lancés sur un serveur déjà installé et
   fonctionnel ou en utilisant une installation temporaire à l'intérieur du
   répertoire de construction. De plus, ils peuvent être lancés en mode
   <quote>parallèle</quote> ou en mode <quote>séquentiel</quote>. Le mode
   séquentiel lance les scripts de test en série, tandis que le mode
   parallèle lance plusieurs processus serveurs pour parallèliser l'exécution des
   groupes de tests. Les tests parallèles permettent de s'assurer du
   bon fonctionnement des communications interprocessus et du verrouillage.
   Pour des raisons historiques, les tests séquentiels sont habituellement lancés
   sur une installation existante et la méthode parallèle préférentiellement
   sur une installation temporaire, mais il n'y a aucune raison technique à cela.
  </para>

  <para>
   Pour lancer les tests de régression après la construction mais avant l'installation,
   il suffit de saisir
<screen>
gmake check
</screen>
   dans le répertoire de premier niveau (on peut aussi se placer dans le répertoire
   <filename>src/test/regress</filename> et y lancer la commande). En premier lieu
   seront construits différents fichiers auxiliaires, tels des exemples de
   fonctions de déclencheurs utilisateur, puis le script de pilotage des tests
   sera exécuté. Au final, la sortie devrait ressembler à quelque chose comme
<screen>
<computeroutput>
======================
 All 93 tests passed.
======================
</computeroutput>
</screen>
   ou une note indiquant l'échec des tests.  Voir <xref
   linkend="regress-evaluation"> ci-dessous pour plus d'informations.
  </para>

   <para>
    Comme cette méthode de tests fonctionne sur un serveur temporaire, le
    superutilisateur, root, ne pourra les lancer. Si la construction a été initiée
    par un uilisateur root, il suffit de rendre le répertoire contenant les tests
    de régression modifiable par un autre utilisateur. Les tests seront alors lancés
    par cet utilisateur. Par exemple
<screen>
<prompt>root# </prompt><userinput>chmod -R a+w src/test/regress</userinput>
<prompt>root# </prompt><userinput>chmod -R a+w contrib/spi</userinput>
<prompt>root# </prompt><userinput>su - joeuser</userinput>
<prompt>joeuser$ </prompt><userinput>cd <replaceable>répertoire_construction_premier_niveau</></userinput>
<prompt>joeuser$ </prompt><userinput>gmake check</userinput>
</screen>
    (La seule <quote>faille de sécurité</quote> potentielle à ce niveau est une
    modification insidieuse des résultats des tests de régression par d'autres utilisateurs.
    Le bon sens guidera la gestion des droits des utilisateurs.)
   </para>
   <para>
    L'autre possibilité consiste à lancer les tests après l'installation.
   </para>

   <para>
    Les tests de régression parallèles lancent plusieurs processus par utilisateur.
    Actuellement, le nombre maximum est de vingt scripts de tests en parallèle,
    soit 60 processus&nbsp;: il y a un processus serveur, un <application>psql</>
    et habituellement un processus parent pour le <application>psql</> de chaque
    script de tests. Si le
    système impose une limite par utilisateur sur le nombre de processus,
    il faudra s'assurer que cette limite est d'au moins 75, sans quoi pourraient
    apparaître des échecs apparemment aléatoires. Si cette limite ne peut être
    modifiée, le degré de parallélisme pourra être réduit en
    initialisant le paramètre <literal>MAX_CONNECTIONS</>. Par exemple,
<screen>
gmake MAX_CONNECTIONS=10 check
</screen>
    ne lancera pas plus de dix tests simultanés.
   </para>

   <para>
    Sur certains systèmes, le shell compatible Bourne installé par défaut
    (<filename>/bin/sh</filename>) a du mal à gérer de nombreux processus fils
    en parallèle. Cela peut engendrer des blocages ou des échecs lors des
    tests en parallèle. Dans ce cas, il suffira de spécifier en ligne de commande
    un shell compatible Bourne différent. On peut, par exemple, écrire&nbsp;:
<screen>
gmake SHELL=/bin/ksh check
</screen>
    Si aucun shell satisfaisant n'est disponible, le problème sera contourné
    par la diminution du nombre de connexions comme indiqué ci-dessus.
   </para>

  <para>
   Le lancement des tests après installation<![%standalone-ignore;[ (voir <xref
   linkend="installation">)]]>se fait en trois étapes, l'initialisation d'un espace
   de données, le lancement du serveur <![%standalone-ignore;[comme expliqué dans <xref
   linkend="runtime">,]]> et le lancement des tests&nbsp;:
<screen>
gmake installcheck
</screen>
   Les tests tenteront de contacter le serveur sur l'hôte local avec le
   numéro de port par défaut. Pour modifier le comportement par défaut, il
   suffira de renseigner les variables d'environnement <envar>PGHOST</envar> et
   <envar>PGPORT</envar>.
  </para>
  </sect1>

  <sect1 id="regress-evaluation">
   <title>Évaluation des tests</title> 

   <para>
    Il arrive parfois qu'une instance de <productname>PostgreSQL</productname>,
    correctement installée et entièrement fonctionnelle, puisse
    <quote>échouer</quote> à certains tests de régression, du fait de
    spécificités de la plateforme. Ces spécificités peuvent, par exemple, être
    la représentation des nombres à virgules flottantes ou le support des fuseaux
    horaires. Les tests sont, à ce jour, évalués en utilisant une simple comparaison
    <command>diff</command> avec les sorties engendrées sur un système de
    référence. Les résultats sont donc sensibles à de petites différences
    système. Lorsqu'un test est annoncé <quote>échoué</quote>, il faudra
    examiner les différences entre les résultats attendus et obtenus&nbsp;; il est
    probable que les différences ne soient pas significatives.
    Néanmoins, tout est fait pour maintenir des fichiers de références précises
    et actualisées pour toutes les plateformes supportées avec un soucis constant
    de réussite des tests.
   </para>

   <para>
    Les sorties actuelles des tests de régression sont stockées dans les fichiers du
    répertoire <filename>src/test/regress/results</filename>. Chaque fichier de
    sortie est comparé (<command>diff</command>) aux sorties de référence stockées
    dans le répertoire <filename>src/test/regress/expected</filename>. Les
    différences sont stockées dans le fichier
    <filename>src/test/regress/regression.diffs</filename>.
    La <command>diff</command> peut également être lancée par l'utilisateur.
   </para>

   <sect2>
    <title>Différences dans les messages d'erreurs</title>
      
    <para>
     Certains des tests de régression impliquent des valeurs en
     entrée intentionnellement invalides. Les messages d'erreur peuvent alors
     provenir, soit du code de <productname>PostgreSQL</productname>, soit des
     routines système de la plateforme hôte. Dans ce cas, les messages
     peuvent varier en fonction des plateformes mais ils doivent toujours refléter
     des informations similaires. Des différences dans les messages produiront
     l'<quote>échec</quote> du test de régression, qui pourra être validé après
     vérification.
    </para>
   </sect2>

   <sect2>
    <title>Différences au niveau des locales</title>

    <para>
     Si des tests sont initiés sur un serveur, déjà installé, initialisé avec
     une régionalisation des sous-tri différente de C, il peut y avoir des
     différences dues aux ordres de tris. La suite de tests de régression gère
     ce problème à l'aide de fichiers de résultats alternatifs tenant compte d'un
     grand nombre de locales. Par exemple, pour le test <literal>char</literal>,
     le fichier <filename>char.out</filename> attendu
     gère les locales <literal>C</> et <literal>POSIX</>, et le fichier
     <filename>char_1.out</filename> gère un grand nombre de locales différentes.
     Le pilote des tests de régression choisira automatiquement le meilleur fichier.
     (Les tests de régression ne détectent pas la pertinence des résultats
     pour la locale configurée. Ils récupèrent le fichier résultat qui fonctionne le mieux.)
    </para>

    <para>
     Si, pour une raison quelconque, les fichiers existants ne couvrent pas
     certaines locales, il est possible d'ajouter un nouveau fichier. Le schéma de
     nommage est <literal><replaceable>nom_test</>_<replaceable>chiffre</>.out</>.
     Le chiffre n'a aucune signification. Le pilote des tests de régression considère
     tous ces fichiers comme des résultats également valides de tests. Si les résultats
     de tests sont spécifiques à une plateforme, il faudra utiliser la technique
     décrite dans <xref linkend="regress-platform">.
    </para>
   </sect2>
    
   <sect2>
    <title>Différences au niveau de la date et de l'heure</title>

    <para>
     Quelques requêtes des tests d'<filename>horologie</filename> échoueront si
     ces tests sont réalisés un jour de changement d'heure ou le lendemain de ce
     jour. Ces requêtes s'attendent à ce que les intervalles entre minuit le jour
     précédent, minuit ce jour et minuit le lendemain soient exactement de 24 heures -- ce qui
     n'est plus le cas lors d'un changement d'heure.
    </para>

    <note>
     <para>
      Comme ce sont les règles de changement d'heure en vigueur aux USA qui sont
      utilisées, ce problème survient toujours le premier dimanche d'avril, le
      dernier dimanche d'octobre et les lundis suivants quelque soit le jour où
      intervient le changement d'heure dans le pays où les tests sont lancés.
      Le problème apparaît et disparaît à minuit heure du Pacifique, UTC-7 ou UTC-8,
      pas à minuit heure locale. Il se peut que l'échec survienne plus
      tard le dimanche ou persiste jusqu'au mardi en fonction du lieu de test.
     </para>
    </note>

    <para>
     La plupart des résultats date/heure dépendent du fuseau horaire. Les
     fichiers de référence sont engendrés pour le fuseau horaire
     <literal>PST8PDT</literal> (Berkeley, Californie). Des échecs peuvent se
     produire si les tests ne sont pas lancés avec ce paramétrage du
     fuseau horaire. Le pilote des tests de régression initialise la variable
     d'environnement <envar>PGTZ</envar> à <literal>PST8PDT</literal>, ce qui
     assure normalement des résultats cohérents. Néanmoins, le système
     d'exploitation doit fournir un support du fuseau horaire
     <literal>PST8PDT</literal>, sinon les tests dépendant du fuseau horaire
     échoueront. Pour vérifier que la machine dispose de ce support,
     on saisira&nbsp;:
<screen>
env TZ=PST8PDT date
</screen>
     La commande ci-dessus devrait renvoyer l'heure système actuelle dans le
     fuseau horaire <literal>PST8PDT</literal>. Si le fuseau horaire
     <literal>PST8PDT</literal> n'est pas disponible, il se peut que le système
     retourne l'heure en UTC. Si le fuseau horaire <literal>PST8PDT</literal> est
     manquant, les règles de fuseau horaire peuvent être spécifiées explicitement&nbsp;:
<programlisting>
PGTZ='PST8PDT7,M04.01.0,M10.05.03'; export PGTZ
</programlisting>
    </para>

    <para>
     Certains systèmes n'acceptent toutefois pas la syntaxe recommandée pour
     initialiser explicitement les règles du fuseau horaire local. Il sera peut-être
     nécessaire d'initialiser différement <envar>PGTZ</envar> sur de telles machines.
    </para>

    <para>
     Certains systèmes, enfin, utilisent d'anciennes bibliothèques de fuseaux horaires
     et échouent lors de l'application des changements d'heure sur les dates
     antérieures à 1970. Les heures <acronym>PDT</acronym> pré-1970 sont alors
     affichées en <acronym>PST</acronym>. Cela produira des différences
     localisées dans les résultats des tests.
    </para>
   </sect2>
    
   <sect2>
    <title>Différences sur les nombres à virgules flottantes</title>
      
    <para>
     Quelques tests impliquent des calculs sur des nombres flottants à 64 bits
     (<type>double precision</type>) à partir de colonnes de tables. Des
     différences dans les résultats appliquant des fonctions mathématiques à des
     colonnes <type>double precision</type> ont été observées. Les tests de
     <literal>float8</> et <literal>geometry</> sont particulièrement sensibles
     aux différences entre plateformes, voire aux différentes options
     d'optimisation des compilateurs. L'&oelig;il humain
     est nécessaire pour déterminer la véritable signification de ces différences,
     habituellement situées après la dixième décimale.
    </para>

    <para>
     Certains systèmes affichent moins zéro comme <literal>-0</> alors que
     d'autres affichent seulement <literal>0</>.
    </para>

    <para>
     Certains systèmes signalent les erreurs des fonctions <function>pow()</function> et
     <function>exp()</function> différemment du mécanisme attendu par le
     code de <productname>PostgreSQL</productname>.
    </para>
   </sect2>

   <sect2>
    <title>Différences dans le tri des lignes</title>
      
    <para>
     Des différences peuvent apparaître entre l'ordre d'affichage des lignes
     et celui du fichier de référence. Dans la plupart des cas, il ne s'agit pas
     vraiment d'un bogue. La plupart des scripts de tests de régression ne sont pas assez
     stricts pour utiliser un <literal>ORDER BY</> sur chaque
     <literal>SELECT</>. De ce fait, l'ordre des lignes n'est pas forcément
     défini suivant la spécification SQL exacte. En pratique, les mêmes requêtes
     étant exécutées sur les mêmes données avec le même logiciel, le même tri des
     résultats est généralement obtenu sur toutes les plateformes et
     le manque d'<literal>ORDER BY</> ne pose pas de problème. Il se peut toutefois
     que quelques requêtes affichent des différences de tri entre plateformes.
     (Ces différences peuvent aussi être la conséquence d'une locale différente de C.)
    </para>

    <para>
     Ainsi, il n'y a pas lieu de s'inquiéter d'une différence de tri, sauf si la
     requête possède un <literal>ORDER BY</> que le résultat ne respecte pas.
     Il est alors intéressant de faire remonter cette information,
     afin qu'un <literal>ORDER BY</> soit ajouté à cette requête pour éliminer les faux
     <quote>échecs</quote> dans les versions suivantes.
    </para>

    <para>
     Si toutes les requêtes ne sont pas ordonnées, c'est simplement parce
     que cela rendrait les tests de régression moins utiles. En effet, ils
     tendraient à exercer des plans de requêtes produisant des résultats
     ordonnés excluant ainsi les autres types de plans.
    </para>
   </sect2>

   <sect2>
    <title>Test <quote>random</quote></title>

    <para>
     Il existe au moins un cas dans le script de tests de <literal>random</literal>
     qui a pour but de produire des résultats aléatoires. Ceci fait échouer random
     aux tests de régression une fois de temps en temps (peut-être une fois toutes
     les cinq à dix tentatives).
     Saisir
<programlisting>
diff results/random.out expected/random.out
</programlisting>
     ne devrait produire au plus que quelques lignes différentes. Cela est normal
     et ne devient préoccupant que si les tests random échouent en permanence lors
     de tests répétés. (De la même façon, il <emphasis>faudra</emphasis> se
     préoccuper d'un test random qui n'échouerait <emphasis>jamais</emphasis>.)
    </para>
   </sect2>
  </sect1>

<!-- We might want to move the following section into the developer's guide. -->
  <sect1 id="regress-platform">
   <title>Fichiers de comparaison spécifiques à la plateforme</title>

   <para>
    Il est inhérent au fonctionnement de certains tests de produire des résultats
    spécifiques à la plateforme. C'est pour cela qu'il est possible de fournir des
    fichiers de comparaison des résultats spécifiques à la plateforme. Il est
    fréquent que la même variation s'applique à plusieurs plateformes.
    Préférentiellement à la fourniture d'un fichier de comparaison pour chaque
    plateforme, un fichier de correspondance est fourni qui définit les fichiers
    de comparaison à utiliser. Ainsi, pour éliminer les <quote>échecs</quote> dûs
    à des tests bogués sur une plateforme particulière, il faudra choisir ou
    créer un fichier de résultats alternatif et ajouter une ligne dans le fichier
    de correspondance, à savoir <filename>src/test/regress/resultmap</filename>.
   </para>

   <para>
    Chaque ligne du fichier de correspondance est de la forme
<synopsis>
nomtest/modeleplateforme=fichiercomparaison
</synopsis>
    <filename>nomtest</filename> est le nom du module de tests de régression. Le
    modèle de plateforme est un modèle dans le style des outils Unix
    <command>expr</> (c'est-à-dire une expression rationnelle avec une
    ancre implicite <literal>^</literal> au début). Il est comparé au nom de
    plateforme affiché par <command>config.guess</command> suivi par
    <literal>:gcc</literal> ou <literal>:cc</literal>, selon qu'est utilisé un
    compilateur GNU ou le compilateur de base du système (sur les
    systèmes pour lesquels il y a une différence). <filename>fichiercomparaison</filename> est le
    nom du fichier de comparaison alternatif.
   </para>

   <para>
    Par exemple&nbsp;: certains systèmes utilisant les anciennes bibliothèques
    de fuseaux horaires échouent à appliquer les changements d'heure pour les dates
    antérieures à 1970. Ce faisant, les dates <acronym>PDT</acronym> pré-1970
    sont affichées en <acronym>PST</acronym>. Il en résulte un certain
    nombre de différences dans les tests de régression d'<filename>horologie</>.
    C'est pour cette raison qu'est fourni un fichier alternatif de comparaison,
    <filename>horology-no-DST-before-1970.out</filename>, qui inclut les
    résultats attendus sur certains systèmes. Pour faire taire les messages
    d'<quote>échec</quote> erronés sur les plateformes <systemitem>HPUX</systemitem>,
    <filename>resultmap</filename> contient
<programlisting>
horology/.*-hpux=horology-no-DST-before-1970
</programlisting>
    qui se déclenchera sur chaque machine pour laquelle la sortie de
    <command>config.guess</command> inclut <literal>-hpux</literal>.
    D'autres lignes de <filename>resultmap</> sélectionnent le fichier de
    comparaison alternatif d'autres plateformes lorsque celui-ci s'applique.
   </para>
    
  </sect1>
  
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
