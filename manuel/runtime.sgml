<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/runtime.sgml,v 1.9.2.7 2005/09/13 20:13:13 guillaume Exp $
-->

<Chapter Id="runtime">
 <Title>Environnement d'exécution du serveur</Title>

 <Para>
  Ce chapitre discute de la configuration, du lancement du serveur de bases de
  données et de ses interactions avec le système d'exploitation.
 </para>

 <sect1 id="postgres-user">
  <title>Compte utilisateur <productname>PostgreSQL</productname></title>

  <indexterm>
   <primary>utilisateur postgres</primary>
  </indexterm>

  <para>
   Comme avec tout autre démon serveur connecté au monde externe, il est
   conseillé de lancer <productname>PostgreSQL</productname> sous un compte
   utilisateur séparé. Ce compte devrait seulement être le propriétaire des
   données gérées par le serveur et ne devrait pas être partagé avec d'autres
   démons (par exemple, utiliser l'utilisateur <literal>nobody</literal> est
   une mauvaise idée). Il n'est pas conseillé de changer le propriétaire des
   exécutables par cet utilisateur car les systèmes compromis pourraient alors
   se voir modifier leur propres binaires.
  </para>

  <para>
   Pour ajouter un compte utilisateur Unix, jetez un &oelig;il à la commande
   <command>useradd</command> ou <command>adduser</command> de votre système.
   Le nom de l'utilisateur <systemitem>postgres</systemitem> est souvent utilisé
   mais ceci n'est pas requis.
  </para>
 </sect1>

 <sect1 id="creating-cluster">
  <title>Créer un groupe de base de données</title>

  <indexterm>
   <primary>groupe de bases de données</primary>
  </indexterm>

  <indexterm>
   <primary>emplacement des données</primary>
   <see>groupe de bases de données</see>
  </indexterm>

  <para>
   Avant de faire quoi que ce soit, vous devez initialiser un emplacement de
   stockage de la base de données. Nous appelons ceci un <firstterm>groupe de
   bases de données</firstterm>. (<acronym>SQL</acronym> utilise à la place 
   le terme de groupe de catalogues.) Un groupe de bases de données est une
   collection de bases données et est accessible par une seule instance d'un
   serveur de bases de données en cours d'exécution. Après initialisation, un
   groupe de bases de données contiendra une base de données nommée
   <literal>template1</literal>. Comme le nom le suggère, elle sera utilisée
   comme modèle pour les bases de données créées après&nbsp;; elle ne devrait
   pas être utilisée pour un vrai travail. (Voir <xref
   linkend="managing-databases"> pour des informations sur la création de bases
   de données.)
  </para>

  <para>
   En termes de système de fichiers, un groupe de bases de données sera un
simple répertoire sous lequel les données seront stockées. Nous l'appelons le
<firstterm>répertoire de données</firstterm> ou l'<firstterm>emplacement des
données</firstterm>. Le choix de cet emplacement vous appartient complètement.
Il n'existe pas de valeur par défaut bien que les emplacements tels que
<filename>/usr/local/pgsql/data</filename> ou
<filename>/var/lib/pgsql/data</filename> sont populaires. Pour initialiser un
groupe de bases de données, utilisez la commande
<command>initdb</command>,<indexterm><primary>initdb</></>, installée avec
<productname>PostgreSQL</productname>. L'emplacement désiré sur le système de
fichier est indiqué par l'option <option>-D</option>, par exemple
<screen>
<prompt>$</> <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
   Notez que vous devez exécuter cette commande en étant connecté sous le compte
   de l'utilisateur <productname>PostgreSQL</productname> décrit dans la section
   précédente.
  </para>

  <tip>
   <para>
    Comme alternative à l'option <option>-D</option>, vous pouvez initialiser
    la variable d'environnement <envar>PGDATA</envar>.
    <indexterm><primary><envar>PGDATA</envar></primary></indexterm>
   </para>
  </tip>

  <para>
   <command>initdb</command> tentera de créer le répertoire que vous avez
   spécifié si celui-ci n'existe pas déjà. Il est possible qu'il n'ait pas le
   droit de le faire (si vous avez suivi notre conseil et créé un compte sans
   droits). Dans ce cas, vous devez créer le répertoire vous-même (en tant que
   root) et modifier le propriétaire pour qu'il corresponde à l'utilisateur
   <productname>PostgreSQL</productname>. Voici comment réaliser ceci&nbsp;:
<screen>
root# <userinput>mkdir /usr/local/pgsql/data</userinput>
root# <userinput>chown postgres /usr/local/pgsql/data</userinput>
root# <userinput>su postgres</userinput>
postgres$ <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
  </para>

  <para>
   <command>initdb</command> refusera de s'exécuter si le répertoire des données
   semble être déjà initialisé.</para>

  <para>
   Comme le répertoire des données contient toutes les données stockées par 
   le système de bases de données, il est essentiel qu'il soit sécurisé par
   rapport à des accès non autorisés. Du coup, <command>initdb</command>
   supprimera les droits d'accès à tout le monde sauf l'utilisateur
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   Néanmoins, bien que le contenu du répertoire soit sécurisé, la configuration
   d'authentification du client par défaut permet à tout utilisateur local de se
   connecter à la base de données et même à devenir le super-utilisateur de
   la base de données. Si vous ne faites pas confiance aux utilisateurs
   locaux, nous vous recommandons d'utiliser l'option <option>-W</option> ou
   <option>--pwprompt</option> de la commande <command>initdb</command> pour
   affecter un mot de passe au super-utilisateur de la base de
   données.<indexterm><primary>mot de passe</><secondary>du
   super-utilisateur</></indexterm> Après <command>initdb</command>, modifiez le
   fichier <filename>pg_hba.conf</filename> pour qu'il utilise <literal>md5</>
   ou <literal>password</> à la place de l'authentification <literal>trust</>
   <emphasis>avant</> de lancer le serveur la première fois. (D'autres
   approches incluent l'utilisation de l'authentification
   <literal>ident</literal> ou les droits du système de fichiers pour
   restreindre les connexions. Voir <xref
   linkend="client-authentication"> pour plus d'informations.)
  </para>

  <para>
   <command>initdb</command> initialise aussi la
   locale<indexterm><primary>locale</></> par défaut du groupe de bases de
   données. Normalement, elle prends seulement le paramétrage local dans
   l'environnement et l'applique à la base de données initialisée. Il est
   possible de spécifier une locale différente pour la base de données&nbsp;;
   la <xref linkend="locale"> propose plus d'informations là-dessus.
   L'ordre de tri utilisé à l'intérieur du groupe de bases de données est
   initialisé par <command>initdb</command> et ne peut pas être modifié après,
   en dehors de la sauvegarde des données, du redémarrage de
   <command>initdb</command> et du rechargement des données. Donc, il est
   important de faire le bon choix la première fois.
  </para>
 </sect1>

 <sect1 id="postmaster-start">
  <title>Lancer le serveur de bases de données</title>

  <para>
   Avant qu'une personne ait accès à la base de données, vous devez démarrer le
serveur de bases de données. Le programme serveur est appelé
<command>postmaster</command>.<indexterm><primary>postmaster</></>. Le
<command>postmaster</command> doit savoir où trouver les données qu'il est
supposé utiliser. Ceci se fait avec l'option <option>-D</option>. Du coup, la
façon la plus simple de lancer le serveur est&nbsp;:
<screen>
$ <userinput>postmaster -D /usr/local/pgsql/data</userinput>
</screen>
   qui laissera le serveur s'exécuter en avant plan. Pour cela, vous devez être
   connecté en utilisant le compte de l'utilisateur
   <productname>PostgreSQL</productname>. Sans <option>-D</option>, le serveur
   essaiera d'utiliser le répertoire de données proposé par la variable
   d'environnement <envar>PGDATA</envar>. Si aucun des deux ne réussit, le
   lancement échouera.
  </para>

  <para>
   Pour lancer <command>postmaster</command> en tâche de fond, utilisez la
   syntaxe shell habituelle&nbsp;:
<screen>
$ <userinput>postmaster -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;</userinput>
</screen>
   Il est important de sauvegarder les sorties <systemitem>stdout</> et
   <systemitem>stderr</> du serveur quelque part, comme montré ci-dessus. Cela
   vous aidera dans des buts d'audits ou pour diagnostiquer des problèmes. (Voir
   <xref linkend="logfile-maintenance"> pour une discussion plus détaillée de
   la gestion de journaux de trace.)
  </para>

  <para>
   Le <command>postmaster</command> prend aussi un certain nombre d'autres
   options en ligne de commande. Pour plus d'informations, voir la page de
   référence ainsi que <xref linkend="runtime-config"> ci-dessous. En
   particuler, pour que le serveur accepte des connexions
   TCP/IP<indexterm><primary>TCP/IP</primary></indexterm> (plutôt que de simples
   sockets de domaine Unix), vous devez ajouter l'option <option>-i</option>.
  </para>

  <para>
   Cette syntaxe shell peut rapidement devenir ennuyante. Donc, un emballage en
   script shell
   <command>pg_ctl</command><indexterm><primary>pg_ctl</primary></indexterm>
   est fourni pour simplifier certaines tâches. Par exemple&nbsp;:
<programlisting>
pg_ctl start -l journaux_trace
</programlisting>
   lancera le serveur en tâche de fond et placera les sorties dans le journal 
   de trace indiqué. L'option <option>-D</option> a la même signification ici
   qu'avec <command>postmaster</command>. <command>pg_ctl</command> est aussi
   capable d'arrêter le serveur.
  </para>

  <para>
   Normalement, vous lancerez le serveur de bases de données lors du
   démarrage de l'ordinateur.<indexterm><primary>démarrage</><secondary>au
   lancement du serveur</></> Les scripts de lancement automatique sont
   spécifiques au système d'exploitation. Certains sont distribués avec
   <productname>PostgreSQL</productname> dans le répertoire
   <filename>contrib/start-scripts</>. Ils pourraient nécessiter les
   droits de root.
  </para>

  <para>
   Différents systèmes ont différentes conventions pour lancer les démons au
   démarrage. La plupart des systèmes ont un fichier
   <filename>/etc/rc.local</filename> ou
   <filename>/etc/rc.d/rc.local</filename>. D'autres utilisent les répertoires
   <filename>rc.d</>. Quoi que vous fassiez, le serveur doit être exécuté par le
   compte utilisateur <productname>PostgreSQL</productname> <emphasis>et non pas
   par root</emphasis> ou tout autre utilisateur. Donc, vous devriez
   probablement former vos commandes en utilisant <literal>su -c '...' 
   postgres</literal>. Par exemple&nbsp;:
<programlisting>
su -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog' postgres
</programlisting>
  </para>

  <para>
   Voici quelques suggestions supplémentaires par système d'exploitation.
   (Toujours les replacer dans le bon répertoire d'installation et le bon nom de
   l'utilisateur.)

   <itemizedlist>
    <listitem>
     <para>
      Pour <productname>FreeBSD</productname>, regardez le fichier
      <filename>contrib/start-scripts/freebsd</filename> du répertoire des
      sources de <productname>PostgreSQL</productname>.
      <indexterm><primary>FreeBSD</><secondary>script de
      lancement</secondary></>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>OpenBSD</productname>, ajoutez les lignes suivantes à
      votre fichier <filename>/etc/rc.local</filename>&nbsp;:
      <indexterm><primary>OpenBSD</><secondary>script de
      lancement</secondary></>
<programlisting>
if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postmaster ]; then
    su - -c '/usr/local/pgsql/bin/pg_ctl start -l /var/postgresql/log -s' postgres
    echo -n ' postgresql'
fi
</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur les systèmes <productname>Linux</productname>, soit vous ajoutez
      <indexterm><primary>Linux</><secondary>script de lancement</secondary></>
<programlisting>
/usr/local/pgsql/bin/pg_ctl start -l journaux_trace -D /usr/local/pgsql/data
</programlisting>
      à <filename>/etc/rc.d/rc.local</filename> soit vous jetez un &oelig;il à
      <filename>contrib/start-scripts/linux</filename> dans le répertoire des
      sources de <productname>PostgreSQL</productname>.
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>NetBSD</productname>, vous pouvez utiliser les scripts
      de lancement de <productname>FreeBSD</productname> ou de
      <productname>Linux</productname> suivant vos préférences.
      <indexterm><primary>NetBSD</><secondary>script de lancement</secondary></>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>Solaris</productname>, créez un fichier appelé
      <filename>/etc/init.d/postgresql</filename> et contenant la ligne
      suivante&nbsp;:
      <indexterm><primary>Solaris</><secondary>script de
      lancement</secondary></>
<programlisting>
su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l journaux_trace -D /usr/local/pgsql/data"
</programlisting>
      Puis, créez un lien symbolique vers lui dans <filename>/etc/rc3.d</> de
      nom <filename>S99postgresql</>.
     </para>
    </listitem>
   </itemizedlist>

  </para>

   <para>
    Tant que <command>postmaster</command> est lancé, son
    <acronym>PID</acronym> est stocké dans le fichier
    <filename>postmaster.pid</filename> du répertoire de données. C'est utilisé
    pour empêcher les nombreux processus <command>postmaster</command> d'être
    exécuté dans le même répertoire de données et peut aussi être utilisé pour
    arrêter le processus <command>postmaster</command>.
   </para>

   <sect2 id="postmaster-start-failures">
    <title>Échecs de lancement</title>

    <para>
     Il existe de nombreuses raisons habituelles pour lesquelles le serveur
     échouerait au lancement. Vérifiez le journal des traces du serveur ou
     lancez-le manuellement (sans redirection des sorties standard et d'erreur)
     et regardez les messages d'erreurs qui apparaissent. Nous en expliquons
     certains ci-dessous parmi les messages d'erreurs les plus communs.
    </para>

    <para>
<screen>
LOG:  could not bind IPv4 socket: Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket
</screen>
     Ceci signifie seulement ce que cela suggère&nbsp;: vous avez essayé de lancer
     un autre <command>postmaster</command> sur le même port où un autre est en 
     cours d'exécution. Néanmoins, si le message d'erreur du noyau 
     n'est pas <computeroutput>Address already in use</computeroutput> ou une
     quelconque variante, il pourrait y avoir un autre problème. Par
     exemple, essayer de lancer un <command>postmaster</command> sur un numéro
     de port réservé pourrait avoir ce résultat&nbsp;:
<screen>
$ <userinput>postmaster -i -p 666</userinput>
LOG:  could not bind IPv4 socket: Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket
</screen>
    </para>

    <para>
     Un message du type
<screen>
FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).
</screen>
     signifie probablement que les limites de votre noyau sur la taille de 
     la mémoire partagée est plus petite que l'aire de fonctionnement que
     <productname>PostgreSQL</productname> essaie de créer (4011376640 octets
     dans cet exemple). Ou il pourrait signifier que vous n'avez pas du tout
     configuré le support de la mémoire partagée de type System-V dans votre
     noyau. Comme contournement temporaire, vous pouvez essayer de lancer le
     serveur avec un nombre de tampons plus petit que la normale (option
     <option>-B</option>). Vous voudrez éventuellement reconfigurer votre noyau
     pour accroître la taille de mémoire partagée autorisée. Vous pourriez voir
     aussi ce message en essayant de lancer plusieurs serveurs sur la même
     machine si le total de l'espace qu'ils requièrent dépasse la limite du
     noyau.
    </para>

    <para>
     Une erreur du type
<screen>
FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).
</screen>
     ne signifie <emphasis>pas</emphasis> qu'il vous manque de l'espace disque.
     Elle signifie que la limite de votre noyau sur le nombre de sémaphores
     <systemitem class="osname">System V</> est inférieur au nombre que
     <productname>PostgreSQL</productname> veut créer. Comme ci-dessus, vous
     pourriez contourner le problème en lançant le serveur avec un nombre
     réduit de connexions autorisées (option <option>-N</option>) mais vous
     voudrez éventuellement augmenter la limite du noyau.
    </para>

    <para>
     Si vous obtenez une erreur <quote>illegal system call</>, il est probable
     que la mémoire partagée ou les sémaphores ne sont pas du tout supportés par
     votre noyau. Dans ce cas, votre seule option est de reconfigurer le noyau
     pour activer ces fonctionnalités.
    </para>

    <para>
     Des détails sur la configuration des capacités <acronym>IPC</> <systemitem
     class="osname">System V</> sont donnés dans la <xref linkend="sysvipc">.
    </para>
   </sect2>

   <sect2 id="client-connection-problems">
    <title>Problèmes de connexion du client</title>

    <para>
     Bien que les conditions d'erreurs possibles du côté client sont assez
     variées et dépendantes de l'application, certaines pourraient être en
     relation direct avec la façon dont le serveur a été lancé. Les conditions
     autres que celles montrées ici devraient être documentées avec
     l'application client respective.
    </para>

    <para>
<screen>
psql: could not connect to server: Connection refused
        Is the server running on host "server.joe.com" and accepting
        TCP/IP connections on port 5432?
</screen>
     Ceci est l'échec générique <quote>Je n'ai pas trouvé de serveur à qui
     parler</quote>. Cela ressemble au message ci-dessus lorsqu'une connexion
     TCP/IP est tentée. Une erreur commune est d'oublier de configurer le
     serveur pour qu'il autorise les connexions TCP/IP.
    </para>

    <para>
     Autrement, vous obtiendrez ceci en essayant une communication de type
     socket de domaine Unix vers un serveur local&nbsp;:
<screen>
psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?
</screen>
    </para>

    <para>
     La dernière ligne est utile pour vérifier si le client essaie de se
     connecter au bon endroit. Si aucun serveur n'est exécuté ici, le
     message d'erreur du noyau sera typiquement soit <computeroutput>Connection
     refused</computeroutput> soit <computeroutput>No such file or
     directory</computeroutput>, comme ce qui est illustré (il est important de
     réaliser que <computeroutput>Connection refused</computeroutput>, dans ce
     contexte, ne signifie <emphasis>pas</emphasis> que le serveur a obtenu une
     demande de connexion et l'a refusé. Ce cas produira un message différent
     comme indiqué dans la <xref linkend="client-authentication-problems">).
     D'autres messages d'erreurs tel que <computeroutput>Connection timed
     out</computeroutput> pourraient indiquer des problèmes plus fondamentaux
     comme un manque de connexion réseau.
    </para>
   </sect2>
  </sect1>

  <sect1 id="runtime-config">
   <Title>Configuration à l'exécution</Title>

   <indexterm>
    <primary>configuration</primary>
    <secondary>du serveur</secondary>
   </indexterm>

   <para>
    Il existe un grand nombre de paramètres de configuration affectant le
    comportement du système de bases de données. Dans cette sous-section, nous
    décrivons comment configurer ces paramètres&nbsp;; les sections suivantes
    discutent de chaque paramètre en détail.
   </para>

   <para>
    Tous les noms de paramètres ne sont pas sensibles à la casse. Chaque
    paramètre prend une valeur d'un des ces quatre types&nbsp;: booléen, entier,
    nombre à virgule flottante et chaîne de caractères. Les valeurs booléennes
    peuvent valoir <literal>ON</literal>, <literal>OFF</literal>,
    <literal>TRUE</literal>, <literal>FALSE</literal>, <literal>YES</literal>,
    <literal>NO</literal>, <literal>1</literal>, <literal>0</literal>
    (quelque soit la casse) ou tout préfixe non ambigu de ceux-ci.
   </para>

   <para>
    Une façon d'initialiser ces paramètres est d'éditer le fichier
<filename>postgresql.conf</filename><indexterm><primary>postgresql.conf</></>
    du répertoire data. (Un fichier par défaut y est installé.) Un exemple de
    ce que ce fichier peut contenir pourrait ressembler à ceci&nbsp;:
<programlisting>
# Ceci est un commentaire
log_connections = yes
syslog = 2
search_path = '$user, public'
</programlisting>
    Un paramètre est spécifié par ligne. Le signe égal entre le nom et la
    valeur est optionnel. Les espaces blancs n'ont pas de signification et les
    lignes blanches sont ignorées. Les marques de hachage (<literal>#</literal>)
    introduisent des commentaires partout. Les valeurs des paramètres qui ne
    sont pas des identifiants simples ou des nombres devraient être entre des
    guillemets simples.
   </para>

   <para>
    <indexterm>
     <primary>SIGHUP</primary>
    </indexterm>
    Le fichier de configuration est relu à chaque fois que le processus
    <command>postmaster</command> reçoit un signal <systemitem>SIGHUP</> 
    (qui est envoyé par un simple appel à <literal>pg_ctl reload</>). Le
    <command>postmaster</command> propage aussi ce signal aux processus serveur
    en cours d'exécution de façon à ce que les sessions existantes
    obtiennent aussi la nouvelle valeur. Autrement, vous pouvez envoyer le
    signal directement à un seul processus serveur.
   </para>

   <para>
    Une autre façon de configurer ces paramètres est de les donner en option sur
    la ligne de commande de <command>postmaster</command> ainsi&nbsp;:
<programlisting>
postmaster -c log_connections=yes -c syslog=2
</programlisting>
    Les options de la ligne de commande surchargent tout paramétrage en
    conflit dans <filename>postgresql.conf</filename>.
   </para>

   <para>
    Occasionnellement, il est aussi utile de donner une option en ligne de
    commande à une session particulière seulement. La variable d'environnement
    <envar>PGOPTIONS</envar> peut être utilisée dans ce but du côté
    client&nbsp;:
<programlisting>
env PGOPTIONS='-c geqo=off' psql
</programlisting>
    (Ceci fonctionne pour toute application client
    basée sur <application>libpq</>, et non pas seulement pour
    <application>psql</application>.) Notez que ceci ne fonctionnera pas pour
    les paramètres fixes lorsque le serveur est lancé (par exemple pour le
    numéro de port).
   </para>

   <para>
    De plus, il est possible d'affecter un ensemble de paramètres à un
    utilisateur d'une base de données. Quand une session est lancée, les
    paramétrages par défaut de l'utilisateur et de la base de données
    impliqués sont chargés. Les commandes <command>ALTER DATABASE</command> et
    <command>ALTER USER</command>, respectivement, sont utilisées pour
    configurer ces paramétrages. Les paramètres par base de données surcharge
    tous ceux reçus de la ligne de commande de <command>postmaster</command> ou
    du fichier de configuration, et sont aussi surchargés par ceux de
    l'utilisateur&nbsp;; les deux sont surchargés par les options par session.
   </para>

   <para>
    Quelques paramètres peuvent être changés dans des sessions
    <acronym>SQL</acronym> individuelles avec la commande <xref
    linkend="SQL-SET" endterm="SQL-SET-title">, par exemple&nbsp;:
<screen>
SET ENABLE_SEQSCAN TO OFF;
</screen>
    Si <command>SET</> est autorisé, il surcharge toutes les autres sources de
    valeurs pour le paramètre. Les superutilisateurs sont autorisés à
    utiliser <command>SET</> avec plus de paramètres que les utilisateurs
    ordinaires.
   </para>

   <para>
    La commande <xref linkend="SQL-SHOW" endterm="SQL-SHOW-title"> permet une
    inspection des valeurs actuelles de tous les paramètres.
   </para>

   <para>
    La table virtuelle <structname>pg_settings</structname> (décrite dans la <xref
    linkend="view-pg-settings">) autorise aussi l'affichage et la mise à jour de
    paramètres de session à l'exécution. Elle est équivalente à <command>SHOW</>
    et <command>SET</> mais peut être plus agréable à utiliser parce qu'elle
    peut être jointe avec d'autres tables ou sélectionnée avec l'utilisation des
    conditions de sélection désirées.
   </para>
    
   <sect2 id="runtime-config-connection">
    <title>Connexions et authentification</title>

    <sect3 id="runtime-config-connection-settings">
     <title>Paramétrages de connexion</title>

     <variablelist>
     
     <varlistentry>
      <term><varname>tcpip_socket</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        S'il est vrai, alors le serveur acceptera des connexions
        TCP/IP.<indexterm><primary>TCP/IP</></> Sinon seules les connexions par
        socket de domaine Unix sont acceptées. Cette option est désactivée par
        défaut et ne peut être activée qu'au lancement du serveur.
       </para>
      </listitem>
     </varlistentry>
  
     <varlistentry>
      <term><varname>max_connections</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Détermine le nombre maximum de connexions concurrentes au serveur de la
        base de données. La valeur par défaut typique est 100 mais pourrait être
        bien moindre si vos paramétrages du noyau ne le supportent pas (ce qui est
        déterminé lors du <application>initdb</>). Ce paramètre peut seulement
        être initialisé au lancement du serveur.
       </para>

       <para>
        Augmenter ce paramètre pourrait faire que <productname>PostgreSQL</>
        réclame plus de mémoire partagée <systemitem class="osname">System V</>
        ou de sémaphores que ne le permet la configuration par défaut de votre système
        d'exploitation. Voir la <xref linkend="sysvipc"> pour plus
        d'informations sur la façon d'ajuster ces paramètres si nécessaire.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><varname>superuser_reserved_connections</varname>
      (<type>integer</type>)</term>
      <listitem>
       <para>
        Détermine le nombre d'<quote>emplacements de connexion</quote> réservés
        aux superutilisateurs <productname>PostgreSQL</>. Au plus
        <varname>max_connections</> connexions peuvent être activées
        simultanément. À chaque fois que le nombre de connexions concurrentes
        actives arrive au moins à <varname>max_connections</> moins
        <varname>superuser_reserved_connections</varname>, les nouvelles
        connexions ne seront acceptées que pour les superutilisateurs.
       </para>

       <para>
        La valeur par défaut est de 2. La valeur doit être plus petite que la
	valeur de <varname>max_connections</varname>. Ce paramètre peut seulement
        être configuré uniquement au lancement du serveur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>port</varname> (<type>integer</type>)</term>
      <indexterm><primary>port</></>
      <listitem>
       <para>
        Le port TCP où le serveur écoute&nbsp;; 5432 par défaut. Cette option
        est seulement initialisable au lancement du serveur.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><varname>unix_socket_directory</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Spécifie le répertoire de la socket de domaine Unix sur lequel le
        serveur attend les connexions des applications clientes. Par défaut, il
        s'agit de <filename>/tmp</filename> mais cela est modifiable à la
        construction.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>unix_socket_group</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Initialise le groupe propriétaire du socket de domaine Unix.
        (L'utilisateur propriétaire de la socket est toujours l'utilisateur qui
        lance le serveur.) En combinaison avec l'option
        <varname>unix_socket_permissions</varname>, ceci peut être utilisé comme
        un mécanisme de contrôle d'accès supplémentaire pour ce type de socket.
        Par défaut, la chaîne est vide et utilise le groupe par défaut de
        l'utilisateur. Cette option est configurable uniquement au lancement du
        serveur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>unix_socket_permissions</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Initialise les droits d'accès au socket de domaine Unix. Les sockets de
        domaine Unix utilisent l'ensemble habituel des droits du système de
        fichiers Unix. La valeur de l'option est attendue dans sa spécification
        en mode numérique, acceptée par les appels système
        <function>chmod</function> et <function>umask</function>. (Pour utiliser
        le format octal personnalisé, le nombre doit commencer avec un
        <literal>0</literal> (zéro).)
       </para>

       <para>
        Les droits par défaut sont <literal>0777</literal>, signifiant que tout
        le monde peut se connecter. Les alternatives raisonnables sont
        <literal>0770</literal> (seulement l'utilisateur et le groupe, voir
        aussi sous <varname>unix_socket_group</varname>) et
        <literal>0700</literal> (seulement l'utilisateur). (Notez que pour un
        socket de domaine Unix, seuls les droits d'écriture ont une
        signification et il n'y a aucune raison à ajouter ou supprimer les
        droits de lecture ou d'exécution.)
       </para>

       <para>
        Ce mécanisme de contrôle d'accès est indépendant de celui décrit dans
        <xref linkend="client-authentication">.
       </para>

       <para>
        Cette option est seulement configurable au lancement du serveur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>virtual_host</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Spécifie le nom d'hôte ou l'adresse IP sur lequel le serveur est en
        attente de connexions d'applications clients. Par défaut, il écoute sur
        toutes les adresses configurées (incluant <systemitem
        class="systemname">localhost</>).
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><varname>rendezvous_name</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Spécifie le nom de <quote>broadcast</quote> de RendezVous. Par défaut,
        le nom de l'ordinateur est utilisé, spécifié comme ''.
       </para>
      </listitem>
     </varlistentry>
     
     </variablelist>
     </sect3>
     <sect3 id="runtime-config-connection-security">
     <title>Sécurité et authentification</title>
     
     <variablelist>
     <varlistentry>
      <term><varname>authentication_timeout</varname> (<type>integer</type>)</term>
      <indexterm><primary>délai</><secondary>authentification
        client</></indexterm>
      <indexterm><primary>authentification client</><secondary>lors du
        délai</></indexterm>
      <listitem>
       <para>
        Temps maximum pour terminer l'authentification du client en
        secondes. Si un client n'a pas terminé le protocole d'authentification
        dans ce délai, le serveur rompt la connexion. Ceci protège le serveur
        des clients bloqués occupant une connexion indéfiniment. Cette option
        n'est configurable qu'au lancement du serveur ou dans le fichier
        <filename>postgresql.conf</filename>. La valeur par défaut est de 60
        secondes.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <indexterm>
       <primary>SSL</primary>
      </indexterm>

      <term><varname>ssl</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active les connexions <acronym>SSL</>. Merci de lire
        <xref linkend="ssl-tcp"> avant d'utiliser ceci. Désactivée par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>password_encryption</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Quand un mot de passe est spécifié dans <command>CREATE USER</> ou
        <command>ALTER USER</> sans écrire soit <literal>ENCRYPTED</> soit
        <literal>UNENCRYPTED</>, cette option détermine si le mot de passe doit
        être crypté. Activé par défaut (donc cryptage du mot de passe).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>krb_server_keyfile</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Initialise l'emplacement du fichier clé du serveur Kerberos. Voir
        <xref linkend="kerberos-auth"> pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>db_user_namespace</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Ceci autorise les noms d'utilisateur par base de données.
        Désactivé par défaut.
       </para>

       <para>
        Si cette option est activée, vous devrez créer des utilisateurs de nom
        <literal>nomutilisateur@nombase</>. Quand <literal>nomutilisateur</>
        est passé pour un client en cours de connexion, <literal>@</> et le nom
        de la base de données est ajouté au nom de l'utilisateur et ce nom
        d'utilisateur spécifique à la base de données est recherché dans le
        serveur. Notez que lorsque vous créez des utilisateurs dont le nom
        contient un <literal>@</> dans l'environnement SQL, vous devez mettre le
        nom entre guillemets.
       </para>

       <para>
        Cette option activée, vous pouvez toujours créer des utilisateurs
        globaux ordinaires. Ajoutez simplement <literal>@</> lors de la
        spécification du nom du client. Le <literal>@</> sera supprimé avant de
        chercher le nom de l'utilisateur dans le serveur.
       </para>

       <note>
        <para>
         Cette fonctionnalité est temporaire jusqu'à ce qu'une solution
        complète soit trouvée. Cette option sera supprimée.
        </para>
       </note>
      </listitem>
     </varlistentry>

    </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-resource">
    <title>Consomnation de ressources</title>

    <sect3 id="runtime-config-resource-memory">
     <title>Memoire</title>

     <variablelist>
     <varlistentry>
      <term><varname>shared_buffers</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Initialise le nombre de tampons en mémoire partagée utilisés par le
        serveur de bases de données. La valeur par défaut est de 1000 mais
        pourrait être moindre si la configuration de votre noyau ne le supporte
        pas (c'est déterminé lors de l'exécution d'<application>initdb</>).
        Chaque tampon fait 8192 octets sauf si une différente valeur de
        <literal>BLCKSZ</> a été choisie lors de la construction du serveur. Ce
        paramétrage doit valoir au moins 16, mais aussi au moins deux fois la
        valeur de <varname>max_connections</varname>&nbsp;; néanmoins, des
        valeurs significativement plus importantes que ce minimum sont
        généralement nécessaires pour de bonnes performances. Des valeurs de
        quelques milliers sont recommandées pour des installations de
        production. Cette option n'est initialisable qu'au lancement du serveur.
       </para>

       <para>
        Augmenter ce paramètre pourrait faire en sorte que
        <productname>PostgreSQL</> réclame plus de mémoire partagé <systemitem
        class="osname">System V</> que ce que la configuration par défaut de
        votre système d'exploitation ne peut gérer. Voir la <xref
        linkend="sysvipc"> pour plus d'informations sur l'ajustement de ces
        paramètres si nécessaire.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>sort_mem</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Spécifie la mémoire utilisée par les opérations internes de tri et par
les tables de hachage avant de basculer sur des fichiers temporaires sur
disque. La valeur est spécifiée en Ko et correspond par défaut à 1024&nbsp;Ko
(soit 1&nbsp;Mo). Notez que pour une requête complexes, plusieurs tris ou
opérations de hachage pourraient être lancés en parallèle&nbsp;; chacun sera
autorisé à utiliser autant de mémoires que cette valeur spécifie avant de
commener à placer les données dans des fichiers temporaires. De plus, plusieurs
sessions en cours d'exécution pourraient effectuer des opérations de tri en
même temps. Donc, la mémoire totale utilisée pourrait être de plusieurs fois la
valeur de <varname>sort_mem</varname>. Les opérations de tri sont utilisées
par <literal>ORDER BY</>, les jointures merge et <command>CREATE INDEX</>. Les
tables de hachage sont utilisées dans les jointures hachées, les agrégats à
base de hachage et les traitements de sous-requêtes <literal>IN</> basés sur
des hachages. Comme <command>CREATE INDEX</> est utilisé lors de la
restauration d'une base de données, augmenter <varname>sort_mem</varname> avant
de faire une grosse opération de restauration peut améliorer les performances.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><varname>vacuum_mem</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Spécifie la mémoire maximum utilisée par <command>VACUUM</command> pour
        garder trace des lignes à réclamer. La valeur est spécifiée en Ko et
        vaut par défaut 8192&nbsp;Ko. Une configuration plus importante pourrait
        améliorer la rapidité du vacuum sur les grosses tables qui ont beaucoup
        de lignes supprimées.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect3>
     <sect3 id="runtime-config-resource-fsm">
     <title>Carte de l'espace libre (<foreignphrase>Free Space
      Map</foreignphrase>)</title>

     <variablelist>
     <varlistentry>
      <term><varname>max_fsm_pages</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Initialise le nombre maximum de pages disque pour lesquelles les
        espaces libres sont tracés dans la carte partagée des espaces libres.
        Six octets de mémoire partagée sont consommés pour chaque emplacement de
        page. Ce paramétrage doit être supérieur à
	16&nbsp;*&nbsp;<varname>max_fsm_relations</varname>. Par défaut,
	il est à 20000. Cette
        option n'est configurable qu'au lancement du serveur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>max_fsm_relations</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Initialise le nombre maximum de relations (tables et index) pour
	lesquelles
        les espaces libres sont tracés dans la carte partagée de l'espace
        libre. En gros, 50 octets de mémoire partagée sont consommés par
        emplacement. La valeur par défaut est de 1000. Cette option n'est
        configurable qu'au lancement du serveur.
       </para>
      </listitem>
     </varlistentry>
     
     </variablelist>
     </sect3>
     <sect3 id="runtime-config-resource-kernel">
     <title>Utilisation des ressources du noyau</title>
     <variablelist>

     <varlistentry>
      <term><varname>max_files_per_process</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Initialise le nombre maximum de fichiers ouverts simultanément permis
        pour chaque sous-processus serveur. La valeur par défaut est de 1000.
	Si le noyau force une limite par processus, vous n'avez pas besoin de
	vous inquiéter de ce paramétrage. Mais, sur certaines plateformes
	(notamment la plupart des systèmes BSD), le noyau autorisera des
	processus individuels à ouvrir beaucoup plus de fichiers que le système
	ne peut réellement supporter quand un grand nombre de processus essaient
	d'ouvrir autant de fichiers. Si vous récupérez des erreurs du type
	<quote>Too many open files</> (trop de fichiers ouverts), essayez de
	réduire ce paramètre. Cette option peut aussi être configurée au
	lancement du serveur.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><varname>preload_libraries</varname> (<type>string</type>)</term>
      <indexterm><primary>preload_libraries</></>
      <listitem>
       <para>
        Cette variable spécifie une ou plusieurs bibliothèques préchargées au
        lancement du serveur. Une fonction d'initialisation sans paramètre peut
        être appelée pour chaque bibliothèque. Pour cela, ajouter un caractère 
        deux points et le nom de la fonction d'initialisation après le nom de la
        bibliothèque. Par exemple, <literal>'$libdir/malib:malib_init'</literal>
        causerait le préchargement de <literal>malib</> et l'exécution de
        <literal>malib_init</>. Si plus d'une bibliothèque doit être chargée,
        séparez leur nom par des virgules.
       </para>

       <para>
        Si <literal>malib</> ou <literal>malib_init</> sont introuvables, le
        serveur échouera au lancement.
       </para>

       <para>
        Les bibliothèques des langages de procédure de
        <productname>PostgreSQL</productname> peuvent être préchargées de
        cette façon, typiquement en utilisant la syntaxe
        <literal>'$libdir/plXXX:plXXX_init'</literal> où
        <literal>XXX</literal> est soit <literal>pgsql</> soit
        <literal>perl</> soit <literal>tcl</> soit <literal>python</>.
       </para>

       <para>
        En préchargeant une bibliothèque partagée (et en l'initialisant dans
        les cas applicables), le temps de lancement de la bibliothèque est
        évité à la première utilisation de la bibliothèque. Néanmoins, le temps
        de lancer chaque nouveau processus augmente même si le processus
        n'utilise pas la bibliothèque.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-wal">
    <title>Write Ahead Log</title>

   <para>
    Voir aussi la <xref linkend="wal-configuration"> pour des détails sur la
    configuration pointue des WAL.
   </para>

    <sect3 id="runtime-config-wal-settings">
     <title>Paramétrages</title>
     <variablelist>
     
     <varlistentry>
      <indexterm>
       <primary>fsync</primary>
      </indexterm>

      <term><varname>fsync</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Si cette option est activée, le serveur <productname>PostgreSQL</>
        utilisera l'appel système <function>fsync()</> à plusieurs endroits pour
        s'assurer que les mises à jour sont écrites physiquement sur le disque.
        Ceci vous assure que le groupe de bases de données retournera à un état
        cohérent après un arrêt brutal du système d'exploitation ou suite à un
        problème matériel. (Les arrêts brutaux du serveur de bases de données ne
        sont <emphasis>pas</> eux-même en relation avec ceci.)
       </para>

       <para>
        Néanmoins, utiliser <function>fsync()</function> implique des coûts au
        niveau performance&nbsp;: lorsqu'une transaction est validée,
        <productname>PostgreSQL</productname> doit attendre que le système
        d'exploitation vide les WAL sur disque. Lorsque <varname>fsync</varname>
        est désactivé, le système d'exploitation est autorisé à faire de son
        mieux en utilisant des tampons pour les écritures, en ordonnant et en
        ajoutant des délais aux écritures. Néanmoins, si le système s'arrête
        brutalement, les résultats des dernières transactions validées
        pourraient être perdus en partie ou complètement. Dans le pire des cas,
        une corruption non récupérable des données pourrait survenir.
       </para>

       <para>
        À cause des risques encourus, il n'existe pas de paramétrage universel
        pour <varname>fsync</varname>. Certains administrateurs désactivent en
        permanence <varname>fsync</varname> alors que d'autres ne le désactivent
        que pour les charges importantes s'il existe un moyen de recommencer
        proprement si quelque chose se passe mal. Mais d'autres administrateurs
        laissent toujours <varname>fsync</varname> activé. La valeur par défaut
        est d'activer <varname>fsync</varname> pour une confiance maximale. Si
        vous avez confiance en votre système d'exploitation (ou sur la
        sauvegarde sur batterie), vous pouvez considérer la désactivation de
        <varname>fsync</varname>.
       </para>

       <para>
        Cette option n'est configurable qu'au lancement du serveur ou dans le
        fichier <filename>postgresql.conf</filename> file.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><varname>wal_sync_method</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Méthode utilisée pour forcer les mises à jour des WAL sur le disque.
        Les valeurs possibles sont
        <literal>fsync</> (appel de <function>fsync()</> à chaque validation),
        <literal>fdatasync</> (appel de <function>fdatasync()</> à chaque
        validation), <literal>open_sync</> (écriture des fichiers WAL avec
        l'option <symbol>O_SYNC</> de <function>open()</>) et
        <literal>open_datasync</> (écriture des fichiers WAL avec l'option
        <symbol>O_DSYNC</> de <function>open()</>). Toutes ces options ne sont
        pas disponibles sur toutes les plateformes. Cette option n'est
        configurable qu'au lancement du serveur ou dans le fichier
        <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><varname>wal_buffers</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Nombre de tampons de pages disque en mémoire partagée pour les traces
        WAL. La valeur par défaut est 8. Cette option n'est configurable qu'au
        lancement du serveur.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect3>
     <sect3 id="runtime-config-wal-checkpoints">
     <title>Points de vérification</title>

    <variablelist>
     <varlistentry>
      <term><varname>checkpoint_segments</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Distance maximum entre des points de vérifications automatiques
        des WAL, dans les segments des journaux de traces (chaque segment fait
        normalement 16&nbsp;Mo). Par défaut, il y en a trois. Cette option
        n'est configurable qu'au lancement du serveur ou dans le fichier
        <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>checkpoint_timeout</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Temps maximum entre des points de vérification automatiques des
        WAL en secondes. La valeur par défaut est de 300 secondes. Cette option
        n'est configurable qu'au lancement du serveur ou dans le fichier
        <filename>postgresql.conf</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>checkpoint_warning</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Écrit un message dans les traces du serveur si les points de
        vérification causés par le remplissage des fichiers de segment arrivent
        plus fréquemment que ce nombre de secondes. La valeur par défaut est de
        30 secondes. Une valeur nulle désactive cet avertissement.
       </para>
      </listitem>
     </varlistentry>
                
                
     <varlistentry>
      <term><varname>commit_delay</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Délai entre l'écriture de l'enregistrement d'une validation dans le
        tampon WAL et le vidage du tampon sur le disque en microsecondes. Un
        délai différent de zéro autorise la validation de plusieurs transactions
        avec un seul appel système <function>fsync()</function> si la charge
        système est assez haute pour que des transactions supplémentaires soient
        disponibles à la validation dans l'intervalle donné. Mais le délai est
        predu si aucune autre transaction n'est prête à la validation. Du coup,
        le délai est réalisé si au moins <varname>commit_siblings</varname>
        autres transactions sont actives à l'instant où un processus serveur a
        écrit son enregistrement de validation. La valeur par défaut est de zéro
        (pas de délai).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>commit_siblings</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Nombre minimum de transactions ouvertes concurrentes réclamées
avant d'exécuter le délai <varname>commit_delay</>. Une valeur plus importante
rend plus probable qu'au moins une autre transaction sera prête à la validation
lors du délai. La valeur par défaut est de cinq.
       </para>
      </listitem>
     </varlistentry>
     
     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-query">
    <title>Planification des requêtes</title>

    <sect3 id="runtime-config-query-enable">
     <title>Configuration de la méthode du planificateur</title>

     <note>
      <para>
       Ces paramètres de configuration fournissent une méthode dure pour
       influencer les plans de requête choisis par l'optimiseur de requêtes. Si
        le plan choisi par défaut par l'optimiseur pour une requête particulière
        n'est pas optimale, une solution temporaire pourrait être découverte en
        utilisant un de ces paramètres de configuration pour forcer l'optimiseur
        à choisir un meilleur plan. D'autres façons d'améliorer la qualité des
        plans choisis par l'optimiseur incluent la configuration de <xref
        linkend="runtime-config-query-constants"
        endterm="runtime-config-query-constants-title">, lancer
        <command>ANALYZE</command> plus fréquemment et d'accroître le nombre de
        statistiques récoltées pour une colonne particulière en utilisant
        <command>ALTER TABLE SET STATISTICS</command>.
      </para>
     </note>

     <variablelist>
     <varlistentry>
      <term><varname>enable_hashagg</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active ou désactive l'utilisation des agrégats hachés par le
        planificateur. Actif par défaut. C'est utilisé pour déboguer le
        planificateur de requêtes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>enable_hashjoin</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active ou désactive l'utilisation des jointures hachées par le
        planificateur. Actif par défaut. C'est utilisé pour déboguer le
        planificateur de requêtes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <indexterm>
       <primary>index scan</primary>
      </indexterm>

      <term><varname>enable_indexscan</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active ou désactive l'utilisation des parcours d'index par le
        planificateur. Actif par défaut. C'est utilisé pour déboguer le
        planificateur de requêtes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>enable_mergejoin</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active ou désactive l'utilisation des jointures de fusion par le
        planificateur. Actif par défaut. C'est utilisé pour déboguer le
        planificateur de requêtes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>enable_nestloop</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active ou désactive l'utilisation des jointures de boucles imbriquées
        par le planificateur. Il n'est pas possible de supprimer les
        jointures de boucles imbriquées complètement mais désactiver cette
        variable décourage le planificateur de l'utiliser si d'autres méthodes
        sont disponibles. Actif par défaut. C'est utilisé pour déboguer le
        planificateur de requêtes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <indexterm>
       <primary>parcours séquentiel</primary>
      </indexterm>

      <term><varname>enable_seqscan</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active ou déactive l'utilisation des parcours séquentiel par le
        planificateur. Il n'est pas possible de supprimer complètement les
        parcours séquentiels mais désactiver cette variable décourage le
        planificateur de l'utiliser si d'autres méthodes sont disponibles.
        Actif par défaut. C'est utilisé pour déboguer le planificateur de
        requêtes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>enable_sort</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active ou désactive l'utilisation des étapes de tri explicite par le 
        planificateur. Il n'est pas possible de supprimer complètement ces tris
        mais désactiver cette variable décourage le planificateur de l'utiliser
        si d'autres méthodes sont disponibles. Actif par défaut. C'est utilisé
        pour déboguer le planificateur de requêtes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>enable_tidscan</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active ou désactive l'utilisation des parcours de <acronym>TID</> par
        le planificateur. Actif par défaut. C'est utilisé pour déboguer le
        planificateur de requêtes.
       </para>
      </listitem>
     </varlistentry>
     
     </variablelist>
     </sect3>
     <sect3 id="runtime-config-query-constants">
     <title id="runtime-config-query-constants-title">
      Constantes de coût du planificateur
     </title>

   <note>
    <para>
     Malheureusement, il n'existe pas de méthode bien définie pour
     déterminer les valeurs idéales pour la famille des variables de coût
     (<quote>cost</quote>) qui apparaissent ci-dessous. Vous êtes encouragés
     à expérimenter et à partager vos découvertes.
    </para>
   </note>

     <variablelist>
     
     <varlistentry>
      <term><varname>effective_cache_size</varname> (<type>floating point</type>)</term>
      <listitem>
       <para>
        Initialise la supposition du planificateur sur la taille réelle du
        cache disque (c'est-à-dire la portion du cache disque du noyau qui sera
        utilisée pour les fichiers de données de
        <productname>PostgreSQL</productname>). C'est mesuré en pages disque,
        qui font normalement 8192 octets chacun. La valeur par défaut est de
        1000.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>random_page_cost</varname> (<type>floating point</type>)</term>
      <listitem>
       <para>
        Initialise l'estimation du coût du planificateur de requêtes pour une
        page disque récupérée de façon non séquentielle. C'est mesuré comme un
        multiple du coût de récupération d'une page séquentielle. Une valeur plus
        haute rend plus probable l'utilisation d'un parcours séquentiel, une
        valeur basse l'utilisation d'un parcours d'index. La valeur par défaut
        est quatre.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>cpu_tuple_cost</varname> (<type>floating point</type>)</term>
      <listitem>
       <para>
        Initialise l'estimation du coût du planificateur de requête pour le 
        traitement de chaque ligne lors d'une requête. C'est mesuré comme une
        fraction du coût de la récupération séquentielle d'une page. La valeur
        par défaut est 0,01.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>cpu_index_tuple_cost</varname> (<type>floating point</type>)</term>
      <listitem>
       <para>
        Initialise l'estimation du coût du planificateur de requête pour le 
        traitement de chaque ligne lors d'un parcours d'index. C'est mesuré
        comme une fraction du coût de la récupération séquentielle d'une page.
        La valeur par défaut est 0,001.
       </para>
      </listitem>
     </varlistentry>
    
     <varlistentry>
      <term><varname>cpu_operator_cost</varname> (<type>floating point</type>)</term>
      <listitem>
       <para>
        Initialise l'estimation du coût du planificateur de requêtes pour le
        traitement de chaque opérateur dans une clause <literal>WHERE</>. C'est
        mesuré comme une fraction du coût de récupération séquentielle d'une
        page. La valeur par défaut est 0,025.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect3>
     <sect3 id="runtime-config-query-geqo">
     <title>Optimiseur génétique de requêtes</title>

     <variablelist>

     <varlistentry>
      <indexterm>
       <primary>optimisation génétique des requêtes</primary>
      </indexterm>
      <indexterm>
       <primary>GEQO</primary>
       <see>optimisation génétique des requêtes</see>
      </indexterm>
      <term><varname>geqo</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active ou désactive l'optimisation génétique des requêtes, algorithme
        qui tente de faire une planification des requêtes sans recherche
        exhaustive. Actif par défaut. Voir les autres paramétrages
        <varname>geqo_</varname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>geqo_threshold</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Utilise l'optimisation génétique des requêtes pour planifier les
        requêtes avec au moins ce nombre d'éléments impliqués dans la clause
        <literal>FROM</>. (Notez qu'un construction <literal>JOIN</> externe
        compte seulement comme un élément du <literal>FROM</>.) La valeur par
        défaut est de 11. Pour des requêtes simples, il est généralement mieux
        d'utiliser le planificateur déterministe, exhaustif mais pour les
        requêtes comprenant beaucoup de tables, le planificateur déterministe
        prendrait trop de temps.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>geqo_effort</varname> (<type>integer</type>)</term>
      <term><varname>geqo_generations</varname> (<type>integer</type>)</term>
      <term><varname>geqo_pool_size</varname> (<type>integer</type>)</term>
      <term><varname>geqo_selection_bias</varname> (<type>floating point</type>)</term>
      <listitem>
       <para>
        Différents paramètres pour l'algorithme d'optimisation génétique des 
        requêtes&nbsp;: la taille de la queue est le nombre d'individus dans une
        population. Les valeurs valides sont comprises entre 128 et 1024. Si
elle est initialisée à 0 (valeur par défaut), une valeur de 2^(QS+1), où QS est
le nombre d'éléments dans la clause <literal>FROM</>, est prise. L'effort est
utilisé pour calculer une valeur par défaut pour les générations. Les valeurs
valides sont entre 1 et 80, 40 étant la valeur par défaut. Les générations
spécifient le nombre d'itérations dans l'algorithme. Le nombre doit être un
entier positif. Si 0 est spécifié, alors <literal>Effort *
Log2(PoolSize)</literal> est utilisé. Le temps d'exécution de l'algorithme est
grossièrement proportionnel à la somme de la taille de la queur et aux
générations. Le biais de sélection est la pression sélective à l'intérieur de la
population. Les valeurs peuvent aller de 1,50 à 2,00&nbsp;; la dernière étant
la valeur par défaut.
       </para>
      </listitem>
     </varlistentry>
     
     </variablelist>
    </sect3>
     <sect3 id="runtime-config-query-other">
     <title>Autres options du planificateur</title>

     <variablelist>

     <varlistentry>
      <term><varname>default_statistics_target</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Initialise la cible par défaut des statistiques pour les colonnes de
        table qui n'ont pas une cible spécifique de colonne configurée via
        <command>ALTER TABLE SET STATISTICS</>. Des valeurs plus importantes
        accroissent le temps nécessaire à exécuter <command>ANALYZE</> mais
        pourrait améliorer les estimations du planificateurs. La valeur par
        défaut est de 10.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>from_collapse_limit</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Le planificateur assemblera les sous-requêtes dans des requêtes
        supérieures si la liste FROM résultante n'aurait pas plus de ce nombre
        d'éléments. Des valeurs plus petites réduisent le temps de
        planification mais ramènent des plans de requêtes inférieurs. La valeur
        par défaut est huit. Il est généralement conseillé de conserver cette
        valeur inférieure à <varname>geqo_threshold</varname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>join_collapse_limit</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Le planificateur va aplatir les constructions <literal>JOIN</>
        internes explicites dans des listes d'élements pour la clause
        <literal>FROM</> lorsqu'il y a moins que ce nombre d'éléments.
        Habituellement, c'est identique à <varname>from_collapse_limit</>. Le
        configurer à 1 empêche tout aplatissement des <literal>JOIN</> internes,
        permettant l'utilisation de la syntaxe <literal>JOIN</> explicite pour
        contrôler l'ordre de jointure. Les valeurs intermédiaires sont utiles
        pour étabir un équilibre entre le temps de planification et la qualité
        du plan.
       </para>
      </listitem>
     </varlistentry>
     
     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-logging">
    <title>Rapports d'erreur et traces</title>

    <indexterm zone="runtime-config-logging">
     <primary>traces serveur</primary>
    </indexterm>

    <sect3 id="runtime-config-logging-syslog">
     <title>Syslog</title>

     <indexterm zone="runtime-config-logging-syslog">
      <primary>syslog</primary>
     </indexterm>

     <variablelist>

     <varlistentry>
      <term><varname>syslog</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        <productname>PostgreSQL</productname> permet l'utilisation de
        <systemitem>syslog</systemitem> pour ses traces. Si cette option est
        initialisée à 1, les messages vont à la fois dans <systemitem>syslog</>
        et sur la sortie standard. Un paramétrage de 2 envoie la sortie
        uniquement dans <systemitem>syslog</>. (Quelques messages iront toujours
        sur la sortie standard ou la sortie des erreurs.) Cette option est par
        défaut à 0, signifiant que <systemitem>syslog</> est désactivée. Cette
        option doit être initialisée au lancement du serveur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>syslog_facility</varname> (<type>string</type>)</term>
       <listitem>
        <para>
          Cette option détermine le niveau (<quote>facility</quote>) que
          <application>syslog</application> doit utiliser pour tracer avec
          <application>syslog</application>. Vous pouvez choisir entre
          <literal>LOCAL0</>, <literal>LOCAL1</>,
          <literal>LOCAL2</>, <literal>LOCAL3</>, <literal>LOCAL4</>,
          <literal>LOCAL5</>, <literal>LOCAL6</>, <literal>LOCAL7</>&nbsp;;
          la valeur par défaut est <literal>LOCAL0</>. Voir aussi la
          documentation du <application>syslog</application> de votre serveur.
        </para>
       </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><varname>syslog_ident</varname> (<type>string</type>)</term>
       <listitem>
        <para>
         Si <application>syslog</> est activé, cette option détermine le nom
         du programme utilisé pour identifier les messages de
         <productname>PostgreSQL</productname> dans les journaux de traces de
         <application>syslog</application>. La valeur par défaut est
         <literal>postgres</literal>.
        </para>
       </listitem>
      </varlistentry>
      
      </variablelist>
    </sect3>
     <sect3 id="runtime-config-logging-when">
     <title>Quand tracer</title>

     <variablelist>

     <varlistentry>
      <term><varname>client_min_messages</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Contrôle les niveaux des messages envoyés au client. Les valeurs
        valides peuvent être <literal>DEBUG5</>,
        <literal>DEBUG4</>, <literal>DEBUG3</>, <literal>DEBUG2</>,
        <literal>DEBUG1</>, <literal>LOG</>, <literal>NOTICE</>,
        <literal>WARNING</> et <literal>ERROR</>. Chaque niveau inclut tous les
        niveaux qui le suivent. La valeur par défaut est <literal>NOTICE</>.
        Notez que <literal>LOG</> a un niveau différent que dans
        <varname>log_min_messages</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>log_min_messages</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Contrôle les niveaux des messages écrits dans les journaux de traces.
        Les valeurs valides sont <literal>DEBUG5</>, <literal>DEBUG4</>,
        <literal>DEBUG3</>, <literal>DEBUG2</>, <literal>DEBUG1</>,
        <literal>INFO</>, <literal>NOTICE</>, <literal>WARNING</>,
        <literal>ERROR</>, <literal>LOG</>, <literal>FATAL</> et
        <literal>PANIC</>. Chaque niveau inclut tous les niveaux qui le
        suivent. Le niveau le plus bas obtient le plus petit nombre de
        messages. La valeur par défaut est <literal>NOTICE</>. Notez que
        <literal>LOG</> a un niveau différent que dans
        <varname>client_min_messages</>. Seuls les superutilisateurs peuvent
        accroître cette option.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>log_error_verbosity</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Contrôle le nombre de détails écrits dans les journaux de traces pour
        chaque message tracé. Les valeurs valides sont <literal>TERSE</>,
        <literal>DEFAULT</> et <literal>VERBOSE</>, chacun ajoutant plus de
        champs aux messages affichés.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>log_min_error_statement</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Contrôle si l'instruction SQL ayant causé une erreur sera aussi
        enregistrée dans le journal des traces. Toutes les instructions SQL, qui
        causent une erreur du niveau spécifié ou d'un niveau plus haut, seront
        tracées. La valeur par défaut est <literal>PANIC</literal> (désactivant
        réellement cette fonctionnalité en production). Les valeurs valides sont
        <literal>DEBUG5</literal>,
        <literal>DEBUG4</literal>, <literal>DEBUG3</literal>,
        <literal>DEBUG2</literal>, <literal>DEBUG1</literal>,
        <literal>INFO</literal>, <literal>NOTICE</literal>,
        <literal>WARNING</literal>, <literal>ERROR</literal>,
        <literal>FATAL</literal> et <literal>PANIC</literal>. Par exemple, si
        vous l'initialisez à <literal>ERROR</literal>, alors toutes les
        instructions SQL causant des erreurs, fatales ou non, ou des paniques
        seront tracées. Activer cette option est utile pour localiser la source
        de toute erreur apparaissant dans le journal des traces. Seuls les
        superutilisateurs peuvent accroître cette option.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><varname>log_min_duration_statement</varname> (<type>integer</type>)</term>
       <listitem>
        <para>
         Initialise un temps d'exécution minimum (en millisecondes) pour que
         l'instruction soit tracée. Toutes les instructions SQL exécutées dans
         le temps imparti ou prenant plus de temps seront tracées avec leur
         durée. L'initialiser à zéro tracera toutes les requêtes avec leur
         durée. -1 (la valeur par défaut) désactive cette option. Par exemple,
         si vous la configurez à <literal>250</literal>, toutes les instructions
         SQL s'exécutant en au moins 250&nbsp;ms seront tracées. Activer cette
         option peut se révéler utile pour tracer les requêtes non optimisées
         dans vos applications. Seuls les superutilisateurs peuvent augmenter
         cette option ou la configurer à -1 si cette option a été initialisée
         par l'administrateur.
        </para>
       </listitem>
      </varlistentry>

     <varlistentry>
      <term><varname>silent_mode</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Exécute le serveur en mode silencieux. Si cette option est donnée, le
        serveur sera lancé automatiquement en tâche de fond et tous les
        terminaux de contrôle seront dissociés. Du coup, aucun message ne sera
        écrit sur la sortie standard ou sur la sortie des erreurs (effet
        identique à l'option <option>-S</option> de <command>postmaster</>).
        Sauf si les traces <application>syslog</> sont activées, l'utilisation
        de cette option n'est pas encouragée car elle rend impossible la
        visualisation des messages d'erreurs.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

       <para>
        Voici une liste des niveaux de sévérité utilisés dans ces
        paramétrages&nbsp;:
        <variablelist>
         <varlistentry>
          <term><literal>DEBUG[1-5]</literal></term>
          <listitem>
           <para>
            Fournit des informations utiles aux développeurs.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>INFO</literal></term>
          <listitem>
           <para>
            Fournit des informations implicitement demandées par l'utilisateur,
            par exemple lors d'un <command>VACUUM VERBOSE</>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>NOTICE</literal></term>
          <listitem>
           <para>
            Fournit des informations qui pourraient être utiles aux
            utilisateurs, par exemple lors du tronquage d'identifiants longs ou
            la création d'index faisant partie de clés primaires.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>WARNING</literal></term>
          <listitem>
           <para>
            Fournit des avertissements aux utilisateurs, par exemple un
            <command>COMMIT</> en dehors d'un bloc de transactions.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>ERROR</literal></term>
          <listitem>
           <para>
            Rapporte une erreur, qui a annulé la transaction actuelle.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>LOG</literal></term>
          <listitem>
           <para>
            Rapporte des informations intéressant les administrateurs, par
            exemple l'activité des points de vérification.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>FATAL</literal></term>
          <listitem>
           <para>
            Rapporte une erreur qui a causé l'annulation de la session courante.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>PANIC</literal></term>
          <listitem>
           <para>
            Rapporte une erreur qui a causé l'annulation de toutes les sessions.
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

    </sect3>
     <sect3 id="runtime-config-logging-what">
     <title>Que tracer</title>
     
     <variablelist>
     
     <varlistentry>
      <term><varname>debug_print_parse</varname> (<type>boolean</type>)</term>
      <term><varname>debug_print_rewritten</varname> (<type>boolean</type>)</term>
      <term><varname>debug_print_plan</varname> (<type>boolean</type>)</term>
      <term><varname>debug_pretty_print</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Ces options activent plusieurs sorties de débogage à être
        envoyées au client ou dans les traces du serveur. Pour chaque requête
        exécutée, elles affichent l'arbre d'analyse résultant.
        <varname>debug_pretty_print</varname> indente ces affichages pour
        produire un format de sortie plus lisible mais plus long. 
        <varname>client_min_messages</varname> ou
        <varname>log_min_messages</varname> doivent valoir
        <literal>DEBUG1</literal> ou plus bas pour envoyer la sortie vers le
        client ou les traces du serveur. Ces options sont désactivées par
        défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>log_connections</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Ceci affiche une ligne dans les traces du serveur détaillant chaque
        connexion réussie. Désactivée par défaut, elle est probablement très
        utile. Ce paramètre peut seulement être configuré dans le fichier
	<filename>postgresql.conf</filename> ou indiqué sur la ligne de commande.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><varname>log_duration</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Trace la durée de toute instruction exécutée. Pour utiliser cette
        option, activez <varname>log_statement</> et <varname>log_pid</> de
        façon à pouvoir lier l'instruction à la durée en utilisant l'identifiant
        du processus. Désactivée par défaut, seuls les superutilisateurs
        peuvent désactiver cette option si elle a été activée par
        l'administrateur.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><varname>log_pid</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Préfixe chaque message dans le journal des traces du serveur avec
        l'identifiant  de processus du serveur. C'est utile pour associer les
        messages aux connexions. Désactivé par défaut, ce paramètre n'affecte
        pas les messages tracés via <application>syslog</>, qui contient
        toujours l'identifiant du processus.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>log_statement</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Trace toutes les instructions SQL. Cette option est désactivée par
        défaut. Seuls les superutilisateurs peuvent désactiver cette option si
        elle a été activée par l'administrateur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>log_timestamp</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Préfixe chaque message du journal des traces avec une indication de la
        date et de l'heure. Désactivée par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>log_hostname</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Par défaut, les traces des connexions n'affichent que l'adresse IP de
        l'hôte se connectant. Si vous souhaitez qu'il affiche le nom de l'hôte,
        vous pouvez activer cette option mais suivant votre configuration de
        résolution de nom d'hôte, cela pourrait imposer une pénalité des
        performances non négligeable. Cette option est seulement configurable au
        lancement du serveur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>log_source_port</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Affiche le numéro de port de l'hôte connecté dans les messages de trace
        des connexions. Vous pouvez traver le numéro de port pour trouver
        l'utilisateur connecté. En dehors de cela, cette option est pratiquement
        inutile et est donc désactivée par défaut. Cette option est seulement
        configurable au lancement du serveur.
       </para>
      </listitem>
     </varlistentry>
     
     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-statistics">
    <title>Statistiques d'exécution</title>

    <sect3 id="runtime-config-statistics-monitor">
     <title>Surveillance des statistiques</title>
     <variablelist>

     <varlistentry>
      <term><varname>log_statement_stats</varname> (<type>boolean</type>)</term>
      <term><varname>log_parser_stats</varname> (<type>boolean</type>)</term>
      <term><varname>log_planner_stats</varname> (<type>boolean</type>)</term>
      <term><varname>log_executor_stats</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Pour chaque requête, écrit les statistiques de performance du module
        respectif dans les journaux de trace. Ceci est un outi brut de
        profilage. Toutes ces options sont désactivées par défaut. Seuls les
        superutilisateurs peuvent les désactiver si elles ont tout d'abord été
        activées par l'administrateur.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect3>
    <sect3 id="runtime-config-statistics-collector">
     <title>Collecteur des statistiques sur les requêtes et les index</title>
     <variablelist>

     <varlistentry>
      <term><varname>stats_start_collector</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Contrôle si le serveur doit lancer le sous-processus de récupération de
        statistiques. Il est activé par défaut mais pourrait être enlevé si
        vous n'avez aucun intérêt dans la récupération de statistiques.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>stats_command_string</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active la récupération de statistiques sur les commandes en cours
        d'exécution par chaque session, avec le moment de l'exécution de la
        commande. Cette option est désactivée par défaut. Notez que, même après
        son activation, cette information n'est pas visible par tous les
        utilisateurs, mais seulement par les superutilisateurs et l'utilisateur
        possédant la session. Donc, cela ne devrait pas représenter un risque de
        sécurité. La donnée est accessible via la vue système
        <structname>pg_stat_activity</structname>&nbsp;; référez-vous au <xref
        linkend="monitoring"> pour plus d'informations.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>stats_block_level</varname> (<type>boolean</type>)</term>
      <term><varname>stats_row_level</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Ceci active la récupération de statistiques sur l'activité du serveur au
        niveau bloc et ligne, respectivement. Ces options sont désactivées par
        défaut. Les données sont accessibles via les familles de vues système
        <structname>pg_stat</structname> et
        <structname>pg_statio</structname>&nbsp;; référez-vous à <xref
        linkend="monitoring"> pour plus d'informations.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>stats_reset_on_server_start</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        En cas d'activation, les statistiques récupérées sont supprimées à
        chaque redémarrage du serveur. Sinon, les statistiques sont accumulées
        avec les redémarrage du serveur. Par défaut, cette option est activée et
        peut seulement être configurée au lancement du serveur.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-client">
    <title>Valeurs par défaut des connexions client</title>

    <sect3 id="runtime-config-client-statement">
     <title>Comportement des instructions</title>
     <variablelist>

     <varlistentry id="guc-search-path" xreflabel="search_path">
      <term><varname>search_path</varname> (<type>string</type>)</term>
      <indexterm><primary>search_path</></>
      <indexterm><primary>path</><secondary>for schemas</></>
      <listitem>
       <para>
        Cette variable spécifie l'ordre dans lequel les schémas sont recherchés
        lorsqu'un objet (table, type de données, fonction, etc.) est référencé
        par un simple nom sans son composant schéma. Quand il existe des noms
        identiques dans différents schémas, le premier trouvé dans le chemin de
        recherche est utilisé. Un objet qui ne fait partie d'aucun des schémas
        du chemin de recherche peut seulement être référencé en spécifiant son
        schéma conteneur avec un nom qualifié.
       </para>

       <para>
        La valeur de <varname>search_path</varname> doit être une liste de noms
        de schémas séparés par des virgules. Si un des éléments de la liste est
        la valeur spéciale <literal>$user</literal>, alors le schéma ayant le
        nom renvoyé par <function>SESSION_USER</> est substitué, si un tel
        schéma existe (sinon <literal>$user</literal> est ignoré).
       </para>

       <para>
        Le schéma du catalogue système, <literal>pg_catalog</>, est toujours
        recherché, qu'il soit ou non mentionné dans le chemin. S'il est
        mentionné, alors il sera cherché dans l'ordre spécifié. Si
        <literal>pg_catalog</> ne fait pas partie du chemin, alors il sera
        cherché <emphasis>avant</> tout élément du chemin.
       </para>

       <para>
	De même, la recherche des schémas passe toujours par le schéma des
	tables temporaires, <literal>pg_temp_<replaceable>nnn</></>, si ce
	dernier existe. Il est toujours possible de l'ajouter dans le chemin
	en utilisant l'alias <literal>pg_temp</>. S'il ne fait pas partie
	du chemin, la recherche commencera par lui (avant même
	<literal>pg_catalog</>). Néanmoins, seuls les noms de relation (table,
	vue, séquence, etc.) et de type de données sont recherchés dans le
	schéma temporaire. Aucune fonction et aucun opérateur n'y sera
	recherché.
       </para>

       <para>
        Lorsque des objets sont créés sans spécifier un schéma cible
        particulier, ils sont placés dans le premier schéma listé dans le chemin
        de recherche. Une erreur est rapportée si le chemin de recherche est
        vide.
       </para>

       <para>
        La valeur par défaut de ce paramètre est <literal>'$user,
        public'</literal> (où la deuxième partie sera ignorée s'il n'existe pas
        de schéma nommé <literal>public</>). Elle supporte l'utilisation
        partagée d'une base de données (où aucun utilisateur n'a de schémas
        privés et tous partagent l'utilisation de <literal>public</>), de
        schémas privés par utilisateur et une combinaison des deux. D'autres
        effets peuvent être obtenus en modifiant le chemin de recherche par
        défaut soit globalement soit par utilisateur.
       </para>

       <para>
        La valeur réelle actuelle du chemin de recherche peut être examinée via
        la fonction <acronym>SQL</acronym> <function>current_schemas()</>. 
        Elle n'est pas identique à la valeur de <varname>search_path</varname>,
        car <function>current_schemas()</> affiche comment la requête
        apparaissant dans <varname>search_path</varname> sera résolue.
       </para>

       <para>
        Pour plus d'informations sur la gestion des schémas, voir la <xref
        linkend="ddl-schemas">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>check_function_bodies</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Ce paramètre est normalement vrai. Lorsqu'il est initialisé à faux, il
        désactive la validation de la chaîne du corps d'une fonction dans
        <command>CREATE FUNCTION</>. Désactiver la validation est quelque
        fois utile pour éviter des problèmes tels que des références lors de la
        restauration de définition de fonctions à partir d'une sauvegarde.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <indexterm>
       <primary>niveau d'isolation de la transaction</primary>
      </indexterm>

      <term><varname>default_transaction_isolation</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Chaque transaction SQL a un niveau d'isolation, qui peut être soit
        <quote>read committed</quote> soit <quote>serializable</quote>. Ce
        paramètre contrôle le niveau d'isolation par défaut de chaque nouvelle
        transaction. La valeur par défaut est <quote>read committed</quote>.
       </para>

       <para>
        Consultez <xref linkend="mvcc"> et <xref linkend="sql-set-transaction">
        pour plus d'informations.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <indexterm>
       <primary>transaction en lecture seule</primary>
      </indexterm>

      <term><varname>default_transaction_read_only</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Une transaction SQL en lecture seule ne pourrait pas modifier les 
        tables non temporaires. Ce paramètre contrôle le statut de lecture seule
        par défaut de chaque nouvelle transaction. La valeur par défaut est faux
        (lecture/écriture).
       </para>

       <para>
        Consultez <xref linkend="sql-set-transaction"> pour plus d'informations.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><varname>statement_timeout</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Annule toute instruction prenant plus que le nombre spécifié de
        millisecondes. Une valeur de zéro désactive le chronomètre et est la
        valeur par défaut.
       </para>
      </listitem>
     </varlistentry>
     
     </variablelist>
    </sect3>
     <sect3 id="runtime-config-client-format">
     <title>Locale et formatage</title>

     <variablelist>

     <varlistentry>
      <term><varname>datestyle</varname> (<type>string</type>)</term>
      <indexterm><primary>date style</></>
      <listitem>
       <para>
        Initialise le format d'affichage des valeurs de type date et heure
        ainsi que des règles d'interprétation des valeurs ambigues de type date
        en entrée. Pour des raisons historiques, cette variable contient deux
        composants indépendants&nbsp;: la spécification du format de sortie
        (<literal>ISO</>, <literal>Postgres</>, <literal>SQL</> ou
        <literal>German</>) et la spécification de l'ordre du champ date
        (<literal>DMY</>, <literal>MDY</>, ou <literal>YMD</>). Elles peuvent
        être spécifiées ensemble ou séparément. Les mots clés <literal>Euro</>
        et <literal>European</> sont synonymes pour <literal>DMY</>&nbsp;; les
        mots clés <literal>US</>, <literal>NonEuro</> et <literal>NonEuropean</>
        sont synonymes pour <literal>MDY</>. Voir <xref
        linkend="datatype-datetime"> pour plus d'informations.  La valeur par
        défaut est <literal>ISO, MDY</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>timezone</varname> (<type>string</type>)</term>
      <indexterm><primary>time zone</></>
      <listitem>
       <para>
        Initialise le fuseau horaire pour l'affichage et l'interprétation de 
        l'heure. La valeur par défaut utilise ce que spécifie l'environnement
        système comme fuseau horaire. Voir <xref linkend="datatype-datetime">
        pour plus d'informations.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>australian_timezones</varname> (<type>boolean</type>)</term>
      <indexterm><primary>time zone</><secondary>Australian</></>
      <listitem>
       <para>
        Si vrai, <literal>ACST</literal>,
        <literal>CST</literal>, <literal>EST</literal> et
        <literal>SAT</literal> sont interprétés commes des fuseaux horaires
        australiens plutôt que comme des fuseaux horaires d'Amérique Nord/Sud.
        Par défaut à faux.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <indexterm>
       <primary>chiffres significatifs</primary>
      </indexterm>
      <indexterm>
       <primary>nombre à virgule flottante</primary>
       <secondary>affichage</secondary>
      </indexterm>

      <term><varname>extra_float_digits</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Ce paramètre ajuste le nombre de chiffres affichés par les valeurs à
        virgule flottante, ceci incluant <type>float4</>, <type>float8</> et les
        types de données géométriques. La valeur du paramètre est ajouté au
        nombre standard de chiffres (<literal>FLT_DIG</> ou <literal>DBL_DIG</>
        comme approprié). La valeur peut être initialisée à une valeur maximum
        de 2 pour inclure les chiffres partiellement significatifs&nbsp;; c'est
        tout spécialement utile pour sauvegarder les données à virgule flottante
        qui ont besoin d'être restaurées exactement. Cette variable peut aussi
        être négative pour supprimer les chiffres non souhaités.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>client_encoding</varname> (<type>string</type>)</term>
      <indexterm><primary>ensemble de caractères</></>
      <listitem>
       <para>
        Initialise le codage côté client (ensemble de caractères). Par défaut,
        utilise le codage de la base de données.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>lc_messages</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Initialise la langue dans laquelle les messages sont affichés. Les
        valeurs acceptables sont dépendantes du système&nbsp;; voir <xref
        linkend="locale"> pour plus d'informations. Si cette variable est
        initialisée en tant que chaîne vide (ce qui est la valeur par défaut),
        alors la valeur est héritée de l'environnement d'exécution du serveur.
       </para>

       <para>
        Avec certains systèmes, cette catégorie de locale n'existe pas.
        Initialiser cette variable fonctionnera toujours mais n'aura aucun
        effet. De même, il existe une chance pour qu'aucun message traduit
        n'existe pour la langue sélectionnée. Dans ce cas, vous continuerez de
        voir les messages en anglais.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>lc_monetary</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Initialise la locale à utiliser pour formater les montants de monnaie,
        par exemple avec la famille de fonctions <function>to_char</function>.
        Les valeurs acceptables dépendent du système&nbsp;; voir la <xref
        linkend="locale"> pour plus d'informations. Si cette variable est une
        chaîne vide (la valeur par défaut), alors la valeur est héritée de
        l'environnement d'exécution du serveur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>lc_numeric</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Initialise la locale à utiliser pour formater les nombres, par exemple
        avec la famille de fonctions <function>to_char()</function>. Les valeurs
        acceptables dépendent du système&nbsp;; voir <xref linkend="locale">
        pour plus d'informations. Si cette variable est une chaîne vide (valeur
        par défaut), alors la valeur est héritée de l'environnement d'exécution
        du serveur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>lc_time</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Initialise la locale à utiliser pour formater les valeurs de date et
        d'heure (actuellement, ce paramétrage ne fait rien mais il le pourrait
        dans le futur). Les valeurs acceptables dépendent du système&nbsp;; voir
        la <xref linkend="locale"> pour plus d'informations. Si cette variable est
        une chaîne vide (la valeur par défaut), alors la valeur est héritée de
        l'environnement système du serveur.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect3>
     <sect3 id="runtime-config-client-other">
     <title>Autres valeurs par défaut</title>

     <variablelist>

     <varlistentry>
      <term><varname>explain_pretty_print</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Détermine si <command>EXPLAIN VERBOSE</> utilise le format indenté ou
        non pour l'affichage des arbres détaillés des requêtes. Activé par
        défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>dynamic_library_path</varname> (<type>string</type>)</term>
      <indexterm><primary>dynamic_library_path</></>
      <indexterm><primary>dynamic loading</></>
      <listitem>
       <para>
        Si un module chargeable dynamiquement a besoin d'être ouvert et que le 
        nom spécifié ne spécifie par un répertoire (c'est-à-dire que le nom ne
        comporte pas de slash), le système cherchera le fichier dans ce chemin.
        (Le nom utilisé est le nom spécifié dans la commande <command>CREATE
        FUNCTION</command> ou <command>LOAD</command>.)
       </para>

       <para>
        La valeur de <varname>dynamic_library_path</varname> doit être une
        liste de noms absolus de répertoire séparés par des virgules. Si un nom
        de répertoire commence avec la valeur spéciale
        <literal>$libdir</literal>, le répertoire des bibliothèques du paquet
        <productname>PostgreSQL</productname> est substitué à sa place. C'est
        ici que sont installés les modules fournis par la distribution
        <productname>PostgreSQL</productname>. (Utilisez <literal>pg_config
        --pkglibdir</literal> pour afficher le nom de ce répertoire.) Par
        exemple&nbsp;:
<programlisting>
dynamic_library_path = '/usr/local/lib/postgresql:/home/my_project/lib:$libdir'
</programlisting>
       </para>

       <para>
        La valeur par défaut de ce paramètre est <literal>'$libdir'</literal>.
        Si la valeur est une chaîne vide, la recherche automatique du chemin est
        désactivée.
       </para>

       <para>
        Ce paramètre peut être modifié à l'exécution par les superutilisateurs
        mais un paramétrage réalisé de cette façon ne persistera que pendant la
        durée de la connexion du client, donc cette méthode devrait être
        réservée à des buts de développements. La façon recommandée
        pour initialiser ce paramètre est d'utiliser le fichier de configuration
        <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>max_expr_depth</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Initialise la profondeur d'imbrication maximale de l'expression. La
        valeur par défaut de 10000 est assez haute pour toute requête normale
        mais vous pouvez l'augmenter si vous le souhaitez. (Mais si vous
        l'augmentez de trop, vous courrez le risque d'un arrêt brutal du serveur
        à cause d'un dépassement de pile.)
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-locks">
    <title>Gestion des verrous</title>

     <variablelist>

     <varlistentry>
      <indexterm>
       <primary>deadlock</primary>
       <secondary>timeout</secondary>
      </indexterm>
      <indexterm>
       <primary>timeout</primary>
       <secondary>deadlock</secondary>
      </indexterm>

      <term><varname>deadlock_timeout</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Temps total, en millisecondes, d'attente d'un verrou avant de vérifier
        s'il s'agit d'une condition de verrous morts (deadlock condition). La
        vérification d'un verrou mort est assez lente, donc le serveur ne le
        fait pas à chaque fois qu'il attent pour un verrou. Nous supposons (de
        façon optimiste) que les verrous morts ne sont pas communs pour les
        applications de production et nous attendons simplement un verrou
        pendant un certain temps avant de lancer une recherche de blocage.
        Augmenter cette valeur réduit le temps perdu en recherche inutile de
        verrous morts mais ralentit la détection de vraies erreurs de verrous
        morts. La valeur par défaut est de 1000 (c'est-à-dire une par seconde),
        ce qui est probablement la plus petite valeur que vous pourriez vouloir
        en pratique. Sur un serveur déjà chargé, vous pouvez
        l'augmenter. Idéalement, ce paramétrage devrait dépasser le temps
        typique d'une transaction de façon à améliorer la probabilité qu'un
        verrou soit abandonné avant que le processus en attente ne décide de
        lancer une recherche de verrous morts.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>max_locks_per_transaction</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        La table des verrous partagés a une taille basée sur la supposition
        que au moins <varname>max_locks_per_transaction</varname> *
        <varname>max_connections</varname> objets distincts seront nécessaires
        pour être verrouillés en même temps. Par défaut, 64, qui a prouvé son
        adéquation historiquement mais vous pourriez avoir besoin d'augmenter
        cette valeur si vous avez des clients qui touchent beaucoup de tables
        différentes dans une seule transaction. Cette option est initialisée au
        lancement du serveur uniquement.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
   </sect2>

   <sect2 id="runtime-config-compatible">
    <title>Compatibilité de version et de plateforme</title>

    <sect3 id="runtime-config-compatible-version">
     <title>Précédentes versions de PostgreSQL</title>
     <variablelist>

     <varlistentry>
      <term><varname>add_missing_from</varname> (<type>boolean</type>)</term>
      <indexterm><primary>FROM</><secondary>manquant</></>
      <listitem>
       <para>
        Si <literal>true</>, les tables qui sont référencées par une requête
        seront automatiquement ajoutées dans la clause <literal>FROM</> si elles
        n'y sont pas déjà présentes. La valeur par défaut est <literal>true</>
        pour des raisons de compatibilité avec les versions précédentes de
        <productname>PostgreSQL</>. Nénamoins, ce comportement n'appartient pas
        au standard SQL et beaucoup de personnes ne l'aiment pas car elle peut
        masquer les erreurs. L'initialiser à <literal>false</> pour avoir un
        comportement en compatibilité avec le standard SQL permet de rejeter les
        références non listés dans la clause <literal>FROM</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-backslash-quote" xreflabel="backslash_quote">
      <term><varname>backslash_quote</varname> (<type>string</type>)</term>
      <indexterm><primary>strings</><secondary>backslash quotes</></>
      <indexterm>
       <primary>paramètre de configuration <varname>backslash_quote</></primary>
      </indexterm>
      <listitem>
       <para>
        Ceci contrôle si un guillemet peut être représenté par un
        <literal>\'</> dans une chaîne. Le moyen préféré, standard SQL, pour
        représenter un guillemet est de le doubler (<literal>''</>) mais,
        historiquement, <productname>PostgreSQL</> accepte aussi
        <literal>\'</>. Néanmoins, l'utilisation de <literal>\'</> ajoute des
        problèmes liés à la sécurité car certains codages d'ensembles de caractères
	des clients contiennent des caractères multi-octets dans lesquel le dernier
	octet est l'équivant ASCII numérique d'un <literal>\</>. Si le code côté
	client ne fait pas un échappement correct, alors une attaque par injection
	SQL est possible. Ce risque peut être annihilé en s'assurant que le 
	serveur rejette les requêtes dans lesquelles apparait un guillemet à
	échapper avec un antislash. Les valeurs autorisées de
	<varname>backslash_quote</> sont
        <literal>on</> (autorise <literal>\'</> en permanence),
        <literal>off</> (rejette en permanence) et
        <literal>safe_encoding</> (l'autorise seulement si le codage du client
	n'autorise pas l'ASCII <literal>\</> dans un caractère multioctet).
        <literal>safe_encoding</> est le paramétrage par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>regex_flavor</varname> (<type>string</type>)</term>
      <indexterm><primary>expressions rationnelles</></>
      <listitem>
       <para>
        La <quote>saveur</> des expressions rationnelles peut être
        <literal>advanced</> (avancée), <literal>extended</> (étendu) ou 
        <literal>basic</> (basique). La valeur par défaut est
        <literal>advanced</>. Le paramétrage <literal>extended</> pourrait être
        utile pour une compatibilité ascendante exacte avec les versions
        précédant la 7.4 de <productname>PostgreSQL</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>sql_inheritance</varname> (<type>boolean</type>)</term>
      <indexterm><primary>inheritance</></>
      <listitem>
       <para>
        Ceci contrôle la sémantique de l'héritage, en particulier si les
        sous-tables sont incluses par les différentes commandes par défaut.
        Elles ne l'étaient pas dans les versions antérieures à la 7.1. Si vous
        avez besoin de l'ancien comportement, vous pouvez désactiver cette
        variable mais, à long terme, vous êtes encouragé à changer vos
        applications pour utiliser le mot clé <literal>ONLY</literal> qui exclut
        les sous-tables. Voir la <xref linkend="ddl-inherit"> pour plus
        d'informations sur les héritages.
       </para>
      </listitem>
     </varlistentry>

          </variablelist>
    </sect3>
    <sect3 id="runtime-config-compatible-clients">
     <title>Compatibilité de la plateforme et du client</title>
     <variablelist>

     <varlistentry>
      <term><varname>transform_null_equals</varname> (<type>boolean</type>)</term>
      <indexterm><primary>IS NULL</></>
      <listitem>
       <para>
        Une fois activée, les expressions de la forme
        <literal><replaceable>expr</> = NULL</literal> (ou <literal>NULL
        = <replaceable>expr</></literal>) sont traitées comme
        <literal><replaceable>expr</> IS NULL</literal>, c'est-à-dire qu'elles
        renvoient vrai si <replaceable>expr</> s'évalue par la valeur NULL, et
        faux sinon. Le bon comportement de <literal><replaceable>expr</> =
        NULL</literal> est de toujours renvoyer NULL (inconnu). Du coup, cette
        option est désactivée par défaut.
       </para>

       <para>
        Néanmoins, les formulaires filtrés dans <productname>Microsoft
        Access</productname> génèrent des requêtes qui utilisent
        <literal><replaceable>expr</> = NULL</literal> pour tester les valeurs
        NULL, donc si vous utilisez cette interface pour accéder à une base de
        données, vous souhaiterez activer cette option. Comme les
        expressions de la forme <literal><replaceable>expr</> = NULL</literal>
        renvoient toujours la valeur NULL (en utilisant la bonne
        interprétation), elles ne sont pas très utiles et n'apparaissent pas
        souvent dans les applications normales, donc cette option a peu
        d'utilité en pratique. Mais les nouveaux utilisateurs confondent
        fréquemment la sémantique des expressions impliquant des valeurs NULL.
        Du coup, cette option n'est pas activée par défaut.
       </para>

       <para>
        Notez que cette option affecte seulement l'opérateur littéral
        <literal>=</>, aucun autre opérateur de comparaison ou aucune autre
        expression qui sont équivalentes en terme de calcul à des expressions
        impliquant l'opérateur égal (telles que <literal>IN</literal>). Du coup,
        cette option n'est pas un correctif général pour une mauvaise
programmation.
       </para>

       <para>
        Référez-vous à la <xref linkend="functions-comparison"> pour des
        informations en relation.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-developer">
    <title>Options pour les développeurs</title>

    <para>
     Les options suivantes ont pour but de travailler sur les sources de
     <productname>PostgreSQL</productname> et, dans certains cas, d'assister
     à une récupération sur des bases de données sévèrement endommagées. Il n'y
     a aucune raison pour les utiliser dans la configuration d'un système de
     production. En tant que tel, elles ont été exclues du fichier d'exemple de
     <filename>postgresql.conf</>. Notez qu'un certain nombre d'entre elles
     requièrent des options de compilation spéciales pour fonctionner.
    </para>

    <variablelist>
     <varlistentry>
      <term><varname>debug_assertions</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Active différentes vérifications des affectations. C'est une aide au
        débogage. Si vous expérimentez des problèmes étranges ou des arrêts
        brutaux, vous pouvez l'activer car cette option pourrait
        exposer des erreurs de programmation. Pour utiliser cette option, la
        macro <literal>USE_ASSERT_CHECKING</literal> doit être définie lors de
        la construction de <productname>PostgreSQL</productname> (ceci
        s'accomplit par l'option <option>--enable-cassert</option> de
        <command>configure</command>). Notez que la valeur de
        <literal>DEBUG_ASSERTIONS</literal> est par défaut active si
        <productname>PostgreSQL</productname> a été construit après ajout
        de l'option ci-dessus.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>pre_auth_delay</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Si différent de zéro, un délai de ce nombre de secondes arrive juste
        après qu'un nouveau processus ne soit créé, avant le processus
        d'authentification. Ceci a pour but de donner une opportunité d'attacher
        un débogueur au processus serveur pour tracer les mauvais comportements
        pendant l'authentification.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_notify</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Génère un grand nombre de sorties de débogage pour les commandes
        <command>LISTEN</command> et <command>NOTIFY</command>.
        <varname>client_min_messages</varname> ou
        <varname>log_min_messages</varname> doivent être
        <literal>DEBUG1</literal> ou plus bas pour envoyer cette sortie sur les
        traces client ou serveur, respectivement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_locks</varname> (<type>boolean</type>)</term>
      <term><varname>trace_lwlocks</varname> (<type>boolean</type>)</term>
      <term><varname>trace_userlocks</varname> (<type>boolean</type>)</term>
      <term><varname>trace_lock_oidmin</varname> (<type>boolean</type>)</term>
      <term><varname>trace_lock_table</varname> (<type>boolean</type>)</term>
      <term><varname>debug_deadlocks</varname> (<type>boolean</type>)</term>
      <term><varname>log_btree_build_stats</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Différentes autres options de trace et de débogage.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>wal_debogue</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Si différent de zéro, active la sortie de débogage relative
        aux WAL.
       </para>
      </listitem>
     </varlistentry>

    <varlistentry>
      <term><varname>zero_damaged_pages</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        La détection d'une en-tête de page endommagée cause généralement le
        rapport d'une erreur par <productname>PostgreSQL</>, l'annulation de la
        transaction courante. Initialiser <varname>zero_damaged_pages</> à vrai
        fait que le système rapporte à la place un avertissement, supprime la
        page endommagée et continue son traitement. Ce comportement
        <emphasis>détruira les données</>, nommément toutes les lignes de la
        page endommagée. Mais cela vous permettra de passer l'erreur et de
        récupérer les lignes des pages non endommagées qui pourraient être
        présentes dans la table. Donc, c'est utile pour récupérer les données si
        la corruption est dûe à une erreur matérielle ou logicielle. Vous ne
        devriez généralement pas configurer cette option à vrai sauf si vous
        abandonnez l'espoir de récupérer les données des pages endommagées d'une
        table. Le paramétrage par défaut est désactivé, et ne peut être modifié
        que par un superutilisateur.
       </para>
      </listitem>
     </varlistentry>
   </variablelist>
  </sect2>
  <sect2 id="runtime-config-short">
   <title>Options courtes</title>

   <para>
    Pour le côté pratique, voici les options sur une lettre en ligne de
    commande disponibles pour certains paramètres. Elles sont décrites dans
    le <xref linkend="runtime-config-short-table">.
   </para>

    <table id="runtime-config-short-table">
     <title>Clés des options courtes</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Option courte</entry>
        <entry>Équivalent</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><option>-B <replaceable>x</replaceable></option></entry>
        <entry><literal>shared_buffers = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-d <replaceable>x</replaceable></option></entry>
        <entry><literal>log_min_messages = DEBUG<replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-F</option></entry>
        <entry><literal>fsync = off</></entry>
       </row>
       <row>
        <entry><option>-h <replaceable>x</replaceable></option></entry>
        <entry><literal>virtual_host = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-i</option></entry>
        <entry><literal>tcpip_socket = on</></entry>
       </row>
       <row>
        <entry><option>-k <replaceable>x</replaceable></option></entry>
        <entry><literal>unix_socket_directory = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-l</option></entry>
        <entry><literal>ssl = on</></entry>
       </row>
       <row>
        <entry><option>-N <replaceable>x</replaceable></option></entry>
        <entry><literal>max_connections = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-p <replaceable>x</replaceable></option></entry>
        <entry><literal>port = <replaceable>x</replaceable></></entry>
       </row>

       <row>
        <entry>
          <option>-fi</option>, <option>-fh</option>,
          <option>-fm</option>, <option>-fn</option>,
          <option>-fs</option>, <option>-ft</option><footnote
          id="fn.runtime-config-short">
           <para>
            Pour des raisons historiques, ces options doivent êtres passées au
            processus serveur individuel via l'option <option>-o</option> de
            <command>postmaster</command>, par exemple,
<screen>
$ <userinput>postmaster -o '-S 1024 -s'</userinput>
</screen>
            ou via <envar>PGOPTIONS</envar> du côté client, comme expliqué
            ci-dessous.
           </para>
          </footnote>
         </entry>
         <entry>
          <literal>enable_indexscan=off</>,
          <literal>enable_hashjoin=off</>,
          <literal>enable_mergejoin=off</>,
          <literal>enable_nestloop=off</>,
          <literal>enable_seqscan=off</>,
          <literal>enable_tidscan=off</>
         </entry>
       </row>

       <row>
        <entry><option>-s</option><footnoteref linkend="fn.runtime-config-short"></entry>
        <entry><literal>log_statement_stats = on</></entry>
       </row>

       <row>
        <entry><option>-S <replaceable>x</replaceable></option><footnoteref linkend="fn.runtime-config-short">
        </entry>
        <entry><literal>sort_mem = <replaceable>x</replaceable></></entry>
       </row>

       <row>
        <entry><option>-tpa</option>, <option>-tpl</option>, <option>-te</option><footnoteref linkend="fn.runtime-config-short"></entry>
        <entry><literal>log_parser_stats=on</>,
        <literal>log_planner_stats=on</>, 
        <literal>log_executor_stats=on</></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect2>
 </sect1>


 <sect1 id="kernel-resources">
  <title>Gérer les ressources du noyau</title>

  <para>
   Une installation importante de <productname>PostgreSQL</> peut rapidement
   épuiser les limites des ressources du système d'exploitation. (Sur certains
   systèmes, les valeurs par défaut sont trop basses que vous n'avez même pas
   besoin d'une installation <quote>importante</>.) Si vous avez rencontré ce
   type de problème, continuez votre lecture.
  </para>

  <sect2 id="sysvipc">
   <title>Mémoire partagée et sémaphore</title>

   <indexterm zone="sysvipc">
    <primary>mémoire partagée</primary>
   </indexterm>

   <indexterm zone="sysvipc">
    <primary>sémaphores</primary>
   </indexterm>

   <para>
    La mémoire partagée et les sémaphores sont nommés collectivement
    <quote><acronym>IPC</><systemitem class="osname">System V</></quote>
    (ensemble avec les queues de messages, qui n'ont pas d'importance pour
    <productname>PostgreSQL</>). Pratiquement tous les systèmes d'exploitation
    modernes fournissent ces fonctionnalités mais parmi elles toutes ne sont pas
    activées ou dimensionnées suffisamment par défaut, spécialement les systèmes
    ayant l'héritage BSD. (Pour les ports <systemitem class="osname">QNX</> et
    <systemitem class="osname">BeOS</>, <productname>PostgreSQL</> fournit sa
    propre implémentation de remplacement de ces fonctionnalités.)
   </para>

   <para>
    Le manque complet de fonctionnalités est généralement manifesté par 
    une erreur <errorname>Illegal system call</> au lancement du serveur. Dans
    ce cas, il n'y a rien à faire à part reconfigurer votre noyau.
    <productname>PostgreSQL</> ne fonctionnera pas sans.
   </para>

   <para>
    Quand <productname>PostgreSQL</> dépasse une des nombreuses limites
    <acronym>IPC</>, le serveur refusera de s'exécuter et lèvera un
    message d'erreur instructif décrivant le problème rencontré et que faire
    avec (voir aussi la <xref linkend="postmaster-start-failures">). Les
    paramètres adéquats du noyau sont nommés de façon cohérente parmi les
    différents systèmes&nbsp;; le <xref linkend="sysvipc-parameters"> donne un
    aperçu. Néanmoins, les méthodes pour les obtenir varient. Les suggestions
    pour quelques plateformes sont données ci-dessous. Attention, il est souvent
    nécessaire de redémarrer votre machine, voire même de recompiler le noyau,
    pour changer ces paramétrages.
   </para>


   <table id="sysvipc-parameters">
    <title>Paramètres <systemitem class="osname">System V</> <acronym>IPC</></>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>Name</>
       <entry>Description</>
       <entry>Valeurs raisonnables</>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><varname>SHMMAX</></>
       <entry>Taille maximum du segment de mémoire partagée (octets)</>
       <entry>250 Ko + 8.2 Ko * <varname>shared_buffers</> + 14.2 Ko *
<varname>max_connections</> jusqu'à l'infini</entry>
      </row>

      <row>
       <entry><varname>SHMMIN</></>
       <entry>Taille minimum du segment de mémoire partagée (octets)</>
       <entry>1</>
      </row>

      <row>
       <entry><varname>SHMALL</></>
       <entry>Total de la mémoire partagée disponible (octets ou pages)</>
       <entry>Si octets, identique à <varname>SHMMAX</varname>&nbsp;; si pages,
        <literal>ceil(SHMMAX/PAGE_SIZE)</literal></>
      </row>

      <row>
       <entry><varname>SHMSEG</></>
       <entry>Nombre maximum de segments de mémoire partagée par
        processus</>
       <entry>Seul un segment est nécessaire mais la valeur par défaut est
        bien plus importante</>
      </row>

       <row>
        <entry><varname>SHMMNI</></>
        <entry>Nombre maximum de segments de mémoire partagée pour
         tout le système</>
        <entry>Comme <varname>SHMSEG</> plus la place pour les autres
         applications</>
       </row>

       <row>
        <entry><varname>SEMMNI</></>
        <entry>Nombre maximum d'identifiants de sémaphores (c'est-à-dire
         d'ensembles)</>
        <entry>Au moins <literal>ceil(max_connections / 16)</literal></>
       </row>

       <row>
        <entry><varname>SEMMNS</></>
        <entry>Nombre maximum de sémaphores rapartis dans le système</>
        <entry><literal>ceil(max_connections / 16) * 17</literal> plus la place
         pour les autres applications</>
       </row>

       <row>
        <entry><varname>SEMMSL</></>
        <entry>Nombre maximum de sémaphores par ensemble</>
        <entry>au moins 17</>
       </row>

       <row>
        <entry><varname>SEMMAP</></>
        <entry>Nombre d'entrées dans la carte des sémaphores</>
        <entry>voir le texte</>
       </row>

       <row>
        <entry><varname>SEMVMX</></>
        <entry>Valeur maximum d'une sémaphore</>
        <entry>au moins 1000 (vaut souvent par défaut 32767, ne pas changer
         sauf si cela vous est demandé.)</>
       </row>

     </tbody>
    </tgroup>
   </table>


   <para>
    <indexterm><primary>SHMMAX</primary></indexterm> Le paramètre de mémoire
    partagé le plus important est <varname>SHMMAX</>, la taille maximum, en
    octets, d'un segment de mémoire partagée. Si vous obtenez un message
    d'erreur à partir de <function>shmget</> comme <errorname>Invalid
    argument</>, il est possible que cette limite soit dépassée. La taille du
    segment de mémoire partagée requise varie à la fois avec le nombre de
    tampons requis (option <option>-B</>) et le nombre de connexions autorisées
    (option <option>-N</>), bien que le premier soir le plus important. (Vous
    pouvez, en solution temporaire, baisser ces paramétrages pour supprimer
    l'échec.) En tant qu'approximation brute, vous pouvez estimer la taille de
    segment requise en multipliant le nombre de tampons et la taille d'un bloc
    (8&nbsp;Ko par défaut) plus un ajout ample (au moins la moitié d'1&nbsp;Mo).
    Tout message d'erreur que vous obtenez contiendra la taille de la requête
    d'allocation échouée.
   </para>

   <para>
    Moins sensible aux problèmes est la taille minimum des segments de mémoire
    partagée (<varname>SHMMIN</>), qui devrait être au plus à environ
    256&nbsp;Ko pour <productname>PostgreSQL</> (il est habituellement à 1). Le
    nombre maximum de segments au travers du système (<varname>SHMMNI</>) ou par
    processus (<varname>SHMSEG</>) ne devrait pas poser problème sauf si votre
    système les a initialisé à zéro. Certains systèmes ont aussi une limite sur
    le nombre total de mémoire partagée dans le système&nbsp;; voir les
    instructions spécifiques à la plateforme ci-dessous.
   </para>

   <para>
    <productname>PostgreSQL</> utilise une sémaphore par connexion autorisée
    (option <option>-N</>), par ensemble de 16. Chacun de ces ensembles
    contiendra aussi une 17è sémaphore qui contient un <quote>nombre
    magique</quote>, pour détecter la collision avec des ensembles de sémaphore
    utilisé par les autres applications. Le nombre maximum de sémaphores dans le
    système est initialisé par <varname>SEMMNS</>, qui en conséquence doit être
    au moins aussi haut que <literal>max_connections</> plus un extra de chacune
    des 16 connexions autorisées (voir la formule dans <xref
    linkend="sysvipc-parameters">). Le paramètre <varname>SEMMNI</> détermine la
    limite sur le nombre d'ensembles de sémaphores qui peuvent exister sur le
    système à un instant précis. Donc, ce paramètre doit être au moins égal à
    <literal>ceil(max_connections / 16)</>. Baisser le nombre de connexions
    autorisées est un contournement temporaire pour les échecs qui sont
    habituellement indiqués par le message <errorname>No space left on
    device</>, à partir de la fonction <function>semget</>.
   </para>

   <para>
    Dans certains cas, il pourrait être nécessaire d'augmenter
    <varname>SEMMAP</> pour être au moins dans l'ordre de <varname>SEMMNS</>. Ce
    paramètre définit la taille de la carte de ressources de sémaphores, dans
    laquelle chaque bloc contigu de sémaphores disponibles ont besoin d'une
    entrée. Lorsqu'un ensemble de sémaphore est libéré ou qu'il est enregistré
    sous une nouvelle entrée de carte. Si la carte est pleine, les sémaphores
    libérées sont perdues (jusqu'au redémarrage). La fragmentation de l'espace
    des sémaphores pourrait amener dans le temps à moins de sémaphores
    disponibles.
   </para>

   <para>
    La paramètre <varname>SEMMSL</>, qui détermine le nombre de sémaphores dans
    un ensemble, pourrait valoir au moins 17 pour <productname>PostgreSQL</>.
   </para>

   <para>
    D'autres paramètres en relation avec l'<quote>annulation de sémaphores</>,
    tels que <varname>SEMMNU</> et <varname>SEMUME</>, ne concernent pas
    <productname>PostgreSQL</>.
   </para>

    <variablelist>

     <varlistentry>
      <term><systemitem class="osname">BSD/OS</></term>
      <indexterm><primary>BSD/OS</><secondary>configuration IPC</></>
      <listitem>
       <formalpara>
        <title>Mémoire partagée</>
        <para>
         Par défaut, seulement 4&nbsp;Mo de mémoire partagée est supportée.
         Gardez en tête que la mémoire partagée n'est pas paginable&nbsp;; elle
         est verrouillée en RAM. Pour accroître la mémoire partagée supportée
         par votre système, ajoutez ce qui suit à la configuration de votre
         noyau. Une valeur de 1024 pour <varname>SHMALL</> représente 4&nbsp;Mo
         de mémoire partagée Ce qui suit augmente l'aire de mémoire partagée
         jusqu'à 32&nbsp;Mo&nbsp;:
<programlisting>
options "SHMALL=8192"
options "SHMMAX=\(SHMALL*PAGE_SIZE\)"
</programlisting>
         Pour ceux utilisant une version 4.3 ou ultérieure, vous aurez
         probablement besoin d'augmenter <varname>KERNEL_VIRTUAL_MB</> au-dessus
         de la valeur par défaut, <literal>248</>. Une fois tous les changements
         effectués, recompilez le noyau et redémarrez.
        </para>
       </formalpara>

       <para>
        Pour ceux utilisant une version 4.0 ou antérieures, utilisez
         <command>bpatch</> pour connaître la valeur <varname>sysptsize</> dans
         le noyau actuel. Elle est calculée dynamiquement au démarrage.
<screen>
$ <userinput>bpatch -r sysptsize</>
<computeroutput>0x9 = 9</>
</screen>
        Ensuite, ajoutez <varname>SYSPTSIZE</> comme valeur codée en dur dans
        le fichier de configuration du noyau. Augmentez la valeur que vous
        trouvez en utilisant <command>bpatch</>. Ajoutez 1 pour chaque
        4&nbsp;Mo supplémentaire de mémoire partagée que vous souhaitez.
<programlisting>
options "SYSPTSIZE=16"
</programlisting>
        <varname>sysptsize</> ne peut pas être modifié
        avec <command>sysctl</command>.
       </para>

       <formalpara>
        <title>Sémaphores</>
        <para>
         Vous pourriez avoir besoin d'augmenter le nombre de sémaphores. Par
         défaut, <productname>PostgreSQL</> alloue 34 sémaphores, qui est à
         moitié au-dessus  du total système par défaut, 60. Initialisez les
         valeurs que vous souhaitez dans le fichier de configuration du
         noyau&nbsp;:
<programlisting>
options "SEMMNI=40"
options "SEMMNS=240"
</programlisting>
        </para>
       </formalpara>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">FreeBSD</></term>
      <term><systemitem class="osname">NetBSD</></term>
      <term><systemitem class="osname">OpenBSD</></term>
      <indexterm><primary>FreeBSD</><secondary>IPC configuration</></>
      <indexterm><primary>NetBSD</><secondary>IPC configuration</></>
      <indexterm><primary>OpenBSD</><secondary>configuration IPC</></>
      <listitem>
       <para>
        Les options <varname>SYSVSHM</> et <varname>SYSVSEM</> doivent être
         activées à la compilation du noyau. (Ils le sont par défaut.) La taille
         maximum de mémoire partagée est déterminée par l'option
         <varname>SHMMAXPGS</> (en pages). Ce qui suit montre un exemple de
         l'initialisation des différents paramètres&nbsp;:
<programlisting>
options         SYSVSHM
options         SHMMAXPGS=4096
options         SHMSEG=256

options         SYSVSEM
options         SEMMNI=256
options         SEMMNS=512
options         SEMMNU=256
options         SEMMAP=256
</programlisting>
        (Sur <systemitem class="osname">NetBSD</> et <systemitem
        class="osname">OpenBSD</>, le mot clé est en fait
        <literal>option</literal> au singulier.)
       </para>
       <para>
        Vous pourriez aussi vouloir configurer votre noyau pour verrouiller la
        mémoire partagée en RAM et l'empêcher d'être paginée en swap. Utilisez
        le paramétrage <literal>kern.ipc.shm_use_phys</> de <command>sysctl</>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">HP-UX</></term>
      <indexterm><primary>HP-UX</><secondary>configuration IPC</></>
      <listitem>
       <para>
        Les paramètres par défaut tendent à suffire pour des installations
        normales. Sur <productname>HP-UX</> 10, la valeur par défaut de
        <varname>SEMMNS</> est 128, qui pourrait être trop basse pour de gros
        sites de bases de données.
       </para>
       <para>
        Les paramètres <acronym>IPC</> peuvent être initialisés dans 
        <application>System Administration Manager</> (<acronym>SAM</>) sous
        <menuchoice><guimenu>Kernel Configuration</><guimenuitem>Configurable
        Parameters</></>. Allez sur <guibutton>Create A New Kernel</> une fois
        terminée.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Linux</></term>
      <indexterm><primary>Linux</><secondary>configuration IPC</></>
      <listitem>
       <para>
        La limite de mémoire partagée par défaut (à la fois
        <varname>SHMMAX</varname> et <varname>SHMALL</varname>) est de
        32&nbsp;Mo pour les noyaux 2.2 mais cela peut se changer dans le système
        de fichiers <filename>proc</filename> (sans redémarrage). Par exemple,
        pour permettre 128&nbsp;Mo&nbsp;:
<screen>
<prompt>$</prompt> <userinput>echo 134217728 >/proc/sys/kernel/shmall</userinput>
<prompt>$</prompt> <userinput>echo 134217728 >/proc/sys/kernel/shmmax</userinput>
</screen>
        Vous pouvez placer ces commandes dans un script exécuté au démarrage.
       </para>

       <para>
        Autrement, vous pouvez utiliser <command>sysctl</command>, si cette
        commande est disponible, pour contrôler ces paramètres. Cherchez un
        fichier nommé <filename>/etc/sysctl.conf</filename> et ajoutez les
        lignes qui suivent&nbsp;:
<programlisting>
kernel.shmall = 134217728
kernel.shmmax = 134217728
</programlisting>
        Ce fichier est habituellement traité au démarrage mais
        <command>sysctl</command> peut aussi être appelé explicitement plus
        tard.
       </para>

       <para>
        D'autres paramètres ont une taille suffisante pour toute application.
        Si vous voulez voir par vous-même, jetez un &oelig;il dans
        <filename>/usr/src/linux/include/asm-<replaceable>xxx</>/shmparam.h</>
        et <filename>/usr/src/linux/include/linux/sem.h</>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">MacOS X</></term>
      <indexterm><primary>MacOS X</><secondary>configuration IPC</></>
      <listitem>
       <para>
        Avec OS X 10.2 et antérieures, éditez le fichier
        <filename>/System/Library/StartupItems/SystemTuning/SystemTuning</>
	et modifiez les valeurs avec les commandes suivantes&nbsp;:
<programlisting>
sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall
</programlisting>
        Avec OS X 10.3, ces commandes ont été déplacées dans
        <filename>/etc/rc</> et doivent être éditées là-bas.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">SCO OpenServer</></term>
      <indexterm><primary>SCO OpenServer</><secondary>configuration IPC</></>
      <listitem>
       <para>
        Dans la configuration par défaut, seuls 512&nbsp;Ko de mémoire partagée
        par segment est autorisé, ce qui est assez pour <option>-B 24 -N
        12</>. Pour augmenter ce paramétrage, allez tout d'abord dans le
        répertoire <filename>/etc/conf/cf.d</>. Pour afficher la valeur courante
        de <varname>SHMMAX</>, lancez
<programlisting>
./configure -y SHMMAX
</programlisting>
        Pour configurer une nouvelle valeur de <varname>SHMMAX</>, lancez
<programlisting>
./configure SHMMAX=<replaceable>valeur</>
</programlisting>
        où <replaceable>value</> est la nouvelle valeur que vous voulez utiliser
        (en octets). Après avoir configuré <varname>SHMMAX</>, reconstruisez le
        noyau&nbsp;:
<programlisting>
./link_unix
</programlisting>
        et redémarrez.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Solaris</></term>
      <indexterm><primary>Solaris</><secondary>configuration IPC</></>
      <listitem>
       <para>
        Au moins dans la version 2.6, la taille maximum par défaut des segments
        de mémoire partagée est trop basse pour <productname>PostgreSQL</>. Le
        paramétrage adéquat peut être modifié dans <filename>/etc/system</>, par
        exemple&nbsp;:
<programlisting>
set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32
</programlisting>
        Vous avez besoin de redémarrer pour que les modifications prennent
        effet.
       </para>

       <para>
        Voir aussi <ulink      
url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"></>
        pour des informations sur la mémoire partagée sous
        <productname>Solaris</>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">UnixWare</></term>
      <indexterm><primary>UnixWare</><secondary>configuration IPC</></>
      <listitem>
       <para>
        Avec <productname>UnixWare</> 7, la taille maximum des segments de
        mémoire partagée est de 512&nbsp;Ko dans la configuration par défaut.
        Ceci est suffisant pour <option>-B 24 -N 12</>. Pour afficher la valeur
        courante de <varname>SHMMAX</>, lancez
<programlisting>
/etc/conf/bin/idtune -g SHMMAX
</programlisting>
        qui affiche la valeur courante, par défaut, minimum et
        maximum. Pour configurer une nouvelle valeur de <varname>SHMMAX</>,
        lancez
<programlisting>
/etc/conf/bin/idtune SHMMAX <replaceable>valeur</>
</programlisting>
        où <replaceable>valeur</> est la nouvelle valeur que vous voulez
        utiliser (en octets). Après avoir initialisé <varname>SHMMAX</>,
        reconstruisez le noyau&nbsp;:
<programlisting>
/etc/conf/bin/idbuild -B
</programlisting>
        et relancez.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

  </sect2>


  <sect2>
   <title>Limites de ressources</title>

   <para>
    Les systèmes d'exploitation style Unix renforcent différents types de
    limites de ressources qui pourraient interférer avec les opérations de votre
    serveur <productname>PostgreSQL</productname>. Les limites sur le nombre de
    processus par utilisateur, le nombre de fichiers ouverts par un processus et la
    taille mémoire disponible pour chaque processus sont d'une grande
    importance. Chacun d'entre elles ont une limite <quote>dure</quote> et une
    limite <quote>souple</quote>. La limite souple est réellement ce qui compte
    mais cela pourrait être changé par l'utilisateur jusqu'à la limite dure. La
    limite dure pourrait seulement être modifié par l'utilisateur root. L'appel
    système <function>setrlimit</function> est responsable de l'initialisation
    de ces paramètres. La commande interne du shell <command>ulimit</command>
    (shells Bourne) ou <command>limit</command> (<application>csh</>) est
    utilisé pour contrôler les limites de ressource à partir de la ligne de
    commande. Sur les systèmes dérivés BSD, le fichier
    <filename>/etc/login.conf</filename> contrôle les différentes limites de
    ressource initialisées à la connexion. Voir la documentation du système
    d'exploitation pour les détails. Les paramètres en question sont
    <varname>maxproc</varname>, <varname>openfiles</varname> et
    <varname>datasize</varname>. Par exemple&nbsp;:
<programlisting>
default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...
</programlisting>
    (<literal>-cur</literal> est la limite douce. Ajoutez
    <literal>-max</literal> pour configurer la limite dure.)
   </para>

   <para>
    Les noyaux peuvent aussi avoir des limites sur le système complet pour
    certaines ressources.
    <itemizedlist>
     <listitem>
      <para>
      Sur <productname>Linux</productname>,
      <filename>/proc/sys/fs/file-max</filename> détermine le nombre maximum de
      fichiers ouverts que le noyau supportera. Ce nombre est modifiable en
      écrivant un autre nombre dans le fichier ou en ajoutant une affectation
      dans <filename>/etc/sysctl.conf</filename>. La limite des fichiers par
      processus est fixée lors de la compilation du noyau&nbsp;; voir
      <filename>/usr/src/linux/Documentation/proc.txt</filename> pour plus
      d'informations.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Le serveur <productname>PostgreSQL</productname> utilise un processus par
    connexion de façon à ce que vous puissiez fournir au moins autant de
    processus que de connexions autorisées, en plus de ce dont vous avez besoin
    pour le reste de votre système. Ceci n'est habituellement pas un problème
    mais si vous exécutez plusieurs serveurs sur une seule machine, cela
    pourrait devenir étroit.
   </para>

   <para>
    La limite par défaut des fichiers ouverts est souvent initialisée pour être
    <quote>amicalement sociale</quote>, pour permettre à de nombreux
    utilisateurs de coexister sur une machine sans utiliser une fraction
    inappropriée des ressources du système. Si vous lancez un grand nombre de
    serveurs sur une machine, cela pourrait être quelque chose que vous
    souhaitez mais sur les serveurs dédiés, vous pourriez vouloir augmenter
    cette limite.
   </para>

   <para>
    D'un autre côté, certains systèmes autorisent l'ouverture d'un grand
    nombre de fichiers à des processus individuels&nbsp;; si un plus grand
    nombre le font, alors les limites du système peuvent facilement être
    dépassées. Si vous rencontrez ce cas et que vous ne voulez pas modifier la
    limite du système, vous pouvez initialiser le paramètre de configuration
    <varname>max_files_per_process</varname> de
    <productname>PostgreSQL</productname> pour limiter la consommation de
    fichiers ouverts.
   </para>
  </sect2>

  <sect2>
   <title>Linux Memory Overcommit</title>

   <para>
    Dans Linux 2.4 et suivants, le comportement par défaut de la mémoire
    virtuelle n'est pas optimal pour <productname>PostgreSQL</productname>.
    Du fait de l'implémentation du <quote>memory overcommit</quote> par le
    noyau, celui-ci peut arrêter le serveur
    <productname>PostgreSQL</productname> (le processus serveur
    maître, <quote>postmaster</quote>) si les demandes de mémoire d'un autre
    processus provoque un manque de mémoire virtuelle au niveau du système.
   </para>

   <para>
    Si ceci arrive, vous verrez un message du noyau qui ressemble à ceci
    (consultez la documentation et la configuration de votre système pour savoir
    où chercher un tel message)&nbsp;:
<programlisting>
Out of Memory: Killed process 12345 (postmaster). 
</programlisting>
    Ceci indique que le processus <filename>postmaster</filename> a été terminé
    à cause d'un problème de mémoire. Bien que les connexions en cours
    continueront de fonctionner normalement, aucune nouvelle
    connexion ne sera acceptée. Pour revenir à un état normal,
    <productname>PostgreSQL</productname> devra être relancé.
   </para>

   <para>
    Une façon d'éviter ce problème revient à lancer
    <productname>PostgreSQL</productname> sur une machine où vous pouvez vous
    assurer que les autres processus ne mettront pas la machine en manque de
    mémoire.
   </para>

   <para>
    Sur Linux 2.6 et ultérieure, une meilleure solution est de modifier le
    comportement du noyau de façon à ce qu'il n'<quote>overcommit</> pas la
    mémoire. Ceci se fait en sélectionnant le mode overcommit strict via
    sysctl&nbsp;:
<programlisting>
sysctl -w vm.overcommit_memory=2
</programlisting>
    ou en plaçant une entrée équivalente dans <filename>/etc/sysctl.conf</>.
    Vous pourriez souhaiter modifier le paramétrage relatif
    <literal>vm.overcommit_ratio</>. Pour les détails, voir la documentation du
    noyau (<filename>Documentation/vm/overcommit-accounting</>).
   </para>

   <para>
    Quelques noyaux 2.4 de vendeurs ont des pré-versions de l'overcommit du
    2.6. Néanmoins, configurer <literal>vm.overcommit_memory</> à 2 sur un noyau
    qui n'a pas le code correspondant rendra les choses pires qu'elles
    n'étaient. Il est recommandé d'inspecter le code source du noyau (voir la
    fonction <function>vm_enough_memory</> dans le fichier
    <filename>mm/mmap.c</>) pour vérifier ce qui est supporté dans votre copie
    avant d'essayer ceci avec une installation 2.4. La présence du fichier de
    documentation <filename>overcommit-accounting</> ne devrait <emphasis>pas</>
    être pris comme une preuve de la présence de cette fonctionnalité. En cas de
    doute, consultez un expert du noyau ou le vendeur de votre noyau.
   </para>
  </sect2>
 </sect1>


 <sect1 id="postmaster-shutdown">
  <title>Arrêter le serveur</title>

  <indexterm zone="postmaster-shutdown">
   <primary>arrêt</>
  </indexterm>

  <para>
   Il existe plusieurs façons d'arrêter le serveur de bases de données. Vous
   contrôlez le type d'arrêt en envoyant différents signaux au processus
   <command>postmaster</command>.

   <variablelist>
    <varlistentry>
     <term><systemitem>SIGTERM</systemitem><indexterm><primary>SIGTERM</></></term>
     <listitem>
      <para>
       Après réception de <systemitem>SIGTERM</systemitem>, le serveur
       désactive les nouvelles connexions mais permet aux sessions en cours de
       terminer leur travail normalement. Il s'arrête seulement après que toutes
       les sessions se sont terminées normalement. C'est l'arrêt intelligent
       (<firstterm>Smart Shutdown</firstterm>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGINT</systemitem><indexterm><primary>SIGINT</></></term>
     <listitem>
      <para>
       Le serveur désactive les nouvelles connexions et envoie à tous
       les processus serveur le signal <systemitem>SIGTERM</systemitem>, qui les
       fera annuler leurs transactions courantes pour quitter rapidement. Il
       attend ensuite la fin des processus serveur et s'arrête finalement.
       C'est l'arrêt rapide (<firstterm>Fast Shutdown</firstterm>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGQUIT</systemitem><indexterm><primary>SIGQUIT</></></term>
     <listitem>
      <para>
      Voici l'arrêt immédiat (<firstterm>Immediate Shutdown</firstterm>), qui
       demande au processus <command>postmaster</command> d'envoyer un signal
       <systemitem>SIGQUIT</systemitem> à tous les processus fils et à quitter
       immédiatement (non proprement). Les processus fils quittent immédiatement
       à réception du signal <systemitem>SIGQUIT</systemitem>. Ceci amènera une
       tentative de récupération (en rejouant les traces WAL) au prochain
       lancement. Ceci n'est recommandé que dans les cas d'urgence.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <important>
    <para>
     Il est préférable de ne pas utiliser <systemitem>SIGKILL</systemitem> pour
     arrêter le serveur. Ceci empêchera le serveur de vider la mémoire
     partagée et les sémaphores, ce qui, du coup, devra être fait
     manuellement.
    </para>
   </important>

  <para>
   Le <acronym>PID</> du processus <command>postmaster</command> est
   récupérable avec le programme <command>ps</command> ou à partir du fichier
   <filename>postmaster.pid</filename> dans le répertoire des données. Donc,
   par exemple, pour demander un arrêt rapide&nbsp;:
<screen>
$ <userinput>kill -INT `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput>
</screen>
  </para>
  <para>
   Le programme <command>pg_ctl</command> est un script shell qui fournit une
   interface agréable pour arrêter le serveur.
  </para>
 </sect1>

 <sect1 id="ssl-tcp">
  <title>Connexions TCP/IP sécurisées avec SSL</title>

  <indexterm zone="ssl-tcp">
   <primary>SSL</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</> dispose d'un support natif pour l'utilisation de
    connexions <acronym>SSL</>, cryptant ainsi les communications
    clients/serveurs pour une sécurité améliorée. Ceci requiert l'installation
    d'<productname>OpenSSL</productname> à la fois sur le système client et sur
    le système serveur et que ce support soit activé au moment de la
    construction de <productname>PostgreSQL</> (voir le <xref
    linkend="installation">).
  </para>

  <para>
   Avec le support <acronym>SSL</> compilé, le serveur
   <productname>PostgreSQL</> peut être lancé avec
   <acronym>SSL</> activé en activant <varname>ssl</varname> dans
   <filename>postgresql.conf</>. Lors d'un démarrage en mode <acronym>SSL</>, le
   serveur cherchera les fichiers <filename>server.key</> et
   <filename>server.crt</> dans le répertoire des données, qui devraient
   contenir respectivement la clé privée du serveur et le certificat. Ces
   fichiers doivent être configurés correctement avant qu'un serveur dont le
   mode <acronym>SSL</> est activé puisse démarrer. Si la clé privée est
   protégée avec une phrase, le serveur la demandera  et ne se lancera pas tant
   que celle-ci n'aura pas été saisie.
  </para>

  <para>
   Le serveur écoutera les connexions <acronym>SSL</> et standard sur le même
   port TCP et négociera avec tout client se connectant qu'il utilise ou non
   <acronym>SSL</>. Voir le <xref linkend="client-authentication"> pour savoir
   comment forcer l'utilisation de <acronym>SSL</> pour certaines connexions.
  </para>

  <para>
   Pour les détails sur la création de la clé privé et du certificat du serveur,
   référez-vous à la documentation d'<productname>OpenSSL</> documentation. Un
   simple certificat signé par soi-même peut être utilisé pour commencer les 
   tests mais un certificat signé par une autorité (<acronym>CA</>) (soit un des
   <acronym>CA</> globaux soit un local) devrait être utilisé en production de
   façon à ce que le client puisse vérifier l'identité du serveur. Pour créer
   rapidement un certificat signé soi-même, utilisez la commande
   <productname>OpenSSL</productname> suivante&nbsp;:
<programlisting>
openssl req -new -text -out server.req
</programlisting>
   Remplissez les informations que <command>openssl</> réclame. Assurez-vous
   que vous entrez le nom local de l'hôte sur <quote>Common Name</>&nbsp;; le
   mot de passe de challenge peut être laissé vide. Le programme générera une
   clé qui est protégée par une phrase&nbsp;; elle n'acceptera pas une phrase
   qui fait moins de quatre caractères. Pour supprimer la phrase (ce que vous
   devez faire si vous voulez automatiser le lancement du serveur), lancez les
   commandes
<programlisting>
openssl rsa -in privkey.pem -out server.key
rm privkey.pem
</programlisting>
   Saisissez l'ancienne phrase pour débloquer la clé existante. Maintenant,
   saisissez
<programlisting>
openssl req -x509 -in server.req -text -key server.key -out server.crt
chmod og-rwx server.key
</programlisting>
   pour remplacer le certificat en un certificat signé par soi-même et copiez la
   clé et le certificat là où le serveur les cherchera.
  </para>
 </sect1>

 <sect1 id="ssh-tunnels">
  <title>Connexions TCP/IP sécurisées avec des tunnels
   <application>SSH</application> Tunnels</title>

  <indexterm zone="ssh-tunnels">
   <primary>ssh</primary>
  </indexterm>

  <para>
   Vous pouvez utiliser <application>SSH</application> pour crypter la
   connexion réseau entre les clients et un serveur
   <productname>PostgreSQL</productname>. Réalisé correctement, ceci fournit une
   connexion réseau sécurisée.
  </para>

  <para>
   Tout d'abord, assurez-vous qu'un serveur <application>SSH</application> est
   en cours d'exécution sur la même machine que le serveur
   <productname>PostgreSQL</productname> et que vous pouvez vous connecter via
   <command>ssh</command> en tant qu'un utilisateur quelconque. Ensuite, vous
   pouvez établir un tunnel sécurisé avec une commande comme ceci sur la machine
   cliente&nbsp;:
<programlisting>
ssh -L 3333:foo.com:5432 joe@foo.com
</programlisting>
   Le premier numéro de l'argument <option>-L</option>, 3333, est le numéro de
port de votre bout du tunnel&nbsp;; il peut être choisi librement. Le second
numéro, 5432, est le bout distant du tunnel&nbsp;: le numéro de port que votre
serveur utilise. Le nom ou l'adresse entre les numéros de port est l'hôte
disposant du serveur de bases de données auquel vous souhaitez vous connecter.
Pour cela, vous vous connectez au port 3333 de votre machine locale&nbsp;:
<programlisting>
psql -h localhost -p 3333 template1
</programlisting>
   Sur le serveur de bases de données, il semblera que vous êtes réellement
   l'utilisateur <literal>joe@foo.com</literal> et il utilisera la procédure
   d'authentification adéquate pour cet utilisateur. Pour que la configuration
   du serveur réussisse, vous devez être autorisé à vous connecter via
   <command>ssh</command> en tant que <literal>joe@foo.com</literal>, comme si
   vous essayez d'utiliser <command>ssh</command> pour configurer une session
   terminal.
  </para>

  <tip>
   <para>
    Plusieurs autres applications existantes peuvent fournir des tunnels
   sécurisés en utilisant une procédure similaire dans le concept à celle que
   nous venons de décrire.
   </para>
  </tip>

 </sect1>

</Chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
