<?xml version="1.0" encoding="UTF-8"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/runtime.sgml,v 1.24 2005/09/22 18:34:43 guillaume Exp $ -->

<chapter id="runtime">
 <title>Environnement du système d'exploitation</title>

 <para>
  Ce chapitre discute de la configuration, du lancement du serveur de bases de
  données et de ses interactions avec le système d'exploitation.
 </para>

 <sect1 id="postgres-user">
  <title>Compte utilisateur <productname>PostgreSQL</productname></title>

  <indexterm>
   <primary>utilisateur postgres</primary>
  </indexterm>

  <para>
   Comme avec tout autre démon serveur accessible au monde externe, il est
   conseillé de lancer <productname>PostgreSQL</productname> sous un compte
   utilisateur séparé. Ce compte devrait seulement être le propriétaire des
   données gérées par le serveur et ne devrait pas être partagé avec d'autres
   démons (par exemple, utiliser l'utilisateur <literal>nobody</literal> est
   une mauvaise idée). Il n'est pas conseillé de changer le propriétaire des
   exécutables par cet utilisateur car les systèmes compromis pourraient alors
   se voir modifier leur propres binaires.
  </para>

  <para>
   Pour ajouter un compte utilisateur Unix, jetez un &oelig;il à la commande
   <command>useradd</command> ou <command>adduser</command> de votre système.
   Le nom de l'utilisateur <systemitem>postgres</systemitem> est souvent utilisé
   et l'est sur tout le livre, mais vous pouvez utiliser un autre nom si vous le
   souhaitez.
  </para>
 </sect1>

 <sect1 id="creating-cluster">
  <title>Créer un groupe de base de données</title>

  <indexterm>
   <primary>groupe de bases de données</primary>
  </indexterm>

  <indexterm>
   <primary>emplacement des données</primary>
   <see>groupe de bases de données</see>
  </indexterm>

  <para>
   Avant de faire quoi que ce soit, vous devez initialiser un emplacement de
   stockage pour la base de données. Nous appelons ceci un <firstterm>groupe de
   bases de données</firstterm> (<acronym>sql</acronym> utilise
   le terme de groupe de catalogues). Un groupe de bases de données est une
   collection de bases données et est géré par une seule instance d'un
   serveur de bases de données en cours d'exécution. Après initialisation, un
   groupe de bases de données contiendra une base de données nommée
   <literal>postgres</literal>, qui a pour but d'être la base de données par
   défaut utilisée par les outils, les utilisateurs et les applications
   tiers. Le serveur de la base de données lui-même ne requiert pas la présence
   de la base de données <literal>postgres</literal> mais beaucoup d'outils
   supposent son existence. Une autre base de données est créée à l'intérieur
   de chaque groupe lors de l'initialisation. Elle est appelée
   <literal>template1</literal>. Comme le nom le suggère, elle sera utilisée
   comme modèle pour les bases de données créées après&nbsp;; elle ne devrait
   pas être utilisée pour un vrai travail (voir le <xref
   linkend="managing-databases"/> pour des informations sur la création de
   nouvelles bases de données dans le groupe).
  </para>

  <para>
   En terme de système de fichiers, un groupe de bases de données sera un
   simple répertoire sous lequel les données seront stockées. Nous l'appelons le
   <firstterm>répertoire de données</firstterm> ou l'<firstterm>emplacement des
   données</firstterm>. Le choix de cet emplacement vous appartient complètement.
   Il n'existe pas de valeur par défaut bien que les emplacements tels que
   <filename>/usr/local/pgsql/data</filename> ou
   <filename>/var/lib/pgsql/data</filename> sont populaires. Pour initialiser un
   groupe de bases de données, utilisez la commande <xref
   linkend="app-initdb"/>,<indexterm><primary>initdb</primary></indexterm> installée avec
   <productname>PostgreSQL</productname>. L'emplacement désiré sur le groupe de
   fichier est indiqué par l'option <option>-d</option>, par exemple
<screen><prompt>$</prompt> <userinput>initdb -d /usr/local/pgsql/data</userinput></screen>
   Notez que vous devez exécuter cette commande en étant connecté sous le compte
   de l'utilisateur <productname>PostgreSQL</productname> décrit dans la section
   précédente.
  </para>

  <tip>
   <para>
    Comme alternative à l'option <option>-d</option>, vous pouvez initialiser
    la variable d'environnement <envar>pgdata</envar>.
    <indexterm><primary><envar>pgdata</envar></primary></indexterm>
   </para>
  </tip>

  <para>
   <command>initdb</command> tentera de créer le répertoire que vous avez
   spécifié si celui-ci n'existe pas déjà. Il est possible qu'il n'ait pas le
   droit de le faire (si vous avez suivi notre conseil et créé un compte sans
   droits). Dans ce cas, vous devez créer le répertoire vous-même (en tant que
   root) et modifier le propriétaire pour qu'il corresponde à l'utilisateur
   <productname>PostgreSQL</productname>. Voici comment réaliser ceci&nbsp;:
<screen>root# <userinput>mkdir /usr/local/pgsql/data</userinput>
root# <userinput>chown postgres /usr/local/pgsql/data</userinput>
root# <userinput>su postgres</userinput>
postgres$ <userinput>initdb -d /usr/local/pgsql/data</userinput></screen>
  </para>

  <para>
   <command>initdb</command> refusera de s'exécuter si le répertoire des données
   semble être déjà initialisé.</para>

  <para>
   Comme le répertoire des données contient toutes les données stockées par 
   le système de bases de données, il est essentiel qu'il soit sécurisé par
   rapport à des accès non autorisés. Du coup, <command>initdb</command>
   supprimera les droits d'accès à tout le monde sauf l'utilisateur
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   Néanmoins, bien que le contenu du répertoire soit sécurisé, la configuration
   d'authentification du client par défaut permet à tout utilisateur local de se
   connecter à la base de données et même à devenir le super-utilisateur de
   la base de données. Si vous ne faites pas confiance aux utilisateurs
   locaux, nous vous recommandons d'utiliser une des options <option>-w</option> ou
   <option>--pwprompt</option> de la commande <command>initdb</command> pour
   affecter un mot de passe au super-utilisateur de la base de
   données <indexterm><primary>mot de passe</primary><secondary>du
   super-utilisateur</secondary></indexterm>. De plus, spécifiez <option>-a md5</option> ou
   <option>-a mot_de_passe</option> de façon à ce que la méthode d'authentification
   <literal>trust</literal> par défaut ne soit pas utilisée&nbsp;; ou modifiez le fichier
   <filename>pg_hba.conf</filename> généré après l'exécution
   d'<command>initdb</command> (d'autres
   approches raisonnables incluent l'utilisation de l'authentification
   <literal>ident</literal> ou les droits du système de fichiers pour
   restreindre les connexions. Voir le <xref
   linkend="client-authentication"/> pour plus d'informations).
  </para>

  <para>
   <command>initdb</command> initialise aussi la
   locale<indexterm><primary>locale</primary></indexterm> par défaut du groupe de bases de
   données. Normalement, elle prends seulement le paramétrage local dans
   l'environnement et l'applique à la base de données initialisée. Il est
   possible de spécifier une locale différente pour la base de données&nbsp;;
   la <xref linkend="locale"/> propose plus d'informations là-dessus.
   L'ordre de tri utilisé à l'intérieur du groupe de bases de données est
   initialisé par <command>initdb</command> et ne peut pas être modifié après,
   en dehors de la sauvegarde des données, du redémarrage de
   <command>initdb</command> et du rechargement des données. Il y a aussi un
   impact sur les performances lors de l'utilisation de locales autres que
   <literal>c</literal> ou <literal>posix</literal>. Du coup, il est important de faire ce
   choix correctement la première fois.
  </para>

  <para>
   <command>initdb</command> configure aussi le codage par défaut de l'ensemble
   de caractères pour le groupe de bases de données. Normalement, cela doit
   être choisi pour correspondre au paramétrage de la locale. Pour les détails,
   voir la <xref linkend="multibyte"/>.
  </para>
 </sect1>

 <sect1 id="server-start">
  <title>Lancer le serveur de bases de données</title>

  <para>
   Avant qu'une personne ait accès à la base de données, vous devez démarrer le
serveur de bases de données. Le programme serveur est appelé
<command>postgres</command><indexterm><primary>postgres</primary></indexterm>. Le
programme <command>postgres</command> doit savoir où trouver les données qu'il est
supposé utiliser. Ceci se fait avec l'option <option>-d</option>. Du coup, la
façon la plus simple de lancer le serveur est&nbsp;:
<screen>$ <userinput>postgres -d /usr/local/pgsql/data</userinput></screen>
   qui laissera le serveur s'exécuter en avant plan. Pour cela, vous devez être
   connecté en utilisant le compte de l'utilisateur
   <productname>PostgreSQL</productname>. Sans l'option <option>-d</option>, le serveur
   essaiera d'utiliser le répertoire de données nommé par la variable
   d'environnement <envar>pgdata</envar>. Si cette variable ne le fournit pas
   non plus, le lancement échouera.
  </para>

  <para>
   Habituellement, il est préférable de lancer <command>postgres</command> en tâche
   de fond. Pour cela, utilisez la syntaxe shell habituelle&nbsp;:
<screen>$ <userinput>postgres -d /usr/local/pgsql/data &gt;journaux_trace 2&gt;&amp;1 &amp;</userinput></screen>
   Il est important de sauvegarder les sorties <systemitem>stdout</systemitem> et
   <systemitem>stderr</systemitem> du serveur quelque part, comme montré ci-dessus. Cela
   vous aidera dans des buts d'audits ou pour diagnostiquer des problèmes (voir
   la <xref linkend="logfile-maintenance"/> pour une discussion plus détaillée
   de la gestion de journaux de trace).
  </para>

  <para>
   Le programme <command>postgres</command> prend aussi un certain nombre d'autres
   options en ligne de commande. Pour plus d'informations, voir la page de
   référence <xref linkend="app-postmaster"/> ainsi que le <xref
   linkend="runtime-config"/> ci-dessous.
  </para>

  <para>
   Cette syntaxe shell peut rapidement devenir ennuyante. Donc, le programme
   d'emballage <xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>
   est fourni pour simplifier certaines tâches. Par exemple&nbsp;:
<programlisting>pg_ctl start -l journaux_trace</programlisting>
   lancera le serveur en tâche de fond et placera les sorties dans le journal 
   de trace indiqué. L'option <option>-d</option> a la même signification ici
   que pour <command>postgres</command>. <command>pg_ctl</command> est aussi
   capable d'arrêter le serveur.
  </para>

  <para>
   Normalement, vous lancerez le serveur de bases de données lors du
   démarrage de l'ordinateur <indexterm><primary>démarrage</primary><secondary>au
   lancement du serveur</secondary></indexterm>. Les scripts de lancement automatique sont
   spécifiques au système d'exploitation. Certains sont distribués avec
   <productname>PostgreSQL</productname> dans le répertoire
   <filename>contrib/start-scripts</filename>. En installer un demandera les
   droits de root.
  </para>

  <para>
   Différents systèmes ont différentes conventions pour lancer les démons au
   démarrage. La plupart des systèmes ont un fichier
   <filename>/etc/rc.local</filename> ou
   <filename>/etc/rc.d/rc.local</filename>. D'autres utilisent les répertoires
   <filename>rc.d</filename>. Quoi que vous fassiez, le serveur doit être exécuté par le
   compte utilisateur <productname>PostgreSQL</productname> <emphasis>et non pas
   par root</emphasis> ou tout autre utilisateur. Donc, vous devriez
   probablement former vos commandes en utilisant <literal>su -c '...' 
   postgres</literal>. Par exemple&nbsp;:
<programlisting>su -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog' postgres</programlisting>
  </para>

  <para>
   Voici quelques suggestions supplémentaires par système d'exploitation
   (dans chaque cas, assurez-vous d'utiliser le bon répertoire d'installation et
   le bon nom de l'utilisateur où nous montrons des valeurs génériques).

   <itemizedlist>
    <listitem>
     <para>
      Pour <productname>freebsd</productname>, regardez le fichier
      <filename>contrib/start-scripts/freebsd</filename> du répertoire des
      sources de <productname>PostgreSQL</productname>.
      <indexterm><primary>freebsd</primary><secondary>script de
      lancement</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>openbsd</productname>, ajoutez les lignes suivantes à
      votre fichier <filename>/etc/rc.local</filename>&nbsp;:
      <indexterm><primary>openbsd</primary><secondary>script de
      lancement</secondary></indexterm>
<programlisting>if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su - -c '/usr/local/pgsql/bin/pg_ctl start -l /var/PostgreSQL/log -s' postgres
    echo -n ' PostgreSQL'
fi</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur les systèmes <productname>linux</productname>, soit vous ajoutez
      <indexterm><primary>linux</primary><secondary>script de lancement</secondary></indexterm>
<programlisting>/usr/local/pgsql/bin/pg_ctl start -l journaux_trace -D /usr/local/pgsql/data</programlisting>
      à <filename>/etc/rc.d/rc.local</filename> soit vous jetez un &oelig;il à
      <filename>contrib/start-scripts/linux</filename> dans le répertoire des
      sources de <productname>PostgreSQL</productname>.
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>netbsd</productname>, vous pouvez utiliser les scripts
      de lancement de <productname>freebsd</productname> ou de
      <productname>linux</productname> suivant vos préférences.
      <indexterm><primary>netbsd</primary><secondary>script de lancement</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      Sur <productname>solaris</productname>, créez un fichier appelé
      <filename>/etc/init.d/PostgreSQL</filename> et contenant la ligne
      suivante&nbsp;:
      <indexterm><primary>solaris</primary><secondary>script de
      lancement</secondary></indexterm>
<programlisting>su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l journaux_trace -D /usr/local/pgsql/data"</programlisting>
      Puis, créez un lien symbolique vers lui dans <filename>/etc/rc3.d</filename> de
      nom <filename>s99PostgreSQL</filename>.
     </para>
    </listitem>
   </itemizedlist>

  </para>

   <para>
    Tant que le serveur est lancé, son
    <acronym>pid</acronym> est stocké dans le fichier
    <filename>postmaster.pid</filename> du répertoire de données. C'est utilisé
    pour empêcher plusieurs instances du serveur d'être exécutées dans le même
    répertoire de données et peut aussi être utilisé pour arrêter le processus
    le serveur.
   </para>

   <sect2 id="server-start-failures">
    <title>Échecs de lancement</title>

    <para>
     Il existe de nombreuses raisons habituelles pour lesquelles le serveur
     échouerait au lancement. Vérifiez le journal des traces du serveur ou
     lancez-le manuellement (sans redirection des sorties standard et d'erreur)
     et regardez les messages d'erreurs qui apparaissent. Nous en expliquons
     certains ci-dessous parmi les messages d'erreurs les plus communs.
    </para>

    <para>
<screen>LOG:  could not bind IPv4 socket: Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket</screen>
     Ceci signifie seulement ce que cela suggère&nbsp;: vous avez essayé de lancer
     un autre serveur sur le même port où un autre est en 
     cours d'exécution. Néanmoins, si le message d'erreur du noyau 
     n'est pas <computeroutput>address already in use</computeroutput> ou une
     quelconque variante, il pourrait y avoir un autre problème. Par
     exemple, essayer de lancer un serveur sur un numéro
     de port réservé pourrait avoir ce résultat&nbsp;:
<screen>$ <userinput>postgres -p 666</userinput>
LOG:  could not bind IPv4 socket: Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket</screen>
    </para>

    <para>
     Un message du type
<screen>FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).</screen>
     signifie probablement que les limites de votre noyau sur la taille de 
     la mémoire partagée est plus petite que l'aire de fonctionnement que
     <productname>PostgreSQL</productname> essaie de créer (4011376640 octets
     dans cet exemple). Ou il pourrait signifier que vous n'avez pas du tout
     configuré le support de la mémoire partagée de type System-V dans votre
     noyau. Comme contournement temporaire, vous pouvez essayer de lancer le
     serveur avec un nombre de tampons plus petit que la normale
     (<xref linkend="guc-shared-buffers"/>). Éventuellement, vous pouvez
     reconfigurer votre noyau pour accroître la taille de mémoire partagée
     autorisée. Vous pourriez voir aussi ce message en essayant d'exécuter
     plusieurs serveurs sur la même machine si le total de l'espace qu'ils
     requièrent dépasse la limite du noyau.
    </para>

    <para>
     Une erreur du type
<screen>FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).</screen>
     ne signifie <emphasis>pas</emphasis> qu'il vous manque de l'espace disque.
     Elle signifie que la limite de votre noyau sur le nombre de sémaphores
     <systemitem class="osname">system v</systemitem> est inférieure au nombre que
     <productname>PostgreSQL</productname> veut créer. Comme ci-dessus, vous
     pouvez contourner le problème en lançant le serveur avec un nombre
     réduit de connexions autorisées (<xref linkend="guc-max-connections"/>)
     mais vous voudrez éventuellement augmenter la limite du noyau.
    </para>

    <para>
     Si vous obtenez une erreur <quote>illegal system call</quote>, il est probable
     que la mémoire partagée ou les sémaphores ne sont pas du tout supportés par
     votre noyau. Dans ce cas, votre seule option est de reconfigurer le noyau
     pour activer ces fonctionnalités.
    </para>

    <para>
     Des détails sur la configuration des capacités <acronym>ipc</acronym> <systemitem
     class="osname">System V</systemitem> sont donnés dans la <xref linkend="sysvipc"/>.
    </para>
   </sect2>

   <sect2 id="client-connection-problems">
    <title>Problèmes de connexion du client</title>

    <para>
     Bien que les conditions d'erreurs possibles du côté client sont assez
     variées et dépendantes de l'application, certaines pourraient être en
     relation direct avec la façon dont le serveur a été lancé. Les conditions
     autres que celles montrées ici devraient être documentées avec
     l'application client respective.
    </para>

    <para>
<screen>psql: could not connect to server: Connection refused
        Is the server running on host "server.joe.com" and accepting
        TCP/IP connections on port 5432?</screen>
     Ceci est l'échec générique <quote>je n'ai pas trouvé de serveur à qui
     parler</quote>. Cela ressemble au message ci-dessus lorsqu'une connexion
     TCP/IP est tentée. Une erreur commune est d'oublier de configurer le
     serveur pour qu'il autorise les connexions TCP/IP.
    </para>

    <para>
     Autrement, vous obtiendrez ceci en essayant une communication de type
     socket de domaine Unix vers un serveur local&nbsp;:
<screen>psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?</screen>
    </para>

    <para>
     La dernière ligne est utile pour vérifier si le client essaie de se
     connecter au bon endroit. Si aucun serveur n'est exécuté ici, le
     message d'erreur du noyau sera typiquement soit <computeroutput>connection
     refused</computeroutput> soit <computeroutput>no such file or
     directory</computeroutput>, comme ce qui est illustré (il est important de
     réaliser que <computeroutput>connection refused</computeroutput>, dans ce
     contexte, ne signifie <emphasis>pas</emphasis> que le serveur a obtenu une
     demande de connexion et l'a refusé. Ce cas produira un message différent
     comme indiqué dans la <xref linkend="client-authentication-problems"/>).
     D'autres messages d'erreurs tel que <computeroutput>connection timed
     out</computeroutput> pourraient indiquer des problèmes plus fondamentaux
     comme un manque de connexion réseau.
    </para>
   </sect2>
  </sect1>

 <sect1 id="kernel-resources">
  <title>Gérer les ressources du noyau</title>

  <para>
   Une installation importante de <productname>PostgreSQL</productname> peut rapidement
   épuiser les limites des ressources du système d'exploitation (Sur certains
   systèmes, les valeurs par défaut sont trop basses que vous n'avez même pas
   besoin d'une installation <quote>importante</quote>.). Si vous avez rencontré ce
   type de problème, continuez votre lecture.
  </para>

  <sect2 id="sysvipc">
   <title>Mémoire partagée et sémaphore</title>

   <indexterm zone="sysvipc">
    <primary>mémoire partagée</primary>
   </indexterm>

   <indexterm zone="sysvipc">
    <primary>sémaphores</primary>
   </indexterm>

   <para>
    La mémoire partagée et les sémaphores sont nommés collectivement
    <quote><acronym>ipc</acronym> <systemitem class="osname">system v</systemitem></quote>
    (ensemble avec les queues de messages, qui n'ont pas d'importance pour
    <productname>PostgreSQL</productname>). Pratiquement, tous les systèmes d'exploitation
    modernes fournissent ces fonctionnalités mais, parmi elles, toutes ne sont pas
    activées ou dimensionnées suffisamment par défaut, spécialement les systèmes
    ayant l'héritage BSD (pour le port <systemitem class="osname">windows</systemitem>,
    <productname>PostgreSQL</productname> fournit sa
    propre implémentation de remplacement de ces fonctionnalités).
   </para>

   <para>
    Le manque complet de fonctionnalités est généralement manifesté par 
    une erreur <errorname>illegal system call</errorname> au lancement du serveur. Dans
    ce cas, il n'y a rien à faire à part reconfigurer votre noyau.
    <productname>PostgreSQL</productname> ne fonctionnera pas sans.
   </para>

   <para>
    Quand <productname>PostgreSQL</productname> dépasse une des nombreuses limites
    <acronym>ipc</acronym>, le serveur refusera de s'exécuter et lèvera un
    message d'erreur instructif décrivant le problème rencontré et que faire
    avec (voir aussi la <xref linkend="server-start-failures"/>). Les
    paramètres adéquats du noyau sont nommés de façon cohérente parmi les
    différents systèmes&nbsp;; le <xref linkend="sysvipc-parameters"/> donne un
    aperçu. Néanmoins, les méthodes pour les obtenir varient. Les suggestions
    pour quelques plateformes sont données ci-dessous. Attention, il est souvent
    nécessaire de redémarrer votre machine, voire même de recompiler le noyau,
    pour changer ces paramétrages.
   </para>


   <table id="sysvipc-parameters">
    <title>Paramètres <systemitem class="osname">system v</systemitem> <acronym>ipc</acronym></title>

    <tgroup cols="3">
     <colspec colnum="1" colwidth="0.3*"/>
     <colspec colnum="2" colwidth="1.5*"/>
     <colspec colnum="3" colwidth="1.2*"/>
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Description</entry>
       <entry>Valeurs raisonnables</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><varname>shmmax</varname></entry>
       <entry>taille maximum du segment de mémoire partagée (octets)</entry>
       <entry>au moins plusieurs mo (voir texte)</entry>
      </row>

      <row>
       <entry><varname>shmmin</varname></entry>
       <entry>taille minimum du segment de mémoire partagée (octets)</entry>
       <entry>1</entry>
      </row>

      <row>
       <entry><varname>shmall</varname></entry>
       <entry>total de la mémoire partagée disponible (octets ou pages)</entry>
       <entry>si octets, identique à <varname>shmmax</varname>&nbsp;; si pages,
        <literal>ceil(shmmax/page_size)</literal></entry>
      </row>

      <row>
       <entry><varname>shmseg</varname></entry>
       <entry>nombre maximum de segments de mémoire partagée par
        processus</entry>
       <entry>seul un segment est nécessaire mais la valeur par défaut est
        bien plus importante</entry>
      </row>

       <row>
        <entry><varname>shmmni</varname></entry>
        <entry>nombre maximum de segments de mémoire partagée pour
         tout le système</entry>
        <entry>comme <varname>shmseg</varname> plus la place pour les autres
         applications</entry>
       </row>

       <row>
        <entry><varname>semmni</varname></entry>
        <entry>nombre maximum d'identifiants de sémaphores (c'est-à-dire
         d'ensembles)</entry>
        <entry>au moins <literal>ceil(max_connections / 16)</literal></entry>
       </row>

       <row>
        <entry><varname>semmns</varname></entry>
        <entry>nombre maximum de sémaphores répartis dans le système</entry>
        <entry><literal>ceil(max_connections / 16) * 17</literal> plus la place
         pour les autres applications</entry>
       </row>

       <row>
        <entry><varname>semmsl</varname></entry>
        <entry>nombre maximum de sémaphores par ensemble</entry>
        <entry>au moins 17</entry>
       </row>

       <row>
        <entry><varname>semmap</varname></entry>
        <entry>nombre d'entrées dans la carte des sémaphores</entry>
        <entry>voir le texte</entry>
       </row>

       <row>
        <entry><varname>semvmx</varname></entry>
        <entry>valeur maximum d'un sémaphore</entry>
        <entry>au moins 1000 (vaut souvent par défaut 32767, ne pas changer
         sauf si vous êtes forcé.)</entry>
       </row>

     </tbody>
    </tgroup>
   </table>


   <para>
    <indexterm><primary>shmmax</primary></indexterm> le paramètre de mémoire
    partagé le plus important est <varname>shmmax</varname>, la taille maximum, en
    octets, d'un segment de mémoire partagée. Si vous obtenez un message
    d'erreur à partir de <function>shmget</function> comme <errorname>invalid
    argument</errorname>, il est possible que cette limite soit dépassée.
    La taille du segment de mémoire partagée requis dépend de plusieurs
    paramètres de configuration de <productname>PostgreSQL</productname>, comme indiqué
    dans le <xref linkend="shared-memory-parameters"/>. temporairement, vous pouvez
    baisser certains de ces paramètres pour éviter un échec. Comme approximation
    brute, vous pouvez estimer la taille du segment requis à 700&nbsp;Ko auquel
    vous ajoutez les tailles variables affichées dans la table (tout message
    d'erreur obtenu incluera la taille exacte utilisée dans la requête
    d'allocation qui a échoué). Alors qu'il est possible d'obtenir de
    <productname>PostgreSQL</productname> qu'il fonctionne avec un <varname>shmmax</varname>
    de 1&nbsp;Mo, vous devez disposer d'au moins 4&nbsp;Mo pour obtenir
    des performances acceptables. Les paramètrages désirables sont plutôt de
    l'ordre de dizaines de Mo.
   </para>

   <para>
    Certains systèmes ont aussi une limite sur le nombre total de mémoire partagée
    dans le système (<varname>shmall</varname>). Assurez-vous que cela soit suffisamment
    important pour <productname>PostgreSQL</productname> et quelque autres applications
    utilisant des segments de mémoire partagée (attention&nbsp;:
    <varname>shmall</varname> est mesuré en pages plutôt qu'en octets sur beaucoup de
    systèmes).
   </para>



   <para>
    La taille minimum des segments de mémoire partagée (<varname>shmmin</varname>) est
    moins sensible aux problèmes. Elle devrait être au plus à environ
    500&nbsp;Ko pour <productname>PostgreSQL</productname> (il est habituellement à 1). Le
    nombre maximum de segments au travers du système (<varname>shmmni</varname>) ou par
    processus (<varname>shmseg</varname>) a peu de chances de causer un problème sauf
    s'ils sont configurés à zéro sur votre système.
   </para>

   <para>
    <productname>PostgreSQL</productname> utilise un sémaphore par connexion autorisée
    (<xref linkend="guc-max-connections"/>), par ensemble de 16. chacun de ces
    ensembles contiendra aussi un 17è sémaphore qui contient un <quote>nombre
    magique</quote> pour détecter la collision avec des ensembles de sémaphore
    utilisés par les autres applications. Le nombre maximum de sémaphores dans le
    système est initialisé par <varname>semmns</varname>, qui en conséquence doit être
    au moins aussi haut que <varname>max_connections</varname> plus un extra de chacune
    des 16 connexions autorisées (voir la formule dans le <xref
    linkend="sysvipc-parameters"/>). Le paramètre <varname>semmni</varname> détermine la
    limite sur le nombre d'ensembles de sémaphores qui peuvent exister sur le
    système à un instant précis. Donc, ce paramètre doit être au moins égal à
    <literal>ceil(max_connections / 16)</literal>. baisser le nombre de connexions
    autorisées est un contournement temporaire pour les échecs qui sont
    habituellement indiqués par le message <errorname>no space left on
    device</errorname>, à partir de la fonction <function>semget</function>.
   </para>

   <para>
    Dans certains cas, il pourrait être nécessaire d'augmenter
    <varname>semmap</varname> pour être au moins dans l'ordre de <varname>semmns</varname>. Ce
    paramètre définit la taille de la carte de ressources de sémaphores, dans
    laquelle chaque bloc contigü de sémaphores disponibles ont besoin d'une
    entrée. Lorsqu'un ensemble de sémaphores est libéré ou qu'il est enregistré
    sous une nouvelle entrée de carte. Si la carte est pleine, les sémaphores
    libérés sont perdus (jusqu'au redémarrage). La fragmentation de l'espace
    des sémaphores pourrait amener dans le temps à moins de sémaphores
    disponibles.
   </para>

   <para>
    La paramètre <varname>semmsl</varname>, qui détermine le nombre de sémaphores dans
    un ensemble, pourrait valoir au moins 17 pour <productname>PostgreSQL</productname>.
   </para>

   <para>
    D'autres paramètres en relation avec l'<quote>annulation de sémaphores</quote>,
    tels que <varname>semmnu</varname> et <varname>semume</varname>, ne concernent pas
    <productname>PostgreSQL</productname>.
   </para>

    <variablelist>

     <varlistentry>
      <term><systemitem class="osname">bsd/os</systemitem></term>
      <listitem>
      <indexterm><primary>bsd/os</primary><secondary>configuration ipc</secondary></indexterm>
       <formalpara>
        <title>Mémoire partagée</title>
        <para>
         Par défaut, seulement 4&nbsp;Mo de mémoire partagée est supportée.
         Gardez en tête que la mémoire partagée n'est pas paginable&nbsp;; elle
         est verrouillée en RAM. Pour accroître la mémoire partagée supportée
         par votre système, ajoutez ce qui suit à la configuration de votre
         noyau. Une valeur de 1024 pour <varname>shmall</varname> représente 4&nbsp;mo
         de mémoire partagée. Pour argumenter la mémoire partagée supportée par
	 votre système, ajoutez quelque chose comme ceci à votre configuration
	 du noyau&nbsp;:
<programlisting>options "SHMALL=8192"
options "SHMMAX=\(SHMALL*PAGE_SIZE\)"</programlisting>
         <varname>shmall</varname> est mesuré en pages de 4&nbsp;Ko, donc une valeur
	 de 1024 représente 4&nbsp;Mo de mémoire partagée. Du coup, la
	 configuration ci-dessus augmente l'aire de mémoire partagée à 32&nbsp;Mo.
         Pour ceux utilisant une version 4.3 ou ultérieure, vous aurez
         probablement besoin d'augmenter <varname>kernel_virtual_mb</varname> au-dessus
         de la valeur par défaut, <literal>248</literal>. Une fois tous les changements
         effectués, recompilez le noyau et redémarrez.
        </para>
       </formalpara>

       <para>
        Pour ceux utilisant une version 4.0 ou antérieures, utilisez
         <command>bpatch</command> pour connaître la valeur <varname>sysptsize</varname> dans
         le noyau actuel. Elle est calculée dynamiquement au démarrage.
<screen>$ <userinput>bpatch -r sysptsize</userinput>
<computeroutput>0x9 = 9</computeroutput></screen>
        Ensuite, ajoutez <varname>sysptsize</varname> comme valeur codée en dur dans
        le fichier de configuration du noyau. Augmentez la valeur que vous
        trouvez en utilisant <command>bpatch</command>. Ajoutez 1 pour chaque
        4&nbsp;Mo supplémentaire de mémoire partagée que vous souhaitez.
<programlisting>options "SYSPTSIZE=16"</programlisting>
        <varname>sysptsize</varname> ne peut pas être modifié
        avec <command>sysctl</command>.
       </para>

       <formalpara>
        <title>Sémaphores</title>
        <para>
	 Vous voudrez probablement aussi augmenter le nombre de sémaphores&nbsp;;
	 la somme totale par défaut du système (60) n'autorisera seulement que
	 50 connexions <productname>PostgreSQL</productname>. Initialisez les
         valeurs que vous souhaitez dans le fichier de configuration du
         noyau&nbsp;:
<programlisting>options "SEMMNI=40"
options "SEMMNS=240"</programlisting>
        </para>
       </formalpara>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">freebsd</systemitem></term>
      <listitem>
      <indexterm><primary>freebsd</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Les paramètres par défaut sont seulement acceptables pour de petites
	installations (par exemple, la valeur par défaut de
	<varname>shmmax</varname> est de 32&nbsp;mo). Les modifications se font
	via les interfaces <command>sysctl</command> ou
        <command>loader</command>. Les paramètres suivants peuvent être configurés
	en utilisant <command>sysctl</command>&nbsp;:
<screen><prompt>$</prompt> <userinput>sysctl -w kern.ipc.shmall=32768</userinput>
<prompt>$</prompt> <userinput>sysctl -w kern.ipc.shmmax=134217728</userinput>
<prompt>$</prompt> <userinput>sysctl -w kern.ipc.semmap=256</userinput></screen>
        Pour que ces paramètres persistent après les redémarrages, modifiez
        <filename>/etc/sysctl.conf</filename>.
       </para>

       <para>
        Les paramètres restant, concernant les sémaphores, sont en lecture seule
	en ce qui concerne <command>sysctl</command> mais peuvent être modifiés
	avant le redémarrage en utilisant l'invite <command>loader</command>&nbsp;:
<screen><prompt>(loader)</prompt> <userinput>set kern.ipc.semmni=256</userinput>
<prompt>(loader)</prompt> <userinput>set kern.ipc.semmns=512</userinput>
<prompt>(loader)</prompt> <userinput>set kern.ipc.semmnu=256</userinput></screen>
        De façon similaire, ils peuvent être sauvegardés entre les redémarrages
	dans <filename>/boot/loader.conf</filename>.
       </para>

       <para>
        Vous pourriez aussi vouloir configurer votre noyau pour verrouiller la
	mémoire partagée en RAM et l'empêcher d'être envoyé dans la swap. Ceci
        s'accomplit en utilisant le paramètre
	<literal>kern.ipc.shm_use_phys</literal> de <command>sysctl</command>.
       </para>

       <para>
        En cas d'exécution dans une cage FreeBSD en activant
	<literal>security.jail.sysvipc_allowed</literal> de <application>sysctl</application>,
	les <application>postmaster</application> exécutés dans différentes cages
	devront être exécutés par différents utilisateurs du système d'exploitation.
	Ceci améliore la sécurité car cela empêche les utilisateurs non root
	d'interférer avec la mémoire partagée ou les sémaphores d'une cage
	différente et cela permet au code de nettoyage des IPC PostgreSQL de
	fonctionner correctement (dans FreeBSD 6.0 et ultérieurs, le code de
	nettoyage IPC ne détecte pas proprement les processus des autres
	cages, empêchant les postmaster en cours d'exécution d'utiliser le
	même port dans différentes cages).
       </para>

       <para>
        Les <systemitem class="osname">freebsd</systemitem>, avant la 4.0, fonctionnent
	comme <systemitem class="osname">netbsd</systemitem> et <systemitem class="osname">
        OpenBSD</systemitem> (voir ci-dessous).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">netbsd</systemitem></term>
      <term><systemitem class="osname">openbsd</systemitem></term>
      <listitem>
      <indexterm><primary>netbsd</primary><secondary>ipc configuration</secondary></indexterm>
      <indexterm><primary>openbsd</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Les options <varname>sysvshm</varname> et <varname>sysvsem</varname> doivent être
        activées à la compilation du noyau (ils le sont par défaut). La taille
        maximum de mémoire partagée est déterminée par l'option
        <varname>shmmaxpgs</varname> (en pages). Ce qui suit montre un exemple de
        l'initialisation des différents paramètres (<systemitem
	class="osname">OpenBSD</systemitem> utilise <literal>option</literal> à la place)&nbsp;:
<programlisting>options         SYSVSHM
options         SHMMAXPGS=4096
options         SHMSEG=256

options         SYSVSEM
options         SEMMNI=256
options         SEMMNS=512
options         SEMMNU=256
options         SEMMAP=256</programlisting>
       </para>
       <para>
        Vous pourriez aussi vouloir configurer votre noyau pour verrouiller la
        mémoire partagée en RAM et l'empêcher d'être paginée en swap. Ceci se
        fait en utilisant le paramètre <literal>kern.ipc.shm_use_phys</literal> de
        <command>sysctl</command>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">hp-ux</systemitem></term>
      <listitem>
      <indexterm><primary>hp-ux</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Les paramètres par défaut tendent à suffire pour des installations
        normales. Sur <productname>hp-ux</productname> 10, la valeur par défaut de
        <varname>semmns</varname> est 128, qui pourrait être trop basse pour de gros
        sites de bases de données.
       </para>
       <para>
        Les paramètres <acronym>ipc</acronym> peuvent être initialisés dans 
        <application>system administration manager</application> (<acronym>sam</acronym>) sous
        <menuchoice><guimenu>kernel configuration</guimenu><guimenuitem>configurable
        Parameters</guimenuitem></menuchoice>. Allez sur <guibutton>create a new kernel</guibutton> une fois
        terminée.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">linux</systemitem></term>
      <listitem>
      <indexterm><primary>linux</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Les paramètres par défaut sont seulement convenables pour de petites
	installations (la taille du segment max par défaut est de 32&nbsp;Mo).
	Néanmoins, les paramètres restants sont assez généreusement configurés
	et ne requièrent pas habituellement de modifications. La taille du
	segment max peut être modifiée via l'interface <command>sysctl</command>.
	Par exemple, pour autoriser 128&nbsp;Mo et pour configurer explicitement
	la taille de la mémoire partagée à 2097152 pages (la valeur par
	défaut)&nbsp;:
<screen><prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=134217728</userinput>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=2097152</userinput></screen>
        De plus, ces paramètrages peuvent être conservés entre les redémarrages
        dans <filename>/etc/sysctl.conf</filename>.
       </para>

       <para>
        Les anciennes distributions pourraient ne pas disposer du programme
	<command>sysctl</command> mais des modifications équivalentes peuvent
	se faire en manipulant le système de fichiers
	<filename>/proc</filename>&nbsp;:
<screen><prompt>$</prompt> <userinput>echo 134217728 &gt;/proc/sys/kernel/shmmax</userinput>
<prompt>$</prompt> <userinput>echo 2097152 &gt;/proc/sys/kernel/shmall</userinput></screen>
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">macos x</systemitem></term>
      <listitem>
      <indexterm><primary>macos x</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Avec OS X 10.2 et antérieures, éditez le fichier
        <filename>/system/library/startupitems/systemtuning/systemtuning</filename>
	et modifiez les valeurs avec les commandes suivantes&nbsp;:
<programlisting>sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall</programlisting>
       </para>

       <para>
        Avec OS X 10.3 et les versions suivantes, ces commandes ont été
        déplacées dans <filename>/etc/rc</filename> et doivent être éditées là-bas.
        Notez que <filename>/etc/rc</filename> est habituellement surchargé par les
        mises à jour d'OS X (comme celle de 10.3.6 à 10.3.7) donc vous devez
        vous attendre à avoir à refaire votre édition après chaque mise à jour.
       </para>

       <para>
        Sous OS X 10.3.9 et les versions ultérieures, au lieu de modifier
	<filename>/etc/rc</filename>, vous pouvez créer un fichier nommé
	<filename>/etc/sysctl.conf</filename> contenant des affectations de
	variables comme
<programlisting>kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
</programlisting>
        Cette méthode est préférée à la modification de <filename>/etc/rc</filename>
        car vos modifications seront préservées y compris après les mises à jour
	du système. Notez que <emphasis>les cinq</emphasis> paramètres de mémoire
	partagée doivent être configurés dans <filename>/etc/sysctl.conf</filename>,
	sinon les valeurs seront ignorées.
       </para>

       <para>
        Attention au fait que les versions récentes d'OS X ignorent les tentatives
	de configuration de <varname>SHMMAX</varname> à une valeur qui n'est pas
	un multiple exact de 4096.
       </para>

       <para>
        <varname>SHMALL</varname> est mesuré en page de 4&nbsp;Ko sur cette
	plateforme.
       </para>

       <para>
        Dans toutes les versions d'OS X, vous aurez besoin de redémarrer pour que
	les modifications de mémoire partagée soient prises en considération.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">sco openserver</systemitem></term>
      <listitem>
      <indexterm><primary>sco openserver</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Dans la configuration par défaut, seuls 512&nbsp;Ko de mémoire partagée
        par segment est autorisé. Pour augmenter ce paramétrage, allez tout
	d'abord dans le répertoire <filename>/etc/conf/cf.d</filename>. pour afficher
	la valeur courante de <varname>shmmax</varname>, lancez
<programlisting>./configure -y SHMMAX</programlisting>
        Pour configurer une nouvelle valeur de <varname>shmmax</varname>, lancez
<programlisting>./configure SHMMAX=<replaceable>valeur</replaceable></programlisting>
        où <replaceable>value</replaceable> est la nouvelle valeur que vous voulez utiliser
        (en octets). Après avoir configuré <varname>shmmax</varname>, reconstruisez le
        noyau&nbsp;:
<programlisting>./link_unix</programlisting>
        et redémarrez.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">aix</systemitem></term>
      <listitem>
      <indexterm><primary>aix</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
	Au moins à partir de la version 5.1, il ne devrait plus être nécessaire
	de faire une configuration spéciale pour tel paramètre comme
	<varname>shmmax</varname> car il apparaît qu'il est configuré pour
	autoriser l'utilisation de toute la mémoire comme mémoire partagée.
	C'est la sorte de configuration utilisée habituellement pour les autres
	bases de données comme <application>db/2</application>.
       </para>

       <para>
	Néanmoins, cela pourrait être nécessaire pour modifier l'information
	globale <command>ulimit</command> dans
	<filename>/etc/security/limits</filename> car les limites dures par
	défaut pour les tailles de fichiers (<varname>fsize</varname>) et les
	nombres de fichiers (<varname>nofiles</varname>) pourraient être trop
	bas.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">solaris</systemitem></term>
      <listitem>
      <indexterm><primary>solaris</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Au moins dans la version 2.6, la taille maximum par défaut des segments
        de mémoire partagée est trop basse pour <productname>PostgreSQL</productname>. le
        paramétrage adéquat peut être modifié dans <filename>/etc/system</filename>, par
        exemple&nbsp;:
<programlisting>set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32</programlisting>
        Vous avez besoin de redémarrer pour que les modifications prennent
        effet.
       </para>

       <para>
        Voir aussi <ulink      
url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"/>
        pour des informations sur la mémoire partagée sous
        <productname>solaris</productname>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">unixware</systemitem></term>
      <listitem>
      <indexterm><primary>unixware</primary><secondary>configuration ipc</secondary></indexterm>
       <para>
        Avec <productname>unixware</productname> 7, la taille maximum des segments de
        mémoire partagée est de 512&nbsp;Ko dans la configuration par défaut.
        Pour afficher la valeur courante de <varname>shmmax</varname>, lancez
<programlisting>/etc/conf/bin/idtune -g SHMMAX</programlisting>
        qui affiche la valeur courante, par défaut, minimum et
        maximum. Pour configurer une nouvelle valeur de <varname>shmmax</varname>,
        lancez
<programlisting>/etc/conf/bin/idtune SHMMAX <replaceable>valeur</replaceable></programlisting>
        où <replaceable>valeur</replaceable> est la nouvelle valeur que vous voulez
        utiliser (en octets). Après avoir initialisé <varname>shmmax</varname>,
        reconstruisez le noyau&nbsp;:
<programlisting>/etc/conf/bin/idbuild -B</programlisting>
        et relancez.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

   <table id="shared-memory-parameters">
    <title>Paramètres de configuration affectant l'utilisation de la mémoire
    partagée par <productname>PostgreSQL</productname></title>

    <tgroup cols="2">
     <colspec colnum="1" colwidth="0.5*"/>
     <colspec colnum="2" colwidth="1.5*"/>
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Multiplicateur approximatif (octets par incrément)</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><xref linkend="guc-max-connections"/></entry>
       <entry>1800 + 270 * <xref linkend="guc-max-locks-per-transaction"/></entry>
      </row>

      <row>
       <entry><xref linkend="guc-max-prepared-transactions"/></entry>
       <entry>700 + 270 * <xref linkend="guc-max-locks-per-transaction"/></entry>
      </row>

      <row>
       <entry><xref linkend="guc-shared-buffers"/></entry>
       <entry>8300 (en supposant 8&nbsp;ko par <symbol>BLCKSZ</symbol>)</entry>
      </row>

      <row>
       <entry><xref linkend="guc-wal-buffers"/></entry>
       <entry>8200 (en supposant 8&nbsp;ko par <symbol>XLOG_BLCKSZ</symbol>)</entry>
      </row>

      <row>
       <entry><xref linkend="guc-max-fsm-relations"/></entry>
       <entry>70</entry>
      </row>

      <row>
       <entry><xref linkend="guc-max-fsm-pages"/></entry>
       <entry>6</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>


  <sect2>
   <title>Limites de ressources</title>

   <para>
    Les systèmes d'exploitation style Unix renforcent différents types de
    limites de ressources qui pourraient interférer avec les opérations de votre
    serveur <productname>PostgreSQL</productname>. Les limites sur le nombre de
    processus par utilisateur, le nombre de fichiers ouverts par un processus et la
    taille mémoire disponible pour chaque processus sont d'une grande
    importance. Chacun d'entre elles ont une limite <quote>dure</quote> et une
    limite <quote>souple</quote>. La limite souple est réellement ce qui compte
    mais cela pourrait être changé par l'utilisateur jusqu'à la limite dure. La
    limite dure pourrait seulement être modifiée par l'utilisateur root. L'appel
    système <function>setrlimit</function> est responsable de l'initialisation
    de ces paramètres. La commande interne du shell <command>ulimit</command>
    (shells Bourne) ou <command>limit</command> (<application>csh</application>) est
    utilisé pour contrôler les limites de ressource à partir de la ligne de
    commande. Sur les systèmes dérivés BSD, le fichier
    <filename>/etc/login.conf</filename> contrôle les différentes limites de
    ressource initialisées à la connexion. Voir la documentation du système
    d'exploitation pour les détails. Les paramètres en question sont
    <varname>maxproc</varname>, <varname>openfiles</varname> et
    <varname>datasize</varname>. par exemple&nbsp;:
<programlisting>default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...</programlisting>
    (<literal>-cur</literal> est la limite douce. Ajoutez
    <literal>-max</literal> pour configurer la limite dure.)
   </para>

   <para>
    Les noyaux peuvent aussi avoir des limites sur le système complet pour
    certaines ressources.
    <itemizedlist>
     <listitem>
      <para>
      Sur <productname>linux</productname>,
      <filename>/proc/sys/fs/file-max</filename> détermine le nombre maximum de
      fichiers ouverts que le noyau supportera. Ce nombre est modifiable en
      écrivant un autre nombre dans le fichier ou en ajoutant une affectation
      dans <filename>/etc/sysctl.conf</filename>. La limite des fichiers par
      processus est fixée lors de la compilation du noyau&nbsp;; voir
      <filename>/usr/src/linux/documentation/proc.txt</filename> pour plus
      d'informations.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Le serveur <productname>PostgreSQL</productname> utilise un processus par
    connexion de façon à ce que vous puissiez fournir au moins autant de
    processus que de connexions autorisées, en plus de ce dont vous avez besoin
    pour le reste de votre système. Ceci n'est habituellement pas un problème
    mais si vous exécutez plusieurs serveurs sur une seule machine, cela
    pourrait devenir étroit.
   </para>

   <para>
    La limite par défaut des fichiers ouverts est souvent initialisée pour être
    <quote>amicalement sociale</quote>, pour permettre à de nombreux
    utilisateurs de coexister sur une machine sans utiliser une fraction
    inappropriée des ressources du système. Si vous lancez un grand nombre de
    serveurs sur une machine, cela pourrait être quelque chose que vous
    souhaitez mais sur les serveurs dédiés, vous pourriez vouloir augmenter
    cette limite.
   </para>

   <para>
    D'un autre côté, certains systèmes autorisent l'ouverture d'un grand
    nombre de fichiers à des processus individuels&nbsp;; si un plus grand
    nombre le font, alors les limites du système peuvent facilement être
    dépassées. Si vous rencontrez ce cas et que vous ne voulez pas modifier la
    limite du système, vous pouvez initialiser le paramètre de configuration
    <xref linkend="guc-max-files-per-process"/> de
    <productname>PostgreSQL</productname> pour limiter la consommation de
    fichiers ouverts.
   </para>
  </sect2>

  <sect2>
   <title>Linux memory overcommit</title>

   <para>
    Dans Linux 2.4 et suivants, le comportement par défaut de la mémoire
    virtuelle n'est pas optimal pour <productname>PostgreSQL</productname>.
    Du fait de l'implémentation du <quote>memory overcommit</quote> par le
    noyau, celui-ci peut arrêter le serveur
    <productname>PostgreSQL</productname> (le processus serveur
    maître, <quote>postmaster</quote>) si les demandes de mémoire d'un autre
    processus provoque un manque de mémoire virtuelle au niveau du système.
   </para>

   <para>
    Si cela se produit, un message du noyau qui ressemble à ceci
    (consulter la documentation et la configuration du système pour savoir
    où chercher un tel message)&nbsp;:
<programlisting>Out of Memory: Killed process 12345 (postgres)</programlisting>
    peut survenir.
    Ceci indique que le processus <filename>postgres</filename> a été terminé
    à cause d'un problème de mémoire. Bien que les connexions en cours
    continuent de fonctionner normalement, aucune nouvelle
    connexion n'est acceptée. Pour revenir à un état normal,
    <productname>PostgreSQL</productname> doit être relancé.
   </para>

   <para>
    Une façon d'éviter ce problème revient à lancer
    <productname>PostgreSQL</productname> sur une machine où vous pouvez vous
    assurer que les autres processus ne mettront pas la machine en manque de
    mémoire.
   </para>

   <para>
    Sur Linux 2.6 et ultérieure, une meilleure solution est de modifier le
    comportement du noyau de façon à ce qu'il n'<quote>overcommit</quote> pas la
    mémoire. Ceci se fait en sélectionnant le mode overcommit strict via
    <command>sysctl</command>&nbsp;:
<programlisting>sysctl -w vm.overcommit_memory=2</programlisting>
    ou en plaçant une entrée équivalente dans <filename>/etc/sysctl.conf</filename>.
    Vous pourriez souhaiter modifier le paramétrage relatif
    <literal>vm.overcommit_ratio</literal>. Pour les détails, voir la documentation du
    noyau (<filename>documentation/vm/overcommit-accounting</filename>).
   </para>

   <para>
    Quelques noyaux 2.4 de vendeurs ont des pré-versions de l'overcommit du
    2.6. Néanmoins, configurer <literal>vm.overcommit_memory</literal> à 2 sur un noyau
    qui n'a pas le code correspondant rendra les choses pires qu'elles
    n'étaient. Il est recommandé d'inspecter le code source du noyau (voir la
    fonction <function>vm_enough_memory</function> dans le fichier
    <filename>mm/mmap.c</filename>) pour vérifier ce qui est supporté dans votre copie
    avant d'essayer ceci avec une installation 2.4. La présence du fichier de
    documentation <filename>overcommit-accounting</filename> ne devrait <emphasis>pas</emphasis>
    être pris comme une preuve de la présence de cette fonctionnalité. En cas de
    doute, consultez un expert du noyau ou le vendeur de votre noyau.
   </para>
  </sect2>
 </sect1>


 <sect1 id="server-shutdown">
  <title>Arrêter le serveur</title>

  <indexterm zone="server-shutdown">
   <primary>arrêt</primary>
  </indexterm>

  <para>
   Il existe plusieurs façons d'arrêter le serveur de bases de données. Vous
   contrôlez le type d'arrêt en envoyant différents signaux au processus
   serveur maître.

   <variablelist>
    <varlistentry>
     <term><systemitem>sigterm</systemitem><indexterm><primary>sigterm</primary></indexterm></term>
     <listitem>
      <para>
       Après réception de <systemitem>sigterm</systemitem>, le serveur
       désactive les nouvelles connexions mais permet aux sessions en cours de
       terminer leur travail normalement. Il s'arrête seulement après que toutes
       les sessions se sont terminées normalement. C'est l'arrêt intelligent
       (<firstterm>smart shutdown</firstterm>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>sigint</systemitem><indexterm><primary>sigint</primary></indexterm></term>
     <listitem>
      <para>
       Le serveur désactive les nouvelles connexions et envoie à tous
       les processus serveur le signal <systemitem>sigterm</systemitem>, qui les
       fera annuler leurs transactions courantes pour quitter rapidement. Il
       attend ensuite la fin des processus serveur et s'arrête finalement.
       C'est l'arrêt rapide (<firstterm>fast shutdown</firstterm>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>sigquit</systemitem><indexterm><primary>sigquit</primary></indexterm></term>
     <listitem>
      <para>
      Voici l'arrêt immédiat (<firstterm>immediate shutdown</firstterm>), qui
       demande au processus <command>postgres</command> maître d'envoyer un signal
       <systemitem>sigquit</systemitem> à tous les processus fils et à quitter
       immédiatement non proprement. Les processus fils quittent immédiatement
       à réception du signal <systemitem>sigquit</systemitem>. ceci amènera une
       tentative de récupération (en rejouant les traces WAL) au prochain
       lancement. Ceci n'est recommandé que dans les cas d'urgence.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Le programme <xref linkend="app-pg-ctl"/> fournit une interface agréable
   pour envoyer ces signaux dans le but d'arrêter le serveur.
  </para>

  <para>
  Autrement, vous pouvez envoyer le signal directement en utilisant
  <command>kill</command>. le <acronym>PID</acronym> du processus <command>postgres</command>
  peut être trouvé en utilisant le programme <command>ps</command> ou à partir du
  fichier <filename>postmaster.pid</filename> dans le répertoire des données.
  Par exemple, pour exécuter un arrêt rapide&nbsp;:
<screen>$ <userinput>kill -int `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput></screen>
  </para>

  <important>
   <para>
    Il vaux mieux de ne pas utiliser <systemitem>sigkill</systemitem> pour arrêter
    le serveur. Le faire empêchera le serveur de libérer la mémoire partagée et
    les sémaphores, ce qui pourrait devoir être fait manuellement avant qu'un
    nouveau serveur ne soit lancé. De plus, <systemitem>SIGKILL</systemitem> tue
    le processus <command>postgres</command> sans que celui-ci ait le temps de
    relayer ce signal à ses sous-processus, donc il sera aussi nécessaire de tuer
    les sous-processus individuels à la main.
   </para>
  </important>
 </sect1>

 <sect1 id="encryption-options">
  <title>Options de chiffrement</title>

  <indexterm zone="encryption-options">
   <primary>chiffrement</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> offre du chiffrement sur plusieurs niveaux
   et fournit une flexibilité pour protéger les données d'être révélées suite à
   un vol du serveur de la base de données, des administrateurs non scrupuleux
   et des réseaux non sécurisés. Le chiffrement pourrait aussi être requis pour
   sécuriser des données sensibles, par exemple des informations médicales ou des
   transactions financières.
  </para>

  <variablelist>

  <varlistentry>
   <term>chiffrement du mot de passe stocké</term>
   <listitem>

    <para>
     Par défaut, les mots de passe des utilisateurs de la base de données sont
     stockées suivant des hachages MD5, donc l'administrateur ne peut pas
     déterminer le mot de passe affecté à l'utilisateur. Si le cryptage MD5
     est utilisé pour l'authentification du client, le mot de passe non crypté
     n'est jamais présent temporairement sur le serveur parce que le client
     le crypte en MD5 avant de l'envoyer sur le réseau.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>chiffrement de colonnes spécifiques</term>

   <listitem>
    <para>
     La bibliothèque de fonctions <filename>/contrib</filename>
     <function>pgcrypto</function> autorise le stockage crypté de certains
     champs. Ceci est utile si seulement certaines données sont sensibles.
     Le client fournit la clé de décryptage et la donnée est décryptée sur
     le serveur puis elle est envoyée au client.
    </para>

    <para>
     La donnée décryptée et la clé de déchiffrement sont présente sur le serveur
     pendant un bref moment où la donnée est décryptée, puis envoyée entre le
     client et le serveur. Ceci présente un bref moment où la données et les
     clés peuvent être interceptées par quelqu'un ayant un accès complet au
     serveur de bases de données, tel que l'administrateur du système.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>chiffrement de la partition de données</term>

   <listitem>
    <para>
     Sur Linux, le chiffrement peut se faire au niveau du montage d'un système
     de fichiers en utilisant un <quote>périphérique loopback</quote>. Ceci
     permet à une partition entière du système de fichiers d'être cryptée et
     décryptée par le système d'exploitation. Sur FreeBSD, la fonctionnalité
     équivalent est appelé <quote>geom based disk encryption</quote>, ou
     <acronym>gbde</acronym>.
    </para>

    <para>
     Ce mécanisme empêche les données non cryptées d'être lues à partir des
     lecteurs s'ils sont volés. Ceci ne protège pas contre les attaques quand
     le système de fichiers est monté parce que, une fois monté, le système
     d'exploitation fournit une vue non cryptée des données. Néanmoins, pour
     monter le système de fichiers, vous avez besoin d'un moyen pour fournir
     la clé de chiffrement au système d'exploitation et, quelque fois, la clé
     est stocké quelque part près de l'hôte qui monte le disque.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>chiffrement des mots de passe sur le réseau</term>

   <listitem>
     <para>
      La méthode d'authentification <literal>md5</literal> crypte deux fois le mot de
      passe sur le client avant de l'envoyer au serveur. Il le crypte tout
      d'abord à partir du nom de l'utilisateur puis il le crypte à partir d'un
      élément du hasard envoyé par le serveur au moment de la connexion. Cette
      valeur, deux fois cryptée, est envoyée sur le réseau au serveur. Le double
      chiffrement empêche non seulement la découverte du mot de passe, il empêche
      aussi une autre connexion en utilisant le même mot de passe crypté pour
      se connecter au serveur de bases de données lors d'une connexion future.
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
   <term>chiffrement des données sur le réseau</term>

    <listitem>
     <para>
      Les connexions SSL cryptent toutes les données envoyées sur le
      réseau&nbsp;: le mot de passe, les requêtes et les données renvoyées. Le
      fichier <filename>pg_hba.conf</filename> permet aux administrateurs de spécifier
      quels hôtes peuvent utiliser des connexions non cryptées (<literal>host</literal>)
      et lesquels requièrent des connexions SSL (<literal>hostssl</literal>). De plus,
      les clients peuvent spécifier qu'ils se connectent aux serveurs seulement
      via SSL. <application>stunnel</application> ou <application>ssh</application> peuvent aussi
      être utilisés pour crypter les transmissions.
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
   <term>authentification de l'hôte ssl</term>

   <listitem>
    <para> 
     Il est possible que le client et le serveur fournissent des clés SSL ou
     des certificats à l'autre. Cela demande une configuration supplémentaire
     de chaque côté mais cela fournit une vérification plus forte de l'identité
     que la simple utilisation de mots de passe. Cela empêche un ordinateur de
     se faire passer pour le serveur assez longtemps pour lire le mot de passe
     envoyé par le client. Cela empêche aussi les attaques du type <quote>man
     in the middle</quote> où un ordinateur, entre le client et le serveur,
     prétend être le serveur, lit et envoie les données entre le client et le
     serveur.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>chiffrement côté client</term>

   <listitem>
    <para>
     Si vous n'avez pas confiance en l'administrateur système, il est nécessaire
     que le client crypte les données&nbsp;; de cette façon, les données non
     cryptées n'apparaissent jamais sur le serveur de la base de données. Les
     données sont cryptées sur le client avant d'être envoyé au serveur, et les
     résultats de la base de données doivent être décryptés sur le client avant
     d'être utilisés.
    </para>
   </listitem>
  </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="ssl-tcp">
  <title>Connexions tcp/ip sécurisées avec ssl</title>

  <indexterm zone="ssl-tcp">
   <primary>ssl</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> dispose d'un support natif pour l'utilisation de
    connexions <acronym>ssl</acronym>, cryptant ainsi les communications
    clients/serveurs pour une sécurité améliorée. Ceci requiert l'installation
    d'<productname>openssl</productname> à la fois sur le système client et sur
    le système serveur et que ce support soit activé au moment de la
    construction de <productname>PostgreSQL</productname> (voir le <xref
    linkend="installation"/>).
  </para>

  <para>
   Avec le support <acronym>ssl</acronym> compilé, le serveur
   <productname>PostgreSQL</productname> peut être lancé avec
   <acronym>ssl</acronym> activé en activant <varname>ssl</varname> dans
   <filename>PostgreSQL.conf</filename>. lors d'un démarrage en mode <acronym>ssl</acronym>, le
   serveur cherchera les fichiers <filename>server.key</filename> et
   <filename>server.crt</filename> dans le répertoire des données, qui doivent
   contenir respectivement la clé privée du serveur et le certificat. Ces
   fichiers doivent être configurés correctement avant qu'un serveur dont le
   mode <acronym>ssl</acronym> est activé puisse démarrer. si la clé privée est
   protégée avec une phrase, le serveur la demandera  et ne se lancera pas tant
   que celle-ci n'aura pas été saisie.
  </para>

  <para>
   Le serveur écoutera les connexions <acronym>ssl</acronym> et standard sur le même
   port TCP et négociera avec tout client se connectant qu'il utilise ou non
   <acronym>ssl</acronym>. voir le <xref linkend="client-authentication"/> pour savoir
   comment forcer l'utilisation de <acronym>ssl</acronym> pour certaines connexions.
  </para>

  <para>
   Pour les détails sur la création de la clé privé et du certificat du serveur,
   référez-vous à la documentation d'<productname>openssl</productname>. un
   simple certificat signé par soi-même peut être utilisé pour des 
   tests mais un certificat signé par une autorité (<acronym>ca</acronym>) (soit un des
   <acronym>ca</acronym> globaux soit un local) devrait être utilisé en production de
   façon à ce que le client puisse vérifier l'identité du serveur. Pour créer
   rapidement un certificat signé soi-même, utilisez la commande
   <productname>openssl</productname> suivante&nbsp;:
<programlisting>openssl req -new -text -out server.req</programlisting>
   Remplissez les informations que <command>openssl</command> réclame. assurez-vous
   que vous entrez le nom local de l'hôte sur <quote>common name</quote>&nbsp;; le
   mot de passe de challenge peut être laissé vide. Le programme générera une
   clé qui est protégée par une phrase&nbsp;; elle n'acceptera pas une phrase
   qui fait moins de quatre caractères. Pour supprimer la phrase (ce que vous
   devez faire si vous voulez automatiser le lancement du serveur), lancez les
   commandes
<programlisting>openssl rsa -in privkey.pem -out server.key
rm privkey.pem</programlisting>
   Saisissez l'ancienne phrase pour débloquer la clé existante. Maintenant,
   saisissez
<programlisting>openssl req -x509 -in server.req -text -key server.key -out server.crt
chmod og-rwx server.key</programlisting>
   pour remplacer le certificat en un certificat signé par soi-même et copiez la
   clé et le certificat là où le serveur les cherchera.
  </para>

  <para>
   Si la vérification des certificats du client est requise, placez les
   certificats du <acronym>ca</acronym> que vous souhaitez vérifier dans le
   fichier <filename>root.crt</filename> du répertoire des données. s'il est
   présent, un certificat client sera demandé à partir du client lors
   du lancement d'une connexion SSL et il doit y avoir des certificats
   présent dans <filename>root.crt</filename>. (Voir <xref
   linkend="libpq-ssl"/> pour une description de la configuration des
   certificats du client.) Les entrées du <acronym>CRL</acronym>
   (<foreignphrase>Certificate Revocation List</foreignphrase>, liste de
   révocation des certificats) sont aussi vérifiées si le fichier 
   <filename>root.crl</filename> existe.
  </para>

  <para>
   Quand le fichier <filename>root.crt</filename> est absent, les certificats
   du client ne seront ni demandés ni vérifiés. Dans ce mode, SSL fournit
   la sécurité de la communication pas l'authentification.
  </para>

  <para>
   Les fichiers <filename>server.key</filename>, <filename>server.crt</filename>,
   <filename>root.crt</filename> et <filename>root.crl</filename> sont seulement
   examinés lors du lancement du serveur&nbsp;; donc vous devez relancer le
   serveur pour prendre en compte les modifications.
</para>
 </sect1>

 <sect1 id="ssh-tunnels">
  <title>Connexions tcp/ip sécurisées avec des tunnels
   <application>ssh</application> tunnels</title>

  <indexterm zone="ssh-tunnels">
   <primary>ssh</primary>
  </indexterm>

  <para>
   Vous pouvez utiliser <application>ssh</application> pour crypter la
   connexion réseau entre les clients et un serveur
   <productname>PostgreSQL</productname>. Réalisé correctement, ceci fournit une
   connexion réseau sécurisée, y compris pour les clients non SSL.
  </para>

  <para>
   Tout d'abord, assurez-vous qu'un serveur <application>ssh</application> est
   en cours d'exécution sur la même machine que le serveur
   <productname>PostgreSQL</productname> et que vous pouvez vous connecter via
   <command>ssh</command> en tant qu'un utilisateur quelconque. Ensuite, vous
   pouvez établir un tunnel sécurisé avec une commande comme ceci sur la machine
   cliente&nbsp;:
<programlisting>ssh -L 3333:foo.com:5432 joe@foo.com</programlisting>
   Le premier numéro de l'argument <option>-l</option>, 3333, est le numéro de
port de votre bout du tunnel&nbsp;; il peut être choisi librement. Le second
numéro, 5432, est le bout distant du tunnel&nbsp;: le numéro de port que votre
serveur utilise. Le nom ou l'adresse entre les numéros de port est l'hôte
disposant du serveur de bases de données auquel vous souhaitez vous connecter.
Pour cela, vous vous connectez au port 3333 de votre machine locale&nbsp;:
<programlisting>psql -h localhost -p 3333 postgres</programlisting>
   Sur le serveur de bases de données, il semblera que vous êtes réellement
   l'utilisateur <literal>joe@foo.com</literal> et il utilisera la procédure
   d'authentification adéquate pour cet utilisateur. Pour que la configuration
   du serveur réussisse, vous devez être autorisé à vous connecter via
   <command>ssh</command> en tant que <literal>joe@foo.com</literal>, comme si
   vous essayez d'utiliser <command>ssh</command> pour configurer une session
   terminal.
  </para>

  <tip>
   <para>
    Plusieurs autres applications existantes peuvent fournir des tunnels
   sécurisés en utilisant une procédure similaire dans le concept à celle que
   nous venons de décrire.
   </para>
  </tip>

 </sect1>

</chapter>
