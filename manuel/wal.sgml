<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/wal.sgml,v 1.6.2.2 2005/07/15 06:33:51 guillaume Exp $ -->

<chapter id="wal">
 <title>Write-Ahead Logging (<acronym>WAL</acronym>)</title>

 <indexterm zone="wal">
  <primary>WAL</primary>
 </indexterm>

 <indexterm>
  <primary>log transaction</primary>
  <see>WAL</see>
 </indexterm>

  <para>
   <firstterm>Write-Ahead Logging</firstterm> (<acronym>WAL</acronym>)
   est une approche standard pour l'écriture d'un journal de
   transactions.  Sa description détaillée peut être trouvée dans la
   plupart (si ce n'est tous) des livres sur le traitement
   transactionnel. Brièvement, le concept central des
   <acronym>WAL</acronym> est que les changements des fichiers de
   données (où résident les tables et les index) doivent être effectués
   uniquement après que ces changements aient été écrits dans un journal,
   c'est-à-dire quand l'enregistrement du journal a été écrit vers le
   stockage permanent.  Si nous suivons cette procédure, nous n'avons
   pas besoin d'écrire les pages de données vers le disque à chaque
   validation de transaction car nous savons que dans l'éventualité
   d'une défaillance, nous serons capables de récupérer la base de
   données en utilisant le journal&nbsp;: chaque changement qui n'a pas été
   appliqué aux pages de données sera d'abord refait depuis les
   enregistrements du journal (ceci est une récupération roll-forward,
   aussi connue sous le nom de REDO) et ensuite les changements effectués
   par des transactions non validées seront supprimés des pages de
   données (récupération roll-backward, UNDO).
  </para>

  <sect1 id="wal-benefits-now">
   <title>Avantages des <acronym>WAL</acronym></title>

   <indexterm zone="wal-benefits-now">
    <primary>fsync</primary>
   </indexterm>

   <para>
    Le premier avantage évident en utilisant les <acronym>WAL</acronym>
    est la réduction significative du nombre d'écritures sur le disque
    puisque uniquement le journal des transactions a besoin d'être écrit sur le
    disque au moment où la transaction est validée&nbsp;; dans un
    environnement multi-utilisateurs, la validation de nombreuses
    transactions peut être accomplie avec un seul
    <function>fsync()</function> du journal.  De plus, ce dernier
    est écrit séquentiellement et donc, le coût de
    synchronisation du journal est largement moindre que le coût
    d'écriture des pages de données.
   </para>

   <para>
    Le second avantage est la cohérence des pages de données.  La
    vérité est qu'avant <acronym>WAL</acronym>,
    <productname>PostgreSQL</productname> n'était pas capable de
    garantir la cohérence en cas de défaillance (crash).  Avant
    <acronym>WAL</acronym>, une défaillance quelconque durant
    l'écriture pouvait être le résultat&nbsp;:

    <orderedlist>
     <listitem>
      <simpara>de lignes d'un index pointant vers des lignes
      inexistantes d'une table&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>de lignes perdues d'un index dans des opérations de
      séparation&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>de tables ou de contenu de pages d'index totalement
      corrompues à cause d'une écriture partielle des pages de
      données</simpara>
     </listitem>
    </orderedlist>

    Les problèmes avec les index (les problèmes 1 et 2) auraient pû
    être corrigés avec des appels supplémentaires à
    <function>fsync()</function> mais il n'est pas évident de traiter
    le dernier cas sans <acronym>WAL</acronym>&nbsp;;
    <acronym>WAL</acronym> sauve le contenu entier de la page de
    données dans le journal si cela est requis pour assurer la cohérence
    de la page et permettre la récupération après défaillance.
   </para>
  </sect1>
  
  <sect1 id="wal-benefits-later">
   <title>Avantages futurs</title>

   <para>
    L'opération UNDO n'est pas implémentée.  Cela signifie que les
    changements faits par des transactions avortées occuperont
    toujours un espace sur le disque et qu'un fichier permanent
    <filename>pg_clog</filename> qui contient le statut des
    transactions, est toujours nécessaire&nbsp;; de plus, les identifiants
    de transactions ne peuvent plus être réutilisés.  Une fois que
    UNDO sera implémenté, il ne sera plus requis que
    <filename>pg_clog</filename> soit permanent&nbsp;; il sera possible
    d'effacer <filename>pg_clog</filename> à l'arrêt. (Cependant,
    l'urgence de ce souci a diminué considérablement avec l'adoption
    d'une méthode de stockage segmenté pour <filename>pg_clog</filename>&nbsp;:
    il n'est plus nécessaire de conserver de vieilles entrées de
    <filename>pg_clog</filename> pour toujours.)
   </para>

   <para>
    Avec UNDO, il sera aussi possible d'implémenter des
    <firstterm>points de sauvegardes</firstterm><indexterm><primary>points de
    sauvegarde</></> pour permettre des annulations partielles
    d'opérations de transactions invalides (erreurs
    d'analyse syntaxique causées par des commandes mal saisies,
    insertions de clés primaire/unique en double et ainsi de suite)
    avec la possibilité de continuer ou de valider les opérations
    correctes faites par la transaction avant l'erreur. À présent,
    une erreur quelconque invalide la transaction toute entière et
    il est requis de l'annuler.
   </para>

   <para>
    <acronym>WAL</acronym> offre l'opportunité d'une nouvelle méthode
    pour la sauvegarde et la restauration en ligne de la base
    (<acronym>BAR</acronym> - Backup And Restore).  Pour utiliser
    cette méthode,  on devrait sauvegarder périodiquement les fichiers
    de données sur un autre disque, une bande ou un autre hôte et
    archiver aussi les journaux <acronym>WAL</acronym>.  La
    copie du fichier de la base et le journal archivé pourront
    être utilisés pour restaurer comme on le ferait après une
    défaillance.  Chaque fois qu'une copie d'un fichier de la base est
    faite, les vieux journaux peuvent être supprimés.
    Implémenter ce service nécessitera l'écriture de traces pour les
    fichiers de données et pour la création et la suppression
    d'index&nbsp;; il sera aussi nécéssaire de développer une méthode pour
    copier les fichiers de données (les commandes de copie du système
    d'exploitation ne sont pas recommandées).
   </para>

   <para>
    La difficulté, dans la manière d'obtenir ces avantages, réside
    dans le fait qu'ils requièrent de sauvegarder les entrées
    <acronym>WAL</acronym> pour des périodes de temps considérables
    (par exemple, aussi longtemps que la plus ancienne transaction
    possible si une transaction UNDO est recherchée).  Le format
    actuel de <acronym>WAL</acronym> est extrêmement étendu depuis
    qu'il inclue de nombreux instantanés de pages disques.  Ce n'est
    pas une préoccupation sérieuse pour le moment puisque les entrées
    ont seulement besoin d'être gardées pour un ou deux intervalles de
    points de contrôles mais pour réaliser ces futurs avantages une
    sorte de format <acronym>WAL</acronym> compressé sera nécéssaire.
   </para>
  </sect1>

 <sect1 id="wal-configuration">
  <title>Configuration de <acronym>WAL</acronym></title>

  <para>
   Il y a plusieurs paramètres de configuration associés à
   <acronym>WAL</acronym> qui affectent les performances de la base de
   de données.  Cette section explique leur utilisation.  Consultez la
   <xref linkend="runtime-config"> pour avoir plus de détails sur la
   mise en place de ces paramètres de configuration.
  </para>

  <para>
   Dans la séquence des transactions, les
   <firstterm>points de contrôles</firstterm><indexterm><primary>points de
   contrôle</></> (checkpoints) sont des
   points qui garantissent que les fichiers de données ont été mis à
   jour avec toutes les informations enregistrées dans le journal avant le
   point de contrôle.  Au moment du point de contrôle, toutes les
   pages de données non propres sont écrites sur le disque et une
   entrée spéciale, pour le point de contrôle, est écrite dans le
   journal.  Cela a pour résultat qu'en cas de défaillance, le
   récupérateur sait à partir de quelle entrée du journal (connu sous
   le nom d'entrée de récupération) il doit démarrer l'opération de
   de récupération (REDO) puisque tous les changements faient sur les
   fichiers de données avant cette entrée sont déjà sur le disque.
   Après avoir fait un point de contrôle, tous les segments de journaux
   écrits avant l'entrée de récupération ne sont plus nécessaires et
   peuvent être recyclés ou supprimés. (Quand la sauvegarde et la
   restauration (<acronym>BAR</acronym>) basées sur
   <acronym>WAL</acronym> sont implémentées, les segments de journaux
   devraient être archivés avant d'être recyclés ou supprimés).
  </para>

  <para>
   Le serveur gère dynamiquement un processus spécial pour créer
   le prochain point de contrôle. Un point de contrôle est créé
   tous les <varname>checkpoint_segments</varname> segments de journaux ou
   dès que <varname>checkpoint_timeout</varname> secondes se sont
   écoulées.  Les paramètres par défaut sont respectivement 3 segments
   et 300 secondes.  Il est également possible de forcer la création
   d'un point de contrôle en utilisant la commande SQL
   <command>CHECKPOINT</command>.
  </para>

  <para>
   Réduire <varname>checkpoint_segments</varname> et/ou
   <varname>checkpoint_timeout</varname> a pour conséquence de faire
   des points de contrôle plus fréquent.  Ceci permet une récupération
   plus rapide après une défaillance (puisque moins de travail a
   besoin d'être récupéré).  Cependant, il faut équilibrer cela avec
   l'augmentation du coût d'écriture des pages de données non propres.
   De plus, après chaque point de contrôle, pour être certain de
   l'intégrité des pages de données, la première modification d'une
   page de données a pour conséquence d'écrire dans le journal le contenu
   entier de la page.  Donc, un intervalle trop petit de points de
   contrôles augmente le volume écrit dans le journal, ce qui annule, en
   partie, les avantages d'utiliser un petit intervalle.  Dans tous les
   cas, cela causera plus d'accès en entrées/sorties (I/O) du disque.
  </para>

  <para>
   Il y aura au moins un fichier segment de 16&nbsp;Mo et normalement
   pas plus de 2 * <varname>checkpoint_segments</varname> + 1
   fichiers.  Vous pouvez utiliser cela pour estimer l'espace disque
   nécessaire pour WAL. D'habitude, quand les vieux fichiers 
   segment de journaux ne sont plus nécessaires, ils sont recyclés
   (renommés pour devenir les prochains segments dans une séquence
   numérotée).  Si, dû à un pic temporaire du taux d'écriture des journaux,
   il y a plus de 2 * <varname>checkpoint_segments</varname> + 1
   fichiers segments, ceux inutilisés seront effacés au lieu d'être
   recyclés jusqu'à ce que le système soit en-dessous de cette limite.
  </para>

  <para>
   Il y a deux fonctions <acronym>WAL</acronym> couramment utilisées&nbsp;:
   <function>LogInsert</function> et <function>LogFlush</function>.
   <function>LogInsert</function> est utilisée pour placer une
   nouvelle entrée à l'intérieur des tampons <acronym>WAL</acronym> en mémoire
   partagée. S'il n'y a plus
   d'espace pour une nouvelle entrée, <function>LogInsert</function>
   devra écrire (bouger dans le cache du noyau) quelques tampons
   <acronym>WAL</acronym> remplis.  Ceci n'est pas désirable parce que
   <function>LogInsert</function> est utilisée lors de chaque
   modification bas niveau de la base (par exemple, insertion d'une
   ligne) quand un verrou exclusif est posé sur des pages de données
   affectées, donc l'opération nécessite d'être aussi rapide que
   possible.  Pire encore, écrire des tampons <acronym>WAL</acronym>
   peut aussi forcer la création d'un nouveau segment de journal ce qui
   peut prendre beaucoup plus de temps.  Normalement, les tampons
   <acronym>WAL</acronym> devraient être écrits et vidés par une requête
   de <function>LogFlush</function> qui est faite, la plupart du
   temps, au moment de la validation d'une transaction pour assurer
   que les entrées de la transaction sont écrites vers un stockage
   permanent.  Sur les systèmes avec une importante écriture de journaux,
   les requêtes de <function>LogFlush</function> peuvent ne pas
   arriver assez souvent pour empécher les tampons
   <acronym>WAL</acronym> d'être écrits par
   <function>LogInsert</function>.  Sur de tel système, on devrait
   augmenter le nombre de tampons <acronym>WAL</acronym> en modifiant
   le paramètre de configuration <varname>wal_buffers</varname>.  Par
   défaut, le nombre de tampons est de 8.  Augmenter cette valeur
   augmentera considérablement l'utilisation de la mémoire partagée.
  </para>

  <para>
   Les points de contrôles sont relativement coûteux car ils forcent
   tous les tampons du noyau non propres sur le disque en utilisant
   l'appel à la fonction du système d'exploitation <literal>sync()</>.
   Les serveurs occupés peuvent remplir les fichiers segments trop
   rapidement causant le déclenchement excessif de points de contrôle.
   Si de tels points de contrôle forcés arrivent plus fréquemment que
   <varname>checkpoint_warning</varname> secondes, un message sera
   écrit dans les traces du serveur recommandant d'augmenter
   <varname>checkpoint_segments</varname>.
  </para>

  <para>
   Le paramètre <varname>commit_delay</varname> définit combien de
   micro-secondes le processus serveur dormira après l'écriture d'une
   entrée de validation dans le journal avec
   <function>LogInsert</function> avant d'exécuter un 
   <function>LogFlush</function>.  Ce délai permet aux autres
   processus du serveur d'ajouter leurs entrées de validation dans le
   fichier de journal afin de tout écrire vers le disque avec une seule
   synchronisation du journal.  Aucune mise en sommeil n'aura lieu si
   <varname>fsync</varname> n'est pas disponible ou si moins de
   <varname>commit_siblings</varname> autres sessions sont, à ce
   moment, dans des transactions actives&nbsp;; cela évite de dormir quand
   il est improbable qu'une autre session fasse bientôt une
   validation.  Notez que dans la plupart des plate-formes, la
   résolution d'une requête de sommeil est de 10 millisecondes, donc
   un <varname>commit_delay</varname> différent de zéro et configuré
   entre 1 et 10000 micro-secondes aura le même effet.  Les bonnes
   valeurs pour ce paramètre ne sont pas encore claires&nbsp;; les essais
   sont encouragés.
  </para>

  <para>
   Le paramètre <varname>wal_sync_method</varname> détermine comment 
   <productname>PostgreSQL</productname> demandera au noyau de forcer
   les mises à jour WAL sur le disque.  Toutes les options devraient
   être les mêmes dans la mesure où la fiabilité ne disparaît pas,
   mais c'est avec des options spécifiques à la plate-forme que ça
   sera le plus rapide.  Notez que ce paramètre est ignoré si
   <varname>fsync</varname> a été désactivé.
  </para>

  <para>
   Configurer le paramètre <varname>wal_debug</varname> avec une
   valeur différente de zéro aura pour résultat d'enregistrer dans les
   journaux du serveur l'appel WAL à chaque <function>LogInsert</function>
   et <function>LogFlush</function>.  En ce moment, il n'est fait
   aucune différence entre les valeurs supérieures à zéro.  Cette
   option pourra être remplacée par un mécanisme plus général dans le
   futur.
  </para>
 </sect1>

 <sect1 id="wal-internals">
  <title>Internes</title>

  <para>
   <acronym>WAL</acronym> est automatiquement disponible&nbsp;; aucune
   action n'est requise de la part de l'administrateur excepté
   de s'assurer que l'espace disque supplémentaire requis par les journaux
   WAL est présent et que tous les réglages sont faits (regardez
   la <xref linkend="wal-configuration">).
  </para>

  <para>
   Les journaux <acronym>WAL</acronym> sont stockés dans le répertoire
   <filename>pg_xlog</filename> sous le répertoire de données, comme
   un ensemble de fichiers segments, chacun d'une taille de 16&nbsp;Mo.
   Chaque segment est divisé en pages de 8&nbsp;Ko.  Les en-têtes de
   l'entrée du journal sont décrites dans
   <filename>access/xlog.h</filename>&nbsp;; le contenu de l'entrée dépend
   du type de l'événement qui est enregistré.  Les fichiers segments
   sont nommés avec un chiffre qui est toujours incrémenté et qui
   commence à <filename>0000000000000000</filename>.  Les nombres ne
   bouclent pas à présent, mais cela devrait prendre beaucoup de temps
   pour épuiser le stock de nombres disponibles.
  </para>

  <para>
   Les tampons <acronym>WAL</acronym> et la structure de contrôle sont
   situés dans la mémoire partagée et sont manipulés par les processus
   enfants du serveur. Ils sont protégés par des verrous légers.  La
   demande en mémoire partagée est dépendante du nombre de tampons.
   La taille par défaut des tampons <acronym>WAL</acronym> est 8
   tampons de 8&nbsp;Ko chacun, soit 64&nbsp;Ko au total.
  </para>

  <para>
   Il est avantageux que le journal soit situé sur un autre disque que
   celui des fichiers principaux de la base de données.  Cela peut
   se réaliser en déplaçant le répertoire
   <filename>pg_xlog</filename> vers un autre emplacement (alors que
   le serveur est arrêté naturellement) et en créant un lien
   symbolique de l'endroit d'origine dans le répertoire principal de
   données au nouvel emplacement.
  </para>

  <para>
   Le but de <acronym>WAL</acronym>, s'assurer que le journal est écrit
   avant l'altération des entrées dans la base, peut être renversé par
   les lecteurs des disques<indexterm><primary>disques durs</></> qui
   faussement rapportent une écriture
   réussie au noyau quand, en fait, ils ont seulement mis en cache
   les données et ne les ont pas encore stockées sur le disque.  Une
   coupure de courant dans ce genre de situation peut toujours mener à
   la corruption irrécupérable des données.  Les administrateurs
   devraient s'assurer que les disques contenant les journaux
   <acronym>WAL</acronym> de <productname>PostgreSQL</productname> ne
   produisent pas ce genre de faux rapports.
  </para>

  <para>
   Après qu'un point de contrôle ait été fait et que le journal a été
   écrit, la position du point de contrôle est sauvegardée dans le
   fichier <filename>pg_control</filename>.  Donc, quand la
   restauration doit se faire, le serveur lit en premier
   <filename>pg_control</filename> et ensuite l'entrée du point de
   contrôle&nbsp;; ensuite, il exécute l'opération REDO en parcourant vers
   l'avant à partir de la position du journal indiquée dans l'entrée du
   point de contrôle. Parce que l'ensemble du contenu des pages de
   données est sauvegardé dans le journal à la première modification de
   page après un point de contrôle, toutes les pages changées depuis
   le point de contrôle seront restaurées dans un état cohérent.
  </para>

  <para>
   Utiliser <filename>pg_control</filename>, pour obtenir la position
   du point de contrôle, accélère le processus de récupération mais
   pour traiter une possible corruption de
   <filename>pg_control</filename>, nous devrions en fait implémenter
   la lecture de segments de journaux dans l'ordre inverse -- du plus jeune
   au plus vieux -- afin de trouver le dernier point de contrôle.
   Ceci n'a pas encore été implémenté.
  </para>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
