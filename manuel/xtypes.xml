<?xml version="1.0" encoding="UTF-8"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/xtypes.sgml,v 1.8 2005/07/15 06:14:31 guillaume Exp $
-->

 <sect1 id="xtypes">
  <title>Types utilisateur</title>

  <indexterm zone="xtypes">
   <primary>type de données</primary>
   <secondary>utilisateur</secondary>
  </indexterm>

  <para>
   Comme cela est décrit dans la <xref linkend="extend-type-system"/>,
   <productname>PostgreSQL</productname> peut être étendu pour supporter de
   nouveaux types de données. Cette section décrit la définition de nouveaux
   types basiques. Ces types de données sont définis en-dessous du
   <acronym>SQL</acronym>. Créer un nouveau type requiert d'implanter des
   fonctions dans un langage de bas niveau, généralement
   le C.
  </para>

  <para>
   Les exemples de cette section sont disponibles dans
   <filename>complex.sql</filename> et <filename>complex.c</filename>
   du répertoire <filename>src/tutorial</filename> de la distribution.
   Voir le fichier <filename>README</filename> de ce répertoire pour les instructions
   d'exécution des exemples.
  </para>

 <para>
  <indexterm>
   <primary>fonction d'entrée</primary>
  </indexterm>
  <indexterm>
   <primary>fonction de sortie</primary>
  </indexterm>
  Un type utilisateur doit toujours avoir des fonctions d'entrée et de sortie.
  <indexterm>
   <primary>fonction d'entrée</primary>
   <secondary>d'un type de données</secondary>
  </indexterm>
  <indexterm>
   <primary>fonction de sortie</primary>
   <secondary>d'un type de données</secondary>
  </indexterm>
  Ces fonctions déterminent la présentation du type en chaînes de caractères
  (pour la saisie par l'utilisateur et le renvoi à l'utilisateur) et son
  organisation en mémoire. La fonction d'entrée prend comme argument une
  chaîne de caractères terminée par NULL et retourne la représentation interne
  (en mémoire) du type. La fonction de sortie prend en argument la
  représentation interne du type et retourne une chaîne de caractères terminée
  par NULL. 
 </para>
 <para>
  Il est possible de faire plus que stocker un type, mais il faut pour cela 
  implémenter des fonctions supplémentaires gérant les opérations souhaitées.
 </para>

 <para>
  Soit le cas d'un type <type>complex</type> représentant les nombres complexes. Une
  façon naturelle de représenter un nombre complexe en mémoire passe par la
  structure C suivante&nbsp;:

<programlisting>typedef struct Complex {
    double      x;
    double      y;
} Complex;
</programlisting>

  Ce type ne pouvant tenir sur une simple valeur <type>Datum</type>, il sera passé
  par référence.
 </para>

 <para>
  La représentation externe du type se fera sous la forme de la chaîne
  <literal>(x,y)</literal>.
 </para>

 <para>
  En général, les fonctions d'entrée et de sortie ne sont pas compliquées à
  écrire, particulièrement la fonction de sortie. 
  Mais lors de la définition de la représentation externe du type par une chaîne de caractères, il faudra peut-être écrire un analyseur complet et robuste, comme fonction d'entrée, pour cette représentation. Par exemple&nbsp;:

<programlisting>PG_FUNCTION_INFO_V1(complex_in);

Datum
complex_in(PG_FUNCTION_ARGS)
{
    char       *str = PG_GETARG_CSTRING(0);
    double      x,
                y;
    Complex    *result;

    if (sscanf(str, " ( %lf , %lf )", &amp;x, &amp;y) != 2)
        ereport(ERROR,
                (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
                 errmsg("invalid input syntax for complex: \"%s\"",
                        str)));

    result = (Complex *) palloc(sizeof(Complex));
    result-&gt;x = x;
    result-&gt;y = y;
    PG_RETURN_POINTER(result);
}
</programlisting>

  La fonction de sortie peut s'écrire simplement&nbsp;:

<programlisting>PG_FUNCTION_INFO_V1(complex_out);

Datum
complex_out(PG_FUNCTION_ARGS)
{
    Complex    *complex = (Complex *) PG_GETARG_POINTER(0);
    char       *result;

    result = (char *) palloc(100);
    snprintf(result, 100, "(%g,%g)", complex-&gt;x, complex-&gt;y);
    PG_RETURN_CSTRING(result);
}
</programlisting>
 </para>

 <para>
  Il est particulièrement important de veiller à ce que les fonctions d'entrée
  et de sortie soient bien inversées l'une par rapport à l'autre. Dans le cas
  contraire, de grosses difficultés pourraient apparaître lors de la sauvegarde
  de la base dans un fichier en vue d'une future relecture de ce fichier.
  Ceci est un problème particulièrement fréquent lorsque des nombres
  à virgule flottante entrent en jeu.
</para>

 <para>
  De manière optionnelle, un type utilisateur peut fournir des
  routines d'entrée et de sortie binaires. Les entrées/sorties binaires sont
  normalement plus rapides mais moins portables que les entrées/sorties
  textuelles. Comme avec les entrées/sorties textuelles, c'est l'utilisateur
  qui définit précisément la représentation binaire externe. La plupart des
  types de données intégrés tentent de fournir une représentation binaire
  indépendante de la machine. Dans le cas du type <type>complex</type>, 
  des convertisseurs d'entrées/sorties binaires pour le type <type>float8</type> sont utilisés&nbsp;:

<programlisting>PG_FUNCTION_INFO_V1(complex_recv);

Datum
complex_recv(PG_FUNCTION_ARGS)
{
    StringInfo  buf = (StringInfo) PG_GETARG_POINTER(0);
    Complex    *result;

    result = (Complex *) palloc(sizeof(Complex));
    result-&gt;x = pq_getmsgfloat8(buf);
    result-&gt;y = pq_getmsgfloat8(buf);
    PG_RETURN_POINTER(result);
}

PG_FUNCTION_INFO_V1(complex_send);

Datum
complex_send(PG_FUNCTION_ARGS)
{
    Complex    *complex = (Complex *) PG_GETARG_POINTER(0);
    StringInfoData buf;

    pq_begintypsend(&amp;buf);
    pq_sendfloat8(&amp;buf, complex-&gt;x);
    pq_sendfloat8(&amp;buf, complex-&gt;y);
    PG_RETURN_BYTEA_P(pq_endtypsend(&amp;buf));
}
</programlisting>
 </para>

 <para>
  La définition du type <type>complex</type> passe par la création préalable
  de fonctions d'entrées/sorties utilisateur&nbsp;:


<programlisting>CREATE FUNCTION complex_in(cstring)
    RETURNS complex
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION complex_out(complex)
    RETURNS cstring
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION complex_recv(internal)
   RETURNS complex
   AS '<replaceable>filename</replaceable>'
   LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION complex_send(complex)
   RETURNS bytea
   AS '<replaceable>filename</replaceable>'
   LANGUAGE C IMMUTABLE STRICT;
</programlisting>

 La déclaration des fonctions d'entrée et de sortie fait référence à un type 
 non encore défini. Ceci est permis, mais provoque des messages d'avertissement qui peuvent être ignorés. La fonction d'entrée doit apparaître la première.
</para>

 <para>
  Le type de données peut ensuite être déclaré&nbsp;:
<programlisting>CREATE TYPE complex (
   internallength = 16,
   input = complex_in,
   output = complex_out,
   receive = complex_recv,
   send = complex_send,
   alignment = double
);
</programlisting>
 </para>

 <para>
  Quand un nouveau type de base est défini,
  <productname>PostgreSQL</productname> fournit automatiquement le support pour
  des tableaux de ce type. 
  <indexterm>
   <primary>tableau</primary>
   <secondary>types utilisateur</secondary>
  </indexterm> 
  Pour des raisons historiques, le type tableau a le nom du type de base
  préfixé par un caractère souligné (<literal>_</literal>).
 </para>

 <para>
  Lorsque le type de données existe, il est possible de déclarer les fonctions
  supplémentaires de définition des opérations utiles pour ce type.
  Les opérateurs peuvent alors être définis par dessus ces fonctions et, si
  nécessaire, des classes d'opérateurs peuvent être créées pour 
  le support de l'indexage du type de données. Ces couches supplémentaires sont
  discutées dans les sections suivantes.
 </para>

 <para>
  Si les valeurs du type de données peuvent excéder une taille de quelques
  centaines d'octets (sous la forme interne), le type de
  données devrait être marqué comme TOAST-able. 
  <indexterm>
   <primary>TOAST</primary>
   <secondary>types utilisateur</secondary>
  </indexterm> 
  Pour cela, la représentation interne doit suivre le cadre standard des données
  à longueur variable&nbsp;: les quatre premiers octets sont un
  <type>int32</type> contenant la longueur totale en octets de la donnée
  (incluant les quatre premiers octets). Les
  fonctions C opérant sur le type de données doivent être attentives à
  déballer toutes les valeurs toastées des données (ce détail est généralement
  masqué par la définition de macros <function>GETARG</function> spécifiques).
  Puis, lors de l'exécution de la commande <command>CREATE TYPE</command>,
  la longueur interne sera spécifiée 
  comme <literal>variable</literal> et l'option de stockage en mémoire appropriée
  sera choisie.
 </para>

 <para>
  Pour plus de détails, voir la description de la commande
  <xref linkend="sql-createtype" endterm="sql-createtype-title"/>.
 </para>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
