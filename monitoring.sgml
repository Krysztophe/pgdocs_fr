<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/monitoring.sgml,v 1.11 2005/09/15 07:03:19 guillaume Exp $
-->

<chapter id="monitoring">
 <title>Surveiller l'activité de la base de données</title>

 <indexterm zone="monitoring">
  <primary>surveiller</primary>
  <secondary>activité de la base de données</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <primary>activité de la base de données</primary>
  <secondary>suveiller</secondary>
 </indexterm>

 <para>
  Un administrateur de bases de données se demande fréquemment, <quote>Que fait
  le système en ce moment&nbsp;?</quote> Ce chapitre discute de la façon de le
  savoir.
 </para>

  <para>
   Plusieurs outils sont disponibles pour surveiller l'activité de la base de
   données et pour analyser les performances. Une grande partie de ce chapitre
   concerne la description du récupérateur de statistiques de
   <productname>PostgreSQL</productname> mais personne ne devrait négliger les
   programmes de surveillance Unix standards tels que <command>ps</>,
   <command>top</>, <command>iostat</> et <command>vmstat</>. De plus, une fois
   qu'une requête peu performante a été identifiée, des investigations
   supplémentaires pourraient être nécessaires en utilisant la commande <xref
   linkend="sql-explain" endterm="sql-explain-title"> de
   <productname>PostgreSQL</productname>. <xref linkend="using-explain"> discute
   de <command>EXPLAIN</> et des autres méthodes pour comprendre le comportement
   d'une seule requête.
  </para>

 <sect1 id="monitoring-ps">
  <title>Outils Unix standard</Title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>pour surveiller l'activité</secondary>
  </indexterm>

  <para>
   Sur la plupart des plateformes, <productname>PostgreSQL</productname> modifie
   son titre de commande reporté par <command>ps</> de façon à ce que les
   processus serveur individuels puissent être rapidement identifiés. Voici un
   affichage d'exemple&nbsp;:

<screen>
$ ps auxww | grep ^postgres
postgres   960  0.0  1.1  6104 1480 pts/1    SN   13:17   0:00 postmaster -i
postgres   963  0.0  1.1  7084 1472 pts/1    SN   13:17   0:00 postgres: stats buffer process   
postgres   965  0.0  1.1  6152 1512 pts/1    SN   13:17   0:00 postgres: stats collector process   
postgres   998  0.0  2.3  6532 2992 pts/1    SN   13:18   0:00 postgres: tgl runbogue 127.0.0.1 idle
postgres  1003  0.0  2.4  6532 3128 pts/1    SN   13:19   0:00 postgres: tgl regression [local] SELECT waiting
postgres  1016  0.1  2.4  6532 3080 pts/1    SN   13:19   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   (L'appel approprié de <command>ps</> varie suivant les différentes
   plateformes, ainsi que les détails sur ce qui est affiché. Cet exemple est
   tiré d'un système Linux récent.) Le premier processus affiché ici est le
   <application>postmaster</>, le processus serveur maître. Les arguments
   affichés de la commande sont les mêmes qu'à son lancement. Les deux processus
   suivant implémentent la récupération de statistiques, qui sera décrite en
   détail dans la section suivante. (Elles ne seront pas présentes si vous avez
   configuré le système pour qu'il ne lance pas le récupérateur de
   statistiques.) Chacun des autres processus est un processus serveur gérant
   une connexion cliente. Tous ces processus restant initialisent l'affichage de
   la ligne de commande de la forme

<screen>
postgres: <replaceable>utilisateur</> <replaceable>base_de_données</>
<replaceable>hôte</> <replaceable>activité</>
</screen>

  L'utilisateur, la base de données et les éléments de l'hôte de connexion
  restent identiques pendant toute la vie de connexion du client mais
  l'indicateur d'activité change. L'activité pourrait être <literal>idle</>
  (c'est-à-dire en attente d'une commande du client), <literal>idle in
  transaction</> (en attente du client à l'intérieur d'un bloc de
  <command>BEGIN</>) ou un nom de commande du type <literal>SELECT</>. De plus,
  <literal>waiting</> est attaché si le processus serveur est en attente d'un
  verrou détenu par un autre processus serveur. Dans l'exemple ci-dessus, nous
  pouvons supposer que le processus 1003 attend que le processus 1016 ait
  terminé sa transaction et du coup libère un verrou.
  </para>

  <tip>
  <para>
  <productname>Solaris</productname> requiert une gestion particulière. Vous
  devez utiliser <command>/usr/ucb/ps</command> plutôt que
  <command>/bin/ps</command>. Vous devez aussi utiliser deux options
  <option>w</option> et non pas seulement une. En plus, votre appel original de
  la commande <command>postmaster</command> doit avoir un affichage de statut
  dans <command>ps</command> plus petit que celui fourni par les autres
  processus serveur. Si vous échouez dans les trois, l'affichage de
  <command>ps</> pour chaque processus serveur sera la ligne de commande
  originale de <command>postmaster</>.
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <title>Le récupérateur de statistiques</Title>

  <indexterm zone="monitoring-stats">
   <primary>statistiques</primary>
  </indexterm>

  <para>
   Le <firstterm>récupérateur de statistiques</> de
   <productname>PostgreSQL</productname> est un sous-système qui supporte la
   récupération et les rapports d'informations sur l'activité du serveur.
   Actuellement, le récupérateur peut compter les accès aux tables et index à la
   fois en terme de blocs disque et de lignes individuelles. Il supporte aussi
   la détermination de la commande exacte en cours d'exécution par les autres
   processus serveur.
  </para>

 <sect2 id="monitoring-stats-setup">
  <title>Configuration de la récupération de statistiques</Title>

  <para>
   Comme la récupération de statistiques ajoute un temps supplémentaire à
   l'exécution de la requête, le système peut être configuré pour récupérer ou
   non des informations. Ceci est contrôlé par les paramètres de configuration
   qui sont normalement initialisés dans <filename>postgresql.conf</>. (Voir
   <xref linkend="runtime-config"> pour plus de détails sur leur
   initialisation.)
  </para>

  <para>
   Le paramètre <xref linkend="guc-stats-start-collector"> doit valoir
   <literal>true</> pour que le récupérateur de statistiques soit seulement
   lancé. C'est la valeur par défaut et la configuration recommandée mais elle
   peut être désactivée si vous n'êtes pas intéressé dans les statistiques et
   que vous souhaitez supprimer toute activité en trop. (Néanmoins, ce que vous
   sauverez sera assez petit.) Notez que cette option ne peut pas être changée
   alors que le serveur est en cours d'exécution.
  </para>

  <para>
   Les paramètres <xref linkend="guc-stats-command-string">, <xref
   linkend="guc-stats-block-level"> et <xref linkend="guc-stats-row-level">
   contrôlent la quantité d'informations réellement envoyée au récupérateur et
   détermine du coup le temps supplémentaire réclamé. Ils déterminent
   respectivement si un processus serveur envoie sa chaîne de commande actuelle,
   les statistiques d'accès au niveau du bloc disque et celles au niveau de la
   ligne vers le récupérateur. Normalement, ces paramètres sont configurés dans
   <filename>postgresql.conf</> de façon à ce qu'ils s'appliquent à tous les
   processus serveur mais il est possible de les activer/désactiver sur des
   sessions individuelles en utilisant la commande <xref
   linkend="sql-set" endterm="sql-set-title">. (Pour empêcher les utilisateurs
   ordinaires de cacher leur activité à l'administrateur, seuls les
   superutilisateurs sont autorisés à modifier ces paramètres avec
   <command>SET</>.)
  </para>

   <note>
    <para>
     Comme les paramètres <varname>stats_command_string</varname>,
     <varname>stats_block_level</varname> et
     <varname>stats_row_level</varname> valent par défaut <literal>false</>,
     très peu de statistiques sont récupérées dans la configuration par défaut.
     Activer une ou plus des variables de configuration améliorera
     significativement le nombre de données utiles produit par le récupérateur
     de statistiques au prix d'une surcharge supplémentaire à l'exécution.
    </para>
   </note>

 </sect2>

 <sect2 id="monitoring-stats-views">
  <title>Visualiser les statistiques récupérées</Title>

  <para>
   Plusieurs vues prédéfinies, listées dans <xref
   linkend="monitoring-stats-views-table">, sont disponibles pour afficher
   les résultats de la récupération de statistiques. Autrement, vous pouvez
   construire des vues personnalisées en utilisant les fonctions statistiques
   existantes.
  </para>

  <para>
   En utilisant les statistiques pour surveiller l'activité en cours, il est
   important de réaliser que l'information n'est pas mise à jour instantanément.
   Chaque processus serveur individuel transmet le nouveau nombre d'accès au
   niveau des blocs et des lignes au récupérateur juste avant l'attente d'une
   nouvelle commande du client&nbsp;; donc une requête toujours en cours
   n'affecte pas les totaux affichés. De plus, le récupérateur lui-même émet un
   nouveau rapport une fois par <varname>pgstat_stat_interval</varname>
   millisecondes (500 par défaut). Donc, les totaux affichés sont bien derrière
   l'activité réelle. L'information sur la requête en cours est rapportée
   immédiatement par le récupérateur mais est toujours sujet au délai
   <varname>pgstat_stat_interval</varname> avant de devenir visible.
  </para>

  <para>
   Un autre point important est que, lorsqu'un processus serveur se voit
   demander d'afficher une des statistiques, il récupère tout d'abord le rapport
   le plus récent émis pas le processus de récupération, puis continue
   d'utiliser cette image de toutes les vues et fonctions statistiques jusqu'à
   la fin de sa transaction en cours. Donc, les statistiques ne sembleront pas
   changer tant que vous restez dans la même transaction. Ceci est une
   fonctionnalité, et non pas un bogue, car il vous permet de traiter plusieurs
   requêtes sur les statistiques et de corréler les résultats sans vous
   inquiétez que les nombres aient pu changer. Mais si vous voulez voir les
   nouveaux résultats pour chaque requête, assurez-vous de lancer les requêtes
   en dehors de tout bloc de transaction.
  </para>

  <table id="monitoring-stats-views-table">
   <title>Vues statistiques standards</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structname>pg_stat_activity</></entry>
      <entry>Une ligne par processus serveur, affichant l'<acronym>ID</> du
      processus, la base de données, l'utilisateur, la requête en cours et le
      temps où a commencé l'exécution de la requête, l'heure à laquelle le
      moteur a été lancé, l'adresse et le numéro de port du client. Les colonnes
      renvoyant des données sur la requête en cours sont seulement disponibles
      si le paramètre <varname>stats_command_string</varname> a été activé. De
      plus, ces colonnes se lisent comme NULL sauf si l'utilisateur examinant
      cette vue est un superutilisateur ou est le propriétaire du processus en
      cours de rapport. (Notez qu'à cause des délais du récupérateur, la requête
      en cours ne sera mise à jour que pour les requêtes de longue durée.)</entry>
     </row>

     <row>
      <entry><structname>pg_stat_database</></entry>
      <entry>Une ligne par base de données, affichant le nombre de processus
      serveur actifs, le nombre total de transactions validées et le nombre de
      celles qui ont été annulées, le nombre total de blocs disque lus et le
      nombre total de succès du tampon (c'est-à-dire le nombre de lecture de
      blocs évité en trouvant déjà le bloc dans le cache du tampon).
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_tables</></entry>
      <entry>Pour chaque table dans la base de données en cours, les nombres
      totaux de parcours séquentiels et indexés, le nombre total de lignes
      renvoyés par chaque type de parcours et le nombre total d'insertions, de
      mises à jour et de suppressions de lignes.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_tables</></entry>
      <entry>Identique à <structname>pg_stat_all_tables</>, sauf que seules les
      tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_tables</></entry>
      <entry>Identique à <structname>pg_stat_all_tables</>, sauf que seules les
      tables utilisateurs sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_indexes</></entry>
      <entry>Pour chaque index dans la base de données en cours, le nombre total
      de parcours d'index qui ont utilisé cet index, le nombre de lignes d'index
      lus et le nombre de lignes d'en-tête récupérées avec succès. (Ceci
      pourrait être moindre quand les entrées d'index pointent vers des lignes
      supprimées.)
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_indexes</></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</>, sauf que seules les
      tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_indexes</></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</>, sauf que seules
      les tables utilisateurs sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_tables</></entry>
      <entry>Pour chaque table de la base de données en cours, le nombre total
      de lecture de blocs disques à partir de cette table, le nombre de
      récupérations valides par les tampons, le nombre de lectures de blocs
      disque et le nombre de récupérations valides par les tampons dans tous les
      index de cette table, le nombre de lectures de blocs disque et le nombre
      de récupérations valides par les tampons dans tous les index à partir de
      la table auxiliaire TOAST (si elle existe) pour cette table, le nombre de
      lectures de blocs disque et le nombre de récupérations valides par les
      tampons pour l'index de la table TOAST.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_tables</></entry>
      <entry>Identique à <structname>pg_statio_all_tables</>, sauf que seules
      les tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_tables</></entry>
      <entry>Identique à <structname>pg_statio_all_tables</>, sauf que seules
      les tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_indexes</></entry>
      <entry>Pour chaque index de la base de données en cours, les nombres de
      lectures de blocs disque et de récupérations valides dans cet index.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_indexes</></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</>, sauf que seuls
      les index systèmes sont affichés.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_indexes</></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</>, sauf que seuls
      les index systèmes sont affichés.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_sequences</></entry>
      <entry>Pour chaque objet séquence de la base de données en cours, le 
      nombres de lectures de blocs disque et de récupérations valides de tampons
      dans cette séquence.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_sequences</></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</>, sauf que
      seules les séquences système sont affichées. (Actuellement, aucune
      séquence système n'est définie, donc cette vue est toujours vide.)</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_sequences</></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</>, sauf que
      seules les séquences utilisateur sont affichées.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les statistiques par index sont particulièrement utiles pour déterminer
   les index utilisés et leur efficacité.
  </para>

  <para>
   Les vues <structname>pg_statio_</> sont principalement utiles pour
   déterminer l'efficacité du cache tampon. Quand le nombre de lectures disques
   réelles est plus petit que le nombre de récupérations valides par le tampon,
   alors le cache satisfait la plupart des demandes de lecture sans faire appel
   au noyau. Néanmoins, ces statistiques ne nous donnent pas l'histoire
   complète&nbsp;: à cause de la façon dont <productname>PostgreSQL</> gère les
   entrées/sorties disque, les données qui ne sont pas dans le tampon de
   <productname>PostgreSQL</> pourraient toujours résider dans le tampon
   d'entrées/sorties du noyau et pourraient, du coup, être toujours récupérées
   sans nécessiter une lecture physique. Les utilisateurs intéressés pour
   obtenir des informations plus détaillées sur le comportement des
   entrées/sorties dans <productname>PostgreSQL</> sont invités à utiliser le
   récupérateur de statistiques de <productname>PostgreSQL</> avec les outils du
   système d'exploitation permettant une vue de la gestion des
   entrées/sorties par le noyau.
  </para>

  <para>
   D'autres façons de regarder les statistiques peuvent se configurer en
   écrivant des requêtes qui utilisent les même fonctions d'accès aux
   statistiques que les vues standard. Ces fonctions sont listées
   dans <xref linkend="monitoring-stats-funcs-table">. Les fonctions d'accès par
   base de données prennent un OID de la base de données comme argument pour
   identifier la base de données du rapport. Les fonctions par table et par
   index prennent l'OID de la table ou de l'index. (Notez que seuls les tables
   et les index de la base de données en cours peuvent être vus par ces
   fonctions.) Les fonctions d'accès au processus prennent le numéro
   d'identifiant du processus.
  </para>

  <table id="monitoring-stats-funcs-table">
   <title>Fonctions d'accès aux statistiques</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Code de retour</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>pg_stat_get_db_numbackends</function>(<type>oid</type>)</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       Nombre de processus actifs pour la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_xact_commit</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Transactions validées dans la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_xact_rollback</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Transactions annulées dans la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_blocks_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de récupérations de blocs disque pour la base de
       données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_blocks_hit</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de récupérations de blocs disque trouvés dans le
       tampon pour la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_numscans</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de parcours séquentiels réalisés lorsque l'argument est une
       table, ou nombre de parcours d'index lorsque l'argument est un index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_returned</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes lues par les parcours séquentiels lorsque l'argument
       est une table, ou nombre de lignes d'index lus lorsque l'argument est un
       index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes récupérées valides (non expirées) récupérées par des
       parcours séquentiels quand l'argument est une table, ou récupérées par
       des parcours d'index en utilisant cet index lorsque l'argument est un
       index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_inserted</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes insérées dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_updated</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes mises à jour dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_deleted</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes supprimées dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_blocks_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de récupération de blocs disques pour la table ou
       l'index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_blocks_hit</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de blocs disque récupérés dans le tampon pour la
       table ou l'index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_idset</function>()</literal></entry>
      <entry><type>set of integer</type></entry>
      <entry>
       Ensemble d'identifiants de processus actifs (de 1 au nombre de processus
       actifs). Voir l'exemple d'utilisation dans le texte.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_backend_pid</function>()</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       ID du processus pour le processus serveur attaché à la session en cours
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_pid</function>(<type>integer</type>)</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       ID du processus pour le processus serveur donné
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_dbid</function>(<type>integer</type>)</literal></entry>
      <entry><type>oid</type></entry>
      <entry>
       ID de la base de données pour le processus serveur en cours
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_userid</function>(<type>integer</type>)</literal></entry>
      <entry><type>oid</type></entry>
      <entry>
       ID de l'utilisateur pour le processus serveur en cours
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity</function>(<type>integer</type>)</literal></entry>
      <entry><type>text</type></entry>
      <entry>
       Commande active du processus serveur en cours (NULL si l'utilisateur
       courant n'est pas un superutilisateur ni le même utilisateur que celui de
       la session en cours de requêtage, ou si
       <varname>stats_command_string</varname> n'est pas activée)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity_start</function>(<type>integer</type>)</literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>
       Le moment où la requête en cours de traitement a été lancé (NULL si
       l'utilisateur courant n'est pas un superutilisateur ou s'il ne s'agit pas
       du même utilisateur que celui de la session qui a lancé la requête ou si
       <varname>stats_command_string</varname> n'est pas actif)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_start</function>(<type>integer</type>)</literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>
       L'heure à laquelle le processus serveur donné a été lancé ou null si
       l'utilisateur en cours n'est ni un superutilisateur ni l'utilisateur
       de la session requêtée
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_addr</function>(<type>integer</type>)</literal></entry>
      <entry><type>inet</type></entry>
      <entry>
       L'adresse IP du client connecté au processus serveur donné. NULL si
       la connexion est établie sur un socket de domaine Unix. Aussi NULL si
       l'utilisateur en cours n'est ni un superutilisateur ni l'utilisateur
       de la session requêtée
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_port</function>(<type>integer</type>)</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       Le numéro de port du client connecté au processus serveur donné. -1 si
       la connexion est établie sur un socket de domaine Unix. NULL si
       l'utilisateur en cours n'est ni un superutilisateur ni l'utilisateur
       de la session requêtée
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset</function>()</literal></entry>
      <entry><type>boolean</type></entry>
      <entry>
       Réinitialise toutes les statistiques en cours
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <note>
    <para>
     <function>pg_stat_get_db_blocks_fetched</function> moins
     <function>pg_stat_get_db_blocks_hit</function> donne le nombre d'appels
     lancés pour la table, l'index ou la base de données&nbsp;; mais le nombre 
     réel de lectures physiques est habituellement moindre à cause des tampons
     du noyau.
    </para>
   </note>

  <para>
   La fonction <function>pg_stat_get_backend_idset</function> fournit un moyen
   agréable de générer une ligne pour chaque processus serveur actif. Par
   exemple, pour afficher les <acronym>PID</> et les requêtes en cours pour
   tous les processus serveur&nbsp;:

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS procpid,
       pg_stat_get_backend_activity(s.backendid) AS current_query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>

 </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
  <title>Visualiser les verrous</title>

  <indexterm zone="monitoring-locks">
   <primary>verrou</primary>
   <secondary>surveillance</secondary>
  </indexterm>

  <para>
   Un autre outil utile pour surveiller l'activité des bases de données est la
   table système <structname>pg_locks</structname>. Elle permet à
   l'administrateur système de visualiser des informations sur les verrous
   restant dans le gestionnaire des verrous. Par exemple, cette fonctionnalité
   peut être utilisée pour&nbsp;:
	
   <itemizedlist>
    <listitem>
     <para>
      Visualiser tous les verrous en cours, tous les verrous sur les relations
      d'une base de données particulière ou tous les verrous détenus par une
      session <productname>PostgreSQL</productname> particulière.
     </para>
    </listitem>

    <listitem>
     <para>
      Détermine la relation de la base de données disposant de la plupart des
      verrous non autorisés (et qui, du coup, pourraient être une source de
      contention parmi les clients de la base de données).
     </para>
    </listitem>

    <listitem>
     <para>
      Détermine l'effet de la contention des verrous sur les performances
      générales des bases de données, ainsi que l'échelle dans laquelle varie la
      contention sur le trafic de la base de données.
     </para>
    </listitem>
   </itemizedlist>

   Les détails sur la vue <structname>pg_locks</structname> apparaissent dans
   <xref linkend="view-pg-locks">. Pour plus d'informations sur les verrous et
   la gestion des concurrences avec <productname>PostgreSQL</productname>,
   référez-vous à <xref linkend="mvcc">.
  </para>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
