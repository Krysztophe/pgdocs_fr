<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="monitoring">
 <title>Surveiller l'activité de la base de données</title>

 <indexterm zone="monitoring">
  <primary>surveiller</primary>
  <secondary>activité de la base de données</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <primary>activité de la base de données</primary>
  <secondary>suveiller</secondary>
 </indexterm>

 <para>
  Un administrateur de bases de données se demande fréquemment&nbsp;: <quote>Que
  fait le système en ce moment&nbsp;?</quote> Ce chapitre discute de la façon
  de le savoir.
 </para>

  <para>
   Plusieurs outils sont disponibles pour surveiller l'activité de la base de
   données et pour analyser les performances. Une grande partie de ce chapitre
   concerne la description du récupérateur de statistiques de
   <productname>PostgreSQL</productname> mais personne ne devrait négliger les
   programmes de surveillance Unix standards tels que <command>ps</command>,
   <command>top</command>, <command>iostat</command> et <command>vmstat</command>. De plus, une fois
   qu'une requête peu performante a été identifiée, des investigations
   supplémentaires pourraient être nécessaires en utilisant la commande <xref
   linkend="sql-explain" endterm="sql-explain-title"/> de
   <productname>PostgreSQL</productname>. La <xref linkend="using-explain"/>
   discute de <command>EXPLAIN</command> et des autres méthodes pour comprendre le
   comportement d'une seule requête.
  </para>

 <sect1 id="monitoring-ps">
  <title>Outils Unix standard</title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>pour surveiller l'activité</secondary>
  </indexterm>

  <para>
   Sur la plupart des plateformes, <productname>PostgreSQL</productname> modifie
   son titre de commande reporté par <command>ps</command> de façon à ce que les
   processus serveur individuels puissent être rapidement identifiés. Voici un
   affichage d'exemple&nbsp;:

<screen>$ ps auxww | grep ^postgres
postgres   960  0.0  1.1  6104 1480 pts/1    SN   13:17   0:00 postgres -i
postgres   963  0.0  1.1  7084 1472 pts/1    SN   13:17   0:00 postgres: writer process   
postgres   965  0.0  1.1  6152 1512 pts/1    SN   13:17   0:00 postgres: stats collector process   
postgres   998  0.0  2.3  6532 2992 pts/1    SN   13:18   0:00 postgres: tgl runbogue 127.0.0.1 idle
postgres  1003  0.0  2.4  6532 3128 pts/1    SN   13:19   0:00 postgres: tgl regression [local] SELECT waiting
postgres  1016  0.1  2.4  6532 3080 pts/1    SN   13:19   0:00 postgres: tgl regression [local] idle in transaction</screen>

   (L'appel approprié de <command>ps</command> varie suivant les différentes
   plateformes, de même que les détails affichés. Cet exemple est
   tiré d'un système Linux récent.) Le premier processus affiché ici est le
   processus serveur maître, le processus serveur maître. Les arguments
   affichés pour cette commande sont les mêmes qu'à son lancement. Les deux
   processus suivant sont des processus en tâche de fond lancés
   automatiquement par le processus maître (le processus
   <quote>stats collector</quote> n'est pas présent si
   vous avez configuré le système pour qu'il ne lance pas le récupérateur de
   statistiques). Chacun des autres processus est un processus serveur gérant
   une connexion cliente. Tous ces processus restant initialisent l'affichage de
   la ligne de commande de la forme

<screen>postgres: <replaceable>utilisateur</replaceable> <replaceable>base_de_données</replaceable> <replaceable>hôte</replaceable> <replaceable>activité</replaceable></screen>

  L'utilisateur, la base de données et les éléments de l'hôte de connexion
  restent identiques pendant toute la vie de connexion du client mais
  l'indicateur d'activité change. L'activité pourrait être <literal>idle</literal>
  (c'est-à-dire en attente d'une commande du client), <literal>idle in
  transaction</literal> (en attente du client à l'intérieur d'un bloc de
  <command>BEGIN</command>/<command>COMMIT</command>) ou un nom de commande du type
  <literal>SELECT</literal>. De plus, <literal>waiting</literal> est attaché si le processus
  serveur est en attente d'un verrou détenu par un autre processus serveur.
  Dans l'exemple ci-dessus, nous pouvons supposer que le processus 1003 attend
  que le processus 1016 ait terminé sa transaction et, du coup, libère un verrou.
  </para>

  <para>
   Si vous avez désactivé <xref linkend="guc-update-process-title"/>, alors
   l'indicateur d'activité n'est pas mis à jour&nbsp;; le titre du processus
   est configuré une seule fois quand un nouveau processus est lancé. Sur
   certaines plateformes, ceci permet d'économiser du temps. Sur d'autres,
   cette économie est insignifiante.
  </para>

  <tip>
  <para>
  <productname>Solaris</productname> requiert une gestion particulière. Vous
  devez utiliser <command>/usr/ucb/ps</command> plutôt que
  <command>/bin/ps</command>. Vous devez aussi utiliser deux options
  <option>w</option> et non pas seulement une. En plus, votre appel original de
  la commande <command>postgres</command> doit avoir un affichage de statut
  dans <command>ps</command> plus petit que celui fourni par les autres
  processus serveur. Si vous échouez dans les trois, l'affichage de
  <command>ps</command> pour chaque processus serveur sera la ligne de commande
  originale de <command>postgres</command>.
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <title>Le récupérateur de statistiques</title>

  <indexterm zone="monitoring-stats">
   <primary>statistiques</primary>
  </indexterm>

  <para>
   Le <firstterm>récupérateur de statistiques</firstterm> de
   <productname>PostgreSQL</productname> est un sous-système qui supporte la
   récupération et les rapports d'informations sur l'activité du serveur.
   Actuellement, le récupérateur peut compter les accès aux tables et index à la
   fois en terme de blocs disque et de lignes individuelles. Il conserve aussi
   la trace de nombre total de lignes dans chaque table ainsi que la date et
   l'heure du dernier VACUUM et du dernier ANALYZE pour chaque table.
   It can also count calls to user-defined functions and
   the total time spent in each one.
  </para>

  <para>
   <productname>PostgreSQL</productname> supporte aussi
   la détermination de la commande exacte en cours d'exécution par les autres
   processus serveur. Cette fonctionnalité indépendante ne dépend pas du
   récupérateur de statistiques.
  </para>

 <sect2 id="monitoring-stats-setup">
  <title>Configuration de la récupération de statistiques</title>

  <para>
   Comme la récupération de statistiques ajoute un temps supplémentaire à
   l'exécution de la requête, le système peut être configuré pour récupérer ou
   non des informations. Ceci est contrôlé par les paramètres de configuration
   qui sont normalement initialisés dans <filename>postgresql.conf</filename> (voir
   <xref linkend="runtime-config"/> pour plus de détails sur leur
   initialisation).
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-counts"/> contrôle si
   statistics are collected about table and index accesses.
  </para>

  <para>
   The parameter <xref linkend="guc-track-functions"> enables tracking of
   usage of user-defined functions.
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-activities"/> active la surveillance
   de la commande en cours d'exécution par un processus serveur.
  </para>

  <para>
   Normalement, ces paramètres sont configurés dans
   <filename>postgresql.conf</filename> de façon à ce qu'ils s'appliquent à tous les
   processus serveur mais il est possible de les activer/désactiver sur des
   sessions individuelles en utilisant la commande <xref
   linkend="sql-set" endterm="sql-set-title"/> (pour empêcher les utilisateurs
   ordinaires de cacher leur activité à l'administrateur, seuls les
   superutilisateurs sont autorisés à modifier ces paramètres avec
   <command>SET</command>).
  </para>

  <para>
   The statistics collector communicates with the backends needing 
   information (including autovacuum) through temporary files.
   These files are stored in the <filename>pg_stat_tmp</filename> subdirectory.
   When the postmaster shuts down, a permanent copy of the statistics
   data is stored in the <filename>global</filename> subdirectory. For increased
   performance, the parameter <xref linkend="guc-stats-temp-directory"> can
   be pointed at a RAM based filesystem, decreasing physical I/O requirements.
  </para>

 </sect2>

 <sect2 id="monitoring-stats-views">
  <title>Visualiser les statistiques récupérées</title>

  <para>
   Plusieurs vues prédéfinies, listées dans le <xref
   linkend="monitoring-stats-views-table"/>, sont disponibles pour afficher
   les résultats de la récupération de statistiques. Autrement, vous pouvez
   construire des vues personnalisées en utilisant les fonctions statistiques
   existantes.
  </para>

  <para>
   En utilisant les statistiques pour surveiller l'activité en cours, il est
   important de réaliser que l'information n'est pas mise à jour instantanément.
   Chaque processus serveur individuel transmet les nouvelles statistiques au
   récupérateur juste avant l'attente d'une
   nouvelle commande du client&nbsp;; donc une requête toujours en cours
   n'affecte pas les totaux affichés. De plus, le récupérateur lui-même émet un
   nouveau rapport une fois par <varname>PGSTAT_STAT_INTERVAL</varname>
   millisecondes (500, sauf si cette valeur a été modifiée lors de la
   construction du serveur). Donc, les totaux affichés sont bien derrière
   l'activité réelle. Néanmoins, l'information sur la requête en cours récupérée
   par <varname>track_activities</varname> est toujours à jour.
  </para>

  <para>
   Un autre point important est que, lorsqu'un processus serveur se voit
   demander d'afficher une des statistiques, il récupère tout d'abord le rapport
   le plus récent émis par le processus de récupération, puis continue
   d'utiliser cette image de toutes les vues et fonctions statistiques jusqu'à
   la fin de sa transaction en cours. De façon similaire, les informations sur
   les requêtes en cours, quelque soit le processus, sont récupérées quand une
   telle information est demandée dans une transaction, et cette même information
   sera affichée lors de la transaction. Donc, les statistiques ne sembleront pas
   changer tant que vous restez dans la même transaction. Ceci est une
   fonctionnalité, et non pas un bogue, car il vous permet de traiter plusieurs
   requêtes sur les statistiques et de corréler les résultats sans vous
   inquiéter que les nombres aient pu changer. Mais si vous voulez voir les
   nouveaux résultats pour chaque requête, assurez-vous de lancer les requêtes
   en dehors de tout bloc de transaction. Autrement, vous pouvez appeler
   <function>pg_stat_clear_snapshot</function>(), qui annulera l'image statistique
   de la transaction en cours. L'utilisation suivante des informations
   statistiques causera la récupération d'une nouvelle image.
  </para>

  <table id="monitoring-stats-views-table">
   <title>Vues statistiques standards</title>

   <tgroup cols="2">
    <colspec colnum="1" colwidth="0.4*"/>
    <colspec colnum="2" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structname>pg_stat_activity</structname></entry>
      <entry>Une ligne par processus serveur, affichant l'OID de la base de
      données, le nom de la base, l'<acronym>ID</acronym> du processus, l'OID de
      l'utilisateur, son nom, la requête en cours, l'état d'attente de la requête,
      le moment où a commencé l'exécution de la requête et de la transaction, le
	  moment où le processus serveur a été lancé ainsi que l'adresse
      et le numéro de port du client. Les colonnes renvoyant des données sur la
      requête en cours sont disponibles sauf si le paramètre
      <varname>track_activities</varname> a été désactivé. De
      plus, ces colonnes sont seulement visibles si l'utilisateur examinant
      cette vue est un superutilisateur ou est le propriétaire du processus en
      cours de rapport.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_bgwriter</structname></entry>
      <entry>Une seule ligne indiquant des statistiques du cluster complet
      provenant du processus d'écriture en tâche de fond&nbsp;: nombre
      de points de vérification planifiés, points de vérification demandés,
      tampons écrits par les points de vérification et parcours de nettoyage,
      et le nombre de fois où le processus d'écriture en tâche de fond a stoppé
      un parcours de nettoyage parce qu'il a écrit trop de tampons. Cela inclut
      aussi des statistiques sur les tampons partagés dont le nombre de
      tampons écrit par les processus serveur (c'est-à-dire par autre chose
      que le processus d'écriture en tâche de fond) et le nombre total de
      tampons alloués.
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database</structname></entry>
      <entry>Une ligne par base de données, affichant l'OID de la base de
      données, son nom, le nombre de processus serveur actifs connectés à cette
      base, le nombre total de transactions validées et le nombre de
      celles qui ont été annulées, le nombre total de blocs disque lus, le
      nombre total de succès du tampon (c'est-à-dire le nombre de lectures de
      blocs évitées en trouvant déjà le bloc dans le cache du tampon), le
      nombre de lignes renvoyées, récupérées, insérées, mises à jour et supprimées.
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_tables</structname></entry>
      <entry>Pour chaque table dans la base de données en cours (ceci 
      incluant les tables TOAST), l'OID de la table, le nom du schéma et de la
      table, le nombre de parcours séquentiels réalisés, le nombre de lignes
      vivantes récupérées par des parcours séquentiels, le nombre de lignes
      vivantes récupérées par des parcours séquentiels, le nombre de parcours
      d'index réalisés (pour tous les index appartenant à cette table), le
      nombre de lignes vivantes récupérées par les parcours d'index, le nombre
      d'insertions, de modifications et de suppressions de ligne, le nombre de
      mises à jour de ligne via HOT (donc sans mise à jour séparée des index),
      le nombre de lignes vivantes et mortes, la dernière
      fois que la table a été la cible d'un VACUUM manuel, la dernière fois
      qu'elle a été la cible d'un VACUUM exécuté par le démon autovacuum, la
      dernière fois que la table a été la cible d'un ANALYZE manuel, la dernière
      fois qu'elle a été la cible d'un ANALYZE exécuté par le démon autovacuum.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_tables</structname></entry>
      <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
      tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_tables</structname></entry>
      <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
      tables utilisateurs sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_indexes</structname></entry>
      <entry>Pour chaque index de la base de données en cours, l'OID de la
      table et de l'index, le nom du schéma, de la table et de l'index, le
      nombre de parcours d'index initiés sur cet index, le nombre d'entrées de
      l'index renvoyées par les parcours d'index, et le nombre de lignes actives
      de table récupérées par de simples parcours d'index utilisant cet index.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_indexes</structname></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules les
      tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_indexes</structname></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules
      les tables utilisateurs sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_tables</structname></entry>
      <entry>Pour chaque table de la base de données en cours (ceci incluant les
      tables TOAST), l'OID de la table, le nom du schéma et de la table, le
      nombre de blocs disque lus à partir de cette table, le nombre de lectures
      tampon réussies dans tous les index de cette table, le nombre de blocs
      disque lus et de lectures tampon réussies à partir de la table TOAST
      (si elle existe), et, enfin, le nombre de blocs disque lus et le nombre
      de lectures tampon réussies à partir de l'index de la table TOAST.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_tables</structname></entry>
      <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
      les tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_tables</structname></entry>
      <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
      les tables utilisateur sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_indexes</structname></entry>
      <entry>Pour chaque index de la base de données en cours, l'OID de la table
      et de l'index, le nom du schéma, de la table et de l'index, le nombre
      de blocs disque lus et le nombre de lectures tampon réussies pour
      cet index.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_indexes</structname></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
      les index systèmes sont affichés.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_indexes</structname></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
      les index utilisateur sont affichés.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_sequences</structname></entry>
      <entry>Pour chaque séquence de la base de données en cours, l'OID de la
      séquence, le nom du schéma et de la séquence, le nombre de blocs disque
      lus et le nombre de lectures réussies du tampon pour cette séquence.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_sequences</structname></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
      seules les séquences système sont affichées (actuellement, aucune
      séquence système n'est définie, donc cette vue est toujours vide)</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_sequences</structname></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
      seules les séquences utilisateur sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_functions</></entry>
      <entry>For all tracked functions, function OID, schema, name, number
      of calls, total time, and self time.  Self time is the
      amount of time spent in the function itself, total time includes the
      time spent in functions it called. Time values are in milliseconds.
     </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les statistiques par index sont particulièrement utiles pour déterminer
   les index utilisés et leur efficacité.
  </para>

  <para>
   À partir de la version 8.1 de <productname>PostgreSQL</productname>, les
   index peuvent être utilisés soit directement soit via des <quote>parcours de
   bitmap</quote>. Dans un parcours de bitmap, les résultats de plusieurs index
   peuvent être combinés via des règles AND ou OR&nbsp;; donc il est difficile
   d'associer des récupérations de lignes d'en-têtes individuelles avec des
   index spécifiques quand un parcours de bitmap est utilisé. Du coup, un
   parcours de bitmap incrémente le nombre dans
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_read</structfield>
   pour les index qu'il utilise et il incrémente le nombre
   <structname>pg_stat_all_tables</structname>.<structfield>idx_tup_fetch</structfield>
   pour la table, mais il n'affecte pas
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>.
  </para>

  <note>
   <para>
    Avant <productname>PostgreSQL</productname> 8.1, les totaux
    <structfield>idx_tup_read</structfield> et <structfield>idx_tup_fetch</structfield> étaient
    pratiquement toujours égaux. Maintenant, ils peuvent être différents même
    sans considérer les parcours de bitmap parce que
    <structfield>idx_tup_read</structfield> compte les entrées d'index récupérées à partir
    de l'index alors que <structfield>idx_tup_fetch</structfield> compte les lignes actives
    récupérées à partir de la table&nbsp;; ce dernier sera moindre si des lignes
    mortes ou pas-encore-validées sont récupérées en utilisant l'index.
   </para>
  </note>

  <para>
   Les vues <structname>pg_statio_</structname> sont principalement utiles pour
   déterminer l'efficacité du cache tampon. Quand le nombre de lectures disques
   réelles est plus petit que le nombre de récupérations valides par le tampon,
   alors le cache satisfait la plupart des demandes de lecture sans faire appel
   au noyau. Néanmoins, ces statistiques ne nous donnent pas l'histoire
   complète&nbsp;: à cause de la façon dont <productname>PostgreSQL</productname> gère les
   entrées/sorties disque, les données qui ne sont pas dans le tampon de
   <productname>PostgreSQL</productname> pourraient toujours résider dans le tampon
   d'entrées/sorties du noyau et pourraient, du coup, être toujours récupérées
   sans nécessiter une lecture physique. Les utilisateurs intéressés pour
   obtenir des informations plus détaillées sur le comportement des
   entrées/sorties dans <productname>PostgreSQL</productname> sont invités à utiliser le
   récupérateur de statistiques de <productname>PostgreSQL</productname> avec les outils du
   système d'exploitation permettant une vue de la gestion des
   entrées/sorties par le noyau.
  </para>

  <para>
   Il existe d'autres façons de regarder les statistiques. Cela se fait en
   écrivant des requêtes qui utilisent les mêmes fonctions d'accès aux
   statistiques que les vues standards. Ces fonctions sont listées
   dans le <xref linkend="monitoring-stats-funcs-table"/>. Les fonctions d'accès
   par base de données prennent un OID de la base de données comme argument pour
   identifier la base de données du rapport. Les fonctions par table et par
   index prennent l'OID de la table ou de l'index. The functions for function-call statistics
   take a function OID. (notez que seuls les tables
   et les index de la base de données en cours peuvent être vus par ces
   fonctions). Les fonctions d'accès au processus prennent le numéro
   d'identifiant du processus.
  </para>

  <table id="monitoring-stats-funcs-table">
   <title>Fonctions d'accès aux statistiques</title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="2.0*"/>
    <colspec colnum="2" colwidth="0.3*"/>
    <colspec colnum="3" colwidth="1.2*"/>
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Code de retour</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>pg_stat_get_db_numbackends</function>(<type>oid</type>)</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       Nombre de processus actifs pour la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_xact_commit</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Transactions validées dans la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_xact_rollback</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Transactions annulées dans la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_blocks_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de récupérations de blocs disque pour la base de
       données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_blocks_hit</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de récupérations de blocs disque trouvés dans le
       tampon pour la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_tuples_returned</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes renvoyées pour la base
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_tuples_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes récupérées pour la base
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_tuples_inserted</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes insérées dans la base
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_tuples_updated</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes mises à jour dans la base
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_tuples_deleted</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes supprimées dans la base
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_numscans</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de parcours séquentiels réalisés lorsque l'argument est une
       table, ou nombre de parcours d'index lorsque l'argument est un index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_returned</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes lues par les parcours séquentiels lorsque l'argument
       est une table, ou nombre de lignes d'index lues lorsque l'argument est un
       index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Le nombre de lignes de table récupérées par des parcours de bitmap quand
       l'argument est une table, ou les lignes de table récupérées par de
       simples parcours d'index en utilisant cet index quand l'argument est un
       index.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_inserted</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes insérées dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_updated</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes mises à jour dans la table (incluant les mises à jour
	   via HOT)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_deleted</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes supprimées dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_hot_updated</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes mises à jour via HOT dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_live_tuples</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes vivantes dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_dead_tuples</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes mortes dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_blocks_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de récupération de blocs disques pour la table ou
       l'index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_blocks_hit</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de blocs disque récupérés dans le tampon pour la
       table ou l'index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_deleted</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes supprimées dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_blocks_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de requêtes de récupération de blocs disque pour les tables ou index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_blocks_hit</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de requêtes de blocs disque trouvés en cache pour les tables ou index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_last_vacuum_time</function>(<type>oid</type>)</literal></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       Date/heure du dernier VACUUM survenu sur cette table à la demande de
       l'utilisateur
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_last_autovacuum_time</function>(<type>oid</type>)</literal></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       Date/heure du dernier ANALYZE lancé par le démon autovacuum survenu sur
       cette table.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_last_analyze_time</function>(<type>oid</type>)</literal></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       Date/heure du dernier VACUUM survenu sur cette table à la demande de
       l'utilisateur
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_last_autoanalyze_time</function>(<type>oid</type>)</literal></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       Date/heure du dernier ANALYZE lancé par le démon autovacuum survenu sur
       cette table.
      </entry>
     </row>

     <row>
       <!-- See also the entry for this in func.sgml -->
      <entry><literal><function>pg_backend_pid</function>()</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       ID du processus pour le processus serveur attaché à la session en cours
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_activity</function>(<type>integer</type>)</literal></entry>
      <entry><type>setof record</type></entry>
      <entry>
       Returns a record of information about the backend with the specified pid, or
       one record for each active backend in the system if <symbol>NULL</symbol> is
       specified. The fields returned are the same as in the 
       <structname>pg_stat_activity</structname> view
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_function_calls</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Number of times the function has been called.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_function_time</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Total wall clock time spent in the function, in microseconds.  Includes
       the time spent in functions called by this one.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_function_self_time</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Time spent in only this function. Time spent in called functions
       is excluded.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_idset</function>()</literal></entry>
      <entry><type>setof integer</type></entry>
      <entry>
       Set of currently active server process numbers (from 1 to the
       number of active server processes).  See usage example in the text
      </entry>
     </row>
     
     <row>
      <entry><literal><function>pg_stat_get_backend_pid</function>(<type>integer</type>)</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       ID du processus pour le processus serveur donné
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_dbid</function>(<type>integer</type>)</literal></entry>
      <entry><type>oid</type></entry>
      <entry>
       ID de la base de données pour le processus serveur en cours
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_userid</function>(<type>integer</type>)</literal></entry>
      <entry><type>oid</type></entry>
      <entry>
       ID de l'utilisateur pour le processus serveur en cours
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity</function>(<type>integer</type>)</literal></entry>
      <entry><type>text</type></entry>
      <entry>
       Commande active du processus serveur indiqué mais seulement si l'utilisateur
       courant est un superutilisateur ou le même utilisateur dont vient la commande
       (et que <varname>track_activities</varname> est activé)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_waiting</function>(<type>integer</type>)</literal></entry>
      <entry><type>boolean</type></entry>
      <entry>
       True si le processus serveur indiqué attend un verrou mais seulement si l'utilisateur
       courant est un superutilisateur ou le même utilisateur dont vient la commande
       (et que <varname>track_activities</varname> est activé)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity_start</function>(<type>integer</type>)</literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>
       Date/heure du lancement de la requête en cours d'exécution sur le processus
       serveur indiqué, mais seulement si l'utilisateur courant est un
       superutilisateur ou le même utilisateur dont vient la commande (et que
       <varname>track_activities</varname> est activé)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_xact_start</function>(<type>integer</type>)</literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>
       Le moment auquel le processus serveur indiqué a été exécuté.
       Seulement si l'utilisateur est un superutilisateur ou le même utilisateur
       que celui qui a lancé la session (et que <varname>track_activities</varname>
       est activé)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_start</function>(<type>integer</type>)</literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>
       L'heure à laquelle le processus serveur donné a été lancé ou NULL si
       l'utilisateur en cours n'est ni un superutilisateur ni l'utilisateur
       de la session requêtée
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_addr</function>(<type>integer</type>)</literal></entry>
      <entry><type>inet</type></entry>
      <entry>
       L'adresse IP du client connecté au processus serveur donné. NULL si
       la connexion est établie sur un socket de domaine Unix. Aussi NULL si
       l'utilisateur en cours n'est ni un superutilisateur ni l'utilisateur
       de la session requêtée
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_port</function>(<type>integer</type>)</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       Le numéro de port du client connecté au processus serveur donné. -1 si
       la connexion est établie sur un socket de domaine Unix. NULL si
       l'utilisateur en cours n'est ni un superutilisateur ni l'utilisateur
       de la session requêtée
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_bgwriter_timed_checkpoints</function>()</literal></entry>
       <entry><type>bigint</type></entry>
       <entry>
        Le nombre de fois où le processus d'écriture en tâche de fond a lancé des points de vérification
	planifiés (donc parce que <varname>checkpoint_timeout</varname> est
	arrivé à expiration)
       </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_bgwriter_requested_checkpoints</function>()</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Le nombre de fois où le processus d'écriture en tâche de fond a lancé des points de vérification en se
       basant sur les demandes des processus serveur parce que
       <varname>checkpoint_segments</varname> a été dépassé ou parce que la
       commande <command>CHECKPOINT</command> a été lancée
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_bgwriter_buf_written_checkpoints</function>()</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Le nombre de tampons écrits par le processus d'écriture en tâche de fond lors de points de vérification
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_bgwriter_buf_written_clean</function>()</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Le nombre de tampons écrits par le processus d'écriture en tâche de fond pour le nettoyage de routine
       des pages sales
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_bgwriter_maxwritten_clean</function>()</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Le nombre de fois où le processus d'écriture en tâche de fond est arrêté son parcours de nettoyage parce
       qu'il a écrit plus de tampons que ce qui est spécifié par le paramètre
       <varname>bgwriter_lru_maxpages</varname>
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_buf_written_backend</function>()</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Le nombre de tampons écrits par les processus serveur parce qu'ils ont
       besoin d'allouer un nouveau tampon
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_buf_alloc</function>()</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Le nombre total d'allocations de tampons
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_clear_snapshot</function>()</literal></entry>
      <entry><type>void</type></entry>
      <entry>
       Annule l'image statistique actuelle
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset</function>()</literal></entry>
      <entry><type>void</type></entry>
      <entry>
       Réinitialise à zéro tous les compteurs statistiques pour la base de
       données actuelle (nécessite les droits superutilisateur)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <note>
    <para>
     <function>pg_stat_get_blocks_fetched</function> moins
     <function>pg_stat_get_blocks_hit</function> donne le nombre d'appels
     lancés pour la table, l'index ou la base de données&nbsp;; mais le nombre 
     réel de lectures physiques est habituellement moindre à cause des tampons
     du noyau.
    </para>
   </note>

  <para>
   All functions to access information about backends are indexed by backend id
   number, except <function>pg_stat_get_activity</function> which is indexed by PID.
   La fonction <function>pg_stat_get_backend_idset</function> fournit un moyen
   agréable de générer une ligne pour chaque processus serveur actif. Par
   exemple, pour afficher les <acronym>PID</acronym> et les requêtes en cours pour
   tous les processus serveur&nbsp;:

<programlisting>SELECT pg_stat_get_backend_pid(s.backendid) AS procpid,
       pg_stat_get_backend_activity(s.backendid) AS current_query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;</programlisting>
  </para>

 </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
  <title>Visualiser les verrous</title>

  <indexterm zone="monitoring-locks">
   <primary>verrou</primary>
   <secondary>surveillance</secondary>
  </indexterm>

  <para>
   Un autre outil utile pour surveiller l'activité des bases de données est la
   table système <structname>pg_locks</structname>. Elle permet à
   l'administrateur système de visualiser des informations sur les verrous
   restant dans le gestionnaire des verrous. Par exemple, cette fonctionnalité
   peut être utilisée pour&nbsp;:
	
   <itemizedlist>
    <listitem>
     <para>
      Visualiser tous les verrous en cours, tous les verrous sur les relations
      d'une base de données particulière ou tous les verrous détenus par une
      session <productname>PostgreSQL</productname> particulière.
     </para>
    </listitem>

    <listitem>
     <para>
      Déterminer la relation de la base de données disposant de la plupart des
      verrous non autorisés (et qui, du coup, pourraient être une source de
      contention parmi les clients de la base de données).
     </para>
    </listitem>

    <listitem>
     <para>
      Déterminer l'effet de la contention des verrous sur les performances
      générales des bases de données, ainsi que l'échelle dans laquelle varie la
      contention sur le trafic de la base de données.
     </para>
    </listitem>
   </itemizedlist>

   Les détails sur la vue <structname>pg_locks</structname> apparaissent dans la
   <xref linkend="view-pg-locks"/>. Pour plus d'informations sur les verrous et
   la gestion des concurrences avec <productname>PostgreSQL</productname>,
   référez-vous au <xref linkend="mvcc"/>.
  </para>
 </sect1>

 <sect1 id="dynamic-trace">
  <title>Traces dynamiques</title>

 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname> fournit un support pour les traces
   dynamiques du serveur de bases de données. Ceci permet l'appel à un outil
   externe à certains points du code pour tracer son exécution.
  </para>

  <para>
   A number of probes or trace points are already inserted into the source
   code. These probes are intended to be used by database developers and
   administrators. By default the probes are not compiled into
   <productname>PostgreSQL</productname>; the user needs to explicitly tell
   the configure script to make the probes available.
  </para>

  <para>
   Currently, only the
   <ulink url="http://opensolaris.org/os/community/dtrace/">DTrace</ulink>
   utility is supported, which is available
   on OpenSolaris, Solaris 10, and Mac OS X Leopard. It is expected that
   DTrace will be available in the future on FreeBSD and possibly other
   operating systems.  The
   <ulink url="http://sourceware.org/systemtap/">SystemTap</ulink> project
   for Linux also provides a DTrace equivalent.  Supporting other dynamic
   tracing utilities is theoretically possible by changing the definitions for
   the macros in <filename>src/include/utils/probes.h</>.
  </para>

  <sect2 id="compiling-for-trace">
   <title>Compiler en activant les traces dynamiques</title>

  <para>
   Par défaut, les sondes ne sont pas disponibles, donc vous aurez besoin d'indiquer
   explicitement au script configure de les activer dans
   <productname>PostgreSQL</productname>. Pour inclure le support de DTrace,
   ajoutez <option>--enable-dtrace</option> aux options de configure. Lire
   <xref linkend="install-procedure"/> pour plus d'informations.
  </para>
  </sect2>

  <sect2 id="trace-points">
   <title>Sondes disponibles</title>

  <para>
   A number of standard probes are provided in the source code,
   as shown in <xref linkend="dtrace-probe-point-table">.
   More can certainly be added to enhance <productname>PostgreSQL</>'s
   observability.
  </para>

 <table id="dtrace-probe-point-table">
  <title>Sondes disponibles pour DTrace</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Nom</entry>
     <entry>Paramètres</entry>
     <entry>Aperçu</entry>
    </row>
   </thead>

   <tbody>
     <entry>transaction-start</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>Probe that fires at the start of a new transaction.
      arg0 is the transaction id.</entry>
    </row>
    <row>
     <entry>transaction-commit</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>Probe that fires when a transaction completes successfully.
      arg0 is the transaction id.</entry>
    </row>
    <row>
     <entry>transaction-abort</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>Probe that fires when a transaction completes unsuccessfully.
      arg0 is the transaction id.</entry>
    </row>
    <row>
     <entry>query-start</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the processing of a query is started.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-done</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the processing of a query is complete.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-parse-start</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the parsing of a query is started.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-parse-done</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the parsing of a query is complete.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-rewrite-start</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the rewriting of a query is started.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-rewrite-done</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the rewriting of a query is complete.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-plan-start</entry>
     <entry>()</entry>
     <entry>Probe that fires when the planning of a query is started.</entry>
    </row>
    <row>
     <entry>query-plan-done</entry>
     <entry>()</entry>
     <entry>Probe that fires when the planning of a query is complete.</entry>
    </row>
    <row>
     <entry>query-execute-start</entry>
     <entry>()</entry>
     <entry>Probe that fires when the execution of a query is started.</entry>
    </row>
    <row>
     <entry>query-execute-done</entry>
     <entry>()</entry>
     <entry>Probe that fires when the execution of a query is complete.</entry>
    </row>
    <row>
     <entry>statement-status</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires anytime the server process updates its
      <structname>pg_stat_activity</>.<structfield>current_query</> status.
      arg0 is the new status string.</entry>
    </row>
    <row>
     <entry>checkpoint-start</entry>
     <entry>(int)</entry>
     <entry>Probe that fires when a checkpoint is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
    <row>
     <entry>checkpoint-done</entry>
     <entry>(int, int, int, int, int)</entry>
     <entry>Probe that fires when a checkpoint is complete.
      (The probes listed next fire in sequence during checkpoint processing.)
      arg0 is the number of buffers written. arg1 is the total number of
      buffers. arg2, arg3 and arg4 contain the number of xlog file(s) added,
      removed and recycled respectively.</entry>
    </row>
    <row>
     <entry>clog-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
    <row>
     <entry>clog-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is
      complete. arg0 has the same meaning as for clog-checkpoint-start.</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      complete. arg0 has the same meaning as for
      subtrans-checkpoint-start.</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      complete. arg0 has the same meaning as for
      multixact-checkpoint-start.</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-start</entry>
     <entry>(int)</entry>
     <entry>Probe that fires when the buffer-writing portion of a checkpoint
      is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
    <row>
     <entry>buffer-sync-start</entry>
     <entry>(int, int)</entry>
     <entry>Probe that fires when we begin to write dirty buffers during
      checkpoint (after identifying which buffers must be written).
      arg0 is the total number of buffers.
      arg1 is the number that are currently dirty and need to be written.</entry>
    </row>
    <row>
     <entry>buffer-sync-written</entry>
     <entry>(int)</entry>
     <entry>Probe that fires after each buffer is written during checkpoint.
      arg0 is the ID number of the buffer.</entry>
    </row>
    <row>
     <entry>buffer-sync-done</entry>
     <entry>(int, int, int)</entry>
     <entry>Probe that fires when all dirty buffers have been written.
      arg0 is the total number of buffers.
      arg1 is the number of buffers actually written by the checkpoint process.
      arg2 is the number that were expected to be written (arg1 of
      buffer-sync-start); any difference reflects other processes flushing
      buffers during the checkpoint.</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-sync-start</entry>
     <entry>()</entry>
     <entry>Probe that fires after dirty buffers have been written to the
      kernel, and before starting to issue fsync requests.</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-done</entry>
     <entry>()</entry>
     <entry>Probe that fires when syncing of buffers to disk is
      complete.</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-start</entry>
     <entry>()</entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      started.</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-done</entry>
     <entry>()</entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      complete.</entry>
    </row>
    <row>
     <entry>buffer-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, bool, bool)</entry>
     <entry>Probe that fires when a buffer read is started.
      arg0 and arg1 contain the fork and block numbers of the page (but
      arg1 will be -1 if this is a relation extension request).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is true for a local buffer, false for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.</entry>
    </row>
    <row>
     <entry>buffer-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, bool, bool, bool)</entry>
     <entry>Probe that fires when a buffer read is complete.
      arg0 and arg1 contain the fork and block numbers of the page (if this
      is a relation extension request, arg1 now contains the block number
      of the newly added block).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is true for a local buffer, false for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.
      arg7 is true if the buffer was found in the pool, false if not.</entry>
    </row>
    <row>
     <entry>buffer-flush-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Probe that fires before issuing any write request for a shared
      buffer.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
    <row>
     <entry>buffer-flush-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Probe that fires when a write request is complete.  (Note
      that this just reflects the time to pass the data to the kernel;
      it's typically not actually been written to disk yet.)
      The arguments are the same as for buffer-flush-start.</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Probe that fires when a server process begins to write a dirty
      buffer.  (If this happens often, it implies that
      <xref linkend="guc-shared-buffers"> is too
      small or the bgwriter control parameters need adjustment.)
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Probe that fires when a dirty-buffer write is complete.
      The arguments are the same as for buffer-write-dirty-start.</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-start</entry>
     <entry>()</entry>
     <entry>Probe that fires when when a server process begins to write a
      dirty WAL buffer because no more WAL buffer space is available.
      (If this happens often, it implies that
      <xref linkend="guc-wal-buffers"> is too small.)</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-done</entry>
     <entry>()</entry>
     <entry>Probe that fires when a dirty WAL buffer write is complete.</entry>
    </row>
    <row>
     <entry>xlog-insert</entry>
     <entry>(unsigned char, unsigned char)</entry>
     <entry>Probe that fires when a WAL record is inserted.
      arg0 is the resource manager (rmid) for the record.
      arg1 contains the info flags.</entry>
    </row>
    <row>
     <entry>xlog-switch</entry>
     <entry>()</entry>
     <entry>Probe that fires when a WAL segment switch is requested.</entry>
    </row>
    <row>
     <entry>smgr-md-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Probe that fires when beginning to read a block from a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
    <row>
     <entry>smgr-md-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int)</entry>
     <entry>Probe that fires when a block read is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the number of bytes actually read, while arg6 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
    <row>
     <entry>smgr-md-write-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Probe that fires when beginning to write a block to a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
    <row>
     <entry>smgr-md-write-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int)</entry>
     <entry>Probe that fires when a block write is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the number of bytes actually written, while arg6 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
    <row>
     <entry>sort-start</entry>
     <entry>(int, bool, int, int, bool)</entry>
     <entry>Probe that fires when a sort operation is started.
      arg0 indicates heap, index or datum sort.
      arg1 is true for unique-value enforcement.
      arg2 is the number of key columns.
      arg3 is the number of kilobytes of work memory allowed.
      arg4 is true if random access to the sort result is required.</entry>
    </row>
    <row>
     <entry>sort-done</entry>
     <entry>(bool, long)</entry>
     <entry>Probe that fires when a sort is complete.
      arg0 is true for external sort, false for internal sort.
      arg1 is the number of disk blocks used for an external sort,
      or kilobytes of memory used for an internal sort.</entry>
    </row>
    <row>
     <entry>lwlock-acquire</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Probe that fires when an LWLock has been acquired.
      arg0 is the LWLock's ID.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry>lwlock-release</entry>
     <entry>(LWLockId)</entry>
     <entry>Probe that fires when an LWLock has been released (but note
      that any released waiters have not yet been awakened).
      arg0 is the LWLock's ID.</entry>
    </row>
    <row>
     <entry>lwlock-wait-start</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Probe that fires when an LWLock was not immediately available and
      a server process has begun to wait for the lock to become available.
      arg0 is the LWLock's ID.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry>lwlock-wait-done</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Probe that fires when a server process has been released from its
      wait for an LWLock (it does not actually have the lock yet).
      arg0 is the LWLock's ID.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry>lwlock-condacquire</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Probe that fires when an LWLock was successfully acquired when the
      caller specified no waiting.
      arg0 is the LWLock's ID.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry>lwlock-condacquire-fail</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Probe that fires when an LWLock was not successfully acquired when
      the caller specified no waiting.
      arg0 is the LWLock's ID.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry>lock-wait-start</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has begun to wait because the lock is not available.
      arg0 through arg3 are the tag fields identifying the object being
      locked.  arg4 indicates the type of object being locked.
      arg5 indicates the lock type being requested.</entry>
    </row>
    <row>
     <entry>lock-wait-done</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has finished waiting (i.e., has acquired the lock).
      The arguments are the same as for lock-wait-start.</entry>
    </row>
    <row>
     <entry>deadlock-found</entry>
     <entry>()</entry>
     <entry>Probe that fires when a deadlock is found by the deadlock
      detector.</entry>
    </row>

   </tbody>
   </tgroup>
  </table>

 <table id="typedefs-table">
  <title>Defined Types Used in Probe Parameters</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>Type</entry>
     <entry>Definition</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry>LocalTransactionId</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>LWLockId</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>LWLockMode</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>LOCKMODE</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>BlockNumber</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>Oid</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>ForkNumber</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>bool</entry>
     <entry>char</entry>
    </row>

   </tbody>
   </tgroup>
  </table>
  </sect2>

  <sect2 id="using-trace-points">
   <title>Utiliser les sondes</title>

  <para>
   L'exemple ci-dessous montre un script DTrace pour l'analyse du nombre de
   transactions sur le système, comme alternative à l'interrogation régulière
   de <structname>pg_stat_database</structname> avant et après un test de
   performance&nbsp;:
<programlisting>#!/usr/sbin/dtrace -qs 

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   À son exécution, le script de l'exemple D donne une sortie comme&nbsp;:
<screen># ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>
  <para>
   Vous devez vous rappeler que les programmes DTrace doivent être écrits
   soigneusement, sinon les informations récoltées pourraient ne rien valoir.
   Dans la plupart des cas où des problèmes sont découverts, c'est
   l'instrumentation qui est erronée, pas le système sous-jacent. En discutant
   des informations récupérées en utilisant un tel système, il est essentiel de
   s'assurer que le script utilisé est lui-aussi vérifié et discuter.
  </para>
  <para>
   More example scripts can be found in the PgFoundry
   <ulink url="http://pgfoundry.org/projects/dtrace/">dtrace project</ulink>.
  </para>
  </sect2>

  <sect2 id="defining-trace-points">
   <title>Définir de nouvelles sondes</title>

  <para>
   De nouvelles sondes peuvent être définies dans le code partout où le
   développeur le souhaite bien que cela nécessite une nouvelle compilation.
   Below are the steps for inserting new probes:
  </para>

  <procedure>
   <step>
    <para>
     Decide on probe names and data to be made available through the probes
    </para>
   </step>

   <step>
    <para>
     Add the probe definitions to <filename>src/backend/utils/probes.d</>
    </para>
   </step>

   <step>
    <para>
     Include <filename>pg_trace.h</> if it is not already present in the
     module(s) containing the probe points, and insert
     <literal>TRACE_POSTGRESQL</> probe macros at the desired locations
     in the source code
    </para>
   </step>

   <step>
    <para>
     Recompile and verify that the new probes are available
    </para>
   </step>
  </procedure>

  <formalpara>
   <title>Example:</title>
   <para>
    Here is an example of how you would add a probe to trace all new
    transactions by transaction ID.
   </para>
  </formalpara>

  <procedure>
   <step>
    <para>
     Decide that the probe will be named <literal>transaction-start</> and
     requires a parameter of type LocalTransactionId
    </para>
   </step>

   <step>
    <para>
     Add the probe definition to <filename>src/backend/utils/probes.d</>:
<programlisting>
      probe transaction__start(LocalTransactionId);
</programlisting>
     Note the use of the double underline in the probe name. In a DTrace
     script using the probe, the double underline needs to be replaced with a
     hyphen, so <literal>transaction-start</> is the name to document for
     users.
    </para>
   </step>

   <step>
    <para>
     At compile time, <literal>transaction__start</> is converted to a macro
     called <literal>TRACE_POSTGRESQL_TRANSACTION_START</> (notice the
     underscores are single here), which is available by including
     <filename>pg_trace.h</>.  Add the macro call to the appropriate location
     in the source code.  In this case, it looks like the following:

<programlisting>
    TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     After recompiling and running the new binary, check that your newly added
     probe is available by executing the following DTrace command.  You
     should see similar output:
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
   </step>
  </procedure>

  <para>
   There are a few things to be careful about when adding trace macros
   to the C code:

   <itemizedlist>
    <listitem>
     <para>
      You should take care that the data types specified for a probe's
      parameters match the data types of the variables used in the macro.
      Otherwise, you will get compilation errors.
     </para>
    </listitem>


    <listitem>
     <para>
      On most platforms, if <productname>PostgreSQL</productname> is
      built with <option>--enable-dtrace</>, the arguments to a trace
      macro will be evaluated whenever control passes through the
      macro, <emphasis>even if no tracing is being done</>.  This is
      usually not worth worrying about if you are just reporting the
      values of a few local variables.  But beware of putting expensive
      function calls into the arguments.  If you need to do that,
      consider protecting the macro with a check to see if the trace
      is actually enabled:

<programlisting>
    if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
        TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      Each trace macro has a corresponding <literal>ENABLED</> macro.
     </para>
    </listitem>
   </itemizedlist>

  </para>

  </sect2>

 </sect1>

</chapter>
