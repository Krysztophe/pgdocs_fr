<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/monitoring.sgml,v 1.11 2005/09/15 07:03:19 guillaume Exp $ -->

<chapter id="monitoring">
 <title>Surveiller l'activité de la base de données</title>

 <indexterm zone="monitoring">
  <primary>surveiller</primary>
  <secondary>activité de la base de données</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <primary>activité de la base de données</primary>
  <secondary>suveiller</secondary>
 </indexterm>

 <para>
  Un administrateur de bases de données se demande fréquemment&nbsp;: <quote>Que
  fait le système en ce moment&nbsp;?</quote> Ce chapitre discute de la façon
  de le savoir.
 </para>

  <para>
   Plusieurs outils sont disponibles pour surveiller l'activité de la base de
   données et pour analyser les performances. Une grande partie de ce chapitre
   concerne la description du récupérateur de statistiques de
   <productname>PostgreSQL</productname> mais personne ne devrait négliger les
   programmes de surveillance Unix standards tels que <command>ps</command>,
   <command>top</command>, <command>iostat</command> et <command>vmstat</command>. De plus, une fois
   qu'une requête peu performante a été identifiée, des investigations
   supplémentaires pourraient être nécessaires en utilisant la commande <xref
   linkend="sql-explain" endterm="sql-explain-title"/> de
   <productname>PostgreSQL</productname>. La <xref linkend="using-explain"/>
   discute de <command>EXPLAIN</command> et des autres méthodes pour comprendre le
   comportement d'une seule requête.
  </para>

 <sect1 id="monitoring-ps">
  <title>Outils Unix standard</title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>pour surveiller l'activité</secondary>
  </indexterm>

  <para>
   Sur la plupart des plateformes, <productname>PostgreSQL</productname> modifie
   son titre de commande reporté par <command>ps</command> de façon à ce que les
   processus serveur individuels puissent être rapidement identifiés. Voici un
   affichage d'exemple&nbsp;:

<screen>$ ps auxww | grep ^postgres
postgres   960  0.0  1.1  6104 1480 pts/1    SN   13:17   0:00 postgres -i
postgres   963  0.0  1.1  7084 1472 pts/1    SN   13:17   0:00 postgres: writer process   
postgres   965  0.0  1.1  6152 1512 pts/1    SN   13:17   0:00 postgres: stats collector process   
postgres   998  0.0  2.3  6532 2992 pts/1    SN   13:18   0:00 postgres: tgl runbogue 127.0.0.1 idle
postgres  1003  0.0  2.4  6532 3128 pts/1    SN   13:19   0:00 postgres: tgl regression [local] SELECT waiting
postgres  1016  0.1  2.4  6532 3080 pts/1    SN   13:19   0:00 postgres: tgl regression [local] idle in transaction</screen>

   (L'appel approprié de <command>ps</command> varie suivant les différentes
   plateformes, de même que les détails affichés. Cet exemple est
   tiré d'un système Linux récent.) Le premier processus affiché ici est le
   processus serveur maître, le processus serveur maître. Les arguments
   affichés pour cette commande sont les mêmes qu'à son lancement. Les deux
   processus suivant sont des processus en tâche de fond lancés
   automatiquement par le processus maître (le processus
   <quote>stats collector</quote> n'est pas présent si
   vous avez configuré le système pour qu'il ne lance pas le récupérateur de
   statistiques). Chacun des autres processus est un processus serveur gérant
   une connexion cliente. Tous ces processus restant initialisent l'affichage de
   la ligne de commande de la forme

<screen>postgres: <replaceable>utilisateur</replaceable> <replaceable>base_de_données</replaceable> <replaceable>hôte</replaceable> <replaceable>activité</replaceable></screen>

  L'utilisateur, la base de données et les éléments de l'hôte de connexion
  restent identiques pendant toute la vie de connexion du client mais
  l'indicateur d'activité change. L'activité pourrait être <literal>idle</literal>
  (c'est-à-dire en attente d'une commande du client), <literal>idle in
  transaction</literal> (en attente du client à l'intérieur d'un bloc de
  <command>BEGIN</command>/<command>COMMIT</command>) ou un nom de commande du type
  <literal>SELECT</literal>. De plus, <literal>waiting</literal> est attaché si le processus
  serveur est en attente d'un verrou détenu par un autre processus serveur.
  Dans l'exemple ci-dessus, nous pouvons supposer que le processus 1003 attend
  que le processus 1016 ait terminé sa transaction et, du coup, libère un verrou.
  </para>

  <para>
   If you have turned off <xref linkend="guc-update-process-title"/> then the
   activity indicator is not updated; the process title is set only once
   when a new process is launched.  On some platforms this saves a useful
   amount of per-command overhead, on others it's insignificant.
  </para>

  <tip>
  <para>
  <productname>Solaris</productname> requiert une gestion particulière. Vous
  devez utiliser <command>/usr/ucb/ps</command> plutôt que
  <command>/bin/ps</command>. Vous devez aussi utiliser deux options
  <option>w</option> et non pas seulement une. En plus, votre appel original de
  la commande <command>postgres</command> doit avoir un affichage de statut
  dans <command>ps</command> plus petit que celui fourni par les autres
  processus serveur. Si vous échouez dans les trois, l'affichage de
  <command>ps</command> pour chaque processus serveur sera la ligne de commande
  originale de <command>postgres</command>.
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <title>Le récupérateur de statistiques</title>

  <indexterm zone="monitoring-stats">
   <primary>statistiques</primary>
  </indexterm>

  <para>
   Le <firstterm>récupérateur de statistiques</firstterm> de
   <productname>PostgreSQL</productname> est un sous-système qui supporte la
   récupération et les rapports d'informations sur l'activité du serveur.
   Actuellement, le récupérateur peut compter les accès aux tables et index à la
   fois en terme de blocs disque et de lignes individuelles.  </para>

  <para>
   <productname>PostgreSQL</productname> supporte aussi
   la détermination de la commande exacte en cours d'exécution par les autres
   processus serveur. Cette fonctionnalité indépendante peut être activée ou
   désactivée que les statistiques niveau bloc et ligne soient récupérées ou
   non.
  </para>

 <sect2 id="monitoring-stats-setup">
  <title>Configuration de la récupération de statistiques</title>

  <para>
   Comme la récupération de statistiques ajoute un temps supplémentaire à
   l'exécution de la requête, le système peut être configuré pour récupérer ou
   non des informations. Ceci est contrôlé par les paramètres de configuration
   qui sont normalement initialisés dans <filename>postgresql.conf</filename> (voir
   <xref linkend="runtime-config"/> pour plus de détails sur leur
   initialisation).
  </para>

  <para>
   Le paramètre <xref linkend="guc-stats-start-collector"/> doit valoir
   <literal>true</literal> pour que le récupérateur de statistiques soit seulement
   lancé. C'est la valeur par défaut et la configuration recommandée mais elle
   peut être désactivée si vous n'êtes pas intéressé par les statistiques et
   que vous souhaitez supprimer toute activité en trop (néanmoins, ce que vous
   sauverez sera assez restreint). Notez que cette option ne peut pas être
   changée alors que le serveur est en cours d'exécution.
  </para>

  <para>
   Les paramètres <xref linkend="guc-stats-block-level"/> et
   <xref linkend="guc-stats-row-level"/>
   contrôlent la quantité d'informations réellement envoyée au récupérateur et
   détermine du coup le temps supplémentaire réclamé. Ils déterminent
   respectivement si un processus serveur tracks disk-block-level access
   statistics and row-level access statistics and sends these to the collector.
   Additionally, per-database transaction commit and abort statistics
   are collected if either of these parameters are set.
  </para>

  <para>
   The parameter <xref linkend="guc-stats-command-string"> enables monitoring
   of the current command being executed by any server process.
   The statistics collector subprocess need not be running to enable this
   feature.
  </para>
  
  <para>
   Normalement, ces paramètres sont configurés dans
   <filename>postgresql.conf</filename> de façon à ce qu'ils s'appliquent à tous les
   processus serveur mais il est possible de les activer/désactiver sur des
   sessions individuelles en utilisant la commande <xref
   linkend="sql-set" endterm="sql-set-title"/> (pour empêcher les utilisateurs
   ordinaires de cacher leur activité à l'administrateur, seuls les
   superutilisateurs sont autorisés à modifier ces paramètres avec
   <command>SET</command>).
  </para>

   <note>
    <para>
     Comme les paramètres <varname>stats_block_level</varname> et
     <varname>stats_row_level</varname> valent par défaut <literal>false</literal>,
     très peu de statistiques sont récupérées dans la configuration par défaut.
     Activer une ou plus des variables de configuration augmentera
     significativement le nombre de données utiles produit par le récupérateur
     de statistiques au prix d'une surcharge supplémentaire à l'exécution.
    </para>
   </note>

 </sect2>

 <sect2 id="monitoring-stats-views">
  <title>Visualiser les statistiques récupérées</title>

  <para>
   Plusieurs vues prédéfinies, listées dans le <xref
   linkend="monitoring-stats-views-table"/>, sont disponibles pour afficher
   les résultats de la récupération de statistiques. Autrement, vous pouvez
   construire des vues personnalisées en utilisant les fonctions statistiques
   existantes.
  </para>

  <para>
   En utilisant les statistiques pour surveiller l'activité en cours, il est
   important de réaliser que l'information n'est pas mise à jour instantanément.
   Chaque processus serveur individuel transmet le nouveau nombre d'accès au
   niveau des blocs et des lignes au récupérateur juste avant l'attente d'une
   nouvelle commande du client&nbsp;; donc une requête toujours en cours
   n'affecte pas les totaux affichés. De plus, le récupérateur lui-même émet un
   nouveau rapport une fois par <varname>PGSTAT_STAT_INTERVAL</varname>
   millisecondes (500, sauf si cette valeur a été modifiée lors de la
   construction du serveur). Donc, les totaux affichés sont bien derrière
   l'activité réelle. Néanmoins, l'information sur la requête en cours récupérée
   par <varname>stats_command_string</varname> est toujours à jour.
  </para>

  <para>
   Un autre point important est que, lorsqu'un processus serveur se voit
   demander d'afficher une des statistiques, il récupère tout d'abord le rapport
   le plus récent émis pas le processus de récupération, puis continue
   d'utiliser cette image de toutes les vues et fonctions statistiques jusqu'à
   la fin de sa transaction en cours. Similarly, information about the current queries of
   all processes is collected when any such information is first requested
   within a transaction, and the same information will be displayed throughout
   the transaction. Donc, les statistiques ne sembleront pas
   changer tant que vous restez dans la même transaction. Ceci est une
   fonctionnalité, et non pas un bogue, car il vous permet de traiter plusieurs
   requêtes sur les statistiques et de corréler les résultats sans vous
   inquiéter que les nombres aient pu changer. Mais si vous voulez voir les
   nouveaux résultats pour chaque requête, assurez-vous de lancer les requêtes
   en dehors de tout bloc de transaction.
  </para>

  <table id="monitoring-stats-views-table">
   <title>Vues statistiques standards</title>

   <tgroup cols="2">
    <colspec colnum="1" colwidth="0.4*"/>
    <colspec colnum="2" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structname>pg_stat_activity</structname></entry>
      <entry>Une ligne par processus serveur, affichant l'OID de la base de
      données, le nom de la base, l'<acronym>ID</acronym> du processus, l'OID de
      l'utilisateur, son nom, la requête en cours, l'état d'attente de la requête
      et le moment où a commencé l'exécution de la requête, ainsi que l'adresse
      et le numéro de port du client. Les colonnes renvoyant des données sur la
      requête en cours sont disponibles sauf si le paramètre
      <varname>stats_command_string</varname> a été désactivé. De
      plus, ces colonnes sont seulement visibles si l'utilisateur examinant
      cette vue est un superutilisateur ou est le propriétaire du processus en
      cours de rapport.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_database</structname></entry>
      <entry>Une ligne par base de données, affichant l'OID de la base de
      données, son nom, le nombre de processus serveur actifs connectés à cette
      base, le nombre total de transactions validées et le nombre de
      celles qui ont été annulées, le nombre total de blocs disque lus et le
      nombre total de succès du tampon (c'est-à-dire le nombre de lectures de
      blocs évitées en trouvant déjà le bloc dans le cache du tampon).
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_tables</structname></entry>
      <entry>Pour chaque table dans la base de données en cours (ceci 
      incluant les tables TOAST), l'OID de la table, le nom du schéma et de la
      table, le nombre de parcours séquentiels réalisés, le nombre de lignes
      actives récupérées par les parcours séquentiels, la dernière fois que la
      table a été VACUUMé par l'utilisateur et par le démon autovacuum, la
      dernière fois que la table a été analysée par l'utilisateur et par le
      démon autovacuum, le nombre de parcours
      d'index réalisés (pour tous les index appartenant à cette table), le
      nombre de lignes actives récupérées par les parcours d'index et le
      nombre d'insertions, mises à jour et suppressions de lignes.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_tables</structname></entry>
      <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
      tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_tables</structname></entry>
      <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
      tables utilisateurs sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_indexes</structname></entry>
      <entry>Pour chaque index de la base de données en cours, l'OID de la
      table et de l'index, le nom du schéma, de la table et de l'index, le
      nombre de parcours d'index initiés sur cet index, le nombre d'entrées de
      l'index renvoyées par les parcours d'index, et le nombre de lignes actives
      de table récupérées par de simples parcours d'index utilisant cet index.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_indexes</structname></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules les
      tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_indexes</structname></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules
      les tables utilisateurs sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_tables</structname></entry>
      <entry>Pour chaque table de la base de données en cours (ceci incluant les
      tables TOAST), l'OID de la table, le nom du schéma et de la table, le
      nombre de blocs disque lus à partir de cette table, le nombre de lectures
      tampon réussies dans tous les index de cette table, le nombre de blocs
      disque lus et de lectures tampon réussies à partir de la table TOAST
      (si elle existe), et, enfin, le nombre de blocs disque lus et le nombre
      de lectures tampon réussies à partir de l'index de la table TOAST.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_tables</structname></entry>
      <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
      les tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_tables</structname></entry>
      <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
      les tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_indexes</structname></entry>
      <entry>Pour chaque index de la base de données en cours, l'OID de la table
      et de l'index, le nom du schéma, de la table et de l'index, le nombre
      de blocs disque lus et le nombre de lectures tampon réussies pour
      cet index.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_indexes</structname></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
      les index systèmes sont affichés.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_indexes</structname></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
      les index systèmes sont affichés.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_sequences</structname></entry>
      <entry>Pour chaque séquence de la base de données en cours, l'OID de la
      séquence, le nom du schéma et de la séquence, le nombre de blocs disque
      lus et le nombre de lectures réussies du tampon pour cette séquence.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_sequences</structname></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
      seules les séquences système sont affichées (actuellement, aucune
      séquence système n'est définie, donc cette vue est toujours vide)</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_sequences</structname></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
      seules les séquences utilisateur sont affichées.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les statistiques par index sont particulièrement utiles pour déterminer
   les index utilisés et leur efficacité.
  </para>

  <para>
   À partir de la version 8.1 de <productname>PostgreSQL</productname>, les
   index peuvent être utilisés soit directement soit via des <quote>parcours de
   bitmap</quote>. Dans un parcours de bitmap, les résultats de plusieurs index
   peuvent être combinés via des règles AND ou OR&nbsp;; donc il est difficile
   d'associer des récupérations de lignes d'en-têtes individuelles avec des
   index spécifiques quand un parcours de bitmap est utilisé. Du coup, un
   parcours de bitmap incrémente le nombre dans
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_read</structfield>
   pour les index qu'il utilise et il incrémente le nombre
   <structname>pg_stat_all_tables</structname>.<structfield>idx_tup_fetch</structfield>
   pour la table, mais il n'affecte pas
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>.
  </para>

  <note>
   <para>
    Avant <productname>PostgreSQL</productname> 8.1, les totaux
    <structfield>idx_tup_read</structfield> et <structfield>idx_tup_fetch</structfield> étaient
    pratiquement toujours égaux. Maintenant, ils peuvent être différents même
    sans considérer les parcours de bitmap parce que
    <structfield>idx_tup_read</structfield> compte les entrées d'index récupérées à partir
    de l'index alors que <structfield>idx_tup_fetch</structfield> compte les lignes actives
    récupérées à partir de la table&nbsp;; ce dernier sera moindre si des lignes
    mortes ou pas-encore-validées sont récupérées en utilisant l'index.
   </para>
  </note>

  <para>
   Les vues <structname>pg_statio_</structname> sont principalement utiles pour
   déterminer l'efficacité du cache tampon. Quand le nombre de lectures disques
   réelles est plus petit que le nombre de récupérations valides par le tampon,
   alors le cache satisfait la plupart des demandes de lecture sans faire appel
   au noyau. Néanmoins, ces statistiques ne nous donnent pas l'histoire
   complète&nbsp;: à cause de la façon dont <productname>PostgreSQL</productname> gère les
   entrées/sorties disque, les données qui ne sont pas dans le tampon de
   <productname>PostgreSQL</productname> pourraient toujours résider dans le tampon
   d'entrées/sorties du noyau et pourraient, du coup, être toujours récupérées
   sans nécessiter une lecture physique. Les utilisateurs intéressés pour
   obtenir des informations plus détaillées sur le comportement des
   entrées/sorties dans <productname>PostgreSQL</productname> sont invités à utiliser le
   récupérateur de statistiques de <productname>PostgreSQL</productname> avec les outils du
   système d'exploitation permettant une vue de la gestion des
   entrées/sorties par le noyau.
  </para>

  <para>
   Il existe d'autres façons de regarder les statistiques. Cela se fait en
   écrivant des requêtes qui utilisent les mêmes fonctions d'accès aux
   statistiques que les vues standards. Ces fonctions sont listées
   dans le <xref linkend="monitoring-stats-funcs-table"/>. Les fonctions d'accès
   par base de données prennent un OID de la base de données comme argument pour
   identifier la base de données du rapport. Les fonctions par table et par
   index prennent l'OID de la table ou de l'index (notez que seuls les tables
   et les index de la base de données en cours peuvent être vus par ces
   fonctions). Les fonctions d'accès au processus prennent le numéro
   d'identifiant du processus.
  </para>

  <table id="monitoring-stats-funcs-table">
   <title>Fonctions d'accès aux statistiques</title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="1.5*"/>
    <colspec colnum="2" colwidth="0.3*"/>
    <colspec colnum="3" colwidth="1.2*"/>
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Code de retour</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>pg_stat_get_db_numbackends</function>(<type>oid</type>)</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       Nombre de processus actifs pour la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_xact_commit</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Transactions validées dans la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_xact_rollback</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Transactions annulées dans la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_blocks_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de récupérations de blocs disque pour la base de
       données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_db_blocks_hit</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de récupérations de blocs disque trouvés dans le
       tampon pour la base de données
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_numscans</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de parcours séquentiels réalisés lorsque l'argument est une
       table, ou nombre de parcours d'index lorsque l'argument est un index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_returned</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes lues par les parcours séquentiels lorsque l'argument
       est une table, ou nombre de lignes d'index lues lorsque l'argument est un
       index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Le nombre de lignes de table récupérées par des parcours de bitmap quand
       l'argument est une table, ou les lignes de table récupérées par de
       simples parcours d'index en utilisant cet index quand l'argument est un
       index.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_inserted</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes insérées dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_updated</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes mises à jour dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_tuples_deleted</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de lignes supprimées dans la table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_blocks_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de récupération de blocs disques pour la table ou
       l'index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_blocks_hit</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Nombre de demandes de blocs disque récupérés dans le tampon pour la
       table ou l'index
      </entry>
     </row>


     <row>
      <entry><literal><function>pg_stat_get_tuples_deleted</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Number of rows deleted from table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_blocks_fetched</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Number of disk block fetch requests for table or index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_blocks_hit</function>(<type>oid</type>)</literal></entry>
      <entry><type>bigint</type></entry>
      <entry>
       Number of disk block requests found in cache for table or index
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_last_vacuum_time</function>(<type>oid</type>)</literal></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       Time of the last vacuum initiated by the user on this table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_last_autovacuum_time</function>(<type>oid</type>)</literal></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       Time of the last vacuum initiated by the autovacuum daemon on this table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_last_analyze_time</function>(<type>oid</type>)</literal></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       Time of the last analyze initiated by the user on this table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_last_autoanalyze_time</function>(<type>oid</type>)</literal></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       Time of the last analyze initiated by the autovacuum daemon on this
       table
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_idset</function>()</literal></entry>
      <entry><type>set of integer</type></entry>
      <entry>
       Ensemble d'identifiants de processus actifs (de 1 au nombre de processus
       actifs). Voir l'exemple d'utilisation dans le texte.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_backend_pid</function>()</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       ID du processus pour le processus serveur attaché à la session en cours
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_pid</function>(<type>integer</type>)</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       ID du processus pour le processus serveur donné
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_dbid</function>(<type>integer</type>)</literal></entry>
      <entry><type>oid</type></entry>
      <entry>
       ID de la base de données pour le processus serveur en cours
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_userid</function>(<type>integer</type>)</literal></entry>
      <entry><type>oid</type></entry>
      <entry>
       ID de l'utilisateur pour le processus serveur en cours
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity</function>(<type>integer</type>)</literal></entry>
      <entry><type>text</type></entry>
      <entry>
       Active command of the given server process, but only if the
       current user is a superuser or the same user as that of
       the session being queried (and
       <varname>stats_command_string</varname> is on)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_waiting</function>(<type>integer</type>)</literal></entry>
      <entry><type>boolean</type></entry>
      <entry>
       True if the given server process is waiting for a lock,
       but only if the current user is a superuser or the same user as that of
       the session being queried (and
       <varname>stats_command_string</varname> is on)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity_start</function>(<type>integer</type>)</literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>
       The time at which the given server process' currently
       executing query was started, but only if the
       current user is a superuser or the same user as that of
       the session being queried (and
       <varname>stats_command_string</varname> is on)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_start</function>(<type>integer</type>)</literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>
       L'heure à laquelle le processus serveur donné a été lancé ou NULL si
       l'utilisateur en cours n'est ni un superutilisateur ni l'utilisateur
       de la session requêtée
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_addr</function>(<type>integer</type>)</literal></entry>
      <entry><type>inet</type></entry>
      <entry>
       L'adresse IP du client connecté au processus serveur donné. NULL si
       la connexion est établie sur un socket de domaine Unix. Aussi NULL si
       l'utilisateur en cours n'est ni un superutilisateur ni l'utilisateur
       de la session requêtée
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_port</function>(<type>integer</type>)</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       Le numéro de port du client connecté au processus serveur donné. -1 si
       la connexion est établie sur un socket de domaine Unix. NULL si
       l'utilisateur en cours n'est ni un superutilisateur ni l'utilisateur
       de la session requêtée
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset</function>()</literal></entry>
      <entry><type>boolean</type></entry>
      <entry>
       Réinitialise les statistiques niveau bloc et niveau ligne à zéro
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <note>
    <para>
     <function>blocks_fetched</function> moins
     <function>blocks_hit</function> donne le nombre d'appels
     lancés pour la table, l'index ou la base de données&nbsp;; mais le nombre 
     réel de lectures physiques est habituellement moindre à cause des tampons
     du noyau.
    </para>
   </note>

  <para>
   La fonction <function>pg_stat_get_backend_idset</function> fournit un moyen
   agréable de générer une ligne pour chaque processus serveur actif. Par
   exemple, pour afficher les <acronym>PID</acronym> et les requêtes en cours pour
   tous les processus serveur&nbsp;:

<programlisting>SELECT pg_stat_get_backend_pid(s.backendid) AS procpid,
       pg_stat_get_backend_activity(s.backendid) AS current_query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;</programlisting>
  </para>

 </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
  <title>Visualiser les verrous</title>

  <indexterm zone="monitoring-locks">
   <primary>verrou</primary>
   <secondary>surveillance</secondary>
  </indexterm>

  <para>
   Un autre outil utile pour surveiller l'activité des bases de données est la
   table système <structname>pg_locks</structname>. Elle permet à
   l'administrateur système de visualiser des informations sur les verrous
   restant dans le gestionnaire des verrous. Par exemple, cette fonctionnalité
   peut être utilisée pour&nbsp;:
	
   <itemizedlist>
    <listitem>
     <para>
      Visualiser tous les verrous en cours, tous les verrous sur les relations
      d'une base de données particulière ou tous les verrous détenus par une
      session <productname>PostgreSQL</productname> particulière.
     </para>
    </listitem>

    <listitem>
     <para>
      Déterminer la relation de la base de données disposant de la plupart des
      verrous non autorisés (et qui, du coup, pourraient être une source de
      contention parmi les clients de la base de données).
     </para>
    </listitem>

    <listitem>
     <para>
      Déterminer l'effet de la contention des verrous sur les performances
      générales des bases de données, ainsi que l'échelle dans laquelle varie la
      contention sur le trafic de la base de données.
     </para>
    </listitem>
   </itemizedlist>

   Les détails sur la vue <structname>pg_locks</structname> apparaissent dans la
   <xref linkend="view-pg-locks"/>. Pour plus d'informations sur les verrous et
   la gestion des concurrences avec <productname>PostgreSQL</productname>,
   référez-vous au <xref linkend="mvcc"/>.
  </para>
 </sect1>
</chapter>
