
<sect1 id="pgbench">
 <title>pgbench</title>
 
 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>

 <para>
  <literal>pgbench</literal> est un programme simple qui exécute un test de
  performances appelé <foreignphrase>benchmark</foreignphrase> en anglais.
  <literal>pgbench</literal> est une application client de PostgreSQL et
  s'exécute avec PostgreSQL seulement. Elle réalise plein de petites
  transactions simples incluant des opérations SELECT/UPDATE/INSERT puis
  calcule le nombre de transactions terminées avec succès en une seconde
  (transactions par seconde, ou tps). Cibler les données inclut une table
  avec au moins 100000 lignes.
 </para>
 <para>
  Voici un exemple d'affichage de pgbench&nbsp;:
 </para>
 <programlisting>
number of clients: 4
number of transactions per client: 100
number of processed transactions: 400/400
tps = 19.875015(including connections establishing)
tps = 20.098827(excluding connections establishing)
 </programlisting>
 <para>
  Un programme similaire appelé JDBCBench existe déjà mais il nécessite
  Java qui pourrait ne pas être disponible sur toutes les plateformes.
  De plus, certaines personnes se posent des questions sur la surcharge
  imposée par Java qui pourrait aboutir à des résultats peu précis. J'ai
  donc décidé de l'écrire en C et de le nommer pgbench.
 </para>

 <para>
  Fonctionnalités de pgbench&nbsp;:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    pgbench est écrit en C et utilise seulement libpq. Donc, il est très
    portable et facile à installer.
   </para>
  </listitem>
  <listitem>
   <para>
    pgbench peut simuler des connexions parallèles en utilisant les capacités
    asynchrones de libpq. La gestion des threads n'est pas utile.
   </para>
  </listitem>
 </itemizedlist>

 <sect2>
  <title>Aperçu</title>
  <orderedlist>
   <listitem>
    <para>(en option)Initialisez la base de données avec&nbsp;:</para>
    <programlisting>
pgbench -i &lt;nombase&gt;
    </programlisting>
    <para>
     où &lt;nombase&gt; est le nom de la base de données. pgbench utilise
     quatre tables&nbsp;: accounts, branches, history et tellers. Ces
     tables seront détruites. Faites donc attention si vous possédez des
     tables de même nom. Les données de test contiennent par défaut&nbsp;:
    </para>
    <programlisting>
table           # of tuples
-------------------------
branches        1
tellers         10
accounts        100000
history         0
    </programlisting>
    <para>
     Vous pouvez augmenter le nombre de lignes en utilisant l'option
     -s. Les tables branches, tellers et accounts sont créées avec un
     facteur de remplissage configuré via l'option -F. Voir ci-dessous&nbsp;:
    </para>
   </listitem>
   <listitem>
    <para>Exécuter le test de performances&nbsp;:</para>
    <programlisting>
pgbench &lt;nombase&gt;
    </programlisting>
    <para>
     La configuration par défaut est&nbsp;:
    </para>
    <programlisting>
     number of clients: 1
     number of transactions per client: 10
    </programlisting>
   </listitem>
  </orderedlist>

  <table>
   <title>Options de <literal>pgbench</literal></title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Paramètre</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>-h hote</literal></entry>
      <entry>
       <para>
        Nom de l'hôte où le serveur est exécuté. Si cette option n'est pas
	donnée, pgbench se connectera à localhost via le socket de
	domaine Unix.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-p port</literal></entry>
      <entry>
       <para>
        Numéro de port où le serveur est en écoute. La valeur par défaut de
        libpq est habituellement 5432.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-c nombre_de_clients</literal></entry>
      <entry>
       <para>
        Nombre de clients simultanés. Par défaut, 1.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-t nombre_de_transactions</literal></entry>
      <entry>
       <para>
        Nombre de transactions exécutées par chaque client. Par défaut, 10.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-s facteur_echelle</literal></entry>
      <entry>
       <para>
        Cette option doit être utilisée avec l'option -i (initialisation).
        Le nombre de lignes générées sera un multiple du facteur d'échelle.
	Par exemple, -s 100 impliquera dix millions de lignes dans la table
        accounts. Par défaut, 1.
       </para>
       <para>
        Note&nbsp;: le facteur d'échelle doit être au moins aussi important
	que le nombre de clients que vous voulez tester. Sinon, vous
	mesurerez principalement la contentiondes mises à jour. Des
	exécutions régulières (sans initialisation entre) utilisant un
	des tests internes détecteront le facteur d'échelle basé sur le
	nombre de branches dans la base de données.  Pour les exécutions
	personnalisés (-f), cela peut être géré manuellement avec ce
	paramètre.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-D variable=valeur</literal></entry>
      <entry>
       <para>
        Définit une variable. Elle peut être utilisée par un script indiqué
	par l'option -f. Plusieurs options -D sont autorisées.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-U nomconnexion</literal></entry>
      <entry>
       <para>
        Précise le nom de connexion s'il est différent de celui de
	l'utilisateur Unix.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-P motdepasse</literal></entry>
      <entry>
       <para>
        Précise le mot de passe de l'utilisateur. Attention&nbsp;: utiliser
	cette option est un risque sur la sécurité car la commande ps
	affichera le mot de passe. À n'utiliser que pour des tests.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-n</literal></entry>
      <entry>
       <para>
        Pas de VACUUM et de nettoyage de la table history avant l'exécution
	du test.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-v</literal></entry>
      <entry>
       <para>
        Exécute un VACUUM avant le test. Cela prendra du temps. Sans
	-n ou -v, pgbench exécute un VACUUM sur les seules tables tellers
	et branches.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-S</literal></entry>
      <entry>
       <para>
        Réalise uniquement des transactions de sélection au lieu du TPC-B.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-N</literal></entry>
      <entry>
       <para>
        Ne met pas à jour les tables branches et tellers. Ceci évitera
	les grosses contentions des mises à jour sur les tables branches et
	tellers mais du coup pgbench ne support pas les transactions du style
	TPC-B.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-f filename</literal></entry>
      <entry>
       <para>
        Lit le script de transaction à partir d'un fichier. Des explications
	détaillées apparaîtront plus tard.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-C</literal></entry>
      <entry>
       <para>
        Établie une connexion pour chaque transaction, plutôt que de se
	connecter une seule fois au lancement de pgbench dans le mode normal.
	Ceci est utile pour mesurer la charge occasionnée par la connexion.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-l</literal></entry>
      <entry>
       <para>
        Écrit le temps pris par chaque transaction dans un fichier de trace,
        du nom pgbench_log.xxx, où xxx est le PID du processus pgbench. Le
	format de la trace est le suivant&nbsp;:
       </para>
       <programlisting>
        client_id transaction_no time file_no time-epoch time-us
       </programlisting>
       <para>
        où time est le temps mesuré en microsecondes, file_no est le fichier
	de test utilisé (utile quand plusieurs sont indiqués avec -f), et
	time-epoch/time-us sont un horodatage au format epoch UNIX suivi par
	un décalage en microsecondes (convenable pour la création d'un
	horodatage ISO 8601 avec une faction d'une seconde) du moment où la
	transaction s'est terminée.
       </para>
       <para>
        Voici un exemple d'affichage&nbsp;:
       </para>
       <programlisting>
 0 199 2241 0 1175850568 995598
 0 200 2465 0 1175850568 998079
 0 201 2513 0 1175850569 608
 0 202 2038 0 1175850569 2663
       </programlisting>
      </entry>
     </row>
     <row>
      <entry><literal>-F facteur_remplissage</literal></entry>
      <entry>
       <para>
        Crée les tables (accounts, tellers et branches) avec le facteur de
	remplissage indiqué. La valeur par défaut est de 100.  Cette option
	est utilisable avec l'option -i (option d'initialisation).
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>-d</literal></entry>
      <entry>
       <para>
        Option de déboguage.
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2>
  <title>Quelle est la transaction réalisée dans pgbench&nbsp;?</title>
  <orderedlist>
   <listitem><para><literal>begin;</literal></para></listitem>

   <listitem><para><literal>update accounts set abalance = abalance + :delta where aid = :aid;</literal></para></listitem>

   <listitem><para><literal>select abalance from accounts where aid = :aid;</literal></para></listitem>

   <listitem><para><literal>update tellers set tbalance = tbalance + :delta where tid = :tid;</literal></para></listitem>

   <listitem><para><literal>update branches set bbalance = bbalance + :delta where bid = :bid;</literal></para></listitem>

   <listitem><para><literal>insert into history(tid,bid,aid,delta) values(:tid,:bid,:aid,:delta);</literal></para></listitem>

   <listitem><para><literal>end;</literal></para></listitem>
  </orderedlist>
  <para>
   Si vous indiquez -N, (4) et (5) ne font plus partie de la transaction.
  </para>
 </sect2>

 <sect2>
  <title>Fichier script</title>
  <para>
   <literal>pgbench</literal> permet de lire un script de transaction,
   script spécifié par l'option <literal>-f</literal>. Ce fichier doit
   inclure des commandes SQL sur chaque ligne. Les commandes SQL sur
   plusieurs lignes ne sont pas acceptées. Les lignes vides et les lignes
   commençant par <literal>--</literal> seront ignorées.
  </para>
  <para>
   Plusieurs options <literal>-f</literal> sont autorisées en même temps.
   Dans ce cas, chaque transaction se voit affectée un script choisi au
   hasard.
  </para>
  <para>
   Les commandes SQL peuvent inclure une méta-commande qui commence par un
   antislash. Uen méta-commande prend plusieurs arguments séparés par des
   espaces blancs. Les méta-commande actuellement acceptées sont&nbsp;:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     <literal>\set name operand1 [ operator operand2 ]</literal>
     - Initialise la variable "name" à partir de la valeur calculée en
     utilisant "operand1" "operator" "operand2". Si "operator" et "operand2"
     sont omis, la valeur d'operand1 est utilisée pour initialiser la variable
     "name".
    </para>
    <para>
     Exemple&nbsp;:
    </para>
    <programlisting>
\set ntellers 10 * :scale
    </programlisting>
   </listitem>
   <listitem>
    <para>
     <literal>\setrandom name min max</literal>
     - Affecte un entier au hasard pour name entre min et max
    </para>
    <para>
     Exemple&nbsp;:
    </para>
    <programlisting>
\setrandom aid 1 100000
    </programlisting>
   </listitem>
   <listitem>
    <para>
     Les variables peuvent être utilisées dans les commandes SQL en ajoutant
     le symbole <literal>:</literal> devant le nom de la variable.
    </para>
    <para>
     Exemple&nbsp;:
    </para>
    <programlisting>
SELECT abalance FROM accounts WHERE aid = :aid
    </programlisting>
    <para>
     Les variables peuvent aussi être définies en utilisant l'option -D.
    </para>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
  <title>Exemples</title>
  <para>
   Exemple d'un test de performances style TPC-B défini ainsi (facteur
   d'échelle à 1)&nbsp;:
  </para>
  <programlisting>
\set nbranches :scale
\set ntellers 10 * :scale
\set naccounts 100000 * :scale
\setrandom aid 1 :naccounts
\setrandom bid 1 :nbranches
\setrandom tid 1 :ntellers
\setrandom delta 1 10000
BEGIN
UPDATE accounts SET abalance = abalance + :delta WHERE aid = :aid
SELECT abalance FROM accounts WHERE aid = :aid
UPDATE tellers SET tbalance = tbalance + :delta WHERE tid = :tid
UPDATE branches SET bbalance = bbalance + :delta WHERE bid = :bid
INSERT INTO history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, 'now')
END
  </programlisting>
  <para>
   Si vous voulez configurer automatiquement le facteur d'échelle à partir
   du nombre de lignes dans la table branches, utilisez l'option -s et une
   commande shell comme la suivante&nbsp;:
  </para>
  <programlisting>
pgbench -s $(psql -At -c "SELECT count(*) FROM branches") -f tpc_b.sql
  </programlisting>
  <para>
   Notez que l'option -f n'exécute pas de VACUUM et n'efface pas
   la table history avant le début d'un test de performances.
  </para>
 </sect2>

</sect1>

