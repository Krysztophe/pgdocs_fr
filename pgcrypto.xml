
<sect1 id="pgcrypto">
 <title>pgcrypto</title>
 
 <indexterm zone="pgcrypto">
  <primary>pgcrypto</primary>
 </indexterm>

 <para>
  Ce module propose des fonctions de cryptographie pour PostgreSQL.
 </para>

 <sect2>
  <title>Notes</title>
  <sect3>
   <title>Configuration</title>
   <para>
    pgcrypto se configure lui-même suivant les découvertes du script
    <literal>configure</literal> principal de PostgreSQL. Les options qui
    l'affectent sont <literal>--with-zlib</literal> et
    <literal>--with-openssl</literal>.
   </para>
   <para>
    Lorsqu'il est compilé avec zlib, les fonctions de chiffrement PGP sont
    capable de compresser avant de chiffrer.
   </para>
   <para>
    Lorsqu'il est compilé avec OpenSSL, d'autres algorithmes sont disponibles.
    De plus, les fonctions de chiffrement avec clé publique sont plus rapides
    car OpenSSL est plus optimisé que les fonctions BIGNUM.
   </para>
   <para>
    Résumé des fonctionnalités avec et sans OpenSSL&nbsp;:
   </para>
   <table>
    <title>Résumé des fonctionnalités avec et sans OpenSSL</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Fonctionnalité</entry>
       <entry>interne</entry>
       <entry>OpenSSL</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>MD5</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>SHA1</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>SHA224/256/384/512</entry>
       <entry>oui</entry>
       <entry>oui (3)</entry>
      </row>
      <row>
       <entry>Tout autre algorithme digest</entry>
       <entry>non</entry>
       <entry>oui (1)</entry>
      </row>
      <row>
       <entry>Blowfish</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>AES</entry>
       <entry>oui</entry>
       <entry>oui (2)</entry>
      </row>
      <row>
       <entry>DES/3DES/CAST5</entry>
       <entry>non</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>Chiffrement Raw</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>chiffrement PGP Symetric</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>Chiffrement PGP Public-Key</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <orderedlist>
    <listitem>
     <para>
      Tout algorithme digest qu'OpenSSL supporte est automatiquement choisi.
      Ce n'est pas possible avec les chiffreurs qui doivent être supportés
      explicitement.
     </para>
    </listitem>
    <listitem>
     <para>
      AES est inclus dans OpenSSL depuis la version 0.9.7. Si pgcrypto est
      compilé avec une ancienne version, il utilisera le code AES interne,
      donc AES est toujours disponible.
     </para>
    </listitem>
    <listitem>
     <para>
      Les algorithmes SHA2 étaient ajoutés à OpenSSL dans la version 0.9.8.
      Pour les anciennes versions, pgcrypto utilisera son code interne.
     </para>
    </listitem>
   </orderedlist>
  </sect3>

  <sect3>
   <title>Gestion des NULL</title>
   <para>
    Comme le standard SQL le demande, toutes les fonctions renvoient NULL si
    un des arguments est NULL. Cela peut permettre une faille de sécurité si
    c'est utilisé sans précaution.
   </para>
  </sect3>

  <sect3>
   <title>Sécurité</title>
   <para>
    Toutes les fonctions sont exécutées au sein du serveur de bases de données.
    Cela signifie que toutes les données et les mots de passe sont passés entre
    pgcrypto et l'application client en texte clair. Donc, vous devez&nbsp;:
   </para>

   <orderedlist>
    <listitem>
     <para>vous connecter localement ou utiliser des connexions SSL&nbsp;;</para>
    </listitem>
    <listitem>
     <para>Faire confiance à votre administrateur système et de base de
      données.</para>
    </listitem>
   </orderedlist>
   <para>
    Si vous ne le pouvez pas, alors il est préférable de chiffrer directement
    au sein de l'application client.
   </para>
  </sect3>
 </sect2>

 <sect2>
  <title>Hachage général</title>
  
  <sect3>
   <title><literal>digest(data, type)</literal></title>
   <programlisting>
    digest(data text, type text) RETURNS bytea
    digest(data bytea, type text) RETURNS bytea
   </programlisting>
   <para>
    Le paramètre type correspond à l'algorithme à utiliser. Les algorithmes
    standards sont <quote>md5</quote> et <quote>sha1</quote> bien qu'il
    peut y en avoir d'autres suivant les options de construction.
   </para>
   <para>
    Renvoie un chachage binaire.
   </para>
   <para>
    Si vous voulez des chaînes hexadécimales, utilisez la fonction encode() sur
    le résultat. Par exemple&nbsp;:
   </para>
   <programlisting>
    CREATE OR REPLACE FUNCTION sha1(bytea) RETURNS text AS $$
      SELECT encode(digest($1, 'sha1'), 'hex')
    $$ LANGUAGE SQL STRICT IMMUTABLE;
   </programlisting>
  </sect3>

  <sect3>
   <title><literal>hmac(data, key, type)</literal></title>
   <programlisting>
    hmac(data text, key text, type text) RETURNS bytea
    hmac(data bytea, key text, type text) RETURNS bytea
   </programlisting>
   <para>
    Calcule un MAC haché sur les données. type est identique à celui de
    digest(). Si la clé est plus importante que la taille du bloc de hachage,
    elle sera d'abord hachée et le hachage sera utilisé comme clé.
   </para>
   <para>
    C'est similaire à digest() mais le hachage peut être recalculé en connaissant
    seulement la clé. Ceci évite le scénario où quelqu'un modifie les données
    et le hachage en même temps.
   </para>
   <para>
    Renvoie un hachage binaire.
   </para>
  </sect3>
 </sect2>

 <sect2>
  <title>Hachage de mots de passe</title>
  <para>
   Les fonctions <literal>crypt()</literal> et <literal>gen_salt()</literal>
   sont spécialement conçues pour hacher les mots de passe.
   <literal>crypt()</literal> s'occupe du hachage et gen_salt() prépare les
   paramètres de l'algorithme pour ça.
  </para>
  <para>
   Les algorithmes de `crypt()` diffèrent des algorithmes de hachage habituels
   comme MD5 ou SHA1&nbsp;:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Ils sont lents. Comme la quantité de données est petite, c'est le seul
     moyen de rendre difficile la découverte par la force des mots de passe.
    </para>
   </listitem>
   <listitem>
    <para>
     Inclut une valeur aléatoire appelée sel (salt en anglais) avec le
     résultat, pour que les utilisateurs qui
     ont le même mot de passer puissent avoir des mots de passe chiffrés
     différents. C'est aussi une défense supplémentaire comme l'inversion de
     l'algorithme.
    </para>
   </listitem>
   <listitem>
    <para>
     Inclut le type de l'algorithme dans le résultat pour que les mots de passe
     hachés avec différents algorithmes puissent co-exister.
    </para>
   </listitem>
   <listitem>
    <para>
     Certains s'adaptent. Cela signifie que, une fois que les ordinateurs
     iront plus vite, vous pourrez configurer l'algorithme pour qu'il soit
     plus lent, ceci sans introduire d'incompatibilité avec les mots de
     passe existant.
    </para>
   </listitem>
  </orderedlist>

  <para>
   Algorithmes supportés&nbsp;:
  </para>
  <programlisting>
`------`--------------`---------`----------`------------------------------
 Type   Taille Max MdP Adaptif   Bits sel   Description
--------------------------------------------------------------------------
`bf`     72             oui       128       Basé sur Blowfish, variante 2a
`md5`    illimitée      non        48       crypt() basé sur md5
`xdes`   8              oui        24       Extended DES
`des`    8              non        12       crypt original UNIX
---------------------------------------------------------------------------
  </programlisting>

  <sect3>
   <title>crypt(password, salt)</title>
   <programlisting>
    crypt(password text, salt text) RETURNS text
   </programlisting>
   <para>
    Calcule un hachage de mot de passe d'après crypt(3) UN*X. Lors du
    stockage d'un nouveau mot de passe, vous devez utiliser la fonction
    gen_salt() pour générer un nouveau sel. Lors de la vérification de mot de
    passe, vous devez utiliser un hachage existant comme sel.
   </para>
   <para>
    Exemple - ajout d'un nouveau mot de passe&nbsp;:
   </para>
   <programlisting>
    UPDATE .. SET pswhash = crypt('new password', gen_salt('md5'));
   </programlisting>
   <para>
    Exemple - authentification&nbsp;:
   </para>
   <programlisting>
    SELECT pswhash = crypt('entered password', pswhash) WHERE .. ;
   </programlisting>
   <para>
    renvoie true ou false si le mot de passe saisi est correct.
    Il peut aussi renvoyer NULL si le champ pswhash est NULL.
   </para>
  </sect3>

  <sect3>
   <title>gen_salt(type)</title>
   <programlisting>
    gen_salt(type text) RETURNS text
   </programlisting>
   <para>
    Génère une nouvelle valeur aléatoire sel pour son utilisation avec
    crypt(). Pour des algorithmes adaptifs, il utilise le nombre d'itération
    par défaut.
   </para>
   <para>
    Les types acceptés sont des, xdes, md5 et bf.
   </para>
  </sect3>
  <sect3>
   <title>gen_salt(type, rounds)</title>
   <programlisting>
    gen_salt(type text, rounds integer) RETURNS text
   </programlisting>
   <para>
    Plus rounds est haut, plus cela prends du temps pour hacher le mot de passe
    et, du coup, plus cela prends de temps pour le casser. Avec une valeur trop
    importante, le temps de calcul pourrait être de plusieurs années, ce qui
    est peu pratique.
   </para>
   <para>
    Le nombre dépend de l'algorithme&nbsp;:
   </para>
   <programlisting>
`-----'---------'-----'----------
 type   default   min   max
---------------------------------
 `xdes`     725     1   16777215
 `bf`         6     4         31
--------------------------------- 
   </programlisting>
   <para>
    Dans le cas de xdes, il existe une limite supplémentaire qui fait que ce
    nombre doit être un nombre impair.
   </para>
   <para>
    Notes:
   </para>
   <itemizedlist>
    <listitem>
     <para>
     Le crypt DES original a été conçu pour réaliser quatre hachages par
     seconde sur le matériel de l'époque.
     </para>
    </listitem>
    <listitem>
     <para>
     Plus lent que quatre hachages par secondes casserait probablement
     la facilité d'utilisation.
     </para>
    </listitem>
    <listitem>
     <para>
     Plus rapide que cent hachages à la seconde est probablement trop rapide.
     </para>
    </listitem>
    <listitem>
     <para>
     Voir la section suivante pour les valeurs possibles de crypt-bf.
     </para>
    </listitem>
   </itemizedlist>
  </sect3>

  <sect3>
   <title>Comparaison du hachage standard et de celui de crypt</title>
   <para>
    Voici une table qui devrait donner un aperçu de la lenteur relative de
    différents algorithmes de hachage.
   </para>
   <itemizedlist>
    <listitem>
     <para>
     Le but est de craquer un mot de passe sur huit caractères qui consiste&nbsp;:
     </para>
     <orderedlist>
      <listitem><para>seulement en des lettres minuscules</para></listitem>
      <listitem><para>de nombres, de lettres minuscules et majuscules.</para></listitem>
     </orderedlist>
    </listitem>
    <listitem>
     <para>
     La table ci-dessous affiche le temps que prends toutes les combinaisons de
     caractères.
     </para>
    </listitem>
    <listitem>
     <para>
     <literal>crypt-bf</literal> fait partie de différents paramétrages - le
     nombre après le slash est le paramètre <literal>rounds</literal> de
     <literal>gen_salt()</literal>.
     </para>
    </listitem>
   </itemizedlist>
   <programlisting>
`------------'------------'---------------'---------------------
Algorithme    Hachages/sec  Caract: [a-z]   Caract: [A-Za-z0-9]
----------------------------------------------------------------
crypt-bf/8              28     246 années         251322 années
crypt-bf/7              57     121 années         123457 années
crypt-bf/6             112      62 années          62831 années
crypt-bf/5             211      33 années          33351 années
crypt-md5             2681     2.6 années           2625 années
crypt-des           362837        7 jours             19 années
sha1                590223        4 jours             12 années
md5                2345086        1 jours              3 années
----------------------------------------------------------------
   </programlisting>
   <itemizedlist>
    <listitem>
     <para>
     La machine utilisée est un 1.5GHz Pentium 4.
     </para>
    </listitem>
    <listitem>
     <para>
     Les numéros des algorithmes crypt-des et crypt-md5 sont pris de la sortie
     du -test de John the Ripper v1.6.38.
     </para>
    </listitem>
    <listitem>
     <para>
     Les nombres MD5 font partie de mdcrack 1.2.
     </para>
    </listitem>
    <listitem>
     <para>
     Les nombres SHA1 font partie de lcrack-20031130-beta.
     </para>
    </listitem>
    <listitem>
     <para>
     Les nombres <literal>crypt-bf</literal> sont pris en utilisant le programme
     simple qui boucle sur 1000 mots de passe de huit caractères. De cette
     façon, je peux afficher la vitesse avec les différents nombres de tours.
     Pour référence&nbsp;: <literal>john -test</literal> affiche 213 tours/sec
     pour crypt-bf/5. (La petite différence dans les résultats est dû au fait
     que l'implémentation de <literal>crypt-bf</literal> dans pgcrypto est la
     même que celle utilisée dans John the Ripper.)
     </para>
    </listitem>
   </itemizedlist>

   <para>
    Notez que tenter toutes les combinaisons n'est pas une exercice réaliste.
    Habituellement craquer les mots de passe se fait avec l'aide de
    dictionnaires contenant les mots standards et différentes variantes. Donc,
    même des mots de passe qui ressemblent vaguement à des mots peuvent être
    craqués plus rapidement que les nombres ci-dessus le suggèrent alors qu'un
    mot de passe sur six caractères qui ne ressemble pas un mot pourrait ne
    pas être craqué.
   </para>
  </sect3>
 </sect2>


 <sect2>
  <title>Chiffrage PGP</title>
  <para>
   Les fonctions implémentent la partie du standard OpenPGP (RFC2440). Les
   chiffrements à clés symétriques et publiques sont supportés.
  </para>

  <sect3>
   <title>Aperçu</title>
   <para>
    Un message PGP chiffré consiste en deux paquets&nbsp;:
   </para>
   <itemizedlist>
    <listitem><para>Paquet pour la clé de session - soit symétrique soit clé
     publique.</para></listitem>
    <listitem><para>Paquet pour les données chiffrées avec la clé de
     session.</para></listitem>
   </itemizedlist>
   <para>
    Lors d'un chiffement avec mot de passe&nbsp;:
   </para>
   <orderedlist>
    <listitem>
     <para>
     Étant donné que le mot de passe est haché en utilisant l'algorithme
     String2Key (S2K), ceci est assez similaire à l'algorithme crypt() -
     lenteur voulue et avec le nombre aléatoire pour le sel - mais il produit
     une clé binaire de taille complète.
     </para>
    </listitem>
    <listitem>
     <para>
     Si une clé de session séparée est demandée, une nouvelle clé sera générée
     au hasard. Sinon une clé S2K sera utilisée directement en tant que clé de
     session.
     </para>
    </listitem>
    <listitem>
     <para>
     Si une clé S2K est à utiliser directement, alors seuls les paramètres S2K sont
     placés dans le paquet de session. Sinon la clé de session sera chiffrée avec la
     clé S2K et placée dans le paquet de session.
     </para>
    </listitem>
   </orderedlist>
   <para>
    Lors du chiffrement avec la clé publique&nbsp;:
   </para>
   <orderedlist>
    <listitem><para>Une nouvelle clé de session est générée au hasard.</para></listitem>
    <listitem><para>Elle est chiffrée en utilisant la clé public et placée dans
     le paquet de session.</para></listitem>
   </orderedlist>

   <para>
    Maintenant, la partie commune, le paquet de données chiffrées de la session
    clé&nbsp;:
   </para>
   <orderedlist>
    <listitem> 
     <para>
     Manipulation optionnelle des données&nbsp;: compression, conversion vers
     UTF-8, conversion de retours à la ligne.
     </para>
    </listitem>
    <listitem>
     <para>
     Les données sont préfixées avec un bloc d'octets pris au hasard. C'est identique
     à l'utilisation de <foreignphrase>random IV</foreignphrase>.
     </para>
    </listitem>
    <listitem>
     <para>
     Un hachage SHA1 d'un préfixe et de données au hasard est ajouté.
     </para>
    </listitem>
    <listitem>
     <para>
     Tout ceci est chiffré avec la clé de la session.
     </para>
    </listitem>
   </orderedlist>
  </sect3>

  <sect3>
   <title><literal>pgp_sym_encrypt(data, psw)</literal></title>
   <programlisting>
    pgp_sym_encrypt(data text, psw text [, options text] ) RETURNS bytea
    pgp_sym_encrypt_bytea(data bytea, psw text [, options text] ) RETURNS bytea
   </programlisting>
   <para>
    Renvoie un message PHP chiffré avec une clé symétrique.
   </para>
   <para>
    Les options sont décrites dans la section 5.8.
   </para>
  </sect3>

  <sect3>
   <title><literal>pgp_sym_decrypt(msg, psw)</literal></title>
   <programlisting>
    pgp_sym_decrypt(msg bytea, psw text [, options text] ) RETURNS text
    pgp_sym_decrypt_bytea(msg bytea, psw text [, options text] ) RETURNS bytea
   </programlisting>
   <para>
    Déchiffre un message PGP chiffré avec une clé symétrique.
   </para>
   <para>
    Déchiffrer des données bytea avec pgp_sym_decrypt est interdit.
    Ceci a pour but d'éviter la sortie de données de type caractère invalides.
    Déchiffrer des données textuelles avec pgp_sym_decrypt_bytea ne pose pas
    de problème.
   </para>
   <para>
    Les options sont décrites dans la section 5.8.
   </para>
  </sect3>

  <sect3>
   <title><literal>pgp_pub_encrypt(data, pub_key)</literal></title>
   <programlisting>
    pgp_pub_encrypt(data text, key bytea [, options text] ) RETURNS bytea
    pgp_pub_encrypt_bytea(data bytea, key bytea [, options text] ) RETURNS bytea
   </programlisting>
   <para>
    Chiffre des données avec une clé publique. Avec cette fonction, une clé
    secrète produit une erreur.
   </para>
   <para>
    Les options sont décrites dans la section 5.8.
   </para>
  </sect3>

  <sect3>
   <title><literal>pgp_pub_decrypt(msg, sec_key [, psw])</literal></title>
   <programlisting>
    pgp_pub_decrypt(msg bytea, key bytea [, psw text [, options text]] ) RETURNS text
    pgp_pub_decrypt_bytea(msg bytea, key bytea [,psw text [, options text]] ) RETURNS bytea
   </programlisting>
   <para>
    Déchiffre un message chiffré avec une clé public grâce à une clé secrète.
    Si la clé secrète est protégée par un mot de passe, vous devez donner le
    mot de passe grâce au paramètre psw. S'il n'y a pas de mot de passe mais
    que vous voulez spécifier une option pour la fonction, vous devez passer
    un mot de passe vide.
   </para>
   <para>
    Déchiffrer des données bytea avec pgp_pub_decrypt est interdit.
    Ceci a pour but d'éviter la sortie de données de type caractère invalides.
    Déchiffrer des données textuelles avec pgp_pub_decrypt_bytea ne pose pas
    de problème.
   </para>
   <para>
    Les options sont décrites dans la section 5.8.
   </para>
  </sect3>

  <sect3>
   <title><literal>pgp_key_id(key / msg)</literal></title>
   <programlisting>
    pgp_key_id(key or msg bytea) RETURNS text
   </programlisting>
   <para>
    Elle vous affiche soit l'identifiant de la clé si elle dispose de la clé
    PGP publique ou secrète. Sinon, elle donne l'identifiant de clé utilisé
    pour chiffrer les données si le message donné est chiffré.
   </para>
   <para>
    Elle peut renvoyer deux identifiants de clés spéciaux&nbsp;:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      SYMKEY&nbsp;:
     </para>
     <para>
      La donnée est chiffrée avec une clé symétrique.
     </para>
    </listitem>
    <listitem>
     <para>
      ANYKEY&nbsp;:
     </para>
     <para>
      La donnée est chiffrée avec une clé publique mais l'identifiant de la clé
      est effacé. Cela signifie que vous avez besoin d'essayer toutes les clés
      secrètes pour voir laquelle la déchiffre. pgcrypto ne réalise pas lui-même
      de tels messages.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Notez que des clés différentes peuvent avoir le même identifiant. C'est rare
    mais normal. L'application client doit alors essayer de déchiffer avec
    chacune d'elle pour voir laquelle correspond - ce qui revient à la gestion
    de ANYKEY.
   </para>
  </sect3>

  <sect3>
   <title><literal>armor / dearmor</literal></title>
   <programlisting>
    armor(data bytea) RETURNS text
    dearmor(data text) RETURNS bytea
   </programlisting>
   <para>
    Ces fonctions enveloppent les données dans une armure ASCII PGP qui est
    basiquement en Base64 avec CRC et un formatage supplémentaire.
   </para>
  </sect3>

  <sect3>
   <title>Options pour les fonctions PGP</title>
   <para>
    Les options sont nommées de façon similaires à GnuPG. Les valeurs sont
    fournies après un signe d'égalité&nbsp;; les options sont séparées par
    des virgules. Par exemple&nbsp;:
   </para>
   <programlisting>
    pgp_sym_encrypt(data, psw, 'compress-algo=1, cipher-algo=aes256')
   </programlisting>
   <para>
    Toutes les options en dehors de convert-crlf s'appliquent seulement aux
    fonctions de chiffrement. Les fonctions de déchiffrement obtiennent des
    paramètres des données PGP.
   </para>
   <para>
    Les options les plus intéressantes sont problablement compression-algo et
    <literal>unicode-mode</literal>. Le reste doit avoir des valeurs par défaut
    raisonnables.
   </para>
  </sect3>

  <sect3>
   <title>cipher-algo</title>
   <para>
    Algorithme de chiffrement à utiliser.
   </para>
   <programlisting>
    Valeurs&nbsp;: bf, aes128, aes192, aes256 (OpenSSL-only: `3des`, `cast5`)
    Par défaut&nbsp;: aes128
    S'applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt
   </programlisting>
  </sect3>

  <sect3>
   <title>compress-algo</title>
   <para>
    Algorithme de compression à utiliser. Nécessite zlib.
   </para>
   <para>
    Valeurs&nbsp;:
   </para>
   <programlisting>
    0 - sans compression
    1 - compression ZIP
    2 - compression ZLIB [=ZIP plus meta-data and block-CRC's]
    Par défaut&nbsp;: 0
    S'applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt
   </programlisting>
  </sect3>

  <sect3>
   <title>compress-level</title>
   <para>
    Niveau de compression. Les grands niveaux compressent mieux mais sont plus
    lents. 0 désactive la compression.
   </para>
   <programlisting>
    Valeurs&nbsp;: 0, 1-9
    Par défaut&nbsp;: 6
    S'applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt
   </programlisting>
  </sect3>

  <sect3>
   <title>convert-crlf</title>
   <para>
    Précise si <literal>\n</literal> doit être converti en
    <literal>\r\n</literal> lors du chiffrement et <literal>\r\n</literal>
    en <literal>\n</literal> lors du déchiffrement. La RFC2440 spécifie que
    les données texte doivent être stockées en utilisant les retours chariot
    <literal>\r\n</literal>. Utilisez cette option pour obtenir un comportement
    respectant la RFC.
   </para>
   <programlisting>
    Valeurs&nbsp;: 0, 1
    Par défaut&nbsp;: 0
    S'applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt
   </programlisting>
  </sect3>

  <sect3>
   <title>disable-mdc</title>
   <para>
    Ne protège pas les données avec SHA-1. La seule bonne raison pour utiliser
    cette option est d'avoir une compatibilité avec les anciens produits PGP
    car un paquet protégé par SHA-1 vient d'une mise à jour de la RFC2440.
    (Actuellement en version RFC2440bis-14.) Les versions récentes des logiciels
    de gnupg.org et pgp.com le supportent.
   </para>
   <programlisting>
    Valeurs&nbsp;: 0, 1
    Par défaut&nbsp;: 0
    S'applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt
   </programlisting>
  </sect3>

  <sect3>
   <title>enable-session-key</title>
   <para>
    Utilise la clé de session séparée. Le chiffrement par clé publique utilise
    toujours une clé de session séparée, c'est pour le chiffrement de clé
    symétrique, qui utilise directement par défaut S2K.
   </para>
   <programlisting>
    Valeurs&nbsp;: 0, 1
    Par défaut&nbsp;: 0
    S'applique à&nbsp;: pgp_sym_encrypt
   </programlisting>
  </sect3>

  <sect3>
   <title>s2k-mode</title>
   <para>
    Algorithme S2K à utiliser.
   </para>
   <programlisting>
    Valeurs&nbsp;:
      0 - Sans sel. Dangereux&nbsp;!
      1 - Avec sel mais avec un décompte fixe des itérations.
      3 - Décompte variables des itérations.
    Par défaut&nbsp;: 3
    S'applique à&nbsp;: pgp_sym_encrypt
   </programlisting>
  </sect3>

  <sect3>
   <title>s2k-digest-algo</title>
   <para>
    Algorithme digest à utiliser dans le calcul S2K.
   </para>
   <programlisting>
    Valeurs&nbsp;: md5, sha1
    Par défaut&nbsp;: sha1
    S'applique à&nbsp;: pgp_sym_encrypt
   </programlisting>
  </sect3>

  <sect3>
   <title>s2k-cipher-algo</title>
   <para>
    Chiffrement à utiliser pour le chiffrage de la clé de session séparée.
   </para>
   <programlisting>
    Valeurs&nbsp;: bf, aes, aes128, aes192, aes256
    Par défaut&nbsp;: use cipher-algo.
    S'applique à&nbsp;: pgp_sym_encrypt
   </programlisting>
  </sect3>

  <sect3>
   <title>unicode-mode</title>
   <para>
    Sélection de la conversion des données texte à partir de l'encodage interne
    de la base vers l'UTF-8 et inversement. Si votre base de données est déjà
    en UTF-8, aucune conversion ne sera réalisée, seules les données seront
    marquées comme étant en UTF-8. Sans cette option, cela ne se fera pas.
   </para>
   <programlisting>
    Valeurs&nbsp;: 0, 1
    Par défaut&nbsp;: 0
    S'applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt
   </programlisting>
  </sect3>
 </sect2>

 <sect2>
  <title>Générer des clés avec GnuPG</title>
  <para>
   Générer une nouvelle clé&nbsp;:
  </para>
  <programlisting>
   gpg --gen-key
  </programlisting>
  <para>
   Le type de clé préféré est <literal>DSA and Elgamal</literal>.
  </para>
  <para>
   Pour le chiffrement RSA, vous devez créer soir une clé de signature seulement
   DSA ou RSA en tant que maître, puis ajouter la sous-clé de chiffrement RSA
   avec <literal>gpg --edit-key</literal>.
  </para>
  <para>
   Lister les clés&nbsp;:
  </para>
  <programlisting>
   gpg --list-secret-keys
  </programlisting>
  <para>
   Exporter la clé publique ASCII&nbsp;:
  </para>
  <programlisting><![CDATA[
   gpg -a --export KEYID > public.key
  ]]></programlisting>
  <para>
   Exporter la clé secrète en ASCII&nbsp;:
  </para>
  <programlisting><![CDATA[
   gpg -a --export-secret-keys KEYID > secret.key
  ]]></programlisting>
  <para> 
   Vous avez besoin d'utiliser la fonction dearmor() sur elles avant de les
   passer aux fonctions pgp_pub_*. Si vous gérez des données binaires, vous
   pouvez omettre l'option <option>-a</option> de gpg.
  </para>
  <para>
   Pour plus de détails, voir la page de référence de gpg, le
   <ulink url="http://www.gnupg.org/gph/en/manual.html">livre « GNU
   Privacy Handbook »</ulink> et d'autres documents sur le
   <ulink url="http://www.gnupg.org">site gnupg.org</ulink>.
  </para>
 </sect2>

 <sect2>
  <title>Limites du code PGP</title>
  <itemizedlist>
   <listitem>
    <para>
    Pas de support des signatures. Cela signifie aussi qu'on ne peut pas
    vérifier si la sous-clé de chiffrage appartient bien à la clé maître.
    </para>
   </listitem>
   <listitem>
    <para>
    Pas de support de la clé de chiffrement en tant que clé maître. Cela ne
    devrait pas être un problème étant donné que cette pratique n'est pas
    encouragée.
    </para>
   </listitem>
   <listitem>
    <para>
    Pas de support pour plusieurs sous-clés. Ceci peut être un problème car
    c'est une pratique courante. D'un autre côté, vous ne devez pas utiliser
    vos clés GPG/PGP habituelles avec pgcrypto, mais en créer de nouvelles
    car l'utilisation est assez différente.
    </para>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
  <title>Chiffrement brut (Raw)</title>
  <para>
   Ces fonctions exécutent directement un calcul des données, ils n'ont
   pas de fonctionnalités avancées de chiffrement PGP. Du coup, ils ont les
   problèmes majeurs suivant&nbsp;:
  </para>
  <orderedlist>
   <listitem>
    <para>
    Elles utilisent directement la clé de l'utilisateur comme clé de calcul.
    </para>
   </listitem>
   <listitem>
    <para>
    Elles ne fournissent pas une vérification de l'intégrité pour savoir si
    les données chiffrées ont été modifiées.
    </para>
   </listitem>
   <listitem>
    <para>
    Elles s'attendent à ce que les utilisateurs gèrent eux-même tous les
    paramètres du chiffrement, même IV.
    </para>
   </listitem>
   <listitem>
    <para>
    Elles ne gèrent pas le texte.
    </para>
   </listitem>
  </orderedlist>
  <para>
   Donc, avec l'introduction du chiffrement PGP, l'utilisation des fonctions
   de chiffrement brut n'est pas encouragée.
  </para>
  <programlisting>
    encrypt(data bytea, key bytea, type text) RETURNS bytea
    decrypt(data bytea, key bytea, type text) RETURNS bytea

    encrypt_iv(data bytea, key bytea, iv bytea, type text) RETURNS bytea
    decrypt_iv(data bytea, key bytea, iv bytea, type text) RETURNS bytea
  </programlisting>
  <para>
   Chiffre/déchiffre les données avec le calcul et l'ajout de données
   d'alignement si nécessaire.
  </para>
  <para>
   Description du paramètre <literal>type</literal>&nbsp;:
  </para>
  <programlisting>
    algo ['-' mode] ['/pad:' padding]
  </programlisting>
  <para>
   Algorithmes supportés&nbsp;:
  </para>
  <itemizedlist>
   <listitem><para><literal>bf</literal>- Blowfish</para></listitem>
   <listitem><para><literal>aes</literal>- AES (Rijndael-128)</para></listitem>
  </itemizedlist>
  <para>
   Modes&nbsp;:
  </para>
  <itemizedlist>
   <listitem>
    <para>
    <literal>cbc</literal>- le bloc suivant dépend du précédent. (par défaut)
    </para>
   </listitem>
   <listitem>
    <para>
    <literal>ecb</literal>- chaque bloc est chiffré séparément. (seulement pour
    les tests)
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Alignement&nbsp;:
  </para>
  <itemizedlist>
   <listitem>
    <para>
    <literal>pkcs</literal>-les données peuvent avoir n'importe quelle longueur
    (par défault)
    </para>
   </listitem>
   <listitem>
    <para>
    <literal>none</literal>- les données doivent être des multiples de la taille
    du bloc de calcul.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   IV est une valeur initiale pour mode, par défaut, tout à zéro. Elle est
   ignorée pour ECB. Elle est remplie de zéro pour l'aliglement si la taille
   de données ne correspond à un multiple de la taille du bloc.
  </para>
  <para>
   Donc, l'exemple&nbsp;:
  </para>
  <programlisting>
   encrypt(data, 'fooz', 'bf')
  </programlisting>
  <para>
   est identique à&nbsp;:
  </para>
  <programlisting>
   encrypt(data, 'fooz', 'bf-cbc/pad:pkcs')
  </programlisting>
 </sect2>

 <sect2>
  <title>Octets au hasard</title>
  <programlisting>
    gen_random_bytes(count integer)
  </programlisting>
  <para>
   Renvoie le nombre count d'octets au hasard dans une valeur bytea.
   Il peut y avoir au maximum 1024 octets extrait à un instant t, ceci pour
   éviter de vider le contenu du générateur de nombres aléatoires.
  </para>
 </sect2>

 <sect2>
  <title>Références/Liens</title>
  
  <sect3>
   <title>Lectures utiles</title>
   <itemizedlist>
    <listitem>
     <para><ulink url="http://www.gnupg.org/gph/en/manual.html"></ulink>&nbsp;:</para>
     <para>GNU Privacy Handbook</para>
    </listitem>
    <listitem>
     <para><ulink url="http://www.openwall.com/crypt/"></ulink>&nbsp;:</para>
     <para>Décrit l'algorithme crypt-blowfish.</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="http://www.stack.nl/~galactus/remailers/passphrase-faq.html"></ulink>&nbsp;:
     </para>
     <para>Comment choisir un bon mot de passe.</para>
    </listitem>
    <listitem>
     <para><ulink url="http://world.std.com/~reinhold/diceware.html"></ulink>&nbsp;:</para>
     <para>Idée intéressant pour le choix d'un mot de passe.</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="http://www.interhack.net/people/cmcurtin/snake-oil-faq.html"></ulink>&nbsp;:
     </para>
     <para>Décrit la bonne et la mauvaise cryptographie.</para>
    </listitem>
   </itemizedlist>
  </sect3>

  <sect3>
   <title>Références techniques</title>
   <itemizedlist>
    <listitem>
     <para><ulink url="http://www.ietf.org/rfc/rfc2440.txt"></ulink>&nbsp;:</para>
     <para>Format d'un message OpenPGP</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="http://www.imc.org/draft-ietf-openpgp-rfc2440bis"></ulink>&nbsp;:
     </para>
     <para>Nouvelle version de RFC2440.</para>
    </listitem>
    <listitem>
     <para><ulink url="http://www.ietf.org/rfc/rfc1321.txt"></ulink>&nbsp;:</para>
     <para>L'algorithme MD5 Message-Digest</para>
    </listitem>
    <listitem>
     <para><ulink url="http://www.ietf.org/rfc/rfc2104.txt"></ulink>&nbsp;:</para>
     <para>HMAC: Keyed-Hashing for Message Authentication</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="http://www.usenix.org/events/usenix99/provos.html"></ulink>&nbsp;:
     </para>
     <para>Comparaison des algorithmes crypt-des, crypt-md5 et bcrypt.</para>
    </listitem>
    <listitem>
     <para><ulink url="http://csrc.nist.gov/cryptval/des.htm"></ulink>&nbsp;:</para>
     <para>Standards pour DES, 3DES et AES.</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="http://en.wikipedia.org/wiki/Fortuna_(PRNG)"></ulink>&nbsp;:
     </para>
     <para>Description de Fortuna CSPRNG.</para>
    </listitem>
    <listitem>
     <para><ulink url="http://jlcooke.ca/random/"></ulink>&nbsp;:</para>
     <para>Jean-Luc Cooke Fortuna-based /dev/random driver for Linux.</para>
    </listitem>
    <listitem>
     <para><ulink url="http://www.cs.ut.ee/~helger/crypto/"></ulink>&nbsp;:</para>
     <para>Ensemble de pointeurs de cryptologie.</para>
    </listitem>
   </itemizedlist>
  </sect3>
 </sect2>

 <sect2>
  <title>Crédits</title>
  <para>
   <literal>pgcrypto</literal> utilise du code provenant des sources
   suivantes&nbsp;:
  </para>
  <table>
   <title>Crédits</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry><para>Algorithme</para></entry>
      <entry><para>Auteur</para></entry>
      <entry><para>Origine du source</para></entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><para>DES crypt()</para></entry>
      <entry><para>David Burren et d'autres</para></entry>
      <entry><para>FreeBSD libcrypt</para></entry>
     </row>
     <row>
      <entry><para>MD5 crypt()</para></entry> 
      <entry><para>Poul-Henning Kamp</para></entry>        
      <entry><para>FreeBSD libcrypt</para></entry>
     </row>
     <row>
      <entry><para>Blowfish crypt()</para></entry>     
      <entry><para>Solar Designer</para></entry>            
      <entry><para>www.openwall.com</para></entry>
     </row>
     <row>
      <entry><para>Chiffrement Blowfish</para></entry>     
      <entry><para>Simon Tatham</para></entry>
      <entry><para>PuTTY</para></entry>
     </row>
     <row>
      <entry><para>Chiffrement Rijndael</para></entry>     
      <entry><para>Brian Gladman</para></entry>
      <entry><para>OpenBSD sys/crypto</para></entry>
     </row>
     <row>
      <entry><para>MD5 et SHA1</para></entry>        
      <entry><para>WIDE Project</para></entry>
      <entry><para>KAME kame/sys/crypto</para></entry>
     </row>
     <row>
      <entry><para>SHA256/384/512 </para></entry>      
      <entry><para>Aaron D. Gifford</para></entry>
      <entry><para>OpenBSD sys/crypto</para></entry>
     </row>
     <row>
      <entry><para>Calcul BIGNUM</para></entry>          
      <entry><para>Michael J. Fromberger</para></entry>
      <entry><para>dartmouth.edu/~sting/sw/imath</para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2>
  <title>Auteur</title>
  <para>
   Marko Kreen <email>markokr@gmail.com</email>
  </para>
 </sect2>
 
</sect1>

