<sect1 id="pgfreespacemap">
 <title>pg_freespacemap</title>
 
 <indexterm zone="pgfreespacemap">
  <primary>pg_freespacemap</primary>
 </indexterm>

 <para>
  Ce module fournit un moyen pour examiner la carte des espaces libres (FSM).
  Il consiste en deux fonctions C&nbsp;:
  <literal>pg_freespacemap_relations()</literal> et
  <literal>pg_freespacemap_pages()</literal> qui renvoient un ensemble
  d'enregistrements, ainsi que deux vues
  <literal>pg_freespacemap_relations</literal> et
  <literal>pg_freespacemap_pages</literal> pour un accès plus facile aux
  fonctions.
 </para>
 <para>
  Ce module permet d'examiner le contenu de la structure FSM sans devoir
  redémarrer le serveur ou le reconstruire avec du code de débogage.
 </para>
 <para>
  Par défaut, l'accès public est interdit à ces fonctions et vues pour des
  raisons de sécurité.
 </para>

 <sect2>
  <title>Notes</title>
  <para>
   Voici la liste des colonnes des vues et leur définition:
  </para>

  <table>
   <title>pg_freespacemap_relations</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Colonne</entry>
      <entry>Référence</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>reltablespace</entry>
      <entry>pg_tablespace.oid</entry>
      <entry>OID du tablespace de la relation</entry>
     </row>
     <row>
      <entry>reldatabase</entry>
      <entry>pg_database.oid</entry>
      <entry>OID de la base de données de la relation</entry>
     </row>
     <row>
      <entry>relfilenode</entry>
      <entry>pg_class.relfilenode</entry>
      <entry>relfilenode de la relation</entry>
     </row>
     <row>
      <entry>avgrequest</entry>
      <entry></entry>
      <entry>Moyenne des demandes d'espace disque (NULL pour les index)</entry>
     </row>
     <row>
      <entry>interestingpages</entry>
      <entry></entry>
      <entry>Nombre de pages rapportées comme contenant des espaces
       libres</entry>
     </row>
     <row>
      <entry>storedpages</entry>
      <entry></entry>
      <entry>Nombre de pages actuellement stockées dans le FSM</entry>
     </row>
     <row>
      <entry>nextpage</entry>
      <entry></entry>
      <entry>Index de la page pour commencer la prochaine recherche (à partir
       de 0)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>pg_freespacemap_pages</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Colonne</entry>
      <entry>Référence</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>reltablespace</entry>
      <entry>pg_tablespace.oid</entry>
      <entry>OID du tablespace de la relation</entry>
     </row>
     <row>
      <entry>reldatabase</entry>
      <entry>pg_database.oid</entry>
      <entry>OID de la base de données de la relation</entry>
     </row>
     <row>
      <entry>relfilenode</entry>
      <entry>pg_class.relfilenode</entry>
      <entry>relfilenode de la relation</entry>
     </row>
     <row>
      <entry>relblocknumber</entry>
      <entry></entry>
      <entry>Numéro de page dans la relation</entry>
     </row>
     <row>
      <entry>bytes</entry>
      <entry></entry>
      <entry>Octets libres dans la page, ou NULL pour une page d'index
       (voir ci-dessous).</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Pour <literal>pg_freespacemap_relations</literal>, il y a une ligne
   pour chaque relation comprise dans la structure FSM.
   <literal>storedpages</literal> est le nombre de pages actuellement stockées
   dans la structure alors que <literal>interestingpages</literal> est le
   nombre de pages que le dernier VACUUM a trouvé intéressantes pour la
   quantité d'espaces libres.
  </para>
  <para>
   Si <literal>storedpages</literal> est bien moindre que interestingpages,
   alors une bonne idée serait d'accroître <literal>max_fsm_pages</literal>.
   De plus, si le nombre de lignes dans
   <literal>pg_freespacemap_relations</literal> est proche de
   <literal>max_fsm_relations</literal>, alors considérez l'augmentation de
   <literal>max_fsm_relations</literal>.
  </para>
  <para>
   Pour <literal>pg_freespacemap_pages</literal>, il y a une ligne pour chaque
   page dans la structure FSM. Le nombre de lignes d'une relation correspond
   à la colonne <literal>storedpages</literal> de
   <literal>pg_freespacemap_relations</literal>.
  </para>
  <para>
   Pour les index, seules les pages entièrement inutilisées sont tracées.
   Il n'y a pas de trace de pages contenant un peu d'espace libre. Du coup,
   la taille moyenne d'une demande et les octets disponibles dans une page
   sont moins intéressantes et sont, du coup, affichés NULL.
  </para>
  <para>
   Comme cette structure est partagée par toutes les bases, elle inclut
   des relations qui n'appartiennent pas à la base en cours.
  </para>
  <para>
   Quand une des vues est utilisée, des verrous sont posés sur la structure
   le temps d'en faire une copie pour l'affichage. Ceci nous assure
   d'avoir une vue cohérente de l'ensemble des résultats tout en ne bloquant
   pas trop l'activité normale. Néanmoins, cela pourrait avoir un impact sur
   les performances de la base de données si les vues sont fréquemment lues.
  </para>
 </sect2>

 <sect2>
  <title>Exemple d'affichage - pg_freespacemap_relations</title>
  <programlisting>
regression=# \d pg_freespacemap_relations
View "public.pg_freespacemap_relations"
    Column        |  Type   | Modifiers
------------------+---------+-----------
 reltablespace    | oid     |
 reldatabase      | oid     |
 relfilenode      | oid     |
 avgrequest       | integer |
 interestingpages | integer |
 storedpages      | integer |
 nextpage         | integer |
View definition:
 SELECT p.reltablespace, p.reldatabase, p.relfilenode, p.avgrequest, p.interestingpages, p.storedpages, p.nextpage
   FROM pg_freespacemap_relations() p(reltablespace oid, reldatabase oid, relfilenode oid, avgrequest integer, interestingpages integer, storedpages integer, nextpage integer);

regression=# SELECT c.relname, r.avgrequest, r.interestingpages, r.storedpages
             FROM pg_freespacemap_relations r INNER JOIN pg_class c
             ON c.relfilenode = r.relfilenode INNER JOIN pg_database d
             ON r.reldatabase = d.oid AND (d.datname = current_database()) 
             ORDER BY r.storedpages DESC LIMIT 10;
             relname             | avgrequest | interestingpages | storedpages
---------------------------------+------------+------------------+-------------
 onek                            |        256 |              109 |         109
 pg_attribute                    |        167 |               93 |          93
 pg_class                        |        191 |               49 |          49
 pg_attribute_relid_attnam_index |            |               48 |          48
 onek2                           |        256 |               37 |          37
 pg_depend                       |         95 |               26 |          26
 pg_type                         |        199 |               16 |          16
 pg_rewrite                      |       1011 |               13 |          13
 pg_class_relname_nsp_index      |            |               10 |          10
 pg_proc                         |        302 |                8 |           8
(10 rows)
  </programlisting>
 </sect2>

 <sect2>
  <title>Exemple d'affichage - pg_freespacemap_pages</title>
  <programlisting>
regression=# \d pg_freespacemap_pages
 View "public.pg_freespacemap_pages"
     Column     |  Type   | Modifiers 
----------------+---------+-----------
 reltablespace  | oid     | 
 reldatabase    | oid     | 
 relfilenode    | oid     | 
 relblocknumber | bigint  | 
 bytes          | integer | 
View definition:
 SELECT p.reltablespace, p.reldatabase, p.relfilenode, p.relblocknumber, p.bytes
   FROM pg_freespacemap_pages() p(reltablespace oid, reldatabase oid, relfilenode oid, relblocknumber bigint, bytes integer);

regression=# SELECT c.relname, p.relblocknumber, p.bytes
             FROM pg_freespacemap_pages p INNER JOIN pg_class c
             ON c.relfilenode = p.relfilenode INNER JOIN pg_database d
             ON (p.reldatabase = d.oid AND d.datname = current_database()) 
             ORDER BY c.relname LIMIT 10;
   relname    | relblocknumber | bytes 
--------------+----------------+-------
 a_star       |              0 |  8040
 abstime_tbl  |              0 |  7908
 aggtest      |              0 |  8008
 altinhoid    |              0 |  8128
 altstartwith |              0 |  8128
 arrtest      |              0 |  7172
 b_star       |              0 |  7976
 box_tbl      |              0 |  7912
 bt_f8_heap   |             54 |  7728
 bt_i4_heap   |             49 |  8008
(10 rows)
  </programlisting>
 </sect2>

 <sect2>
  <title>Auteur</title>
  <para>
   Mark Kirkwood <email>markir@paradise.net.nz</email>
  </para>
 </sect2>
</sect1>

