<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/plhandler.sgml,v 1.5 2005/06/13 06:25:42 guillaume Exp $
-->

 <chapter id="plhandler">
   <title>Écrire un gestionnaire de langage procédural</title>

   <indexterm zone="plhandler">
    <primary>langage procédural</primary>
    <secondary>gestionnaire</secondary>
   </indexterm>

   <para>
    Tous les appels de fonctions écrites dans un langage autre que celui
    de l'interface <quote>version 1</quote> pour les langages compilés (ce qui
    inclut les fonctions dans les langages procéduraux utilisateur, les
    fonctions SQL et les fonctions utilisant l'interface de langage compilé
    version 0), passent par une fonction spécifique au langage du
    <firstterm>gestionnaire d'appels</firstterm>.
    Le gestionnaire d'appels exécute la fonction de manière appropriée, 
    par exemple en interprétant le code source fourni. Ce chapitre 
    décrit l'écriture du gestionnaire d'appels d'un nouveau langage
    procédural.
   </para>

   <para>
    Le gestionnaire d'appel d'un langage procédural est une fonction
    <quote>normale</quote> qui doit être écrite dans un langage compilé tel que
    le C, en utilisant l'interface version-1, et enregistrée sous
    <productname>PostgreSQL</productname> comme une fonction sans argument
    et retournant le type <type>language_handler</type>. Ce pseudo-type spécial
    identifie la fonction comme gestionnaire d'appel et empêche son appel 
    à partir des commandes SQL.
   </para>

   <para>
    L'appel du gestionnaire d'appels est identique à celui de toute
    autre fonction&nbsp;: il reçoit un pointeur de <type>structure</type>
    <structname>FunctionCallInfoData</structname> qui contient les
    valeurs des arguments et d'autres informations de la fonction appelée.
    Il retourne un résultat <type>Datum</type> (et, initialise
    le champ <structfield>isnull</structfield> de la structure
    <structname>FunctionCallInfoData</structname> si un résultat SQL NULL doit
    être retourné). La différence entre un gestionnaire d'appels et une
    fonction ordinaire se situe au niveau du champ
    <structfield>flinfo-&gt;fn_oid</structfield> de la structure
    <structname>FunctionCallInfoData</structname>. Dans le cas du gestionnaire
    d'appels, il contiendra l'OID de la fonction à appeler, et non pas celui du
    gestionnaire d'appels lui-même.
    Le gestionnaire d'appels utilise ce champ pour déterminer la
    fonction à exécuter. De plus, la liste d'arguments passée a été dressée 
    à partir de la déclaration de la fonction cible, et non pas en
    fonction du gestionnaire d'appels.
   </para>

   <para>
    C'est le gestionnaire d'appels qui récupère l'entrée de la
    fonction dans la table système <classname>pg_proc</classname> et
    analyse les types des arguments et de la valeur de retour de la fonction
    appelée. La clause <literal>AS</literal> de la commande
    <command>CREATE FUNCTION</command> se situe dans la
    colonne <literal>prosrc</literal> de
    <classname>pg_proc</classname>. Il s'agit généralement du texte source du
    langage procédural lui-même (comme pour PL/Tcl) mais, en théorie, cela
    peut être un chemin vers un fichier ou tout ce qui indique
    au gestionnaire d'appels les détails des actions à effectuer.
   </para>

   <para>
    Souvent, la même fonction est appelée plusieurs fois dans la même
    instruction SQL.
    L'utilisation du champ <structfield>flinfo-&gt;fn_extra</structfield> 
    évite au gestionnaire d'appels de répéter la recherche des informations 
    concernant la fonction appelée. Ce champ, initialement
    <symbol>NULL</symbol>, peut être configuré par le gestionnaire d'appels pour
    pointer sur l'information concernant la fonction appelée. Lors des appels
    suivants, si <structfield>flinfo-&gt;fn_extra</structfield> est différent
    de <symbol>NULL</symbol>, alors il peut être utilisé et l'étape de
    recherche d'information évitée. Le gestionnaire d'appels doit
    s'assurer que <structfield>flinfo-&gt;fn_extra</structfield> pointe sur une 
    zone mémoire qui restera allouée au moins jusqu'à la fin de la requête en
    cours, car une structure de données <structname>FmgrInfo</structname> peut
    être conservée aussi longtemps. Cela peut-être obtenu par l'allocation
    des données supplémentaires dans le contexte mémoire spécifié par
    <structfield>flinfo-&gt;fn_mcxt</structfield>&nbsp;; de telles données
    ont la même espérance de vie que <structname>FmgrInfo</structname>. 
    Le gestionnaire peut également choisir d'utiliser un contexte mémoire de
    plus longue espérance de vie de façon à
    mettre en cache sur plusieurs
    requêtes les informations concernant les définitions des fonctions.
   </para>

   <para>
    Lorsqu'une fonction en langage procédural est appelée via un déclencheur,
    aucun argument ne lui est passé de façon traditionnelle mais le champ
    <structfield>context</structfield> de
    <structname>FunctionCallInfoData</structname> pointe sur une structure
    <structname>TriggerData</structname>. Il n'est pas
    <symbol>NULL</symbol> comme c'est le cas dans les appels de fonctions standard.
    Un gestionnaire de langage doit fournir les mécanismes pour que les
    fonctions de langages procéduraux obtiennent les informations du
    déclencheur.
   </para>

   <para>
    Voici un modèle de gestionnaire de langage procédural écrit en C&nbsp;:
<programlisting>#include "postgres.h"
#include "executor/spi.h"
#include "commands/trigger.h"
#include "fmgr.h"
#include "access/heapam.h"
#include "utils/syscache.h"
#include "catalog/pg_proc.h"
#include "catalog/pg_type.h"

PG_FUNCTION_INFO_V1(plsample_call_handler);

Datum
plsample_call_handler(PG_FUNCTION_ARGS)
{
    Datum          retval;

    if (CALLED_AS_TRIGGER(fcinfo))
    {
        /*
         * Appelé comme procédure de déclencheur
         */
        TriggerData    *trigdata = (TriggerData *) fcinfo-&gt;context;

        retval = ...
    }
    else
    {
        /*
         * Appelé en tant que fonction
         */

        retval = ...
    }

    return retval;
}
</programlisting>
    Il suffit de remplacer les points de suspension par quelques milliers de
    lignes de codes pour compléter ce modèle.
   </para>

   <para>
    Lorsque la fonction du gestionnaire est compilée dans un module chargeable
    (voir <xref linkend="dfunc"/>), les commandes suivantes enregistrent le langage
    procédural défini dans l'exemple&nbsp;:
<programlisting>CREATE FUNCTION plsample_call_handler() RETURNS language_handler
    AS '<replaceable>nomfichier</replaceable>'
    LANGUAGE C;
CREATE LANGUAGE plsample
    HANDLER plsample_call_handler;
</programlisting>
   </para>

   <para>
    Les langages procéduraux inclus dans la distribution standard sont de
    bons points de départ à l'écriture de son propre gestionnaire
    d'appels. Les sources se trouvent dans le répertoire <filename>src/pl</filename>.
   </para>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
