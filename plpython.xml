<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="plpython">
 <title>PL/Python - Langage de procédures Python</title>

 <indexterm zone="plpython"><primary>PL/Python</primary></indexterm>
 <indexterm zone="plpython"><primary>Python</primary></indexterm>

 <para>
  Le langage de procédures <application>PL/Python</application> permet l'écriture
  de fonctions <productname>PostgreSQL</productname> avec le
  <ulink url="http://www.python.org">langage Python</ulink>.
 </para>

 <para>
  Pour installer PL/Python dans une base de données particulières, utilisez
  <literal>createlang plpythonu <replaceable>nom_base</replaceable></literal>.
 </para>

  <tip>
   <para>
    Si un langage est installé dans <literal>template1</literal>, toutes les bases
    nouvellement créées se verront installées ce langage automatiquement.
   </para>
  </tip>

 <para>
  Depuis <productname>PostgreSQL</productname> 7.4, PL/Python est seulement
  disponible en tant que langage <quote>sans confiance</quote> (ceci signifiant
  qu'il n'offre aucun moyen de restreindre ce que les utilisateurs en font). Il
  a donc été renommé en <literal>plpythonu</literal>. La variante de confiance
  <literal>plpython</literal> pourrait être de nouveau disponible dans le futur, si un
  nouveau mécanisme sécurisé d'exécution est développé dans Python.
 </para>

 <note>
  <para>
   Les utilisateurs des paquets sources doivent activer spécifiquement la
   construction de PL/Python lors des étapes d'installation (référez-vous aux
   instructions d'installation pour plus d'informations). Les utilisateurs de
   paquets binaires pourront trouver PL/Python dans un paquet séparé.
  </para>
 </note>

 <sect1 id="plpython-funcs">
  <title>Fonctions PL/Python</title>

  <para>
   Les fonctions PL/Python sont déclarées via la syntaxe standard <xref
   linkend="sql-createfunction" endterm="sql-createfunction-title"/>&nbsp;:
<programlisting>CREATE FUNCTION <replaceable>nom_fonction</replaceable> (<replaceable>liste-arguments</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # corps de la fonction PL/Python
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
   Le corps d'une fonction est tout simplement un script Python. Quand la
   fonction est appelée, ses arguments sont passés au script Python comme des
   éléments du tableau <varname>args[]</varname>&nbsp;; les arguments nommés
   sont en plus passés comme des variables ordinaires. Le résultat est renvoyé
   par le code Python de la façon habituelle, avec <literal>return</literal> ou
   <literal>yield</literal> (dans le cas d'une instruction avec un ensemble
   de résultats).
  </para>

  <para>
   Par exemple, une fonction renvoyant le plus grand de deux entiers peut
   être définie ainsi&nbsp;:

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   Le code Python donné comme corps de la définition de fonction est transformé
   en fonction Python. Par exemple, le code ci-dessus devient&nbsp;:

<programlisting>def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b</programlisting>

   en supposant que 23456 est l'OID affecté à la fonction par
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   Les paramètres de fonction <productname>PostgreSQL</productname> sont
   disponibles dans la liste globale <varname>args</varname>. Dans l'exemple
   <function>pymax</function>, <varname>args[0]</varname> contient tout ce qui
   a été passé comme premier argument et <varname>args[1]</varname> contient la
   valeur du deuxième argument. Sinon, vous pouvez utiliser les paramètres
   nommés comme le montre l'exemple ci-dessus. L'utilisation de paramètres
   nommés est habituellement plus lisible.
  </para>

  <para>
   Si une valeur SQL NULL<indexterm><primary>valeur NULL</primary><secondary
   sortas="PL/Python">PL/Python</secondary></indexterm> est passée à une fonction,
   la valeur de l'argument apparaîtra comme <symbol>None</symbol> au niveau de
   Python. La définition de la fonction ci-dessus renverra la mauvaise réponse
   pour des entrées NULL. Nous pouvons jouer <literal>STRICT</literal> à la
   définition de la fonction pour faire en sorte que
   <productname>PostgreSQL</productname> fasse quelque-chose de plus
   raisonnable&nbsp;: si une valeur NULL est passée, la fonction ne sera pas
   appelée du tout mais renverra juste un résultat NULL automatiquement.
   Sinon, vous pouver vérifier les entrées NULL dans le corps de la
   fonction&nbsp;:

<programlisting>CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   Comme montré ci-dessus, pour renvoyer une valeur SQL NULL à partir d'une
   fonction PL/Python, renvoyez la valeur <symbol>None</symbol>. Ceci peut
   se faire que la fonction soit stricte ou non.
  </para>

  <para>
   Les arguments de type composite sont passés à la fonction via une
   correspondance Python. Les noms d'élément de la correspondance sont les noms
   d'attribut du type composite. Si un attribut a une valeur NULL dans la ligne
   traitée; il a la valeur NULL dans sa correspondance. Voici un exemple&nbsp;:

<programlisting>CREATE TABLE employe (
  nom text,
  salaire integer,
  age integer
);

CREATE FUNCTION trop_paye (e employe)
  RETURNS boolean
AS $$
  if e["salaire"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salaire"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
   Il existe plusieurs façon de renvoyer une ligne ou des types composites à
   partir d'une fonction Python. Les exemples suivants supposent que nous
   avons&nbsp;:

<programlisting>CREATE TABLE valeur_nommee (
  nom   text,
  valeur  integer
);
</programlisting>
   ou
<programlisting>CREATE TYPE valeur_nommee AS (
  nom   text,
  valeur  integer
);
</programlisting>

   Une valeur composite peut être renvoyé comme&nbsp;:
   <variablelist>
    <varlistentry>
     <term>Un type séquence (ligne ou liste), mais pas
       un ensemble parce que ce n'est pas indexable</term>
     <listitem>
      <para>
       Les objets séquences renvoyés doivent avoir le même nombre d'éléments que
       le type composite a de champs. L'élément d'index 0 est affecté au
       premier champ du type composite, 1 au second et ainsi de suite. Par
       exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  return [ nom, valeur ]
  # ou autrement, en tant que ligne : return ( nom, valeur )
$$ LANGUAGE plpythonu;
</programlisting>

       Pour renvoyer NULL dans une colonne, insérez <symbol>None</symbol> à la
       position correspondante.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Correspondance (dictionnaire)</term>
     <listitem>
      <para>
       La valeur de chaque colonne du type résultat est récupérée à partir de la
       correspondance avec le nom de colonne comme clé. Exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  return { "nom": nom, "valeur": valeur }
$$ LANGUAGE plpythonu;
</programlisting>

       Des paires clés/valeurs supplémentaires du dictionnaire sont ignorées.
       Les clés manquantes sont traitées comme des erreurs.
       Pour renvoyer NULL comme une colonne, insérez <symbol>None</symbol>
       avec le nom de la colonne correspondante comme clé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Objet (tout objet fournissant la méthode <literal>__getattr__</literal>)</term>
     <listitem>
      <para>
       Ceci fonctionne de la même façon qu'une correspondance.
       Exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  class valeur_nommee:
    def __init__ (self, n, v):
      self.nom = n
      self.valeur = v
  return valeur_nommee(nom, valeur)

  # ou simplement
  class nv: pass
  nv.nom = nom
  nv.valeur = valeur
  return nv
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Si vous ne fournissez pas de valeur de retour,
   <application>PL/Python</application> renvoie par défaut
   <symbol>None</symbol>. Le module du langage traduit le
   <symbol>None</symbol> de Python en la valeur NULL en SQL.
  </para>

  <para>
   Une fonction <application>PL/Python</application> peut aussi renvoyer des
   ensembles scalaires ou des types composites. Il existe plusieurs façon de
   faire ceci parce que l'objet renvoyé est transformé en interne en itérateur.
   Les exemples suivants supposent que nous avons le type composite&nbsp;:

<programlisting>CREATE TYPE greeting AS (
  how text,
  who text
);
</programlisting>
   
   Un résultat ensemble peut être renvoyé à partir de&nbsp;:
   <variablelist>
    <varlistentry>
     <term>Un type séquence (ligne, liste, ensemble)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # renvoie la ligne contenant les listes en tant que types composites
  # toutes les autres combinaisons fonctionnent aussi
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>L'itérateur (tout objet fournissant les méthodes <symbol>__iter__</symbol>
      et <symbol>next</symbol>)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Le générateur (<literal>yield</literal>)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpythonu;
</programlisting>

       <warning>
        <para>
         Actuellement, à cause du
         <ulink url="http://bugs.python.org/issue1483133">bogue #1483133</ulink> de Python,
         certaines versions de débogage de Python 2.4
         (configuré et compilé avec l'option <literal>--with-pydebug</literal>)
         sont connues pour arrêter brutalement le serveur
	 <productname>PostgreSQL</productname> lors de l'utilisation d'un
	 itérateur pour renvoyer un résultat ensemble. Les versions non corrigées de
         Fedora 4 contiennent ce bogue. Cela n'arrive pas dans les versions de
         production de Python et sur les versions corrigées de Fedora 4.
        </para>
       </warning>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Le dictionnaire global <varname>SD</varname> est disponible pour stocker des
   données entres les appels de fonctions. Cette variable est une donnée
   statique privée. Le dictionnaire global <varname>GD</varname> est une donnée
   publique disponible pour toutes les fonctions Python à l'intérieur d'une
   session. À utiliser avec précaution.<indexterm><primary>données
   globales</primary><secondary>en PL/Python</secondary></indexterm>
  </para>

  <para>
   Chaque fonction obtient son propre environnement d'exécution dans
   l'interpréteur Python, de façon à ce que les données globales et les
   arguments de fonction provenant de <function>ma_fonction</function> ne soient
   pas disponibles depuis <function>ma_fonction2</function>. L'exception
   concerne les données du dictionnaire <varname>GD</varname> comme indiqué
   ci-dessus.
  </para>
 </sect1>

 <sect1 id="plpython-trigger">
  <title>Fonctions de déclencheurs</title>

  <indexterm zone="plpython-trigger">
   <primary>déclencheur</primary>
   <secondary>en PL/Python</secondary>
  </indexterm>

  <para>
   Quand une fonction est utilisée comme un déclencheur, le dictionnaire
   <literal>TD</literal> contient des valeurs relatives au déclencheur.
   <literal>TD["event"]</literal> contient l'événement en tant que chaîne
   (<literal>INSERT</literal>, <literal>UPDATE</literal>,
   <literal>DELETE</literal>, <literal>TRUNCATE</literal> ou <literal>UNKNOWN</literal>).
   <literal>TD["when"]</literal> contient soit <literal>BEFORE</literal>, soit
   <literal>AFTER</literal> soit <literal>UNKNOWN</literal>.
   <literal>TD["level"]</literal> contient une valeur parmi <literal>ROW</literal>,
   <literal>STATEMENT</literal> et <literal>UNKNOWN</literal>.
   Pour un trigger niveau ligne, les lignes du trigger sont dans
   <literal>TD["new"]</literal> et/ou <literal>TD["old"]</literal> suivant
   l'événement qui a déclenché le trigger.
   <literal>TD["name"]</literal> contient le nom du déclencheur,
   <literal>TD["table_name"]</literal> contient le nom de la table pour laquelle
   a été exécuté le déclencheur,
   <literal>TD["table_schema"]</literal> contient le schéma de la table pour laquelle
   a été exécuté le déclencheur,
   <literal>TD["relid"]</literal> l'OID de la table sur lequel le déclencheur a été
   activé. Si la commande <command>CREATE TRIGGER</command> incluait des
   arguments, ils sont disponibles dans les variables de
   <literal>TD["args"][0]</literal> à
   <literal>TD["args"][<replaceable>n</replaceable>-1]</literal>.
  </para>

  <para>
   Si <literal>TD["when"]</literal> vaut <literal>BEFORE</literal> et si
   <literal>TD["level"]</literal> vaut <literal>ROW</literal>, vous pourriez
   renvoyer <literal>None</literal> ou <literal>"OK"</literal> à partir de la
   fonction Python pour indiquer que la ligne n'est pas modifiée,
   <literal>"SKIP"</literal> pour annuler l'événement ou <literal>"MODIFY"</literal>
   pour indiquer que vous avez modifié la ligne. Sinon la valeur de retour est
   ignorée.
  </para>
 </sect1>

 <sect1 id="plpython-database">
  <title>Accès à la base de données</title>

  <para>
   Le module du langage PL/Python importe automatiquement un module Python
   appelé <literal>plpy</literal>. Les fonctions et constantes de ce module
   vous sont accessibles dans le code Python via
   <literal>plpy.<replaceable>foo</replaceable></literal>. Actuellement,
   <literal>plpy</literal> implémente les fonctions
   <literal>plpy.debug(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.log(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.info(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.notice(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.warning(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.error(<replaceable>msg</replaceable>)</literal> et
   <literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>.
   <indexterm><primary>elog</primary><secondary>dans PL/Python</secondary></indexterm>
   <function>plpy.error</function> et <literal>plpy.fatal("msg")</literal>
   lèvent une exception Python qui, si non attrapée, se propage à la requête
   appelante causant l'annulation de la transaction ou sous-transaction en
   cours.  <literal>raise plpy.ERROR(<replaceable>msg</replaceable>)</literal> et
   <literal>raise plpy.FATAL(<replaceable>msg</replaceable>)</literal> sont équivalent à
   appeler, respectivement, <function>plpy.error</function> et
   <function>plpy.fatal</function>. Les autres fonctions génèrent uniquement
   des messages de
   niveaux de priorité différents. Que les messages d'une priorité particulière
   soient reportés au client, écrit dans les journaux du serveur ou les deux,
   cette configuration est contrôlée par les variables <xref
   linkend="guc-log-min-messages"/> et <xref linkend="guc-client-min-messages"/>.
   Voir le <xref linkend="runtime-config"/> pour plus d'informations.
  </para>

  <para>
   De plus, le module <literal>plpy</literal> fournit deux fonctions appelées
   <function>execute</function> et <function>prepare</function>. Appeler
   <function>plpy.execute</function> avec une chaîne de requête et un argument
   de limite optionnel fait que la requête est lancée et que le résultat est
   renvoyé dans un objet résultat. L'objet résultat émule une liste ou un objet
   dictionnaire. L'objet résultat est accessible par le numéro de ligne et le
   nom de la colonne. Il a plusieurs méthodes supplémentaires&nbsp;:
   <function>nrows</function> qui renvoie le nombre de lignes retournées par la
   requête et <function>status</function> qui est le code de retour de
   <function>SPI_execute()</function>. L'objet résultat peut être modifié.
  </para>

  <para>
   Par exemple&nbsp;:
<programlisting>rv = plpy.execute("SELECT * FROM ma_table", 5)
</programlisting>
   renvoie cinq lignes de <literal>ma_table</literal>. Si
   <literal>ma_table</literal> dispose d'une colonne
   <literal>ma_colonne</literal>, elle sera accessible avec&nbsp;:
<programlisting>foo = rv[i]["ma_colonne"]
</programlisting>
  </para>

  <para>
   <indexterm><primary>préparer une requête</primary><secondary>en
PL/Python</secondary></indexterm>
   La seconde fonction, <function>plpy.prepare</function>, prépare le plan
   d'exécution pour une requête. Il est appelé avec une chaîne contenant la
   requête et une liste des types de paramètres si vous avez des références de
   paramètres dans la requête. Par exemple&nbsp;:
<programlisting>plan = plpy.prepare("SELECT nom FROM mes_utilisateurs WHERE prenom = $1", [
"text" ])
</programlisting>
   <literal>text</literal> est le type de la variable que vous voulez passer via
   <literal>$1</literal>. Après avoir préparé une instruction, vous utilisez la
   fonction <function>plpy.execute</function> pour l'exécuter&nbsp;:
<programlisting>rv = plpy.execute(plan, [ "nom" ], 5)
</programlisting>
   Le troisième argument est la limite et est optionnelle.
  </para>

  <para>
   Lorsque vous préparez un plan en utilisant le module PL/Python, il est
   automatiquement sauvegardé. Lisez la documentation SPI (<xref
   linkend="spi"/>) pour une description de ce que cela signifie. Pour faire
   réellement usage de ceci dans les appels de fonction, vous avez besoin
   d'utiliser un des dictionnaires à stockage permanent
   <literal>SD</literal> ou <literal>GD</literal> (voir le
   <xref linkend="plpython-funcs"/>). Par exemple&nbsp;:
<programlisting>CREATE FUNCTION utiliseplansauvegarde() RETURNS trigger AS $$
    if SD.has_key("plan"):
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # reste de la fonction
$$ LANGUAGE plpythonu;
</programlisting>
  </para>
 </sect1>

<!-- [IGNORE[ NOT CURRENTLY SUPPORTED

 <sect1 id="plpython-trusted">
  <title>Restricted Environment</title>

  <para>
   The current version of <application>PL/Python</application>
   functions as a trusted language only; access to the file system and
   other local resources is disabled.  Specifically,
   <application>PL/Python</application> uses the Python restricted
   execution environment, further restricts it to prevent the use of
   the file <function>open</function> call, and allows only modules from a
   specific list to be imported.  Presently, that list includes:
   <literal>array</literal>, <literal>bisect</literal>, <literal>binascii</literal>,
   <literal>calendar</literal>, <literal>cmath</literal>, <literal>codecs</literal>,
   <literal>errno</literal>, <literal>marshal</literal>, <literal>math</literal>, <literal>md5</literal>,
   <literal>mpz</literal>, <literal>operator</literal>, <literal>pcre</literal>,
   <literal>pickle</literal>, <literal>random</literal>, <literal>re</literal>, <literal>regex</literal>,
   <literal>sre</literal>, <literal>sha</literal>, <literal>string</literal>, <literal>StringIO</literal>,
   <literal>struct</literal>, <literal>time</literal>, <literal>whrandom</literal>, and
   <literal>zlib</literal>.
  </para>
 </sect1>

-->

</chapter>
