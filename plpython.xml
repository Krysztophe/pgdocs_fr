<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/plpython.sgml,v 1.10 2005/09/15 07:03:20 guillaume Exp $ -->

<chapter id="plpython">
 <title>PL/Python - Langage de procédures Python</title>

 <indexterm zone="plpython"><primary>PL/Python</primary></indexterm>
 <indexterm zone="plpython"><primary>Python</primary></indexterm>

 <para>
  Le langage de procédures <application>PL/Python</application> permet l'écriture
  de fonctions <productname>PostgreSQL</productname> avec le
  <ulink url="http://www.python.org">langage Python</ulink>.
 </para>

 <para>
  Pour installer PL/Python dans une base de données particulières, utilisez
  <literal>createlang plpythonu <replaceable>nom_base</replaceable></literal>.
 </para>

  <tip>
   <para>
    Si un langage est installé dans <literal>template1</literal>, toutes les bases
    nouvellement créées se verront installées ce langage automatiquement.
   </para>
  </tip>

 <para>
  Depuis <productname>PostgreSQL</productname> 7.4, PL/Python est seulement
  disponible en tant que langage <quote>sans confiance</quote> (ceci signifiant
  qu'il n'offre aucun moyen de restreindre ce que les utilisateurs en font). Il
  a donc été renommé en <literal>plpythonu</literal>. La variante de confiance
  <literal>plpython</literal> pourrait être de nouveau disponible dans le futur, si un
  nouveau mécanisme sécurisé d'exécution est développé dans Python.
 </para>

 <note>
  <para>
   Les utilisateurs des paquets sources doivent activer spécifiquement la
   construction de PL/Python lors des étapes d'installation (référez-vous aux
   instructions d'installation pour plus d'informations). Les utilisateurs de
   paquets binaires pourront trouver PL/Python dans un paquet séparé.
  </para>
 </note>

 <sect1 id="plpython-funcs">
  <title>Fonctions PL/Python</title>

  <para>
   Les fonctions PL/Python sont déclarées via la syntaxe standard <xref
   linkend="sql-createfunction" endterm="sql-createfunction-title"/>&nbsp;:
<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-list</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # PL/Python function body
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
   The body of a function is simply a Python script. When the function
   is called, all unnamed arguments are passed as elements to the array
   <varname>args[]</varname> and named arguments as ordinary variables to the
   Python script. The result is returned from the Python code in the usual way,
   with <literal>return</literal> or <literal>yield</literal> (in case of
   a resultset statement).
  </para>

  <para>
   For example, a function to return the greater of two integers can be
   defined as:

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   Le code Python donné comme corps de la définition de fonction est transformé
   en fonction Python. Par exemple, le code ci-dessus devient

<programlisting>def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b</programlisting>

   en supposant que 23456 est l'OID affecté à la fonction par
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   The <productname>PostgreSQL</productname> function parameters are available in
   the global <varname>args</varname> list.  In the
   <function>pymax</function> example, <varname>args[0]</varname> contains
   whatever was passed in as the first argument and
   <varname>args[1]</varname> contains the second argument's value. Alternatively,
   one can use named parameters as shown in the example above. This greatly simplifies
   the reading and writing of <application>PL/Python</application> code.
  </para>

  <para>
   If an SQL null value<indexterm><primary>null value</primary><secondary
   sortas="PL/Python">PL/Python</secondary></indexterm> is passed to a
   function, the argument value will appear as <symbol>None</symbol> in
   Python. The above function definition will return the wrong answer for null
   inputs. We could add <literal>STRICT</literal> to the function definition
   to make <productname>PostgreSQL</productname> do something more reasonable:
   if a null value is passed, the function will not be called at all,
   but will just return a null result automatically. Alternatively,
   we could check for null inputs in the function body:

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a > b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   As shown above, to return an SQL null value from a PL/Python
   function, return the value <symbol>None</symbol>. This can be done whether the
   function is strict or not.
  </para>

  <para>
   Composite-type arguments are passed to the function as Python mappings. The
   element names of the mapping are the attribute names of the composite type.
   If an attribute in the passed row has the null value, it has the value
   <symbol>None</symbol> in the mapping. Here is an example:

<programlisting>
CREATE TABLE employee (
  name text,
  salary integer,
  age integer
);

CREATE FUNCTION overpaid (e employee)
  RETURNS boolean
AS $$
  if e["salary"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salary"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
   There are multiple ways to return row or composite types from a Python
   scripts. In following examples we assume to have:

<programlisting>
CREATE TABLE named_value (
  name   text,
  value  integer
);
</programlisting>
   or
<programlisting>
CREATE TYPE named_value AS (
  name   text,
  value  integer
);
</programlisting>

   <variablelist>
    <varlistentry>
     <term>Sequence types (tuple or list), but not <literal>set</literal> (because
     it is not indexable)</term>
     <listitem>
      <para>
       Returned sequence objects must have the same number of items as
       composite types have fields. Item with index 0 is assigned to the first field
       of the composite type, 1 to second and so on. For example:

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return [ name, value ]
  # or alternatively, as tuple: return ( name, value )
$$ LANGUAGE plpythonu;
</programlisting>

       To return SQL null in any column, insert <symbol>None</symbol> at
       the corresponding position.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Mapping (dictionary)</term>
     <listitem>
      <para>
       Value for a composite type's column is retrieved from the mapping with
       the column name as key. Example:

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return { "name": name, "value": value }
$$ LANGUAGE plpythonu;
</programlisting>

       Additional dictionary key/value pairs are ignored. Missing keys are
       treated as errors, i.e. to return an SQL null value for any column, insert
       <symbol>None</symbol> with the corresponding column name as the key.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Object (any object providing method <literal>__getattr__</literal>)</term>
     <listitem>
      <para>
       Example:

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  class named_value:
    def __init__ (self, n, v):
      self.name = n
      self.value = v
  return named_value(name, value)

  # or simply
  class nv: pass
  nv.name = name
  nv.value = value
  return nv
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Si vous ne fournissez pas de valeur de retour,
   <application>PL/Python</application> renvoie par défaut
   <symbol>None</symbol>. Le module du langage traduit le
   <symbol>None</symbol> de Python en la valeur NULL en SQL.
  </para>

  <para>
   A <application>PL/Python</application> function can also return sets of
   scalar or composite types. There are serveral ways to achieve this because
   the returned object is internally turned into an iterator. For following
   examples, let's assume to have composite type:

<programlisting>
CREATE TYPE greeting AS (
  how text,
  who text
);
</programlisting>
   
   Currently known iterable types are:
   <variablelist>
    <varlistentry>
     <term>Sequence types (tuple, list, set)</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # return tuple containing lists as composite types
  # all other combinations work also
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Iterator (any object providing <symbol>__iter__</symbol> and
      <symbol>next</symbol> methods)</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Generator (<literal>yield</literal>)</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpythonu;
</programlisting>

       <warning>
        <para>
         Currently, due to Python 
         <ulink url="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1483133&amp;group_id=5470&amp;atid=105470">bug #1483133</ulink>,
         some debug versions of Python 2.4
         (configured and compiled with option <literal>--with-pydebug</literal>)
         are known to crash the <productname>PostgreSQL</productname> server.
         Unpatched versions of Fedora 4 contain this bug.
         It does not happen in production version of Python or on patched
         versions of Fedora 4.
        </para>
       </warning>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Whenever new iterable types are added to Python language,
   <application>PL/Python</application> is ready to use it.
  </para>

  <para>
   Le dictionnaire global <varname>SD</varname> est disponible pour stocker des
   données entres les appels de fonctions. Cette variable est une donnée
   statique privée. Le dictionnaire global <varname>GD</varname> est une donnée
   publique disponible pour toutes les fonctions Python à l'intérieur d'une
   session. À utiliser avec précaution.<indexterm><primary>données
   globales</primary><secondary>en PL/Python</secondary></indexterm>
  </para>

  <para>
   Chaque fonction obtient son propre environnement d'exécution dans
   l'interpréteur Python, de façon à ce que les données globales et les
   arguments de fonction provenant de <function>ma_fonction</function> ne soient
   pas disponibles depuis <function>ma_fonction2</function>. L'exception
   concerne les données du dictionnaire <varname>GD</varname> comme indiqué
   ci-dessus.
  </para>
 </sect1>

 <sect1 id="plpython-trigger">
  <title>Fonctions de déclencheurs</title>

  <indexterm zone="plpython-trigger">
   <primary>déclencheur</primary>
   <secondary>en PL/Python</secondary>
  </indexterm>

  <para>
   Quand une fonction est utilisée comme un déclencheur, le dictionnaire
   <literal>TD</literal> contient des valeurs relatives au déclencheur. Les
   lignes du déclencheur sont dans <literal>TD["new"]</literal> et/ou
   <literal>TD["old"]</literal> suivant l'événement ayant lancé le déclencheur.
   <literal>TD["event"]</literal> contient l'événement en tant que chaîne
   (<literal>INSERT</literal>, <literal>UPDATE</literal>,
   <literal>DELETE</literal> ou <literal>UNKNOWN</literal>).
   <literal>TD["when"]</literal> contient soit <literal>BEFORE</literal>, soit
   <literal>AFTER</literal> soit <literal>UNKNOWN</literal>.
   <literal>TD["level"]</literal> contient une valeur parmi <literal>ROW</literal>,
   <literal>STATEMENT</literal> et <literal>UNKNOWN</literal>.
   <literal>TD["name"]</literal> contains the trigger name,
   <literal>TD["table_name"]</literal> contains the name of the table on which the trigger occurred,
   <literal>TD["table_schema"]</literal> contains the schema of the table on which the trigger occurred,
   <literal>TD["name"]</literal> contient le nom du déclencheur et
   <literal>TD["relid"]</literal> l'OID de la table sur lequel le déclencheur a été
   activé. Si la commande <command>CREATE TRIGGER</command> incluait des
   arguments, ils sont disponibles dans les variables de
   <literal>TD["args"][0]</literal> à
   <literal>TD["args"][(<replaceable>n</replaceable>-1)]</literal>.
  </para>

  <para>
   Si <literal>TD["when"]</literal> vaut <literal>BEFORE</literal>, vous pourriez
   renvoyer <literal>None</literal> ou <literal>"OK"</literal> à partir de la
   fonction Python pour indiquer que la ligne n'est pas modifiée,
   <literal>"SKIP"</literal> pour annuler l'événement ou <literal>"MODIFY"</literal> pour
   indiquer que vous avez modifié la ligne.
  </para>
 </sect1>

 <sect1 id="plpython-database">
  <title>Accès à la base de données</title>

  <para>
   Le module du langage PL/Python importe automatiquement un module Python
   appelé <literal>plpy</literal>. Les fonctions et constantes de ce module
   vous sont accessibles dans le code Python via
   <literal>plpy.<replaceable>foo</replaceable></literal>. Actuellement,
   <literal>plpy</literal> implémente les fonctions
   <literal>plpy.debug(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.log(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.info(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.notice(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.warning(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.error(<replaceable>msg</replaceable>)</literal> et
   <literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>.
   <indexterm><primary>elog</primary><secondary>dans PL/Python</secondary></indexterm>
   <function>plpy.error</function> et <literal>plpy.fatal("msg")</literal>
   lèvent une exception Python qui, si non attrapée, se propage à la requête
   appelante causant l'annulation de la transaction ou sous-transaction en
   cours.  <literal>raise plpy.ERROR(<replaceable>msg</replaceable>)</literal> et
   <literal>raise plpy.FATAL(<replaceable>msg</replaceable>)</literal> sont équivalent à
   appeler, respectivement, <function>plpy.error</function> et
   <function>plpy.fatal</function>. Les autres fonctions génèrent uniquement
   des messages de
   niveaux de priorité différents. Que les messages d'une priorité particulière
   soient reportés au client, écrit dans les journaux du serveur ou les deux,
   cette configuration est contrôlée par les variables <xref
   linkend="guc-log-min-messages"/> et <xref linkend="guc-client-min-messages"/>.
   Voir le <xref linkend="runtime-config"/> pour plus d'informations.
  </para>

  <para>
   De plus, le module <literal>plpy</literal> fournit deux fonctions appelées
   <function>execute</function> et <function>prepare</function>. Appeler
   <function>plpy.execute</function> avec une chaîne de requête et un argument
   de limite optionnel fait que la requête est lancée et que le résultat est
   renvoyé dans un objet résultat. L'objet résultat émule une liste ou un objet
   dictionnaire. L'objet résultat est accessible par le numéro de ligne et le
   nom de la colonne. Il a plusieurs méthodes supplémentaires&nbsp;:
   <function>nrows</function> qui renvoie le nombre de lignes retournées par la
   requête et <function>status</function> qui est le code de retour de
   <function>SPI_execute()</function>. L'objet résultat peut être modifié.
  </para>

  <para>
   Par exemple,
<programlisting>rv = plpy.execute("SELECT * FROM ma_table", 5)
</programlisting>
   renvoie cinq lignes de <literal>ma_table</literal>. Si
   <literal>ma_table</literal> dispose d'une colonne
   <literal>ma_colonne</literal>, elle sera accessible avec
<programlisting>foo = rv[i]["ma_colonne"]
</programlisting>
  </para>

  <para>
   <indexterm><primary>préparer une requête</primary><secondary>en
PL/Python</secondary></indexterm>
   La seconde fonction, <function>plpy.prepare</function>, prépare le plan
   d'exécution pour une requête. Il est appelé avec une chaîne contenant la
   requête et une liste des types de paramètres si vous avez des références de
   paramètres dans la requête. Par exemple&nbsp;:
<programlisting>plan = plpy.prepare("SELECT nom FROM mes_utilisateurs WHERE prenom = $1", [
"text" ])
</programlisting>
   <literal>text</literal> est le type de la variable que vous voulez passer via
   <literal>$1</literal>. Après avoir préparé une instruction, vous utilisez la
   fonction <function>plpy.execute</function> pour l'exécuter&nbsp;:
<programlisting>rv = plpy.execute(plan, [ "nom" ], 5)
</programlisting>
   Le troisième argument est la limite et est optionnelle.
  </para>

  <para>
   Lorsque vous préparez un plan en utilisant le module PL/Python, il est
   automatiquement sauvegardé. Lisez la documentation SPI (<xref
   linkend="spi"/>) pour une description de ce que cela signifie. Pour faire
   réellement usage de ceci dans les appels de fonction, vous avez besoin
   d'utiliser un des dictionnaires à stockage permanent
   <literal>SD</literal> ou <literal>GD</literal> (voir le
   <xref linkend="plpython-funcs"/>). Par exemple&nbsp;:
<programlisting>CREATE FUNCTION utiliseplansauvegarde() RETURNS trigger AS $$
    if SD.has_key("plan"):
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # reste de la fonction
$$ LANGUAGE plpythonu;
</programlisting>
  </para>
 </sect1>

<!-- [IGNORE[ NOT CURRENTLY SUPPORTED

 <sect1 id="plpython-trusted">
  <title>Restricted Environment</title>

  <para>
   The current version of <application>PL/Python</application>
   functions as a trusted language only; access to the file system and
   other local resources is disabled.  Specifically,
   <application>PL/Python</application> uses the Python restricted
   execution environment, further restricts it to prevent the use of
   the file <function>open</function> call, and allows only modules from a
   specific list to be imported.  Presently, that list includes:
   <literal>array</literal>, <literal>bisect</literal>, <literal>binascii</literal>,
   <literal>calendar</literal>, <literal>cmath</literal>, <literal>codecs</literal>,
   <literal>errno</literal>, <literal>marshal</literal>, <literal>math</literal>, <literal>md5</literal>,
   <literal>mpz</literal>, <literal>operator</literal>, <literal>pcre</literal>,
   <literal>pickle</literal>, <literal>random</literal>, <literal>re</literal>, <literal>regex</literal>,
   <literal>sre</literal>, <literal>sha</literal>, <literal>string</literal>, <literal>StringIO</literal>,
   <literal>struct</literal>, <literal>time</literal>, <literal>whrandom</literal>, and
   <literal>zlib</literal>.
  </para>
 </sect1>

-->

</chapter>
