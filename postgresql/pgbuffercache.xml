<?xml version="1.0" encoding="UTF-8"?>
<sect1 id="pgbuffercache" xreflabel="pg_buffercache">
 <title>pg_buffercache &mdash; inspect <productname>PostgreSQL</productname>
    buffer cache state</title>

 <indexterm zone="pgbuffercache">
  <primary>pg_buffercache</primary>
 </indexterm>

 <para>
  Le module <filename>pg_buffercache</filename> fournit un moyen pour
  examiner ce qui se passe dans le cache partagé en temps réel.
 </para>

 <indexterm>
  <primary>pg_buffercache_pages</primary>
 </indexterm>

 <indexterm>
  <primary>pg_buffercache_summary</primary>
 </indexterm>

 <para>
  This module provides the <function>pg_buffercache_pages()</function>
  function (wrapped in the <structname>pg_buffercache</structname> view),
  the <function>pg_buffercache_summary()</function> function, and the
  <function>pg_buffercache_usage_counts()</function> function.
 </para>

 <para>
  The <function>pg_buffercache_pages()</function> function returns a set of
  records, each row describing the state of one shared buffer entry. The
  <structname>pg_buffercache</structname> view wraps the function for
  convenient use.
 </para>

 <para>
  The <function>pg_buffercache_summary()</function> function returns a single
  row summarizing the state of the shared buffer cache.
 </para>

 <para>
  The <function>pg_buffercache_usage_counts()</function> function returns a set
  of records, each row describing the number of buffers with a given usage
  count.
 </para>

 <para>
  Par défaut, l'utilisation est restreinte aux superutilisateurs et aux rôles
  disposant des attributs du rôle <literal>pg_monitor</literal>. L'accès peut
  être accordé à d'autres rôle en utilisant <command>GRANT</command>.
 </para>

 <sect2 id="pgbuffercache-pg-buffercache">
  <title>La vue <structname>pg_buffercache</structname></title>

  <para>
   Voici la définition des colonnes exposées par la vue affichée dans <xref
   linkend="pgbuffercache-columns"/>&nbsp;:
  </para>

  <table id="pgbuffercache-columns">
   <title>Colonnes de <structname>pg_buffercache</structname></title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Type de la colonne
       </para>
       <para>
        Description
       </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>bufferid</structfield> <type>integer</type>
       </para>
       <para>
        ID, qui va de 1 à <varname>shared_buffers</varname>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relfilenode</structfield> <type>oid</type>
        (references <link linkend="catalog-pg-class"><structname>pg_class</structname></link>.<structfield>relfilenode</structfield>)
       </para>
       <para>
        Numéro filenode de la relation
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>reltablespace</structfield> <type>oid</type>
        (references <link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID du tablespace de la relation
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>reldatabase</structfield> <type>oid</type>
        (references <link linkend="catalog-pg-database"><structname>pg_database</structname></link>.<structfield>oid</structfield>)
       </para>
       <para>
        OID de la base de données de la relation
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relforknumber</structfield> <type>smallint</type>
       </para>
       <para>
        Numéro du fork dans la relation&nbsp;; voir
        <filename>common/relpath.h</filename>
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>relblocknumber</structfield> <type>bigint</type>
       </para>
       <para>
        Numéro de page dans la relation
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>isdirty</structfield> <type>boolean</type>
       </para>
       <para>
        Page modifiée&nbsp;?
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>usagecount</structfield> <type>smallint</type>
       </para>
       <para>
        Compteur d'accès clock-sweep
       </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>pinning_backends</structfield> <type>integer</type>
       </para>
       <para>
        Nombre de processus serveur en accès sur ce bloc
       </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Il y a une ligne pour chaque tampon dans le cache partagé. Les tampons
   inutilisés sont affichés avec des champs NULL sauf pour
   <structfield>bufferid</structfield>. Les catalogues systèmes partagés sont
   affichés comme appartenant à la base de données zéro.
  </para>

  <para>
   Comme le cache est partagé par toutes les bases de données, il y aura
   des pages de relations n'appartenant pas à la base de données courante.
   Cela signifie qu'il pourrait y avoir des lignes sans correspondance dans
   <structname>pg_class</structname>, ou qu'il pourrait y avoir des jointures
   incorrectes. Si vous essayez une jointure avec
   <structname>pg_class</structname>, une bonne idée est de restreindre la
   jointure aux lignes ayant un <structfield>reldatabase</structfield> égal
   à l'OID de la base de données actuelle ou à zéro.
  </para>

  <para>
   Comme des verrous du gestionnaire de tampons ne sont pas acquis pour copier
   les données d'état du tampon que la vue affichera, accéder à la vue
   <structname>pg_buffercache</structname> a moins d'impact sur l'activité
   normale du tampon mais il ne fournit pas un ensemble cohérent de résultats
   sur tous les tampons. Néanmoins, nous nous assurons que l'information de
   chaque tampon est cohérent avec lui-même.
  </para>
 </sect2>

 <sect2 id="pgbuffercache-summary">
  <title>The <function>pg_buffercache_summary()</function> Function</title>

  <para>
   The definitions of the columns exposed by the function are shown in <xref linkend="pgbuffercache-summary-columns"/>.
  </para>

  <table id="pgbuffercache-summary-columns">
   <title><function>pg_buffercache_summary()</function> Output Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_used</structfield> <type>int4</type>
      </para>
      <para>
       Number of used shared buffers
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_unused</structfield> <type>int4</type>
      </para>
      <para>
       Number of unused shared buffers
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_dirty</structfield> <type>int4</type>
      </para>
      <para>
       Number of dirty shared buffers
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_pinned</structfield> <type>int4</type>
      </para>
      <para>
       Number of pinned shared buffers
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usagecount_avg</structfield> <type>float8</type>
      </para>
      <para>
       Average usage count of used shared buffers
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The <function>pg_buffercache_summary()</function> function returns a
   single row summarizing the state of all shared buffers. Similar and more
   detailed information is provided by the
   <structname>pg_buffercache</structname> view, but
   <function>pg_buffercache_summary()</function> is significantly cheaper.
  </para>

  <para>
   Like the <structname>pg_buffercache</structname> view,
   <function>pg_buffercache_summary()</function> does not acquire buffer
   manager locks. Therefore concurrent activity can lead to minor inaccuracies
   in the result.
  </para>
 </sect2>

 <sect2 id="pgbuffercache-usage-counts">
  <title>The <function>pg_buffercache_usage_counts()</function> Function</title>

  <para>
   The definitions of the columns exposed by the function are shown in
   <xref linkend="pgbuffercache_usage_counts-columns"/>.
  </para>

  <table id="pgbuffercache_usage_counts-columns">
   <title><function>pg_buffercache_usage_counts()</function> Output Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usage_count</structfield> <type>int4</type>
      </para>
      <para>
       A possible buffer usage count
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers</structfield> <type>int4</type>
      </para>
      <para>
       Number of buffers with the usage count
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dirty</structfield> <type>int4</type>
      </para>
      <para>
       Number of dirty buffers with the usage count
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pinned</structfield> <type>int4</type>
      </para>
      <para>
       Number of pinned buffers with the usage count
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The <function>pg_buffercache_usage_counts()</function> function returns a
   set of rows summarizing the states of all shared buffers, aggregated over
   the possible usage count values.  Similar and more detailed information is
   provided by the <structname>pg_buffercache</structname> view, but
   <function>pg_buffercache_usage_counts()</function> is significantly cheaper.
  </para>

  <para>
   Like the <structname>pg_buffercache</structname> view,
   <function>pg_buffercache_usage_counts()</function> does not acquire buffer
   manager locks. Therefore concurrent activity can lead to minor inaccuracies
   in the result.
  </para>
 </sect2>

 <sect2 id="pgbuffercache-sample-output">
  <title>Affichage en sortie</title>

  <screen>
  regression=# SELECT n.nspname, c.relname, count(*) AS buffers
               FROM pg_buffercache b JOIN pg_class c
               ON b.relfilenode = pg_relation_filenode(c.oid) AND
                  b.reldatabase IN (0, (SELECT oid FROM pg_database
                                        WHERE datname = current_database()))
               JOIN pg_namespace n ON n.oid = c.relnamespace
               GROUP BY n.nspname, c.relname
               ORDER BY 3 DESC
               LIMIT 10;

  nspname   |        relname         | buffers
------------+------------------------+---------
 public     | delete_test_table      |     593
 public     | delete_test_table_pkey |     494
 pg_catalog | pg_attribute           |     472
 public     | quad_poly_tbl          |     353
 public     | tenk2                  |     349
 public     | tenk1                  |     349
 public     | gin_test_idx           |     306
 pg_catalog | pg_largeobject         |     206
 public     | gin_test_tbl           |     188
 public     | spgist_text_tbl        |     182
  (10 rows)

regression=# SELECT * FROM pg_buffercache_summary();
 buffers_used | buffers_unused | buffers_dirty | buffers_pinned | usagecount_avg
--------------+----------------+---------------+----------------+----------------
          248 |        2096904 |            39 |              0 |       3.141129
(1 row)


regression=# SELECT * FROM pg_buffercache_usage_counts();
 usage_count | buffers | dirty | pinned
-------------+---------+-------+--------
           0 |   14650 |     0 |      0
           1 |    1436 |   671 |      0
           2 |     102 |    88 |      0
           3 |      23 |    21 |      0
           4 |       9 |     7 |      0
           5 |     164 |   106 |      0
(6 rows)
  </screen>
 </sect2>

 <sect2 id="pgbuffercache-authors">
  <title>Auteurs</title>

  <para>
   Mark Kirkwood <email>markir@paradise.net.nz</email>
  </para>

  <para>
   Suggestions de conception&nbsp;: Neil Conway <email>neilc@samurai.com</email>
  </para>

  <para>
   Conseils pour le débogage&nbsp;: Tom Lane <email>tgl@sss.pgh.pa.us</email>
  </para>
 </sect2>

</sect1>
