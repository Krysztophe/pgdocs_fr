<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="plpython">
 <title>PL/Python - Langage de procédures Python</title>

 <indexterm zone="plpython"><primary>PL/Python</primary></indexterm>
 <indexterm zone="plpython"><primary>Python</primary></indexterm>

 <para>
  Le langage de procédures <application>PL/Python</application> permet
  l'écriture de fonctions <productname>PostgreSQL</productname> avec le
  <ulink url="http://www.python.org">langage Python</ulink> (mais voir aussi
  <xref linkend="plpython-python23"/>).
 </para>

 <para>
  Pour installer PL/Python dans une base de données particulières, utilisez
  <literal>createlang plpythonu <replaceable>nom_base</replaceable></literal>.
 </para>

  <tip>
   <para>
    Si un langage est installé dans <literal>template1</literal>, toutes les bases
    nouvellement créées se verront installées ce langage automatiquement.
   </para>
  </tip>

 <para>
  Depuis <productname>PostgreSQL</productname> 7.4, PL/Python est seulement
  disponible en tant que langage <quote>sans confiance</quote> (ceci signifiant
  qu'il n'offre aucun moyen de restreindre ce que les utilisateurs en font). Il
  a donc été renommé en <literal>plpythonu</literal>. La variante de confiance
  <literal>plpython</literal> pourrait être de nouveau disponible dans le futur, si un
  nouveau mécanisme sécurisé d'exécution est développé dans Python. Le codeur
  d'une fonction dans PL/Python sans confiance doit faire attention à ce que
  cette fonction ne puisse pas être utilisée pour réaliser quelque chose qui
  n'est pas prévue car il sera possible de faire tout ce que peut faire un
  utilisateur connecté en tant qu'administrateur de la base de données. Seuls
  les superutilisateurs peuvent créer des fonctions dans des langages sans
  confiance comme <literal>plpythonu</literal>.
 </para>

 <note>
  <para>
   Les utilisateurs des paquets sources doivent activer spécifiquement la
   construction de PL/Python lors des étapes d'installation (référez-vous aux
   instructions d'installation pour plus d'informations). Les utilisateurs de
   paquets binaires pourront trouver PL/Python dans un paquet séparé.
  </para>
 </note>

 <sect1 id="plpython-python23">
  <title>Python 2 et Python 3</title>

  <para>
   PL/Python accepte à la fois les versions 2 et 3 de Python. (Les instructions
   d'installation de PostgreSQL peuvent contenir des informations plus précises
   sur les versions mineures précisément supportées de Python.) Comme les
   variantes Python 2 et Python 3 sont incompatibles pour certaines parties
   très importantes, le schéma de nommage et de transition suivant est utilisé
   par PL/Python pour éviter de les mixer&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Le langage PostgreSQL nommé <literal>plpython2u</literal> implémente
      PL/Python sur la variante Python 2 du langage.
     </para>
    </listitem>

    <listitem>
     <para>
      Le langage PostgreSQL nommé <literal>plpython3u</literal> implémente
      PL/Python sur la variante Python 3 du langage.
     </para>
    </listitem>

    <listitem>
     <para>
      Le langage nommé <literal>plpythonu</literal> implémente PL/Python
      suivant la variante par défaut du langage Python, qui est actuellement
      Python 2. (Cette valeur par défaut est indépendante de ce que toute
      installations locales de Python pourrait considérer comme la valeur
      par <quote>défaut</quote>, par exemplece que pourrait être
      <filename>/usr/bin/python</filename>.) La valeur par défaut sera
      probablement changée avec Python 3 dans une prochaine version de
      PostgreSQL, suivant les progrès de la migration à Python 3 dans la
      communauté Python.
     </para>
    </listitem>
   </itemizedlist>

   Cela dépend de la configuration lors de la compilation ou des paquets
   installés si PL/Python pour Python 2 ou Python 3 ou les deux sont
   disponibles.
  </para>

  <tip>
   <para>
    La variante construite dépend de la version de Python trouvée pendant
    l'installation ou de la version sélectionnée explicitement en configurant
    la variable d'environnement <envar>PYTHON</envar>&nbsp;; voir <xref
    linkend="install-procedure"/>. Pour que les deux variantes de PL/Python
    soient disponibles sur une installation, le répertoire des sources doit
    être configuré et construit deux fois.
   </para>
  </tip>

  <para>
   Ceci a pour résultat la stratégie suivante d'utilisation et de
   migration&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Les utilisateurs existants et ceux qui ne sont pas actuellement
      intéressés par Python 3 utilisent le nom <literal>plpythonu</literal>
      et n'ont rien à changer pour l'instant. Il est recommandé de
      <quote>s'assurer</quote> graduellement de migrer le code vers
      Python 2.6/2.7 pour simplifier une migration éventuelle vers Python 3.
     </para>

     <para>
      En pratique, beaucoup de fonctions PL/Python seront migrées à Python 3
      avec peu, voire par du tout, de modifications.
     </para>
    </listitem>

    <listitem>
     <para>
      Les utilisateurs sachant d'avance qu'ils ont du code reposant massivement
      sur Python 2 et ne planifient pas de changer peuvent utiliser le nom
      <literal>plpython2u</literal>. Cela continuera de fonctionner, y compris
      dans un futur lointain, jusqu'à ce que le support de Python 2 soit
      complètement supprimée de PostgreSQL.
     </para>
    </listitem>

    <listitem>
     <para>
      Les utilisateurs qui veulent utiliser Python 3 peuvent utiliser le nom
      <literal>plpython3u</literal>, qui continuera à fonctionner en permanence
      avec les standards actuels. Dans le futur, quand Python 3 deviendra la
      version par défaut du langage, ils pourront supprimer le chiffre
      <quote>3</quote>, principalement pour des raisons esthétiques.
     </para>
    </listitem>

    <listitem>
     <para>
      Les intrépides qui veulent construire un système d'exploitation utilisant
      seulement Python-3, peuvent modifier les scripts de compilation pour
      rendre <literal>plpythonu</literal> équivalent à
      <literal>plpython3u</literal>, en gardant en tête que cela rend leur
      installation incompatible avec la majorité de ce qui existe dans ce
      monde.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Voir aussi le document <ulink
   url="http://docs.python.org/py3k/whatsnew/3.0.html">What's New In Python
   3.0</ulink> pour plus d'informations sur le portage vers Python 3.
  </para>

  <para>
   Il n'est pas permis d'utiliser PL/Python basé sur Python 2 et PL/Python
   basé sur Python 3 dans la même session car les symbôles dans les modules
   dynamiques entreraient en conflit, ce qui pourrait résulter en des arrêts
   brutaux du processus serveur PostgreSQL. Une vérification est ajoutée pour
   empêcher ce mélange de versions majeures Python dans une même sessio. Cette
   vérification aura pour effet d'annuler la session si une différence est
   détectée. Néanmoins, il est possible d'utiliser les deux variantes de
   PL/Python dans une même base de données à condition que ce soit dans des
   sessions séparées.
  </para>
 </sect1>

 <sect1 id="plpython-funcs">
  <title>Fonctions PL/Python</title>

  <para>
   Les fonctions PL/Python sont déclarées via la syntaxe standard <xref
   linkend="sql-createfunction"/>&nbsp;:
<programlisting>CREATE FUNCTION <replaceable>nom_fonction</replaceable> (<replaceable>liste-arguments</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # corps de la fonction PL/Python
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
   Le corps d'une fonction est tout simplement un script Python. Quand la
   fonction est appelée, ses arguments sont passés au script Python comme des
   éléments de la liste <varname>args</varname>&nbsp;; les arguments nommés
   sont en plus passés comme des variables ordinaires. L'utilisation des
   arguments nommés est beaucoup plus lisible.  Le résultat est renvoyé
   par le code Python de la façon habituelle, avec <literal>return</literal> ou
   <literal>yield</literal> (dans le cas d'une instruction avec un ensemble
   de résultats). Si vous ne fournissez pas une valeur de retour, Python
   renvoie la valeur par défaut <symbol>None</symbol>.
   <application>PL/Python</application> traduit la valeur <symbol>None</symbol>
   de Python comme une valeur NULL SQL.
  </para>

  <para>
   Par exemple, une fonction renvoyant le plus grand de deux entiers peut
   être définie ainsi&nbsp;:

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   Le code Python donné comme corps de la définition de fonction est transformé
   en fonction Python. Par exemple, le code ci-dessus devient&nbsp;:

<programlisting>def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b</programlisting>

   en supposant que 23456 est l'OID affecté à la fonction par
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   Les arguments sont définis comme des variables globales. Conséquence subtile 
   des règles sur la portée de variables dans Python, il n'est pas possible de 
   réaffecter une variable à l'intérieur d'une fonction en conservant son nom, 
   sauf si elle est préalablement déclarée comme globale à l'intérieur du bloc.
   Ainsi, l'exemple suivant ne fonctionnera pas&nbsp;:
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  x = x.strip()  # error
  return x
$$ LANGUAGE plpythonu;
</programlisting>
   car affecter la variable <varname>x</varname> la transforme en variable 
   locale pour ce bloc et que, par conséquent, la variable <varname>x</varname> 
   de l'expression de droite fait référence à une variable locale 
   <varname>x</varname> non encore définie, et non pas au paramètre de la 
   fonction PL/Python. L'utilisation du mot-clé <literal>global</literal> permet 
   de résoudre le problème&nbsp;:
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  global x
  x = x.strip()  # ok now
  return x
$$ LANGUAGE plpythonu;
</programlisting>
   Cependant, il vaut mieux ne pas trop s'appuyer sur ce détail d'implémentation 
   de PL/Python. Il est préférable de traiter les paramètres de fonction 
   comme étant en lecture seule.
  </para>
 </sect1>

 <sect1 id="plpython-data">
  <title>Valeur des données avec PL/Python</title>
  <para>De manière générale, le but de PL/Python est de fournir une relation 
  <quote>naturelle</quote> entre PostgreSQL et le monde Python. Ces règles 
  relationelles sont décrites ci-dessous.
  </para>

  <sect2>
   <title>Type de données</title>
   <para>
    Les paramètres de fonctions sont convertis de leur type PostgreSQL vers un 
    type correspondant en Python&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Le type <type>boolean</type> PostgreSQL est converti en
       <type>bool</type> Python.
      </para>
     </listitem>

     <listitem>
      <para>
       Les <type>smallint</type> et <type>int</type> de PostgreSQL sont 
       convertis en <type>int</type> Python.
       Le <type>bigint</type> PostgreSQL est converti en <type>long</type> pour 
       Python 2 et en <type>int</type> pour Python 3.
      </para>
     </listitem>

     <listitem>
      <para>
       Les <type>real</type>, <type>double</type> et <type>numeric</type> de 
       PostgreSQL sont convertis en <type>float</type> Python. Notez que pour 
       <type>numeric</type>, cela entraine une perte d'information et peut 
       aboutir à des résulats incorrects. Cela devrait être corrigé dans une 
       future version.
      </para>
     </listitem>

     <listitem>
      <para>
       Le <type>bytea</type> PostgreSQL est converti en <type>str</type>
       pour Python 2 et en <type>bytes</type> pour Python 3. Avec Python 2, la 
       chaîne devrait être traitée comme une séquence d'octets sans encodage.
      </para>
     </listitem>

     <listitem>
      <para>
       Tous les autres types de données, y compris les chaînes de caractères 
       PostgreSQL, sont convertis en <type>str</type> Python. En Python 2, ces 
       chaînes auront le même encodage de caractères que le serveur. En 
       Python 3, ce seront des chaînes Unicode comme les autres.
      </para>
     </listitem>

     <listitem>
      <para>
       Pour les données non scalaires, voir ci-dessous.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Les valeurs renvoyées par les fonctions sont converties en types de retour PostgreSQL comme suit:
    <itemizedlist>
     <listitem>
      <para>
       Quand le type de la valeur PostgreSQL renvoyée est <type>boolean</type>, 
       la valeur de retrour sera évaluée en fonction des règles 
       <emphasis>Python</emphasis>. Ainsi, les 0 et les chaines vides sont 
       fausses, mais la valeur <literal>'f'</literal> est vraie.
      </para>
     </listitem>

     <listitem>
      <para>
       Quand le type de la valeur PostgreSQL renvoyée est <type>bytea</type>, la 
       valeur de retour sera convertie en chaine de caractères (Python 2) ou en 
       octets (Python 3) en utilisant les mécanismes Python correspondants, le 
       résultat étant ensuite converti en <type>bytea</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       Pour tous les autres types de retrour PostgreSQL, la valeur renvoyée par 
       Python est convertie en chaine de caractères en utilisant la méthode 
       Python <literal>str</literal>, et et le résultat est transmis à la 
       fonction d'entrée du type de données PostgreSQL.
      </para>

      <para>
       Les chaines de caractères en Python 2 doivent être transmises dans le 
       même encodage que celui du serveur PostgreSQL. Les chaines invalides dans
       l'encodage du serveur entraineront la levée d'une erreur, mais toutes les 
       erreurs d'encodage ne sont pas detectées, ce qui peut aboutir à une 
       corruption des données lorsque ces règles ne sont pas respéctée. Les 
       chaines  Unicode sont automatiquement converties dans le bon encodage, 
       il est donc plus prudent de les utiliser. Dans Python 3, toutes les 
       chaines sont en Unicode.
      </para>
     </listitem>

     <listitem>
      <para>
       Pour les données non scalaires, voire ci dessous.
      </para>
     </listitem>
    </itemizedlist>

    Notez que les erreurs logiques entre le type de retour déclaré dans 
    PostgreSQL et le type de l'objet Python renvoyé ne sont pas détectées. La 
    valeur sera convertie dans tous les cas.
   </para>

   <tip>
    <para>
     Les fonctions <application>PL/Python</application> ne peuvent renvoyer les 
     types <type>RECORD</type> ou <type>SETOF RECORD</type>. Une solution de 
     contournement est d'écrire une fonction <application>PL/pgSQL</application>
     qui crée une table temporaire, d'appeler la fonction en 
     <application>PL/Python</application> pour remplir cette table puis de 
     laisser à la fonction <application>PL/pgSQL</application>  le soin de 
     renvoyer le type générique <type>RECORD</type> de cette table temporaire.
    </para>
   </tip>
  </sect2>

  <sect2>
   <title>Null, None</title>

  <para>
   Si une valeur SQL NULL<indexterm><primary>valeur NULL</primary><secondary
   sortas="PL/Python">PL/Python</secondary></indexterm> est passée à une fonction,
   la valeur de l'argument apparaîtra comme <symbol>None</symbol> au niveau de
   Python. Par exemple, la définition de la fonction
   <function>pymax</function> montrée dans <xref linkend="plpython-funcs"/>
   renverra la mauvaise réponse pour les valeurs NULL.
   Nous pouvons ajouter <literal>STRICT</literal> à la
   définition de la fonction pour faire en sorte que
   <productname>PostgreSQL</productname> fasse quelque-chose de plus
   raisonnable&nbsp;: si une valeur NULL est passée, la fonction ne sera pas
   appelée du tout mais renverra juste un résultat NULL automatiquement.
   Sinon, vous pouver vérifier les entrées NULL dans le corps de la
   fonction&nbsp;:

<programlisting>CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

   Comme montré ci-dessus, pour renvoyer une valeur SQL NULL à partir d'une
   fonction PL/Python, renvoyez la valeur <symbol>None</symbol>. Ceci peut
   se faire que la fonction soit stricte ou non.
  </para>

  </sect2>

  <sect2 id="plpython-arrays">
   <title>Tableaux, Listes</title>
  <para>
   Les valeurs de type tableaux SQL sont passées via PL/Python comme des listes
   Python. Pour renvoyer une valeur de type tableau SQL par une fonction
   PL/Python, renvoyez une séquence Python, par exemple une liste ou un
   tuple&nbsp;:

<programlisting>
CREATE FUNCTION return_arr()
  RETURNS int[]
AS $$
return (1, 2, 3, 4, 5)
$$ LANGUAGE plpythonu;

SELECT return_arr();
 return_arr  
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>

   Notez que, avec Python, les chaînes sont des séquences, ce qui peut avoir
   des effets indésirables qui peuvent être familiers aux codeurs Python&nbsp;:

<programlisting>
CREATE FUNCTION return_str_arr()
  RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpythonu;

SELECT return_str_arr();
 return_str_arr
----------------
 {h,e,l,l,o}
(1 row)
</programlisting>
  </para>
  </sect2>

  <sect2>
   <title>Types composites</title>
  <para>
   Les arguments de type composite sont passés à la fonction via une
   correspondance Python. Les noms d'élément de la correspondance sont les noms
   d'attribut du type composite. Si un attribut a une valeur NULL dans la ligne
   traitée; il a la valeur NULL dans sa correspondance. Voici un exemple&nbsp;:

<programlisting>CREATE TABLE employe (
  nom text,
  salaire integer,
  age integer
);

CREATE FUNCTION trop_paye (e employe)
  RETURNS boolean
AS $$
  if e["salaire"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salaire"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
   Il existe plusieurs façon de renvoyer une ligne ou des types composites à
   partir d'une fonction Python. Les exemples suivants supposent que nous
   avons&nbsp;:

<programlisting>CREATE TABLE valeur_nommee (
  nom   text,
  valeur  integer
);
</programlisting>
   ou
<programlisting>CREATE TYPE valeur_nommee AS (
  nom   text,
  valeur  integer
);
</programlisting>

   Une valeur composite peut être renvoyé comme&nbsp;:
   <variablelist>
    <varlistentry>
     <term>Un type séquence (ligne ou liste), mais pas
       un ensemble parce que ce n'est pas indexable</term>
     <listitem>
      <para>
       Les objets séquences renvoyés doivent avoir le même nombre d'éléments que
       le type composite a de champs. L'élément d'index 0 est affecté au
       premier champ du type composite, 1 au second et ainsi de suite. Par
       exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  return [ nom, valeur ]
  # ou autrement, en tant que ligne : return ( nom, valeur )
$$ LANGUAGE plpythonu;
</programlisting>

       Pour renvoyer NULL dans une colonne, insérez <symbol>None</symbol> à la
       position correspondante.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Correspondance (dictionnaire)</term>
     <listitem>
      <para>
       La valeur de chaque colonne du type résultat est récupérée à partir de la
       correspondance avec le nom de colonne comme clé. Exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  return { "nom": nom, "valeur": valeur }
$$ LANGUAGE plpythonu;
</programlisting>

       Des paires clés/valeurs supplémentaires du dictionnaire sont ignorées.
       Les clés manquantes sont traitées comme des erreurs.
       Pour renvoyer NULL comme une colonne, insérez <symbol>None</symbol>
       avec le nom de la colonne correspondante comme clé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Objet (tout objet fournissant la méthode <literal>__getattr__</literal>)</term>
     <listitem>
      <para>
       Ceci fonctionne de la même façon qu'une correspondance.
       Exemple&nbsp;:

<programlisting>CREATE FUNCTION cree_paire (nom text, valeur integer)
  RETURNS valeur_nommee
AS $$
  class valeur_nommee:
    def __init__ (self, n, v):
      self.nom = n
      self.valeur = v
  return valeur_nommee(nom, valeur)

  # ou simplement
  class nv: pass
  nv.nom = nom
  nv.valeur = valeur
  return nv
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  </sect2>

  <sect2>
   <title>Set-Returning Functions</title>

  <para>
   Une fonction <application>PL/Python</application> peut aussi renvoyer des
   ensembles scalaires ou des types composites. Il existe plusieurs façon de
   faire ceci parce que l'objet renvoyé est transformé en interne en itérateur.
   Les exemples suivants supposent que nous avons le type composite&nbsp;:

<programlisting>CREATE TYPE greeting AS (
  how text,
  who text
);
</programlisting>
   
   Un résultat ensemble peut être renvoyé à partir de&nbsp;:
   <variablelist>
    <varlistentry>
     <term>Un type séquence (ligne, liste, ensemble)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # renvoie la ligne contenant les listes en tant que types composites
  # toutes les autres combinaisons fonctionnent aussi
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>L'itérateur (tout objet fournissant les méthodes <symbol>__iter__</symbol>
      et <symbol>next</symbol>)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Le générateur (<literal>yield</literal>)</term>
     <listitem>
      <para>
<programlisting>CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpythonu;
</programlisting>

       <warning>
        <para>
         À cause du
         <ulink url="http://bugs.python.org/issue1483133">bogue #1483133</ulink> de Python,
         certaines versions de débogage de Python 2.4
         (configuré et compilé avec l'option <literal>--with-pydebug</literal>)
         sont connues pour arrêter brutalement le serveur
	 <productname>PostgreSQL</productname> lors de l'utilisation d'un
	 itérateur pour renvoyer un résultat ensemble. Les versions non corrigées de
         Fedora 4 contiennent ce bogue. Cela n'arrive pas dans les versions de
         production de Python et sur les versions corrigées de Fedora 4.
        </para>
       </warning>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  </sect2>
 </sect1>

 <sect1 id="plpython-sharing">
  <title>Sharing Data</title>
  
  <para>
   Le dictionnaire global <varname>SD</varname> est disponible pour stocker des
   données entres les appels de fonctions. Cette variable est une donnée
   statique privée. Le dictionnaire global <varname>GD</varname> est une donnée
   publique disponible pour toutes les fonctions Python à l'intérieur d'une
   session. À utiliser avec précaution.<indexterm><primary>données
   globales</primary><secondary>en PL/Python</secondary></indexterm>
  </para>

  <para>
   Chaque fonction obtient son propre environnement d'exécution dans
   l'interpréteur Python, de façon à ce que les données globales et les
   arguments de fonction provenant de <function>ma_fonction</function> ne soient
   pas disponibles depuis <function>ma_fonction2</function>. L'exception
   concerne les données du dictionnaire <varname>GD</varname> comme indiqué
   ci-dessus.
  </para>
 </sect1>

 <sect1 id="plpython-do">
  <title>Blocs de code anonymes</title>

  <para>
   PL/Python accepte aussi les blocs de code anonymes appelés avec
   l'instruction <xref linkend="sql-do"/>&nbsp;:

<programlisting>
DO $$
    # Code PL/Python
$$ LANGUAGE plpythonu;
</programlisting>

   Un bloc de code anonyme ne reçoit aucun argument et, quelque soit la valeur
   renvoyée, elle est ignorée. Sinon, ce bloc se comporte exactement comme
   n'importe quelle fonction.
  </para>
 </sect1>

 <sect1 id="plpython-trigger">
  <title>Fonctions de déclencheurs</title>

  <indexterm zone="plpython-trigger">
   <primary>déclencheur</primary>
   <secondary>en PL/Python</secondary>
  </indexterm>

  <para>
   Quand une fonction est utilisée par un trigger, le dictionnaire
   <literal>TD</literal> contient les valeurs relatives au trigger&nbsp;:
   <variablelist>
    <varlistentry>
     <term><literal>TD["event"]</literal></term>
     <listitem>
      <para>
       contient l'événement sous la forme d'une chaîne&nbsp;:
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>
       ou <literal>UNKNOWN</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["when"]</literal></term>
     <listitem>
      <para>
       contient une chaîne valant soit <literal>BEFORE</literal>, soit
       <literal>AFTER</literal> soit <literal>UNKNOWN</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["level"]</literal></term>
     <listitem>
      <para>
       contient une chaîne valant soit <literal>ROW</literal> soit
       <literal>STATEMENT</literal> soit <literal>UNKNOWN</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["new"]</literal></term>
     <term><literal>TD["old"]</literal></term>
     <listitem>
      <para>
       pour un trigger au niveau ligne, ces champs contiennent les lignes
       du trigger, l'ancienne version et la nouvelle version&nbsp;; les deux
       champs ne sont pas forcément disponibles, ceci dépendant de l'événement
       qui a déclenché le trigger
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["name"]</literal></term>
     <listitem>
      <para>
       contient le nom du trigger.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_name"]</literal></term>
     <listitem>
      <para>
       contient le nom de la table sur laquelle le trigger a été déclenché
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_schema"]</literal></term>
     <listitem>
      <para>
       contient le schéma de la table sur laquelle le trigger a été déclenché
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["relid"]</literal></term>
     <listitem>
      <para>
       contient l'OID de la table sur laquelle le trigger a été déclenché
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["args"]</literal></term>
     <listitem>
      <para>
       si la commande <command>CREATE TRIGGER</command> comprend des arguments,
       ils sont disponibles dans les variables allant de
       <literal>TD["args"][0]</literal> à
       <literal>TD["args"][<replaceable>n</replaceable>-1]</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Si <literal>TD["when"]</literal> vaut <literal>BEFORE</literal> et si
   <literal>TD["level"]</literal> vaut <literal>ROW</literal>, vous pourriez
   renvoyer <literal>None</literal> ou <literal>"OK"</literal> à partir de la
   fonction Python pour indiquer que la ligne n'est pas modifiée,
   <literal>"SKIP"</literal> pour annuler l'événement ou <literal>"MODIFY"</literal>
   pour indiquer que vous avez modifié la ligne. Sinon la valeur de retour est
   ignorée.
  </para>
 </sect1>

 <sect1 id="plpython-database">
  <title>Accès à la base de données</title>

  <para>
   Le module du langage PL/Python importe automatiquement un module Python
   appelé <literal>plpy</literal>. Les fonctions et constantes de ce module
   vous sont accessibles dans le code Python via
   <literal>plpy.<replaceable>foo</replaceable></literal>. 
  </para>

  <para>
   Le module <literal>plpy</literal> propose deux fonctions appelées
   <function>execute</function> et <function>prepare</function>. Appeler
   <function>plpy.execute</function> avec une requête sous forme de chaîne
   de caractères et un argument optionnel de limite fait que la requête est
   exécutée et le résultat renvoyé dans un objet résultat. Cet objet émule un
   objet liste ou dictionnaire. L'accès aux résultats se fait par numéro de
   ligne et nom de colonne. Deux méthodes supplémentaires sont
   utilisables&nbsp;: <function>nrows</function> qui renvoit le nombre de
   lignes renvoyées par la requête, et <function>status</function> qui
   correspond à la valeur de retour de <function>SPI_execute()</function>.
   L'objet résultat est modifiable.
  </para>

  <para>
   Par exemple&nbsp;:
<programlisting>
rv = plpy.execute("SELECT * FROM ma_table", 5)
</programlisting>
   renvoit jusqu'à cinq lignes de <literal>ma_table</literal>. Si
   <literal>ma_table</literal> a une colonne <literal>ma_colonne</literal>,
   son contenu peut être récupéré ainsi&nbsp;:
<programlisting>
foo = rv[i]["ma_colonne"]
</programlisting>
  </para>

  <para>
   <indexterm><primary>préparer une requête</primary><secondary>en
   PL/Python</secondary></indexterm>
   la seconde fonction, <function>plpy.prepare</function>, prépare le plan
   d'exécution d'une requête. Il utilise comme arguments une chaîne de
   caractères pour la requête et une liste des types de paramètres si des
   références de paramètres sont indiquées dans la requête. Par exemple&nbsp;:
<programlisting>
plan = plpy.prepare("SELECT nom FROM mes_utilisateurs WHERE prenom = $1", [ "text" ])
</programlisting>
   <literal>text</literal> est le type de la variable que vous devrez passer
   pour <literal>$1</literal>. Après avoir préparé une requête, vous devez
   utiliser la fonction <function>plpy.execute</function> pour
   l'exécuter&nbsp;:
<programlisting>
rv = plpy.execute(plan, [ "nom" ], 5)
</programlisting>
   Le troisième argument, optionnel, est la limite.
  </para>

  <para>
   Les paramètres de requêtes et les champs de résultats sont convertis entre
   PostgreSQL et les types de données Python comme indiqué dans <xref
   linkend="plpython-data"/>. L'exception est que les types composites ne sont
   pas actuellement supportés&nbsp;: ils sont rejetés dans le cas des
   paramètres de requête et convertis en chaînes de caractères quand ils
   apparaissent dans le résultat d'une requête. Pour contourner ce deuxième
   cas, la requête peut être quelque fois écrite de façon à ce que le type
   composite apparaisse comme une ligne de résultat plutôt que comme le champ
   d'une ligne du résultat. Autrement, la chaîne résultante peut être analysée
   manuellement mais cette approche n'est pas recommendée car une version
   future pourrait demander de refaire l'analyse de la chaîne en retour.
  </para>

  <para>
   Quand vous préparez un plan en utilisant le module PL/Python, il est
   automatiquement sauvegardé. Lisez la documentation SPI (<xref
   linkend="spi"/>) pour une description complète. Pour en avoir une
   utilisation réelle via des appels de fonctions, vous avez besoin d'utiliser
   un dictionnaire de stockage persistent
   <literal>SD</literal> ou <literal>GD</literal> (voir
   <xref linkend="plpython-sharing"/>). Par exemple&nbsp;:
<programlisting>
CREATE FUNCTION utilise_plan_sauvegarde() RETURNS trigger AS $$
    if SD.has_key("plan"):
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # reste de la fonction
$$ LANGUAGE plpythonu;
</programlisting>
  </para>
 </sect1>

 <sect1 id="plpython-util">
  <title>Fonctions outils</title>
  <para>
   Le module <literal>plpy</literal> fournit aussi les fonctions
   <literal>plpy.debug(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.log(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.info(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.notice(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.warning(<replaceable>msg</replaceable>)</literal>,
   <literal>plpy.error(<replaceable>msg</replaceable>)</literal> et
   <literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>.
   <indexterm><primary>elog</primary><secondary>dans PL/Python</secondary></indexterm>
   <function>plpy.error</function> et <literal>plpy.fatal("msg")</literal>
   lèvent une exception Python qui, si non attrapée, se propage à la requête
   appelante causant l'annulation de la transaction ou sous-transaction en
   cours.  <literal>raise plpy.Error(<replaceable>msg</replaceable>)</literal> et
   <literal>raise plpy.Fatal(<replaceable>msg</replaceable>)</literal> sont équivalent à
   appeler, respectivement, <function>plpy.error</function> et
   <function>plpy.fatal</function>. Les autres fonctions génèrent uniquement
   des messages de
   niveaux de priorité différents. Que les messages d'une priorité particulière
   soient reportés au client, écrit dans les journaux du serveur ou les deux,
   cette configuration est contrôlée par les variables <xref
   linkend="guc-log-min-messages"/> et <xref linkend="guc-client-min-messages"/>.
   Voir le <xref linkend="runtime-config"/> pour plus d'informations.
  </para>
 </sect1>


 <sect1 id="plpython-envar">
  <title>Variables d'environnement</title>

  <para>
   Certaines des variables d'environnement qui sont acceptées par
   l'interpréteur Python peuvent aussi être utilisées pour modifier le
   comportement de PL/Python. Elles doivent être configurées dans
   l'environnement du processus serveur PostgreSQL principal, par exemple dans
   le script de démarrage. Les variables d'environnement disponibles dépendent
   de la version de Python&nbsp;; voir la documentation de Python pour les
   détails. Au moment de l'écriture de ce chapitre, les variables
   d'environnement suivantes avaient un comportement sur PL/Python, à
   condition d'utiliser une version adéquate de Python&nbsp;:
   <itemizedlist>
    <listitem>
     <para><envar>PYTHONHOME</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONPATH</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONY2K</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONOPTIMIZE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDEBUG</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONVERBOSE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONCASEOK</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDONTWRITEBYTECODE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONIOENCODING</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONUSERBASE</envar></para>
    </listitem>
   </itemizedlist>

   (Cela semble être un détail d'implémentation de Python, en dehors du
   contrôle de PL/Python, qui fait que certaines variables d'environnement
   listées dans la page man de <command>python</command> sont seulement
   utilisables avec l'interpréteur en ligne de commande et non avec
   un interpréteur Python embarqué.)
  </para>
 </sect1>
</chapter>
