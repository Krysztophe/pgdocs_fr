<?xml version="1.0" encoding="UTF-8"?>
<!--
doc/src/sgml/ref/merge.sgml
PostgreSQL documentation
-->

<refentry id="sql-merge">

 <refmeta>
  <refentrytitle>MERGE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>MERGE</refname>
  <refpurpose>Insère, met à jour ou efface des lignes d'une table selon une condition</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
[ WITH <replaceable class="parameter">clause_with</replaceable> [, ...] ]
MERGE INTO <replaceable class="parameter">nom_table_cible</replaceable> [ [ AS ] <replaceable class="parameter">alias_cible</replaceable> ]
USING <replaceable class="parameter">source_des_données</replaceable> ON <replaceable class="parameter">condition_de_jointure</replaceable>
<replaceable class="parameter">clause_when</replaceable> [...]

<phrase>où <replaceable class="parameter">source_des_données</replaceable> est&nbsp;:</phrase>

{ <replaceable class="parameter">nom_table_source</replaceable> | ( <replaceable class="parameter">requête_source</replaceable> ) } [ [ AS ] <replaceable class="parameter">alias_source</replaceable> ]

<phrase>et <replaceable class="parameter">clause_when</replaceable> est&nbsp;:</phrase>

{ WHEN MATCHED [ AND <replaceable class="parameter">condition</replaceable> ] THEN { <replaceable class="parameter">merge_update</replaceable> | <replaceable class="parameter">merge_delete</replaceable> | DO NOTHING } |
  WHEN NOT MATCHED [ AND <replaceable class="parameter">condition</replaceable> ] THEN { <replaceable class="parameter">merge_insert</replaceable> | DO NOTHING } }

<phrase>et <replaceable class="parameter">merge_insert</replaceable> est&nbsp;:</phrase>

INSERT [( <replaceable class="parameter">nom_de_colonne</replaceable> [, ...] )]
[ OVERRIDING { SYSTEM | USER } VALUE ]
{ VALUES ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) | DEFAULT VALUES }

<phrase>et <replaceable class="parameter">merge_update</replaceable> est&nbsp;:</phrase>

UPDATE SET { <replaceable class="parameter">nom_de_colonne</replaceable> = { <replaceable class="parameter">expression</replaceable> | DEFAULT } |
             ( <replaceable class="parameter">nom_de_colonne</replaceable> [, ...] ) = ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) } [, ...]

<phrase>et <replaceable class="parameter">merge_delete</replaceable> est :</phrase>

DELETE
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>MERGE</command> exécute des actions qui modifient des lignes dans
   <replaceable class="parameter">nom_table_cible</replaceable>,
   en utilisant la <replaceable class="parameter">source_des_données</replaceable>.
   <command>MERGE</command> fournit un ordre <acronym>SQL</acronym>
   qui, à lui seul et selon la condition, peut opérer un <command>INSERT</command>,
   un <command>UPDATE</command> ou un <command>DELETE</command> sur des lignes,
   un rôle qui nécessiterait sinon de multiples appels dans un langage procédural.
  </para>

  <para>
   La commande <command>MERGE</command> commence par faire une jointure
   de <replaceable class="parameter">source_des_données</replaceable> et
   <replaceable class="parameter">nom_table_cible</replaceable>
   et obtient zéro ou plus ligne(s) candidates au changement. Pour chacune,
   le statut <literal>MATCHED</literal> ou <literal>NOT MATCHED</literal>
   est posé une seule fois, puis les clauses <literal>WHEN</literal> sont
   évaluées dans l'ordre spécifié. Pour chaque ligne candidate à un changement,
   la première clause évaluée à Vrai est exécutée. Il est exécuté au plus
   une clause <literal>WHEN</literal> pour chaque ligne candidate au changement.
  </para>

  <para>
   Les opérations de <command>MERGE</command> ont le même effet que les
   commandes <command>UPDATE</command>, <command>INSERT</command>, ou
   <command>DELETE</command> de même nom. La syntaxe de ces commandes
   diffère, notamment sur l'absence de clause <literal>WHERE</literal>
   et de nom de table.
   Toutes les actions se réfèrent à la table
   <replaceable class="parameter">nom_table_cible</replaceable>,
   bien que des modifications sur d'autres tables puissent être faites
   par triggers.
  </para>

  <para>
   Si <literal>DO NOTHING</literal> est précisé, la ligne source est passée.
   Comme les actions sont évaluées dans l'ordre spécifié,
   il peut être utile de sauter les lignes source sans intérêt
   avant une gestion plus fine.
  </para>

  <para>
   Il n'y a pas de privilège <literal>MERGE</literal> dédié.
   Si vous spécifiez une mise à jour, vous devez posséder le
   privilège <literal>UPDATE</literal> sur les colonnes
   de <replaceable class="parameter">nom_table_cible</replaceable>
   mentionnées dans <literal>SET</literal>.
   Si vous spécifiez une insertion, vous devez posséder le privilège
   <literal>INSERT</literal> sur <replaceable class="parameter">nom_table_cible</replaceable>.
   Si vous spécifiez une suppression, vous devez posséder le privilège
   <literal>DELETE</literal> sur <replaceable class="parameter">nom_table_cible</replaceable>.
   Les privilèges sont testés et vérifiés une fois au démarrage de l'ordre,
   que les clauses <literal>WHEN</literal> concernées soient exécutées ou pas.
   Vous aurez besoin du privilège <literal>SELECT</literal> sur
   <replaceable class="parameter">source_des_données</replaceable>
   et toute(s) colonne(s) de <replaceable class="parameter">nom_table_cible</replaceable>
   référencée dans <literal>condition</literal>.
  </para>

  <para>
   <command>MERGE</command> n'est pas supporté si
   <replaceable class="parameter">nom_table_cible</replaceable>
   est une vue matérialisée, une table étrangère,
   ou si des règles y sont définies.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom_table_cible</replaceable></term>
    <listitem>
     <para>
      Nom (éventuellement avec le schéma) de la table cible où fusionner
      des informations.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alias_cible</replaceable></term>
    <listitem>
     <para>
      Un nom à substituer à la table cible. Quand un alias est fourni,
      il cache complètement le nom réel de la table.
      Par exemple, avec <literal>MERGE INTO foo AS f</literal>,
      le reste de l'ordre <command>MERGE</command> devra appeler la
      table avec <literal>f</literal> et non <literal>foo</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_table_source</replaceable></term>
    <listitem>
     <para>
      Le nom (éventuellement qualifié avec le schéma) de la source, vue
      ou table de transition source.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">requête_source</replaceable></term>
    <listitem>
     <para>
      Une requête (commande <command>SELECT</command> ou <command>VALUES</command>)
      fournissant les lignes à fusionner dans 
      <replaceable class="parameter">nom_table_cible</replaceable>.
      Se référer à la documentation de <xref linkend="sql-select"/> ou
      <xref linkend="sql-values"/> pour une description de leurs syntaxes.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alias_source</replaceable></term>
    <listitem>
     <para>
      Un nom substitut de la source de données.
      Quand un alias est fourni, il cache complètement le nom réel de la table
      ou le fait qu'une requête ait été fournie.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition_de_jointure</replaceable></term>
    <listitem>
     <para>
      <replaceable class="parameter">condition_de_jointure</replaceable> est
      Une expression dont le résultat est un
      <type>boolean</type> (similaire à une clause <literal>WHERE</literal>),
      lequel spécifie quelles lignes de 
      <replaceable class="parameter">source_des_données</replaceable>
      correspondent à des lignes dans
      <replaceable class="parameter">nom_table_cible</replaceable>.
     </para>
     <warning>
      <para>
       Seules les colonnes de <replaceable class="parameter">nom_table_cible</replaceable>
       qui cherchent une similitude dans <replaceable class="parameter">source_des_données</replaceable>
       devraient apparaître dans <replaceable class="parameter">condition_de_jointure</replaceable>.
       Les sous-expressions qui ne référencent que <replaceable class="parameter">nom_table_cible</replaceable>
       peuvent affecter le choix de l'action, souvent de manière surprenante.
      </para>
     </warning>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">clause_when</replaceable></term>
    <listitem>
     <para>
      Au moins une clause <literal>WHEN</literal> est nécessaire.
     </para>
     <para>
      Si la clause <literal>WHEN</literal> indique <literal>WHEN MATCHED</literal>
      et que la ligne candidate correspond à une ligne de 
      <replaceable class="parameter">nom_table_cible</replaceable>,
      et si <replaceable class="parameter">condition</replaceable>
      est absente ou évaluée à <literal>true</literal>,
      alors la clause <literal>WHEN</literal> est exécutée.
     </para>
     <para>
      À l'inverse, si la clause <literal>WHEN</literal> spécifie
      <literal>WHEN NOT MATCHED</literal>,
      et que la ligne candidate n'a pas de ligne correspondante dans
      <replaceable class="parameter">nom_table_cible</replaceable>,
      alors la clause <literal>WHEN</literal> est exécutée,
      si <replaceable class="parameter">condition</replaceable>
      est absente ou évaluée à <literal>true</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
     <para>
      Une expression dont le résultat est un <type>boolean</type>.
      Si cette expression renvoie <literal>true</literal>,
      alors la clause <literal>WHEN</literal> qu'elle accompagne
      est exécutée pour la ligne en cours.
     </para>
     <para>
      Une condition d'une clause <literal>WHEN MATCHED</literal> peut
      se référer à des colonnes de la relation source comme de la cible.
      Une condition d'une clause <literal>WHEN NOT MATCHED</literal>
      ne peut se référer qu'à des colonnes de la relation source,
      puisque, par définition, il n'y a pas de ligne correspondante
      dans la cible. Seuls les attributs de la table cible sont
      modifiables.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_insert</replaceable></term>
    <listitem>
     <para>
      Spécification de la clause <literal>INSERT</literal> qui insère une
      ou plusieurs lignes dans la table cible. Les noms des colonnes cibles
      peuvent être listés dans n'importe quel ordre. Si aucune liste n'est
      donnée, le défaut est l'ensemble des colonnes de la table dans leur
      ordre de déclaration.
     </para>
     <para>
      Chaque colonne absente de la liste des champs, explicite ou implicite,
      sera remplie par une valeur par défaut, soit sa valeur par défaut
      déclarée, soit null.
     </para>
     <para>
      Si l'expression d'une colonne quelconque n'est pas du bon type de
      données, une conversion automatique du type sera tentée.
     </para>
     <para>
      Si <replaceable class="parameter">nom_table_cible</replaceable>
      est une table partitionnée, chaque ligne est routée vers la
      partitions appropriée et insérée dedans.
      Si <replaceable class="parameter">nom_table_cible</replaceable>
      est une partition, une erreur se produira si une ligne quelconque
      viole la contrainte de partitionnement.
     </para>
     <para>
      Les noms de colonnes ne peuvent être spécifiés qu'une fois.
      Les commandes <command>INSERT</command> ne peuvent contenir
      des sous-selects.
     </para>
     <para>
      Une seule clause <literal>VALUES</literal> peut être spécifiée.
      La clause <literal>VALUES</literal> ne peut se référer qu'à des
      colonnes de la table source, puisque par définition il n'y a
      pas de ligne cible correspondante. 
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_update</replaceable></term>
    <listitem>
     <para>
      Spécification de la commande <literal>UPDATE</literal> qui met à jour
      la ligne courante de <replaceable class="parameter">nom_table_cible</replaceable>.
      Les noms de colonnes ne peuvent être utilisés plus d'une fois.
     </para>
     <para>
      Ne sont permis ni un nom de table, ni une clause <literal>WHERE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_delete</replaceable></term>
    <listitem>
     <para>
      Spécifie une action <literal>DELETE</literal> qui efface la ligne courante
      de  <replaceable class="parameter">nom_table_cible</replaceable>.
      N'incluez ni le nom de la table ni aucune autre clause,
      comme vous le feriez pour une commande <xref linkend="sql-delete"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_de_colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne dans
      <replaceable class="parameter">nom_table_cible</replaceable>.
      Au besoin, il peut être complété avec un nom de sous-champ
      ou un indice de tableau.
      (N'insérer que dans certains champs d'une colonne composée laisse
      les autres champs à null).
      N'incluez par le nom de la table dans la définition d'une colonne cible.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OVERRIDING SYSTEM VALUE</literal></term>
    <listitem>
     <para>
      Sans cette clause, une erreur sera levée si une valeur explicite
      (other than <literal>DEFAULT</literal>) est spécifiée pour une
      colonne identité définie comme <literal>GENERATED ALWAYS</literal>.
      Cette clause passe outre à la restriction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OVERRIDING USER VALUE</literal></term>
    <listitem>
     <para>
      Avec cette clause, toutes les valeur fournies pour des colonnes
      identités définies comme <literal>GENERATED BY DEFAULT</literal>
      sont ignorées, et les valeurs générées par séquence sont appliquées.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT VALUES</literal></term>
    <listitem>
     <para>
      Toutes les colonnes seront remplies avec leur valeur par défaut.
      (Une clause <literal>OVERRIDING</literal> n'est alors pas permise.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">expression</replaceable></term>
    <listitem>
     <para>
      An expression to assign to the column.  If used in a
      <literal>WHEN MATCHED</literal> clause, the expression can use values
      from the original row in the target table, and values from the
      <literal>source_des_données</literal> row.
      If used in a <literal>WHEN NOT MATCHED</literal> clause, the
      expression can use values from the <literal>source_des_données</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT</literal></term>
    <listitem>
     <para>
      Set the column to its default value (which will be <literal>NULL</literal>
      if no specific default expression has been assigned to it).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">clause_with</replaceable></term>
    <listitem>
     <para>
      The <literal>WITH</literal> clause allows you to specify one or more
      subqueries that can be referenced by name in the <command>MERGE</command>
      query. See <xref linkend="queries-with"/> and <xref linkend="sql-select"/>
      for details.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
  <title>Outputs</title>

  <para>
   On successful completion, a <command>MERGE</command> command returns a command
   tag of the form
<screen>
MERGE <replaceable class="parameter">total_count</replaceable>
</screen>
   The <replaceable class="parameter">total_count</replaceable> is the total
   number of rows changed (whether inserted, updated, or deleted).
   If <replaceable class="parameter">total_count</replaceable> is 0, no rows
   were changed in any way.
  </para>

 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   The following steps take place during the execution of
   <command>MERGE</command>.
    <orderedlist>
     <listitem>
      <para>
       Perform any <literal>BEFORE STATEMENT</literal> triggers for all
       actions specified, whether or not their <literal>WHEN</literal>
       clauses match.
      </para>
     </listitem>
     <listitem>
      <para>
       Perform a join from source to target table.
       The resulting query will be optimized normally and will produce
       a set of candidate change rows. For each candidate change row,
       <orderedlist>
        <listitem>
         <para>
          Evaluate whether each row is <literal>MATCHED</literal> or
          <literal>NOT MATCHED</literal>.
         </para>
        </listitem>
        <listitem>
         <para>
          Test each <literal>WHEN</literal> condition in the order
          specified until one returns true.
         </para>
        </listitem>
        <listitem>
         <para>
          When a condition returns true, perform the following actions:
          <orderedlist>
           <listitem>
            <para>
             Perform any <literal>BEFORE ROW</literal> triggers that fire
             for the action's event type.
            </para>
           </listitem>
           <listitem>
            <para>
             Perform the specified action, invoking any check constraints on the
             target table.
            </para>
           </listitem>
           <listitem>
            <para>
             Perform any <literal>AFTER ROW</literal> triggers that fire for
             the action's event type.
            </para>
           </listitem>
          </orderedlist></para>
        </listitem>
       </orderedlist></para>
     </listitem>
     <listitem>
      <para>
       Perform any <literal>AFTER STATEMENT</literal> triggers for actions
       specified, whether or not they actually occur.  This is similar to the
       behavior of an <command>UPDATE</command> statement that modifies no rows.
      </para>
     </listitem>
    </orderedlist>
   In summary, statement triggers for an event type (say,
   <command>INSERT</command>) will be fired whenever we
   <emphasis>specify</emphasis> an action of that kind.
   In contrast, row-level triggers will fire only for the specific event type
   being <emphasis>executed</emphasis>.
   So a <command>MERGE</command> command might fire statement triggers for both
   <command>UPDATE</command> and <command>INSERT</command>, even though only
   <command>UPDATE</command> row triggers were fired.
  </para>

  <para>
   You should ensure that the join produces at most one candidate change row
   for each target row.  In other words, a target row shouldn't join to more
   than one data source row.  If it does, then only one of the candidate change
   rows will be used to modify the target row; later attempts to modify the
   row will cause an error.
   This can also occur if row triggers make changes to the target table
   and the rows so modified are then subsequently also modified by
   <command>MERGE</command>.
   If the repeated action is an <command>INSERT</command>, this will
   cause a uniqueness violation, while a repeated <command>UPDATE</command>
   or <command>DELETE</command> will cause a cardinality violation; the
   latter behavior is required by the <acronym>SQL</acronym> standard.
   This differs from historical <productname>PostgreSQL</productname>
   behavior of joins in <command>UPDATE</command> and
   <command>DELETE</command> statements where second and subsequent
   attempts to modify the same row are simply ignored.
  </para>

  <para>
   If a <literal>WHEN</literal> clause omits an <literal>AND</literal>
   sub-clause, it becomes the final reachable clause of that
   kind (<literal>MATCHED</literal> or <literal>NOT MATCHED</literal>).
   If a later <literal>WHEN</literal> clause of that kind
   is specified it would be provably unreachable and an error is raised.
   If no final reachable clause is specified of either kind, it is
   possible that no action will be taken for a candidate change row.
  </para>

  <para>
   The order in which rows are generated from the data source is
   indeterminate by default.
   A <replaceable class="parameter">requête_source</replaceable> can be
   used to specify a consistent ordering, if required, which might be
   needed to avoid deadlocks between concurrent transactions.
  </para>

  <para>
   There is no <literal>RETURNING</literal> clause with
   <command>MERGE</command>.  Actions of <command>INSERT</command>,
   <command>UPDATE</command> and <command>DELETE</command> cannot contain
   <literal>RETURNING</literal> or <literal>WITH</literal> clauses.
  </para>

  <para>
   When <command>MERGE</command> is run concurrently with other commands
   that modify the target table, the usual transaction isolation rules
   apply; see <xref linkend="transaction-iso"/> for an explanation
   on the behavior at each isolation level.
   You may also wish to consider using <command>INSERT ... ON CONFLICT</command>
   as an alternative statement which offers the ability to run an
   <command>UPDATE</command> if a concurrent <command>INSERT</command>
   occurs.  There are a variety of differences and restrictions between
   the two statement types and they are not interchangeable.
  </para>
 </refsect1>

 <refsect1>
  <title>Examples</title>

  <para>
   Perform maintenance on <literal>CustomerAccounts</literal> based
   upon new <literal>Transactions</literal>.

<programlisting>
MERGE INTO CustomerAccount CA
USING RecentTransactions T
ON T.CustomerId = CA.CustomerId
WHEN MATCHED THEN
  UPDATE SET Balance = Balance + TransactionValue
WHEN NOT MATCHED THEN
  INSERT (CustomerId, Balance)
  VALUES (T.CustomerId, T.TransactionValue);
</programlisting>
  </para>

  <para>
   Notice that this would be exactly equivalent to the following
   statement because the <literal>MATCHED</literal> result does not change
   during execution.

<programlisting>
MERGE INTO CustomerAccount CA
USING (Select CustomerId, TransactionValue From RecentTransactions) AS T
ON CA.CustomerId = T.CustomerId
WHEN NOT MATCHED THEN
  INSERT (CustomerId, Balance)
  VALUES (T.CustomerId, T.TransactionValue)
WHEN MATCHED THEN
  UPDATE SET Balance = Balance + TransactionValue;
</programlisting>
  </para>

  <para>
   Attempt to insert a new stock item along with the quantity of stock. If
   the item already exists, instead update the stock count of the existing
   item. Don't allow entries that have zero stock.
<programlisting>
MERGE INTO wines w
USING wine_stock_changes s
ON s.winename = w.winename
WHEN NOT MATCHED AND s.stock_delta > 0 THEN
  INSERT VALUES(s.winename, s.stock_delta)
WHEN MATCHED AND w.stock + s.stock_delta > 0 THEN
  UPDATE SET stock = w.stock + s.stock_delta
WHEN MATCHED THEN
  DELETE;
</programlisting>

   The <literal>wine_stock_changes</literal> table might be, for example, a
   temporary table recently loaded into the database.
  </para>

 </refsect1>

 <refsect1>
  <title>Compatibility</title>
   <para>
    This command conforms to the <acronym>SQL</acronym> standard.
  </para>
   <para>
    The WITH clause and <literal>DO NOTHING</literal> action are extensions to
    the <acronym>SQL</acronym> standard.
  </para>
 </refsect1>
</refentry>
