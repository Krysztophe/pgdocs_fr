<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="protocol">
 <title>Protocole client/serveur</title>

 <indexterm zone="protocol">
  <primary>protocol</primary>
  <secondary>frontend-backend</secondary>
 </indexterm>

 <para>
  <productname>postgresql</productname> utilise un protocole messages pour la
  communication entre les clients et les serveurs (<quote>frontend</quote> et
  <quote>backend</quote>). le protocole est supporté par <acronym>tcp/ip</acronym>
  et par les sockets de domaine Unix. Le numéro de port 5432 a été enregistré
  par l'IANA comme numéro de port TCP personnalisé pour les serveurs supportant ce
  protocole mais en pratique tout numéro de port non privilégié peut être
  utilisé.
 </para>

 <para>
  Ce document décrit la version 3.0 de ce protocole, telle qu'implantée dans
  <productname>postgresql</productname> depuis la version 7.4. pour obtenir la
  description des versions précédentes du protocole, il faudra se reporter aux
  versions antérieures de la documentation de <productname>postgresql</productname>. un
  même serveur peut supporter plusieurs versions du protocole. Lors de l'établissement
  de la communication le client indique au serveur la version du protocole qu'il
  souhaite utiliser. Le serveur suivra ce protocole s'il en est capable.
 </para>

 <para>
  Les fonctionnalités de haut niveau construites sur ce protocole
  (par exemple, la façon dont <application>libpq</application> passe certaines
  variables d'environnement à l'établissement de la connexion) ne sont pas couvertes
  par ce chapitre.
 </para>

  <para>
   Pour répondre efficacement à de multiples clients, le serveur lance un
   nouveau serveur (<quote>backend</quote>) pour chaque client. dans l'implémentation
   actuelle, un nouveau processus fils est créé immédiatement après la détection
   d'une connexion entrante. Et cela de façon transparente pour le
   protocole. Pour le protocole, les termes <quote>backend</quote> et
   <quote>serveur</quote> sont interchangeables&nbsp;; comme <quote>frontend</quote>,
   <quote>interface</quote> et <quote>client</quote>.
  </para>

 <sect1 id="protocol-overview">
  <title>Aperçu</title>

  <para>
   Le protocole utilise des phases distinctes pour le lancement et le fonctionnement
   habituel. Dans la phase de lancement, le client ouvre une connexion au
   serveur et s'authentifie (ce qui peut impliquer un message simple, ou plusieurs
   messages, en fonction de la méthode d'authentification utilisée). En cas de
   réussite, le serveur
   envoie une information de statut au client et entre dans le mode normal de
   fonctionnement. Exception faite du message initial de demande de lancement, cette
   partie du protocole est conduite par le serveur.
  </para>

  <para>
   En mode de fonctionnement normal, le client envoie requêtes et commandes au
   serveur et celui-ci retourne les résultats de requêtes et autres réponses.
   Il existe quelques cas (comme <command>notify</command>) pour lesquels le serveur
   enverra des messages non sollicités. Mais dans l'ensemble, cette partie
   de la session est conduite par les requêtes du client.
  </para>

  <para>
   En général, c'est le client qui décide de la clôture de la session. Il arrive,
   cependant, qu'elle soit forcée par le moteur. Dans tous les cas, lors de la
   fermeture de la connexion par le serveur, toute transaction ouverte (non terminée)
   sera annulée.
  </para>

  <para>
   En mode opérationnel normal, les commandes SQL peuvent être exécutées
   via deux sous-protocoles. Dans le protocole des <quote>requêtes simples</quote>,
   le client envoie juste une chaîne, la requête, qui est analysée et exécutée
   immédiatement par le serveur. Dans le protocole des <quote>requêtes
   étendues</quote>, le traitement des requêtes est découpé en de nombreuses
   étapes&nbsp;: l'analyse, le lien avec les valeurs de paramètres et
   l'exécution. Ceci offre flexibilité et gains en performances
   au prix d'une complexité supplémentaire.
  </para>

  <para>
   Le mode opérationnel normal offre des sous-protocoles supplémentaires pour
   certaines opérations comme <command>copy</command>.
  </para>

 <sect2 id="protocol-message-concepts">
  <title>Aperçu des messages</title>

  <para>
   Toute la communication s'effectue au travers d'un flux de messages. Le premier octet
   d'un message identifie le type de message et les quatre octets suivants
   spécifient la longueur du reste du message (cette longueur inclut les 4 octets
   de longueur, mais pas l'octet du type de message). Le reste du contenu du
   message est déterminé par le type de message. Pour des raisons historiques,
   le tout premier message envoyé par le client (le message de lancement) n'a
   pas l'octet initial de type du message.
  </para>

  <para>
   Pour éviter de perdre la synchronisation avec le flux de messages, le
   serveur et le client stocke le message complet dans un tampon
   (en utilisant le nombre d'octets) avant de tenter de traiter son contenu.
   Cela permet une récupération simple si une erreur est détectée lors du
   traitement du contenu. Dans les situations extrêmes (telles que de ne pas avoir
   assez de mémoire pour placer le message dans le tampon), le récepteur
   peut utiliser le nombre d'octets pour déterminer le nombre d'entrées à ignorer
   avant de continuer la lecture des messages.
  </para>

  <para>
   En revanche, serveurs et clients doivent être attentifs à ne pas envoyer
   de message incomplet. Ceci est habituellement obtenu en plaçant le message
   complet dans un tampon avant de commencer l'envoi. Si un échec de
   communications survient pendant l'envoi ou la réception d'un message, la
   seule réponse plausible est l'abandon de la connexion. Il y a, en effet, peu d'espoir
   de resynchronisation des messages.
  </para>
 </sect2>

  <sect2 id="protocol-query-concepts">
   <title>Aperçu des requêtes étendues</title>

   <para>
    Dans le protocole des requêtes étendues, l'exécution de commandes SQL est
    scindée en plusieurs étapes. L'état retenu entre les étapes est représenté
    par deux types d'objets&nbsp;: les <firstterm>instructions préparées</firstterm> et
    les <firstterm>portails</firstterm>. une instruction préparée représente le résultat
    de l'analyse syntaxique, de l'analyse sémantique et de la planification d'une
    chaîne de requête textuelle. Une instruction préparée n'est pas nécessairement prête à
    être exécutée parce qu'il peut lui manquer certaines valeurs de
    <firstterm>paramètres</firstterm>. un portail représente une instruction prête à être
    exécutée ou déjà partiellement exécutée, dont toutes les valeurs de
    paramètres manquant sont données (pour les instructions
    <command>select</command>, un portail est équivalent à un curseur ouvert. il est
    choisi d'utiliser un terme différent car les curseurs ne gèrent pas les
    instructions autres que <command>select</command>)
   </para>

   <para>
    Le cycle d'exécution complet consiste en une étape d'<firstterm>analyse syntaxique</firstterm>,
    qui crée une instruction préparée à partir d'une chaîne de requête textuelle&nbsp;;
    une étape de <firstterm>liaison</firstterm>, qui crée un portail à partir d'une
    instruction préparée et des valeurs pour les paramètres nécessaires&nbsp;;
    et une étape d'<firstterm>exécution</firstterm> qui exécute une requête du portail.
    Dans le cas d'une requête qui renvoie des lignes (<command>select</command>,
    <command>show</command>, etc), il peut être signalé à l'étape d'exécution
    que seul un certain nombre de lignes doivent être retournées, de sorte que
    de multiples étapes d'exécution seront nécessaires pour terminer l'opération.
   </para>

   <para>
    Le serveur peut garder la trace de multiples instructions préparées et
    portails (qui n'existent qu'à l'intérieur d'une session, et ne sont jamais
    partagés entre les sessions). Les instructions
    préparées et les portails sont référencés par les noms qui leur sont affectés
    à la création. De plus, il existe une instruction préparée et un portail
    <quote>non nommés</quote>. bien qu'ils se comportent comme des
    objets nommés, les opérations y sont optimisées en vue d'une exécution unique
    de la requête avant son annulation puis est annulée. En revanche, les
    opérations sur les objets nommés sont optimisées pour des utilisations multiples.
   </para>
  </sect2>

  <sect2 id="protocol-format-codes">
   <title>Formats et codes de format</title>

   <para>
    Les données d'un type particulier pouvaient être transmises sous
    différents <firstterm>formats</firstterm>. depuis <productname>postgresql</productname> 7.4, les
    seuls formats supportés sont le <quote>texte</quote> et le <quote>binaire</quote> mais
    le protocole prévoit des extensions futures. Le format désiré pour toute valeur
    est spécifié par un <firstterm>code de format</firstterm>. les clients peuvent spécifier
    un code de format pour chaque valeur de paramètre transmise et pour chaque
    colonne du résultat d'une requête. Le texte a zéro pour code de format zéro,
    le binaire un. Tous les autres codes de format sont réservés pour des
    définitions futures.
   </para>

   <para>
    La représentation au format texte des valeurs est toute chaîne produite et acceptée
    par les fonctions de conversion en entrée/sortie pour le type de données
    particulier. Dans la représentation transmise, il n'y a pas de caractère nul
    de terminaison de chaîne&nbsp;; le client doit en ajouter un s'il
    souhaite traiter les valeurs comme des chaînes C (le format texte n'autorise pas
    les valeurs nulles intégrées).
   </para>

   <para>
    Les représentations binaires des entiers utilisent l'ordre d'octet
    réseau (octet le plus significatif en premier). Pour les autres types de
    données, il faudra consulter la documentation ou le code source pour connaître
    la représentation binaire. Les représentations binaires
    des types de données complexes changent parfois entre les versions du
    serveur&nbsp;; le format texte reste le choix le plus portable.
   </para>
  </sect2>
 </sect1>

 <sect1 id="protocol-flow">
  <title>Flux de messages</title>

  <para>
   Cette section décrit le flux des messages et la sémantique de chaque type
   de message (les détails concernant la représentation exacte de chaque message
   apparaissent dans <xref linkend="protocol-message-formats"/>). il existe
   différents sous-protocoles en fonction de l'état de la connexion&nbsp;: lancement,
   requête, appel de fonction, COPY et clôture. Il existe aussi des provisions
   spéciales pour les opérations asynchrones (incluant les
   réponses aux notifications et les annulations de commande), qui peuvent
   arriver à tout moment après la phase de lancement.
  </para>

  <sect2>
   <title>Lancement</title>

   <para>
    Pour débuter une session, un client ouvre une connexion au serveur et
    envoie un message de démarrage. Ce message inclut les noms de l'utilisateur
    et de la base de données à laquelle le client souhaite se connecter&nbsp;; il
    identifie aussi la version particulière du protocole à utiliser
    (optionnellement, le message de démarrage peut inclure des précisions
    supplémentaires pour les paramètres d'exécution). Le serveur utilise
    ces informations et le contenu des fichiers de configuration
    (tels que <filename>pg_hba.conf</filename>) pour déterminer si la connexion
    est acceptable et quelle éventuelle authentification supplémentaire est requise.
   </para>

   <para>
    Le serveur envoie ensuite le message de demande d'authentification
    approprié, auquel le client doit répondre avec le message de réponse
    d'authentification adapté (tel un mot de passe). Pour toutes les méthodes
    d'authentification, sauf GSSAPI et SSPI, il y a au maximum une requête et
    une réponse. Avec certaines méthodes, aucune réponse du client n'est
    nécessaire&nbsp; aucune demande d'authentification n'est alors effectuée.
    Pour GSSAPI et SSPI, plusieurs itérations de paquets peuvent être nécessaire pour
    terminer l'authentification.
   </para>

   <para>
    Le cycle d'authentification se termine lorque le serveur rejette la tentative
    de connexion (ErrorResponse) ou l'accepte (AuthenticationOk).
   </para>

   <para>
    Les messages possibles du serveur dans cette phase sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>errorresponse</term>
      <listitem>
       <para>
        La tentative de connexion a été rejetée.
        Le serveur ferme immédiatement la connexion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>authenticationok</term>
      <listitem>
       <para>
        L'échange d'authentification s'est terminé avec succès.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>authenticationkerberosv5</term>
      <listitem>
       <para>
        Le client doit alors prendre part à un dialogue
        d'authentification Kerberos V5 (spécification Kerberos, non décrite ici)
        avec le serveur. En cas de succès, le serveur répond AuthenticationOk,
        ErrorResponse sinon.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>authenticationcleartextpassword</term>
      <listitem>
       <para>
        Le client doit alors envoyer un PasswordMessage contenant le mot
        de passe en clair. Si le mot de passe est correct, le serveur répond
        AuthenticationOk, ErrorResponse sinon.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>authenticationcryptpassword</term>
      <listitem>
       <para>
        Le client doit alors envoyer un PasswordMessage contenant le mot
        de passe chiffré à l'aide de crypt(3), en utilisant le composant salt de deux
        caractères spécifié dans le message AuthenticationCryptPassword. Si le
        mot de passe est correct, le serveur répond AuthenticationOk,
        ErrorResponse sinon.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>authenticationmd5password</term>
      <listitem>
       <para>
        Le client doit alors envoyer un PasswordMessage contenant le mot
        de passe chiffré à l'aide de MD5, en utilisant le composant salt de quatre
        caractères spécifié dans le message AuthenticationMD5Password. Si le mot
        de passe est correct, le serveur répond AuthenticationOk,
        ErrorResponse sinon.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>authenticationscmcredential</term>
      <listitem>
       <para>
        Cette réponse est possible uniquement pour les connexions locales de
        domaine Unix sur les plateformes qui supportent les messages
        de légitimation SCM. Le client doit fournir un message de légitimation
	SCM, puis envoyer une donnée d'un octet. Le contenu de cet octet
	importe peu&nbsp;; il n'est utilisé que pour s'assurer que le serveur
	attend assez longtemps pour recevoir le message de légitimation.
	Si la légitimation est acceptable, le serveur répond AuthenticationOk,
	ErrorResponse sinon.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationGSS</term>
      <listitem>
       <para>
        L'interface doit maintenant initier une négotiation GSSAPI. L'interface
	doit envoyer un PasswordMessage avec la première partie du flux de
	données GSSAPI en réponse à ceci. Si plus de messages sont nécessaires,
        le serveur répondra avec AuthenticationGSSContinue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSSPI</term>
      <listitem>
       <para>
        L'interface doit maintenant initier une négotiation SSPI. L'interface
	doit envoyer un PasswordMessage avec la première partie du flux de
	données SSPI en réponse à ceci. Si plus de messages sont nécessaires,
        le serveur répondra avec AuthenticationGSSContinue.
       </para>
      </listitem>

     </varlistentry>

     <varlistentry>
      <term>AuthenticationGSSContinue</term>
      <listitem>
       <para>
        Ce message contient les données de la réponse de l'étape précédente
	pour la négotiation GSSAPI ou SSPI (AuthenticationGSS ou un précédent
        AuthenticationGSSContinue). Si les données GSSAPI dans ce message
	indique que plus de données sont nécessaire pour terminer
        l'authentification, l'interface doit envoyer cette donnée dans un
	autre PasswordMessage. Si l'authentification GSSAPI ou SSPI est
	terminée par ce
	message, le serveur enverra aussi AuthenticationOk pour indiquer une
	authentification réussie ou ErrorResponse pour indiquer l'échec.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
    Si le client ne supporte pas la méhode d'authentification demandée par le
    serveur, il doit immédiatement fermer la connexion.
   </para>

   <para>
    Après la réception du message AuthenticationOk, le client attend d'autres
    messages du serveur. Au cours de cette phase, un processus serveur est lancé
    et le client est simplement en attente. Il est encore possible que la tentative de
    lancement échoue (ErrorResponse) mais, dans la plupart des cas, le serveur
    enverra les messages ParameterStatus, BackendKeyData et enfin ReadyForQuery.
   </para>

   <para>
    Durant cette phase, le serveur tentera d'appliquer tous les paramètres
    d'exécution supplémentaires qui ont été fournis par le message de lancement.
    En cas de succès, ces valeurs deviennent les valeurs par défaut de la session.
    Une erreur engendre ErrorResponse et déclenche la sortie.
   </para>

   <para>
    Les messages possibles du serveur dans cette phase sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>backendkeydata</term>
      <listitem>
       <para>
        Ce message fournit une clé secrète que le client doit conserver s'il
        souhaite envoyer des annulations de requêtes par la suite.
        Le client ne devrait pas répondre à ce message, mais continuer à attendre
        un message ReadyForQuery.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>parameterstatus</term>
      <listitem>
       <para>
        Ce message informe le client de la configuration actuelle (initiale)
        des paramètres du serveur, tels <varname>client_encoding</varname> ou
        <varname>datestyle</varname>. le client peut ignorer ce message ou enregistrer
        la configuration pour ses besoins futurs&nbsp;; voir
        <xref linkend="protocol-async"/> pour plus de détails. le client ne
        devrait pas répondre à ce message mais continuer à attendre un message
        ReadyForQuery.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>readyforquery</term>
      <listitem>
       <para>
        Le lancement est terminé. Le client peut dès lors envoyer des commandes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>errorresponse</term>
      <listitem>
       <para>
        Le lancement a échoué. La connexion est fermée après l'envoi de ce
	message.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>noticeresponse</term>
      <listitem>
       <para>
        Un message d'avertissement a été envoyé. Le client devrait afficher ce
	message mais continuer à attendre un ReadyForQuery ou un ErrorResponse.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Le même message ReadyForQuery est envoyé à chaque cycle de commande.
    En fonction des besoins de codage du client, il est possible de
    considérer ReadyForQuery comme le début d'un cycle de commande, ou de le
    considérer comme terminant la phase de lancement et chaque cycle de commande.
   </para>
  </sect2>

  <sect2>
   <title>Requête simple</title>

   <para>
    Un cycle de requête simple est initié par le client qui envoie un message
    Query au serveur. Le message inclut une commande SQL (ou plusieurs) exprimée
    comme une chaîne texte. Le serveur envoie, alors, un ou plusieurs messages
    de réponse dépendant du contenu de la chaîne représentant la requête et
    enfin un message ReadyForQuery. ReadyForQuery informe le client qu'il peut
    envoyer une nouvelle commande. Il n'est pas nécessaire que le client attende
    ReadyForQuery avant de lancer une autre commande mais le client prend alors
    la responsabilité de ce qui arrive si la commande précédente échoue et que
    les commandes suivantes, déjà lancées, réussissent.
   </para>

   <para>
    Les messages de réponse du serveur sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>commandcomplete</term>
      <listitem>
       <para>
        Commande SQL terminée normalement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>copyinresponse</term>
      <listitem>
       <para>
        Le serveur est prêt à copier des données du client vers une table&nbsp;
	voir <xref linkend="protocol-copy"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>copyoutresponse</term>
      <listitem>
       <para>
        Le serveur est prêt à copier des données d'une table vers le client&nbsp;;
	voir <xref linkend="protocol-copy"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>rowdescription</term>
      <listitem>
       <para>
        Indique que des lignes vont être envoyées en réponse à une
	requête <command>select</command>, <command>fetch</command>...
	Le contenu de ce message décrit le placement des colonnes dans les
	lignes. Le contenu est suivi d'un message DataRow pour chaque ligne envoyée
	au client.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>datarow</term>
      <listitem>
       <para>
        Un des ensembles de lignes retournés par une requête
	<command>select</command>, <command>fetch</command>...
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>emptyqueryresponse</term>
      <listitem>
       <para>
        Une chaîne de requête vide a été reconnue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>errorresponse</term>
      <listitem>
       <para>
        Une erreur est survenue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>readyforquery</term>
      <listitem>
       <para>
        Le traitement d'une requête est terminé. Un message séparé est envoyé
	pour l'indiquer parce qu'il se peut que la chaîne de la requête contienne
	plusieurs commandes SQL. CommandComplete marque la fin du traitement
	d'une commande SQL, pas de la chaîne complète. ReadyForQuery sera
	toujours envoyé que le traitement se termine avec succès ou non.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>noticeresponse</term>
      <listitem>
       <para>
        Un message d'avertissement concernant la requête a été envoyé. Les
	avertissements sont complémentaires des autres réponses, le serveur
	continuera à traiter la commande.
       </para>
      </listitem>
     </varlistentry>

      </variablelist>
     </para>

      <para>
       La réponse à une requête <command>select</command> (ou à d'autres requêtes, telles
       <command>explain</command> ou <command>show</command>, qui retournent des ensembles de
       données) consiste normalement en un RowDescription, plusieurs messages
       DataRow (ou aucun) et pour finir un CommandComplete. <command>copy</command> depuis
       ou vers le client utilise un protocole spécial décrit dans
       <xref linkend="protocol-copy"/>. tous les autres types de requêtes produisent
       uniquement un message CommandComplete.
      </para>

      <para>
       Puisqu'une chaîne de caractères peut contenir plusieurs requêtes (séparées
       par des points virgules), il peut y avoir plusieurs séquences de réponses
       avant que le serveur ne finisse de traiter la chaîne. ReadyForQuery est
       envoyé lorsque la chaîne complète a été traitée et que le serveur est prêt à
       accepter une nouvelle chaîne de requêtes.
      </para>

      <para>
       Si une chaîne de requêtes complètement vide est reçue (aucun contenu autre
       que des espaces fines), la réponse sera EmptyQueryResponse suivie de
       ReadyForQuery.
      </para>

      <para>
       En cas d'erreur, ErrorResponse est envoyé suivi de ReadyForQuery. Tous les
       traitements suivants de la chaîne sont annulés par ErrorResponse (quelque
       soit le nombre de requêtes restant à traiter). Ceci peut survenir au
       milieu de la séquence de messages engendrés par une requête individuelle.
      </para>

      <para>
       En mode de requêtage simple, les valeurs récupérées sont toujours au format
       texte, sauf si la commande est un <command>fetch</command> sur un curseur déclaré
       avec l'option <literal>binary</literal>. dans ce cas, les valeurs récupérées sont
       au format binaire. Les codes de format donnés dans le message RowDescription
       indiquent le format utilisé.
      </para>

    <para>
      La planification de requêtes pour des instructions préparées survient
      lorsque le message Parse est reçu. Si une requête sera exécuté de façon
      répété avec différents paramètres, il pourrait être bénéfique d'envoyer un
      seul message Parse contenant une requête avec paramètres, suivie de
      plusieurs messages Bind et Execute. Ceci évitera de planifier de nouveau
      la requête pour chaque exécution.
    </para>

    <para>
      L'instruction préparée non nommée est planifiée lors du traitement de Parse
      si le message Parse ne définit aucun paramètre. Mais s'il existe des
      paramètres, la planification de la requête est repoussée jusqu'à ce que le
      premier message Bind de cette instruction est reçu. Le planificateur
      considérera les valeurs réelles des paramètres fournies dans le message
      Bind lors de la planification de la requête.
    </para>

    <note>
       <para>
        Les plans de requêtes générés à partir d'une requête avec paramètres
        pourraient être moins efficaces que les plans de requêtes générés à partir
        d'une requête équivalente dont les valeurs de paramètres réelles ont été
        placées. Le planificateur de requêtes ne peut pas prendre les décisions
        suivant les valeurs réelles des paramètres (par exemple, la sélectivité
        de l'index) lors de la planification d'une requête avec paramètres affectée
        à un objet instruction préparée nommée. La pénalité possible est évitée
        lors de l'utilisation d'une instruction non nommée car elle n'est pas
        planifiée jusqu'à ce que des valeurs réelles de paramètres soient
        disponibles.
       </para>

       <para>
        Si un autre Bind référençant l'objet instruction préparée non nommée est
        reçu, la requête n'est pas de nouveau planifiée. Les valeurs de paramètres
        utilisées dans le premier message Bind pourrait produire un plan de requête
        qui est seulement efficace pour un sous-ensemble des valeurs de paramètres
        possibles. Pour forcer une nouvelle planification de la requête pour un
        ensemble nouveau de paramètres, envoyez un autre message Parse pour
        remplacer l'objet instruction préparée non nommée.
       </para>
    </note>

       <para>
       Un client doit être préparé à accepter des messages ErrorResponse et
       NoticeResponse quand bien même il s'attendrait à un autre type de message.
       Voir aussi <xref linkend="protocol-async"/> concernant les messages que le
       client pourrait engendrer du fait d'événements extérieurs.
       </para>

       <para>
       La bonne pratique consiste à coder les clients dans un style machine-état
       qui acceptera tout type de message à tout moment plutôt que de parier sur
       la séquence exacte des messages.
       </para>
     </sect2>

    <sect2 id="protocol-flow-ext-query">
      <title>Requête étendue</title>

      <para>
       Le protocole de requête étendu divise le protocole de requêtage simple décrit
       ci-dessus en plusieurs étapes. Les résultats des étapes de préparation
       peuvent être réutilisés plusieurs fois pour plus d'efficacité. De plus,
       des fonctionnalités supplémentaires sont disponibles, telles que la
       possibilité de fournir les valeurs des données comme des paramètres séparés
       au lieu d'avoir à les insérer directement dans une chaîne de requêtes.
      </para>

      <para>
       Dans le protocole étendu, le client envoie tout d'abord un message Parse
       qui contient une chaîne de requête, optionnellement quelques informations
       sur les types de données aux emplacements des paramètres, et le nom de
       l'objet de destination d'une instruction préparée (une chaîne vide
       sélectionne l'instruction préparée sans nom). La réponse est soit
       ParseComplete soit ErrorResponse. Les types de données des paramètres
       peuvent être spécifiés par l'OID&nbsp;; dans le cas contraire, l'analyseur
       tente d'inférer les types de données de la même façon qu'il le ferait pour
       les constantes chaînes littérales non typées.
      </para>

      <note>
       <para>
        La chaîne contenue dans un message Parse ne peut pas inclure plus d'une
        instruction SQL, sinon une erreur de syntaxe est rapportée. Cette
        restriction n'existe pas dans le protocole de requête simple, mais est
        présente dans le protocole étendu. En effet, permettre aux instructions
        préparées ou aux portails de contenir de multiples commandes compliquerait
        inutilement le protocole.
       </para>
      </note>

      <para>
       En cas de succès de sa création, une instruction préparée nommée dure
       jusqu'à la fin de la session courante, sauf si elle est détruite
       explicitement. Une instruction préparée non nommée ne dure que jusqu'à
       la prochaine instruction Parse spécifiant l'instruction non nommée comme
       destination. Un simple message Query détruit également l'instruction non
       nommée. Les instructions préparées nommées doivent être explicitement
       closes avant de pouvoir être redéfinies par un message Parse. Ce n'est
       pas obligatoire pour une instruction non nommée. Il est également possible
       de créer des instructions préparées nommées, et d'y accéder, en ligne de
       commandes SQL à l'aide des instructions <command>prepare</command> et
       <command>execute</command>.
      </para>

      <para>
       Dès lors qu'une instruction préparée existe, elle est déclarée exécutable
       par un message Bind. Le message Bind donne le nom de l'instruction préparée
       source (une chaîne vide désigne l'instruction préparée non nommée), le nom
       du portail destination (une chaîne vide désigne le portail non nommé) et les
       valeurs à utiliser pour tout emplacement de paramètres présent dans
       l'instruction préparée. L'ensemble des paramètres fournis doit
       correspondre à ceux nécessaires à l'instruction préparée. Bind spécifie aussi
       le format à utiliser pour toutes les données renvoyées par la requête&nbsp;;
       le format peut être spécifié complètement ou par colonne. La réponse est, soit
       BindComplete, soit ErrorResponse.
      </para>

      <note>
       <para>
        Le choix entre sortie texte et binaire est déterminé par les codes
        de format donnés dans Bind, quelque soit la commande SQL impliquée.
        L'attribut <literal>binary</literal> dans les déclarations du curseur n'est pas
        pertinent lors de l'utilisation du protocole de requête étendue.
       </para>
      </note>

      <para>
       En cas de succès de sa création, un objet portail nommé dure jusqu'à la fin
       de la transaction courante sauf s'il est explicitement détruit. Un
       portail non nommé est détruit à la fin de la transaction ou dès la prochaine
       instruction Bind spécifiant le portail non nommé comme destination.
       Un simple message Query détruit également le portail non nommé. Les
       portails nommés doivent être explicitement fermés avant de pouvoir être
       redéfinis par un message Bind. Cela n'est pas obligatoire pour le portail non
       nommé. Il est également possible de créer des portails nommés, et d'y
       accéder, en ligne de commandes SQL à l'aide des instructions
       <command>declare cursor</command> et <command>fetch</command>.
      </para>

      <para>
       Dès lors qu'un portail existe, il peut être exécuté à l'aide d'un message
       Execute. Ce message spécifie le nom du portail (une chaîne vide désigne le
       portail non nommé) et un nombre maximum de lignes de résultat (zéro
       signifiant la <quote>récupération de toutes les lignes</quote>). le nombre de lignes
       de résultat a seulement un sens pour les portails contenant des commandes
       qui renvoient des ensembles de lignes&nbsp;; dans les autres cas, la
       commande est toujours exécutée jusqu'à la fin et le nombre de lignes est
       ignoré. Les réponses possibles d'Execute sont les même que celles
       décrites ci-dessus pour les requêtes lancées via le protocole de requête
       simple, si ce n'est qu'Execute ne cause pas l'envoi de ReadyForQuery ou de
       RowDescription.
      </para>

      <para>
       Si Execute se termine avant la fin de l'exécution d'un portail (du fait
       d'un nombre de lignes de résultats différent de zéro), il enverra un
       message PortalSuspended&nbsp;; la survenue de ce message indique au client
       qu'un autre Execute devrait être lancé sur le même portail pour terminer
       l'opération. Le message CommandComplete indiquant la fin de la commande
       SQL n'est pas envoyé avant l'exécution complète du portail. Une phase
       Execute est toujours terminée par la survenue d'un seul de ces
       messages&nbsp;: CommandComplete, EmptyQueryResponse (si le portail a été
       créé à partir d'une chaîne de requête vide), ErrorResponse ou PortalSuspended.
      </para>

      <para>
       À la réalisation complète de chaque série de messages de requêtes étendues,
       le client doit lancer un message Sync. Ce message sans paramètre oblige
       le serveur à fermer la transaction courante si elle n'est pas à l'intérieur
       d'un bloc de transaction <command>begin</command>/<command>commit</command>
       (<quote>fermer</quote> signifiant valider en l'absence d'erreur ou annuler sinon).
       Une réponse ReadyForQuery est alors envoyée. Le but de Sync est de fournir
       un point de resynchronisation pour les récupérations d'erreurs. Quand une
       erreur est détectée lors du traitement d'un message de requête étendue, le
       serveur lance ErrorResponse, puis lit et annule les messages jusqu'à ce
       qu'un Sync soit atteint. Il envoie ensuite ReadyForQuery et retourne au
       traitement normal des messages. Aucun échappement n'est réalisé si une erreur
       est détectée <emphasis>lors</emphasis> du traitement de sync &mdash; l'unicité du
       ReadyForQuery envoyé pour chaque Sync est ainsi assurée.
      </para>

      <note>
       <para>
        Sync n'impose pas la fermeture d'un bloc de transactions ouvert avec
        <command>begin</command>. cette situation est détectable car le message
        ReadyForQuery inclut le statut de la transaction.
       </para>
      </note>

      <para>
       En plus de ces opérations fondamentales, requises, il y a plusieurs opérations
       optionnelles qui peuvent être utilisées avec le protocole de requête étendue.
      </para>

      <para>
       Le message Describe (variante de portail) spécifie le nom d'un portail
       existant (ou une chaîne vide pour le portail non nommé). La réponse est un
       message RowDescription décrivant les lignes qui seront renvoyées par
       l'exécution du portail&nbsp;; ou un message NoData si le portail ne contient
       pas de requête renvoyant des lignes&nbsp;; ou ErrorResponse le portail
       n'existe pas.
      </para>

      <para>
       Le message Describe (variante d'instruction) spécifie le nom d'une
       instruction préparée existante (ou une chaîne vide pour l'instruction
       préparée non nommée). La réponse est un message ParameterDescription
       décrivant les paramètres nécessaires à l'instruction, suivi d'un message
       RowDescription décrivant les lignes qui seront renvoyées lors de l'éventuelle
       exécution de l'instruction (ou un message NoData si l'instruction ne renvoie pas
       de lignes). ErrorResponse est retourné si l'instruction préparée n'existe
       pas. Comme Bind n'a pas encore été exécuté, les formats à utiliser
       pour les lignes retournées ne sont pas encore connues du serveur&nbsp;; dans
       ce cas, les champs du code de format dans le message RowDescription seront
       composés de zéros.
      </para>

      <tip>
       <para>
        Dans la plupart des scénarios, le client devra exécuter une des variantes de
        Describe avant de lancer Execute pour s'assurer qu'il sait interpréter
        les résultats reçus.
       </para>
      </tip>

      <para>
       Le message Close ferme une instruction préparée ou un portail et libère les
       ressources. L'exécution de Close sur une instruction ou un portail
       inexistant ne constitue pas une erreur. La réponse est en général
       CloseComplete mais peut être ErrorResponse si une difficulté quelconque est
       rencontrée lors de la libération des ressources. Clore une instruction
       préparée ferme implicitement  tout autre portail ouvert construit à partir
       de cette instruction.
      </para>

      <para>
       Le message Flush n'engendre pas de sortie spécifique, mais
       force le serveur à délivrer toute donnée restante dans les tampons de
       sortie. Un Flush doit être envoyé après toute commande de requête étendue,
       à l'exception de Sync, si le client souhaite examiner le résultat de cette
       commande avant de lancer d'autres commandes. Sans Flush, les messages
       retournés par le serveur seront combinés en un nombre minimum de paquets
       pour minimiser la charge réseau.
      </para>

      <note>
       <para>
        Le message Query simple est approximativement équivalent aux séries Parse,
        Bind, Describe sur un portail, Execute, Close, Sync utilisant les
        objets de l'instruction préparée ou du portail, non nommés et sans
        paramètres. Une différence est l'acceptation de plusieurs instructions SQL
        dans la chaîne de requêtes, la séquence bind/describe/execute étant
        automatiquement réalisée pour chacune, successivement. Il en diffère
        également en ne retournant pas les messages ParseComplete, BindComplete,
        CloseComplete ou NoData.
       </para>
      </note>
     </sect2>

    <sect2>
     <title>Appel de fonction</title>

     <para>
     Le sous-protocole d'appel de fonction (NDT&nbsp;: Function Call dans la
     version originale) permet au client d'effectuer un appel direct à toute
     fonction du catalogue système <structname>pg_proc</structname> de la base de
     données. Le client doit avoir le droit d'exécution de la fonction.
     </para>

     <note>
      <para>
      Le sous-protocole d'appel de fonction est une fonctionnalité qu'il vaudrait
      probablement mieux éviter dans tout nouveau code. Des résultats similaires
      peuvent être obtenus en initialisant une instruction préparée qui lance
      <literal>select function($1, ...)</literal>. le cycle de l'appel de fonction peut
      alors être remplacé par Bind/Execute.
      </para>
     </note>

     <para>
      Un cycle d'appel de fonction est initié par le client envoyant un message
     FunctionCall au serveur. Le serveur envoie alors un ou plusieurs messages de
     réponse en fonction des résultats de l'appel de la fonction et finalement un
     message de réponse ReadyForQuery. ReadyForQuery informe le client qu'il
     peut envoyer en toute sécurité une nouvelle requête ou un nouvel appel de
     fonction.
     </para>

     <para>
    Les messages de réponse possibles du serveur sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>errorresponse</term>
      <listitem>
       <para>
        Une erreur est survenue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>functioncallresponse</term>
      <listitem>
       <para>
        L'appel de la fonction est terminé et a retourné le résultat
	donné dans le message. Le protocole d'appel de fonction ne peut
	gérer qu'un résultat scalaire simple, pas un type ligne ou un
	ensemble de résultats.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>readyforquery</term>
      <listitem>
       <para>
        Le traitement de l'appel de fonction est terminé. ReadyForQuery sera
	toujours envoyé, que le traitement se termine avec succès ou avec une
	erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>noticeresponse</term>
      <listitem>
       <para>
        Un message d'avertissement relatif à l'appel de fonction a été retourné.
	Les avertissements sont complémentaires des autres réponses,
	c'est-à-dire que le seveur continuera à traiter la commande.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="protocol-copy">
     <title>Opérations copy</title>

     <para>
     La commande <command>copy</command> permet des transferts rapides de données en lot
     vers ou à partir du serveur. Les opérations Copy-in et Copy-out basculent
     chacune la connexion dans un sous-protocole distinct qui existe jusqu'à la
     fin de l'opération.
     </para>

     <para>
      Le mode Copy-in (transfert de données vers le serveur) est initié quand le
     serveur exécute une instruction SQL <command>copy from stdin</command>. le serveur
     envoie une message CopyInResponse au client. Le client peut alors envoyer
     zéro (ou plusieurs) message(s) CopyData, formant un flux de données en
     entrée (il n'est pas nécessaire que les limites du message aient un
     rapport avec les limites de la ligne, mais cela est souvent un choix
     raisonnable). Le client peut terminer le mode Copy-in en envoyant un
     message CopyDone (permettant une fin avec succès) ou un message CopyFail
     (qui causera l'échec de l'instruction SQL <command>copy</command> avec une erreur).
     Le serveur retourne alors au mode de traitement de la commande précédant le
     début de <command>copy</command>, protocole de requête simple ou étendu. il
     enverra enfin CommandComplete (en cas de succès) ou ErrorResponse (sinon).
     </para>

     <para>
     Si le serveur détecte un erreur en mode copy-in (ce qui inclut la
     réception d'un message CopyFail), il enverra un message ErrorResponse.
     Si la commande <command>copy</command> a été lancée à l'aide d'un message de
     requête étendue, le serveur annulera les messages du client jusqu'à
     ce qu'un message Sync soit reçu. Il enverra alors un message ReadyForQuery
     et retournera dans le mode de fonctionnement normal. Si la commande
     <command>copy</command> a été lancée dans un message
     simple Query, le reste de ce message est annulé et ReadyForQuery est envoyé.
     Dans tous les cas, les messages CopyData, CopyDone ou CopyFail suivants
     envoyés par l'interface seront simplement annulés.
     </para>

     <para>
     Le serveur ignorera les messages Flush et Sync reçus en mode copy-in. La
     réception de tout autre type de messages hors-copie constitue une
     erreur qui annulera l'état Copy-in, comme cela est décrit plus haut.
     L'exception pour Flush et Sync est faite pour les bibliothèques clientes
     qui envoient systématiquement Flush ou Sync après un message Execute sans
     vérifier si la commande à exécuter est <command>copy from stdin</command>.
     </para>

     <para>
      Le mode Copy-out (transfert de données à partir du serveur) est initié
     lorsque le serveur exécute une instruction SQL <command>copy to stdout</command>.
     Le moteur envoie un message CopyOutResponse au client suivi de zéro (ou
     plusieurs) message(s) CopyData (un par ligne), suivi de CopyDone.
     Le serveur retourne ensuite au mode de traitement de commande dans lequel il
     se trouvait avant le lancement de <command>copy</command> et envoie commandcomplete.
     Le client ne peut pas annuler le transfert (sauf en fermant la connexion ou en
     lançant une requête d'annulation, Cancel), mais il peut ignorer les messages
     CopyData et CopyDone non souhaités.
     </para>

     <para>
     Si le serveur détecte une erreur en mode Copy-out, il enverra un message
     ErrorResponse et retournera dans le mode de traitement normal. Le client
     devrait traiter la réception d'un message ErrorResponse comme terminant
     le mode <quote>copy-out</quote>.
   </para>

   <para>
    Il est possible que les messages NoticeResponse et ParameterStatus soient
    entremêlés avec des messages CopyData&nbsp;; les interfaces doivent gérer
    ce cas, et devraient être aussi préparées à d'autres types de messages
    asynchrones (voir <xref linkend="protocol-async"/>). Sinon, tout type
    de message autre que CopyData et CopyDone pourrait être traité comme
    terminant le mode copy-out.
   </para>

     <para>
      Les messages CopyInResponse et CopyOutResponse incluent les champs qui
     informent le client du nombre de colonnes par ligne et des codes de format
     de chaque colonne. Dans l'implantation actuelle, toutes les colonnes d'une
     opération <command>copy</command> donnée utilisent le même format, mais la
     conception du message n'en tient pas compte.
     </para>
    </sect2>

    <sect2 id="protocol-async">
      <title>Opérations asynchrones</title>

      <para>
       Il existe plusieurs cas pour lesquels le serveur enverra des messages qui ne
       sont pas spécifiquement demandés par le flux de commande du client. Les
       clients doivent être préparés à gérer ces messages à tout moment même si
       aucune requête n'est en cours. Vérifier ces cas avant de commencer à lire la
       réponse d'une requête est un minimum.
      </para>

      <para>
       Il est possible que des messages NoticeResponse soient engendrés en dehors de
       toute activité&nbsp;; par exemple, si l'administrateur de la base de données
       commande un arrêt <quote>rapide</quote> de la base de données, le serveur
       enverra un NoticeResponse l'indiquant avant de fermer la connexion. Les
       clients devraient toujours être prêts à accepter et afficher les messages
       NoticeResponse, même si la connexion est inactive.
      </para>

      <para>
       Des messages ParameterStatus seront engendrés à chaque fois que la valeur
       active d'un paramètre est modifiée, et cela pour tout paramètre que le
       serveur pense utile au client. Cela survient plus généralement en réponse à
       une commande SQL <command>set</command> exécutée par le client. ce cas est en fait
       synchrone &mdash; mais il est possible aussi que le changement de statut d'un
       paramètre survienne à la suite d'une modification par l'administrateur des
       fichiers de configuration&nbsp;; changements suivis de l'envoi du signal
       <systemitem>sighup</systemitem> au postmaster. de plus, si une commande set
       est annulée, un message ParameterStatus approprié sera engendré pour
       rapporter la valeur effective.
      </para>

      <para>
       À ce jour, il existe un certain nombre de paramètres codés en dur pour
       lesquels des messages ParameterStatus seront engendrés&nbsp;: on trouve
     <literal>server_version</literal>,
     <literal>client_encoding</literal>,
     <literal>server_encoding</literal>,
     <literal>is_superuser</literal>,
     <literal>session_authorization</literal> et
     <literal>session_authorization</literal>,
     <literal>datestyle</literal>,
     <literal>timezone</literal> et
     <literal>integer_datetimes</literal>
     (<literal>server_encoding</literal>, <literal>timezone</literal> et
     <literal>integer_datetimes</literal> n'ont pas été reportés par les sorties avant
     la 8.0). Notez que
     <literal>server_version</literal>,
     <literal>server_encoding</literal> et
     <literal>integer_datetimes</literal> sont des pseudo-paramètres qui ne peuvent pas
     changer après le lancement.
       Cet ensemble pourrait changer dans le futur, voire devenir configurable.
       De toute façon, un client peut ignorer un message ParameterStatus
       pour les paramètres qu'il ne comprend pas ou qui ne le concernent pas.
      </para>

      <para>
       Si un client lance une commande <command>listen</command>, alors le serveur
       enverra un message NotificationResponse (à ne pas confondre avec
       NoticeResponse&nbsp;!) à chaque fois qu'une commande
       <command>notify</command> est exécutée pour la notification de même nom.
      </para>

      <note>
       <para>
        Actuellement, NotificationResponse ne peut être envoyé qu'à l'extérieur
        d'une transaction. Il ne surviendra donc pas au milieu d'une réponse à une
        commande, mais il peut survenir juste avant ReadyForQuery.
        Il est toutefois déconseillé de concevoir un client en partant de ce
        principe. La bonne pratique est d'être capable d'accepter
        NotificationResponse à tout moment du protocole.
       </para>
      </note>
     </sect2>

    <sect2>
      <title>Annulation de requêtes en cours</title>

      <para>
       Pendant le traitement d'une requête, le client peut demander
       l'annulation de la requête. La demande d'annulation n'est pas envoyée
       directement au serveur par la connexion ouverte pour des raisons
       d'efficacité de l'implémentation&nbsp;: il n'est pas admissible que le
       serveur vérifie constamment les messages émanant du client lors du
       traitement des requêtes. Les demandes d'annulation sont relativement
       inhabituelles&nbsp;; c'est pourquoi elles sont traitées de manière
       relativement simple afin d'éviter que ce traitement ne pénalise le
       fonctionnement normal.
      </para>

      <para>
       Pour effectuer une demande d'annulation, le client ouvre une nouvelle
       connexion au serveur et envoie un message CancelRequest à la place du
       message StartupMessage envoyé habituellement à l'ouverture d'une connexion.
       Le serveur traitera cette requête et fermera la connexion. Pour des raisons
       de sécurité, aucune réponse directe n'est faite au message de requête
       d'annulation.
      </para>

      <para>
       Un message CancelRequest sera ignoré sauf s'il contient la même donnée clé
       (PID et clé secrète) que celle passée au client lors du démarrage de la
       connexion. Si la donnée clé correspond, le traitement de la requête en cours
       est annulé (dans l'implantation existante, ceci est obtenu en envoyant un
       signal spécial au processus serveur qui traite la requête).
      </para>

      <para>
       Le signal d'annulation peut ou non être suivi d'effet &mdash; par exemple, s'il
       arrive après la fin du traitement de la requête par le serveur, il n'aura
       alors aucun effet. Si l'annulation est effective, il en résulte la fin
       précoce de la commande accompagnée d'un message d'erreur.
      </para>

      <para>
       De tout ceci, il ressort que, pour des raisons de sécurité et d'efficacité,
       le client n'a aucun moyen de savoir si la demande d'annulation a abouti.
       Il continuera d'attendre que le serveur réponde à la requête. Effectuer une
       annulation permet simplement d'augmenter la probabilité de voir la requête
       en cours finir rapidement et échouer accompagnée d'un message d'erreur
       plutôt que réussir.
      </para>

      <para>
       Comme la requête d'annulation est envoyée via une nouvelle connexion au
       serveur et non pas au travers du lien de communication client/serveur établi,
       il est possible que la requête d'annulation soit lancée par un processus
       quelconque, pas forcément celui du client pour lequel la requête doit être
       annulée. Cela peut fournir une flexibilité supplémentaire dans la
       construction d'applications multi-processus&nbsp;; mais également une faille
       de sécurité puisque des personnes non autorisées pourraient tenter d'annuler
       des requêtes. La faille de sécurité est comblée par l'exigence d'une clé
       secrète, engendrée dynamiquement, pour toute requête d'annulation.
      </para>
     </sect2>

    <sect2>
      <title>Fin</title>

      <para>
       Lors de la procédure normale de fin le client envoie un message Terminate et
       ferme immédiatement la connexion. À la réception de ce message, le
       serveur ferme la connexion et s'arrête.
      </para>

      <para>
       Dans de rares cas (tel un arrêt de la base de données par l'administrateur),
       le serveur peut se déconnecter sans demande du client. Dans de tels cas,
       le serveur tentera d'envoyer un message d'erreur ou d'avertissement en
       donnant la raison de la déconnexion avant de fermer la connexion.
      </para>

      <para>
       D'autres scénarios de fin peuvent être dus à différents cas d'échecs,
       tels qu'un <quote>core dump</quote> côté client ou serveur, la perte du lien
       de communications, la perte de synchronisation des limites du message, etc.
       Que le client ou le serveur s'aperçoive d'une fermeture de la connexion, le
       buffer sera vidé et le processus terminé. Le client a la possibilité de
       lancer un nouveau processus serveur en recontactant le serveur s'il ne
       souhaite pas se finir. Il peut également envisager de clore la
       connexion si un type de message non reconnu est reçu&nbsp;; en effet, ceci
       est probablement le résultat de la perte de synchronisation des limite de
       messages.
      </para>

      <para>
       Que la fin soit normale ou non, toute transaction ouverte est annulée, non
       pas validée. Si un client se déconnecte alors qu'une requête autre que
       <command>select</command> est en cours de traitement, le serveur terminera
       probablement la requête avant de prendre connaissance de la déconnexion.
       Si la requête est en dehors d'un bloc de transaction (séquence
       <command>begin</command> ... <command>commit</command>), il se peut que les résultats
       soient validés avant que la connexion ne soit reconnue.
      </para>
     </sect2>

     <sect2>
      <title>Chiffrement <acronym>ssl</acronym> de session</title>

      <para>
       Si <productname>postgresql</productname> a été construit avec le support de
       <acronym>ssl</acronym>, les communications client/serveur peuvent être chiffrées
       en l'utilisant. Ce chiffrement assure la sécurité de la communication
       dans les environnements où des agresseurs pourraient capturer le trafic
       de la session. Pour plus d'informations sur le cryptage des sessions
       <productname>postgresql</productname> avec <acronym>ssl</acronym>, voir
       <xref linkend="ssl-tcp"/>.
      </para>

      <para>
       Pour initier une connexion chiffrée par <acronym>ssl</acronym>, le client envoie
       initialement un message SSLRequest à la place d'un StartupMessage. Le
       serveur répond avec un seul octet contenant <literal>s</literal> ou <literal>n</literal>
       indiquant respectivement s'il souhaite ou non utiliser le <acronym>ssl</acronym>.
       Le client peut alors clore la connexion s'il n'est pas satisfait de la
       réponse. Pour continuer après un <literal>s</literal>, il faut échanger une poignée
       de main <acronym>ssl</acronym> (handshake) (non décrite ici car faisant partie de
       la spécification <acronym>ssl</acronym>) avec le serveur. en cas de succès, le
       StartupMessage habituel est envoyé. Dans ce cas, StartupMessage et toutes
       les données suivantes seront chiffrées avec <acronym>ssl</acronym>. pour continuer
       après un <literal>n</literal>, il suffit d'envoyer le startupmessage habituel et
       de continuer sans chiffrage.
      </para>

      <para>
       Le client doit être préparé à gérer une réponse ErrorMessage à un SSLRequest
       émanant du serveur. Ceci ne peut survenir que si le serveur ne dispose pas
       du support de <acronym>ssl</acronym>. dans ce cas, la connexion doit être fermée,
       mais le client peut choisir d'ouvrir une nouvelle connexion et procéder
       sans <acronym>ssl</acronym>.
      </para>

      <para>
       Un SSLRequest initial peut également être utilisé dans une connexion en
       cours d'ouverture pour envoyer un message CancelRequest.
      </para>

      <para>
       Alors que le protocole lui-même ne fournit pas au serveur de moyen de
       forcer le chiffrage <acronym>ssl</acronym>, l'administrateur peut configurer le
       serveur pour rejeter les sessions non chiffrées, ce qui est une autre
       façon de vérifier l'authentification.
      </para>
     </sect2>
    </sect1>

   <sect1 id="protocol-message-types">
   <title>Types de données des message</title>

   <para>
   Cette section décrit les types de données basiques utilisés dans les messages.

   <variablelist>

  <varlistentry>
  <term>
          Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)
</term>
<listitem>
<para>
                Un entier sur <replaceable>n</replaceable> bits dans l'ordre des
		octets réseau (octet le plus significatif en premier). Si
		<replaceable>i</replaceable> est spécifié, c'est exactement
		la valeur qui apparaîtra, sinon la valeur est
		variable, par exemple Int16, Int32(42).
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]
</term>
<listitem>
<para>
		Un tableau de <replaceable>k</replaceable> entiers sur
                <replaceable>n</replaceable> bits, tous dans l'ordre des octets
		réseau. La longueur <replaceable>k</replaceable> du tableau est
		toujours déterminée par un champ précédent du message, par
		exemple, Int16[M].
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        String(<replaceable>s</replaceable>)
</term>
<listitem>
<para>
                Une chaîne terminée par un octet nul (chaîne style C). Il n'y
		a pas de limitation sur la longueur des chaînes. Si
		<replaceable>s</replaceable> est spécifié, c'est la valeur exacte
		qui apparaîtra, sinon la valeur est variable. Par exemple,
		String("utilisateur").
</para>

<note>
<para>
<emphasis>il n'y a aucune limite prédéfinie</emphasis> à la longueur d'une
chaîne retournée par le serveur. Une bonne stratégie de codage
de client consiste à utiliser un tampon dont la taille peut croître pour que
tout ce qui tient en mémoire puisse être accepté. Si cela n'est pas
faisable, il faudra lire la chaîne complète et supprimer les caractères
qui ne tiennent pas dans le tampon de taille fixe.
</para>
</note>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)
</term>
<listitem>
<para>
                Exactement <replaceable>n</replaceable> octets. si la largeur
		<replaceable>n</replaceable> du champ n'est pas une constante,
		elle peut toujours être déterminée à partir d'un champ précédent
		du message. Si <replaceable>c</replaceable> est spécifié, c'est
		la valeur exacte. Par exemple, Byte2, Byte1('\n').
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</sect1>

<sect1 id="protocol-message-formats">
<title>Formats de message</title>

<para>
Cette section décrit le format détaillé de chaque message. Chaque message est
marqué pour indiquer s'il peut être envoyé par un client (F pour
<foreignphrase>frontend</foreignphrase>), un serveur (B pour
<foreignphrase>backend</foreignphrase>) ou les deux (F &amp; B). bien
que chaque message commence par son nombre d'octets, le format du message est
défini de telle sorte que la fin du message puisse être trouvée sans ce nombre.
Cela contribue à la vérification de la validité. Le message CopyData
est une exception car il constitue une partie du flux de données&nbsp;; le contenu
d'un message CopyData individuel n'est, en soi, pas interprétable.
</para>

<variablelist>


<varlistentry>
<term>
AuthenticationOk (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Marqueur de demande d'authentification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(0)
</term>
<listitem>
<para>
                L'authentification a réussi.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationKerberosV5 (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Marqueur de demande d'authentification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(2)
</term>
<listitem>
<para>
                Une authentification Kerberos V5 est requise.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationCleartextPassword (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Marqueur de demande d'authentification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(3)
</term>
<listitem>
<para>
                Un mot de passe en clair est requis.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationCryptPassword (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Marqueur de demande d'authentification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(10)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Un mot de passe chiffré à l'aide de crypt() est requis.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte2
</term>
<listitem>
<para>
                Composant (salt) à utiliser lors du chiffrement du mot de
		passe.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationMD5Password (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Marqueur de demande d'authentification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
                Un mot de passe chiffré par MD5 est requis.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte4
</term>
<listitem>
<para>
                Composant (salt) à utiliser lors du chiffrement du mot de passe.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationSCMCredential (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Marqueur de demande d'authentification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(6)
</term>
<listitem>
<para>
                Un message d'accréditation SCM est requis.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationGSS (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifie le message en tant que requête d'authentification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Longueur du contenu du message en octets, lui-même inclus.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(7)
</term>
<listitem>
<para>
                Spécifie qu'une authentification GSSAPI est requise.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationSSPI (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifie le message en tant que requête d'authentification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Longueur du message en octet, incluant la longueur.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(9)
</term>
<listitem>
<para>
                Specifie que l'authentification SSPI est requise.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
AuthenticationGSSContinue (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifie le message comme une requête d'authentification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Longueur du message en octet, incluant la longueur.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Spécifie que ce message contient des données GSSAPI ou SSPI.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                Données d'authentification GSSAPI.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
BackendKeyData (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
		Marqueur de clé d'annulation. Le
		client doit sauvegarder ces valeurs s'il souhaite initier des
		messages CancelRequest par la suite.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID du processus du serveur concerné.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Clé secrète du serveur concerné.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Bind (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('B')
</term>
<listitem>
<para>
                Marqueur de commande Bind.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
		Nom du portail de destination
		(une chaîne vide sélectionne le portail non-nommé).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
		Nom de l'instruction source préparée
		(une chaîne vide sélectionne l'instruction préparée non-nommée).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
		Nombre de codes de format de paramètres qui suivent (notés
		<replaceable>c</replaceable> ci-dessous). peut valoir zéro pour indiquer
		qu'il n'y a aucun paramètre ou que tous les paramètres utilisent
		le format par défaut (texte)&nbsp;; ou un, auquel cas le code de
		format spécifié est appliqué à tous les paramètres&nbsp;; il
		peut aussi être égal au nombre courant de paramètres.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>c</replaceable>]
</term>
<listitem>
<para>
		Codes de format des paramètres. Tous doivent valoir zéro
		(texte) ou un (binaire).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
		Nombre de valeurs de paramètres qui suivent (peut valoir zéro).
		Cela doit correspondre au nombre de paramètres nécessaires à la
		requête.
</para>
</listitem>
</varlistentry>
</variablelist>
		Puis, le couple de champs suivant apparaît pour chaque paramètre&nbsp;:
		paramètre&nbsp;:
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
		Taille de la valeur du paramètre, en octets (ce nombre 
		n'inclut pas la longueur elle-même). Peut valoir zéro. 
		Traité comme un cas spécial, -1 indique une valeur de paramètre 
		NULL. Aucun octet de valeur ne suit le cas NULL.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
		Valeur du paramètre, dans le format indiqué par le code de
		format associé. <replaceable>n</replaceable> est la longueur ci-dessus.
</para>
</listitem>
</varlistentry>
</variablelist>
        Après le dernier paramètre, les champs suivants apparaissent&nbsp;:
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
		Nombre de codes de format des colonnes de résultat qui
		suivent (noté <replaceable>r</replaceable> ci-dessous). peut valoir zéro 
		pour indiquer qu'il n'y a pas de colonnes de résultat ou que les
		colonnes de résultat utilisent le format par défaut 
		(texte)&nbsp;; ou une, auquel cas le code de format spécifié est
		appliqué à toutes les colonnes de résultat (s'il y en a)&nbsp;; 
		il peut aussi être égal au nombre de colonnes de résultat de la 
		requête.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>r</replaceable>]
</term>
<listitem>
<para>
		Codes de format des colonnes de résultat. Tous doivent 
		valoir zéro (texte) ou un (binaire).
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
BindComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('2')
</term>
<listitem>
<para>
                Indicateur de Bind complet.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CancelRequest (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32(16)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877102)
</term>
<listitem>
<para>
		Code d'annulation de la requête. La valeur est choisie pour
		contenir <literal>1234</literal> dans les 16 bits les plus 
		significatifs et <literal>5678</literal> dans les 16 bits les moins 
		significatifs (pour éviter toute confusion, ce code ne doit pas 
		être le même qu'un numéro de version de protocole).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID du processus du serveur cible.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Clé secrète du serveur cible.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Close (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
                Marqueur de commande Close.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                '<literal>s</literal>' pour fermer une instruction préparée&nbsp;; ou
                '<literal>p</literal>' pour fermer un portail.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
		Nom de l'instruction préparée ou du portail à fermer (une
		chaîne vide sélectionne l'instruction préparée ou le portail
		non-nommé(e)).
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CloseComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('3')
</term>
<listitem>
<para>
                Indicateur de complétude de Close.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CommandComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
                Marqueur de réponse de complétude de commande.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
       <para>
        Balise de la commande. Mot simple identifiant la commande SQL terminée.
       </para>

       <para>
        Pour une commande <command>insert</command>, la balise est
        <literal>insert <replaceable>oid</replaceable>
        <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> est le nombre de lignes insérées.
        <replaceable>oid</replaceable> est l'id de l'objet de la ligne insérée
        si <replaceable>lignes</replaceable> vaut 1 et que la table cible a des
	OID&nbsp;; sinon <replaceable>oid</replaceable> vaut 0.
       </para>

       <para>
        Pour une commande <command>delete</command>, la balise est
	<literal>delete <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> est le nombre de lignes supprimées.
       </para>

       <para>
        Pour une commande <command>update</command>, la balise est
	<literal>update <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> est le nombre de lignes mises à jour.
       </para>

       <para>
        Pour une commande <command>move</command>, la balise est
        <literal>move <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> est le nombre de lignes de déplacement
	du curseur.
       </para>

       <para>
        Pour une commande <command>fetch</command>, la balise est
        <literal>fetch <replaceable>lignes</replaceable></literal> où
        <replaceable>lignes</replaceable> est le nombre de lignes 
        récupérées à partir du curseur.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyData (F &amp; B)
</term>
<listitem>
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('d')
</term>
<listitem>
<para>
                Marqueur de données de COPY.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
		Données formant une partie d'un flux de données 
		<command>copy</command>. les messages envoyés depuis le serveur
		correspondront toujours à des lignes uniques de données, mais 
		les messages envoyés par les clients peuvent diviser le flux de 
		données de façon arbitraire.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyDone (F &amp; B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('c')
</term>
<listitem>
<para>
                Indicateur de fin de COPY.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyFail (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('f')
</term>
<listitem>
<para>
                Indicateur d'échec de COPY.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Message d'erreur rapportant la cause d'un échec.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyInResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('G')
</term>
<listitem>
<para>
                Marqueur de réponse de Start Copy In.
                Le client doit alors envoyer des données de copie (s'il n'est 
		pas à cela, il enverra un message CopyFail).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                0 indique que le format de copie complet est textuel (lignes
 		séparées par des retours chariot, colonnes séparées par des
 		caractères de séparation, etc). 1 indique que le format de copie
 		complet est binaire (similaire au format DataRow).
 		Voir <xref linkend="sql-copy" endterm="sql-copy-title"/> pour
 		plus d'informations.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
		Nombre de colonnes dans les données à copier (noté
		<replaceable>n</replaceable> ci-dessous).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>n</replaceable>]
</term>
<listitem>
<para>
                Codes de format à utiliser pour chaque colonne. Chacun doit
		valoir zéro (texte) ou un (binaire). Tous doivent valoir zéro si
		le format de copie complet est de type texte.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyOutResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
                Marqueur de réponse Start Copy Out.
                Ce message sera suivi de données copy-out.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                0 indique que le format de copie complet est textuel (lignes
		séparées par des retours chariots, colonnes séparées par des
		caractères séparateur, etc). 1 indique que le format de copie
		complet est binaire (similaire au format DataRow).
		Voir <xref linkend="sql-copy" endterm="sql-copy-title"/> pour
		plus d'informations.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
		Nombre de colonnes de données à copier (noté
		<replaceable>n</replaceable> ci-dessous).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>n</replaceable>]
</term>
<listitem>
<para>
                Codes de format à utiliser pour chaque colonne. Chaque code
		doit valoir zéro (texte) ou un (binaire). Tous doivent valoir
		zéro si le format de copie complet est de type texte.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
DataRow (B)
</term>
<listitem>
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
                Marqueur de ligne de données.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Nombre de valeurs de colonnes qui suivent (peut valoir zéro).
</para>
</listitem>
</varlistentry>
</variablelist>
        Apparaît ensuite le couple de champs suivant, pour chaque colonne&nbsp;:
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Longueur de la valeur de la colonne, en octets (ce nombre
		n'inclut pas la longueur elle-même). Peut valoir zéro.
		Traité comme un cas spécial, -1 indique une valeur NULL de
		colonne. Aucun octet de valeur ne suit le cas NULL.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                Valeur de la colonne dans le format indiqué par le code de
		format associé. <replaceable>n</replaceable> est la longueur
		ci-dessus.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Describe (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
                Marqueur de commande Describe.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                '<literal>s</literal>' pour décrire une instruction préparée&nbsp;; ou
                '<literal>p</literal>' pour décrire un portail.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Nom de l'instruction préparée ou du portail à décrire (une
		chaîne vide sélectionne l'instruction préparée ou le portail
		non-nommé(e)).
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
EmptyQueryResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('I')
</term>
<listitem>
<para>
                Marqueur de réponse à une chaîne de requête vide (c'est un
		substitut de CommandComplete).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ErrorResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
                Marqueur d'erreur.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>
        Le corps du message est constitué d'un ou plusieurs champs identifié(s),
	suivi(s) d'un octet nul comme terminateur. L'ordre des champs n'est pas
	fixé. Pour chaque champ, on trouve les informations suivantes&nbsp;:
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                Code identifiant le type de champ&nbsp;; s'il vaut zéro,
		c'est la fin du message et aucune chaîne ne suit. Les types de
		champs définis sont listés dans
		<xref linkend="protocol-error-fields"/>. de nouveaux types de
		champs pourraient être ajoutés dans le futur, les clients
		doivent donc ignorer silencieusement les types non reconnus.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Valeur du champ.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Execute (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
                Marqueur de commande Execute.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Nom du portail à exécuter (une chaîne vide sélectionne le
		portail non-nommé).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Nombre maximum de lignes à retourner si le portail contient une
		requête retournant des lignes (ignoré sinon). Zéro signifie
		<quote>aucune limite</quote>.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Flush (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
                Marqueur de commande Flush.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
FunctionCall (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('F')
</term>
<listitem>
<para>
                Marqueur d'appel de fonction.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Spécifie l'ID de l'objet représentant la fonction à appeler.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
 		Nombre de codes de format de l'argument qui suivent
 		(noté <replaceable>c</replaceable> ci-dessous). cela peut être zéro pour
 		indiquer qu'il n'y a pas d'arguments ou que tous les arguments
 		utilisent le format par défaut (texte)&nbsp;; un, auquel cas
 		le code de format est appliqué à tous les arguments&nbsp;; il
 		peut aussi être égal au nombre réel d'arguments.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>c</replaceable>]
</term>
<listitem>
<para>
                Les codes de format d'argument. Chacun doit valoir zéro
		(texte) ou un (binaire).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Nombre d'arguments fournis à la fonction.
</para>
</listitem>
</varlistentry>
</variablelist>
        Apparaît ensuite, pour chaque argument, le couple de champs suivant&nbsp;:
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Longueur de la valeur de l'argument, en octets (ce nombre
		n'inclut pas la longueur elle-même). Peut valoir zéro.
		Traité comme un cas spécial, -1 indique une valeur NULL de
		l'argument. Aucun octet de valeur ne suit le cas NULL.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                Valeur de l'argument dans le format indiqué par le code de
		format associé. <replaceable>n</replaceable> est la longueur
		ci-dessus.
</para>
</listitem>
</varlistentry>
</variablelist>
        Après le dernier argument, le champ suivant apparaît&nbsp;:
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Code du format du résultat de la fonction. Doit valoir zéro
		(texte) ou un (binaire).
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
FunctionCallResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('V')
</term>
<listitem>
<para>
                Marqueur de résultat d'un appel de fonction.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Longueur de la valeur du résultat de la fonction, en octets
		(ce nombre n'inclut pas la longueur elle-même). Peut valoir zéro.
		Traité comme un cas spécial, -1 indique un résultat de fonction
		NULL. Aucun octet de valeur ne suit le cas NULL.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                Valeur du résultat de la fonction, dans le format indiqué
		par le code de format associé. <replaceable>n</replaceable> est
		la longueur ci-dessus.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
NoData (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('n')
</term>
<listitem>
<para>
                Indicateur d'absence de données.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
NoticeResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
                Marqueur d'avertissement.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>
        Le corps du message est constitué d'un ou plusieurs champs identifié(s),
	suivi(s) d'un octet zéro comme terminateur. L'ordre des champs n'est pas
	fixé. Pour chaque champ, on trouve les informations suivantes&nbsp;:
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                Code identifiant le type de champ&nbsp;; s'il vaut zéro,
		c'est la fin du message et aucune chaîne ne suit. Les types de
		champs déjà définis sont listés dans
		<xref linkend="protocol-error-fields"/>. de nouveaux types de
		champs pourraient être ajoutés dans le futur, les clients doivent
		donc ignorer silencieusement les champs de type non reconnu.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Valeur du champ.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
NotificationResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('A')
</term>
<listitem>
<para>
                Marqueur de réponse de notification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID du processus serveur ayant procédé à la notification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Nom de la condition à l'origine de la notification.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Information supplémentaire provenant du processus à l'origine de
		la notification (cette fonctionnalité n'est, à ce jour, pas
		implantée, le champ est donc toujours constitué d'une chaîne vide).
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParameterDescription (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('t')
</term>
<listitem>
<para>
                Marqueur de description de paramètre.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Nombre de paramètres utilisé par l'instruction (peut valoir
		zéro).
</para>
</listitem>
</varlistentry>
</variablelist>
        Pour chaque paramètre, suivent&nbsp;:
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID de l'objet du type de données du paramètre.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParameterStatus (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
                Marqueur de rapport d'état de paramètre
		d'exécution.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Nom du paramètre d'exécution dont le rapport est en cours.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Valeur actuelle du paramètre.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Parse (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('P')
</term>
<listitem>
<para>
                Marqueur de commande Parse.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Nom de l'instruction préparée de destination (une chaîne
		vide sélectionne l'instruction préparée non-nommée).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Chaîne de requête à analyser.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Nombre de types de données de paramètre spécifiés (peut
		valoir zéro). Ce n'est pas une indication du nombre de
		paramètres pouvant apparaître dans la chaîne de requête,
		mais simplement le nombre de paramètres pour lesquels le client
		veut pré-spécifier les types.
</para>
</listitem>
</varlistentry>
</variablelist>
        Pour chaque paramètre, on trouve ensuite&nbsp;:
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID de l'objet du type de données du paramètre.
		la valeur zéro équivaut à ne pas spécifier le type.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParseComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('1')
</term>
<listitem>
<para>
                Indicateur de fin de Parse.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
PasswordMessage (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
                Marqueur de réponse de mot de passe. Notez que c'est aussi
		utilisé par les messages de réponse GSSAPI.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Mot de passe (chiffré à la demande).
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
PortalSuspended (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('s')
</term>
<listitem>
<para>
                Indicateur de suspension du portail.
		Apparaît seulement si la limite du nombre de lignes d'un
		message Execute a été atteint.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Query (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Q')
</term>
<listitem>
<para>
                Marqueur de requête simple.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                La chaîne de requête elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ReadyForQuery (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Z')
</term>
<listitem>
<para>
                Identifie le type du message. ReadyForQuery est envoyé à chaque
		fois que le serveur est prêt pour un nouveau cycle de requêtes.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                Indicateur de l'état transactionnel du serveur.
		Les valeurs possibles sont '<literal>i</literal>' s'il est en pause
		(en dehors d'un bloc de transaction)&nbsp;; '<literal>t</literal>' s'il
		est dans un bloc de transaction&nbsp;; ou '<literal>e</literal>' s'il
		est dans un bloc de transaction échouée (les requêtes seront
		réjetées jusqu'à la fin du bloc).
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
RowDescription (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('T')
</term>
<listitem>
<para>
                Marqueur de description de ligne.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Nombre de champs dans une ligne (peut valoir zéro).
</para>
</listitem>
</varlistentry>
</variablelist>
        On trouve, ensuite, pour chaque champ&nbsp;:
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Nom du champ.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Si le champ peut être identifié comme colonne d'une table
		spécifique, l'ID de l'objet de la table&nbsp;; sinon zéro.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Si le champ peut être identifié comme colonne d'une table
		spécifique, le numéro d'attribut de la colonne&nbsp;; sinon zéro.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID de l'objet du type de données du champ.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Taille du type de données (voir <varname>pg_type.typlen</varname>).
		Les valeurs négatives indiquent des types de largeur variable.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Modificateur de type (voir <varname>pg_attribute.atttypmod</varname>).
		La signification du modificateur est spécifique au type.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Code de format utilisé pour le champ. Zéro (texte) ou un
		(binaire), à l'heure actuelle. Dans un RowDescription retourné
		par la variante de l'instruction de Describe, le code du format
		n'est pas encore connu et vaudra toujours zéro.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
SSLRequest (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877103)
</term>
<listitem>
<para>
                 Code de requête <acronym>ssl</acronym>. la valeur est choisie pour contenir
 		<literal>1234</literal> dans les 16 bits les plus significatifs, et
 		<literal>5679</literal> dans les 16 bits les moins significatifs
 		(pour éviter toute confusion, ce code ne doit pas être le même
 		que celui d'un numéro de version de protocole).
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
StartupMessage (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(196608)
</term>
<listitem>
<para>
                Numéro de version du protocole. Les 16 bits les plus
		significatifs représentent le numéro de version majeure (3 pour le
		protocole décrit ici). Les 16 bits les moins significatifs représentent
		le numéro de version mineure (0 pour le protocole décrit ici).
</para>
</listitem>
</varlistentry>
</variablelist>
        Le numéro de version du protocole est suivi par un ou plusieurs
	couple(s) nom de paramètre et chaîne de valeur. Un octet zéro est requis
	comme terminateur après le dernier couple nom/valeur. L'ordre des
	paramètres n'est pas fixé. Le paramètre <literal>user</literal> est requis,
	les autres sont optionnels. Chaque paramètre est spécifié de la façon
	suivante&nbsp;:
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Nom du paramètre. Les noms actuellement reconnus sont&nbsp;:

<variablelist>
<varlistentry>
<term>
                <literal>user</literal>
</term>
<listitem>
<para>
                        Nom de l'utilisateur de base de données sous lequel se
			connecter. Requis&nbsp;; il n'y a pas de valeur par défaut.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>database</literal>
</term>
<listitem>
<para>
                        Base de données à laquelle se connecter.
			Par défaut le nom de l'utilisateur.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>options</literal>
</term>
<listitem>
<para>
                        Arguments en ligne de commande pour le serveur
			(rendu obsolète par l'utilisation de paramètres
			individuels d'exécution).
</para>
</listitem>
</varlistentry>
</variablelist>

                En plus de ce qui précède, tout paramètre d'exécution
		pouvant être initialisé au démarrage du serveur peut être listé.
		Ces paramètres seront appliqués au démarrage du serveur
		(après analyse des options en ligne de commande, s'il y en a).
		Leurs valeurs agiront comme valeurs de session par défaut.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Valeur du paramètre.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Sync (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
                Marqueur de commande Sync.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Terminate (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('X')
</term>
<listitem>
<para>
                Marqueur de fin.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Taille du message en octets, y compris la taille elle-même.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


</variablelist>

</sect1>


<sect1 id="protocol-error-fields">
<title>Champs des messages d'erreur et d'avertissement</title>

<para>
Cette section décrit les champs qui peuvent apparaître dans les messages
ErrorResponse et NoticeResponse. Chaque type de champ a un motif
d'identification codé sur un octet. Tout type de champ donné doit apparaître au
plus une fois par message.
</para>

<variablelist>

<varlistentry>
<term>
<literal>s</literal>
</term>
<listitem>
<para>
        Gravité (Severity)&nbsp;: le contenu du champ peut être
        <literal>error</literal>, <literal>fatal</literal> ou
        <literal>panic</literal> dans un message d'erreur,
	<literal>warning</literal>, <literal>notice</literal>, <literal>debug</literal>,
	<literal>info</literal> ou <literal>log</literal> dans un message d'avertissement,
	ou la traduction régionale de l'un d'eux. Toujours présent.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>c</literal>
</term>
<listitem>
<para>
        Code&nbsp;: code SQLSTATE de l'erreur (voir
	<xref linkend="errcodes-appendix"/>). non internationalisable.
	Toujours présent.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>m</literal>
</term>
<listitem>
<para>
        Message&nbsp;: premier message d'erreur, en clair.
	Doit être court et précis (typiquement une ligne). Toujours présent.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>d</literal>
</term>
<listitem>
<para>
        Détail&nbsp;: deuxième message d'erreur, optionnel, apportant des
	informations supplémentaires sur le problème. Peut être sur plusieurs
	lignes.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>h</literal>
</term>
<listitem>
<para>
        Astuce (Hint)&nbsp;: suggestion optionnelle de résolution du
	problème. Différent de Détail parce qu'il offre un
	conseil (potentiellement inapproprié) plutôt que des faits réels.
	Peut être sur plusieurs lignes.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>p</literal>
</term>
<listitem>
<para>
        Position&nbsp;: valeur du champ, entier décimal ASCII indiquant
	un curseur sur la position de l'erreur dans la chaîne de requête
	originale. Le premier caractère a l'index 1. Les positions sont mesurées
	en caractères, non pas en octets.
</para>
</listitem>
</varlistentry>

<varlistentry>
  <term>
    <literal>p</literal>
</term>
<listitem>
  <para>
    Position interne&nbsp;: ceci est défini de la même façon que le champ
    <literal>p</literal> mais c'est utilisé quand la position du curseur se réfère
    à une commande générée en interne plutôt qu'une soumise par le client.
    Le champ <literal>q</literal> apparaîtra toujours quand ce champ apparaît.
</para>
</listitem>
</varlistentry>

<varlistentry>
  <term>
    <literal>q</literal>
</term>
<listitem>
  <para>
    Requête interne&nbsp;: le texte d'une commande générée en interne et qui a échoué.
    Ceci pourrait être, par exemple, une requête SQL lancée par une fonction PL/pgSQL.
  </para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>w</literal>
</term>
<listitem>
<para>
Où (Where)&nbsp;: indication du contexte dans lequel l'erreur est
survenue. Inclut, actuellement, une trace de la pile des appels des
fonctions PL actives. Cette trace comprend une entrée par ligne, la plus
récente en premier.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>f</literal>
</term>
<listitem>
<para>
        Fichier (File)&nbsp;: nom du fichier de code source comportant
	l'erreur.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>l</literal>
</term>
<listitem>
<para>
        Ligne (Line)&nbsp;: numéro de ligne dans le fichier de code source
	comportant l'erreur.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>r</literal>
</term>
<listitem>
<para>
        Routine&nbsp;: nom de la routine dans le code source comportant
	l'erreur.
</para>
</listitem>
</varlistentry>

</variablelist>

<para>
Le client est responsable du formatage adapté à ses besoins des informations
affichées&nbsp;; en particulier par l'ajout de retours chariots sur les lignes
longues, si cela s'avérait nécessaire. Les caractères de retour chariot
apparaissant dans les champs de messages d'erreur devraient être traités comme
des changements de paragraphes, non comme des changements de lignes.
</para>

</sect1>


<sect1 id="protocol-changes">
<title>Résumé des modifications depuis le protocole 2.0</title>

<para>
Cette section fournit une liste rapide des modifications à l'attention des
développeurs essayant d'adapter au protocole 3.0 des bibliothèques clientes
existantes.
</para>

<para>
Le paquet de démarrage initial utilise un format flexible de liste de chaînes
au lieu d'un format fixe. Les valeurs de session par défaut des paramètres
d'exécution peuvent même être spécifiées directement dans le paquet de démarrage
(en fait, cela était déjà possible en utilisant le champ <literal>options</literal>&nbsp;;
mais étant donné la largeur limitée d'<literal>options</literal> et l'impossibilité de
mettre entre guillemets les espaces fines dans les valeurs, ce n'était pas une
technique très sûre).
</para>

<para>
Tous les messages possèdent désormais une indication de longueur qui suit
immédiatement l'octet du type de message (sauf pour les paquets de démarrage qui
n'ont pas d'octet de type). PasswordMessage possède à présent un octet de type.
</para>

<para>
Les messages ErrorResponse et NoticeResponse ('<literal>e</literal>' et
'<literal>n</literal>') contiennent maintenant plusieurs champs, à partir desquels le
code client peut assembler un message d'erreur fonction du niveau de verbiage
désiré. Des champs individuels ne se termineront plus par un retour chariot
alors que la chaîne seule envoyée dans l'ancien protocole le faisait
systématiquement.
</para>

<para>
Le message ReadyForQuery ('<literal>z</literal>') inclut un indicateur d'état de
la transaction.
</para>

<para>
La distinction entre les types de messages BinaryRow et DataRow est supprimée&nbsp;;
le type de message DataRow seul sert à retourner les données dans tous les
formats. La disposition de DataRow a changé pour faciliter son analyse.
La représentation des valeurs binaires a également été modifiée&nbsp;: elle
n'est plus liée directement à la représentation interne du serveur.
</para>

<para>
Il existe un nouveau sous-protocole pour les <quote>requêtes étendues</quote> qui
  ajoute les types de messages client Parse, Bind, Execute, Describe, Close,
  Flush et Sync et les types de messages serveur ParseComplete, BindComplete,
  PortalSuspended, ParameterDescription, NoData et CloseComplete. Les clients
 existants ne sont pas directement concernés par ce sous-protocole, mais son
 utilisation apportera des améliorations en terme de performances et de
 fonctionnalités.
  </para>

  <para>
   Les données de <command>copy</command> sont désormais encapsulées dans des messages
   CopyData et CopyDone. Il y a une façon bien définie de réparer les erreurs
   lors du <command>copy</command>. la dernière ligne spéciale <quote><literal>\.</literal></quote>
   n'est plus nécessaire et n'est pas envoyée lors de <command>copy out</command> (elle
   est toujours reconnue comme un indicateur de fin lors du <command>copy in</command>
   mais son utilisation est obsolète. Elle sera éventuellement supprimée). Le
   <command>copy</command> binaire est supporté. les messages copyinresponse et
   CopyOutResponse incluent les champs indiquant le nombre de colonnes et le
   format de chaque colonne.
  </para>

   <para>
   La disposition des messages FunctionCall et FunctionCallResponse a changé.
   FunctionCall supporte à présent le passage aux fonctions d'arguments NULL. Il
   peut aussi gérer le passage de paramètres et la récupération de résultats aux
   formats texte et binaire. Il n'y a plus aucune raison de considérer FunctionCall
   comme une faille potentielle de sécurité car il n'offre plus d'accès direct aux
   représentations internes des données du serveur.
   </para>

   <para>
   Le serveur envoie des messages ParameterStatus ('<literal>s</literal>') lors de
   l'initialisation de la connexion pour tous les paramètres qu'il considère
   intéressants pour la bibliothèque client. En conséquence, un message
   ParameterStatus est envoyé à chaque fois que la valeur active d'un de ces
   paramètres change.
   </para>

   <para>
   Le message RowDescription ('<literal>t</literal>') contient les nouveaux champs oid
   de table et de numéro de colonne pour chaque colonne de la ligne décrite. Il
   affiche aussi le code de format pour chaque colonne.
   </para>

   <para>
   Le message CursorResponse ('<literal>p</literal>') n'est plus engendré par le serveur.
   </para>

   <para>
   Le message NotificationResponse ('<literal>a</literal>') a un champ de type chaîne
   supplémentaire, actuellement vide mais qui pourrait à terme transporter des
   données supplémentaires engendrées par l'émetteur de l'événement <command>notify</command>.
   </para>

   <para>
   Le message EmptyQueryResponse ('<literal>i</literal>') nécessitait un paramètre chaîne
   vide&nbsp;; ce n'est plus le cas.
   </para>

   </sect1>


</chapter>
