<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="queries">
 <title>Requêtes</title>

 <indexterm zone="queries">
  <primary>requête</primary>
 </indexterm>

 <indexterm zone="queries">
  <primary>SELECT</primary>
 </indexterm>

 <para>
  Les précédents chapitres ont expliqué comme créer des tables, comment 
  les remplir avec des données et comment manipuler ces données.
  Maintenant, nous discutons enfin de la façon de récupérer ces données
  depuis la base de données.
 </para>


 <sect1 id="queries-overview">
  <title>Aperçu</title>

  <para>
   Le processus et la commande de récupération des données sont appelés une
   <firstterm>requête</firstterm>. En SQL, la commande <xref linkend="sql-select"
   endterm="sql-select-title"/> est utilisée pour spécifier des requêtes. La
   syntaxe générale de la commande <command>SELECT</command> est
<synopsis>
<optional>WITH <replaceable>with_requêtes</replaceable></optional> SELECT <replaceable>liste_select</replaceable> FROM <replaceable>expression_table</replaceable> <optional><replaceable>specification_tri</replaceable></optional>
</synopsis>
   Les sections suivantes décrivent le détail de la liste de sélection,
   l'expression des tables et la spécification du tri. <literal>WITH</>
   queries are treated last since they are an advanced feature.
  </para>

  <para>
   Un type de requête simple est de la forme&nbsp;:
<programlisting>SELECT * FROM table1;</programlisting>
  En supposant qu'il existe une table appelée <literal>table1</literal>, cette
  commande récupérera toutes les lignes et toutes les colonnes de
  <literal>table1</literal>. La méthode de récupération dépend de l'application
  cliente. Par exemple, le programme <application>psql</application> affichera
  une table, façon art ASCII, alors que les bibliothèques du client offriront 
  des fonctions d'extraction de valeurs individuelles à partir du résultat de
  la requête. <literal>*</literal> comme liste de sélection signifie que toutes
  les colonnes de l'expression de table seront récupérées. Une liste de sélection
  peut aussi être un sous-ensemble des colonnes disponibles ou effectuer 
  un calcul en utilisant les colonnes. Par exemple, si <literal>table1</literal>
  dispose des colonnes nommées <literal>a</literal>, <literal>b</literal> et <literal>c</literal> (et
  peut-être d'autres), vous pouvez lancer la requête suivante&nbsp;:
<programlisting>SELECT a, b + c FROM table1;</programlisting>
  (en supposant que <literal>b</literal> et <literal>c</literal> soient de type numérique).
  Voir la <xref linkend="queries-select-lists"/> pour plus de détails.
 </para>

 <para>
  <literal>FROM table1</literal> est un type très simple d'expression de
tables&nbsp;: il lit une seule table. En général, les expressions de tables
sont des constructions complexes de tables de base, de jointures et de
sous-requêtes. Mais vous pouvez aussi entièrement omettre l'expression de table
et utiliser la commande <command>SELECT</command> comme une calculatrice&nbsp;:
<programlisting>SELECT 3 * 4;</programlisting>
  Ceci est plus utile si les expressions de la liste de sélection renvoient des
  résultats variants. Par exemple, vous pouvez appeler une fonction de cette
  façon&nbsp;:
<programlisting>SELECT random();</programlisting>
  </para>
 </sect1>


 <sect1 id="queries-table-expressions">
  <title>Expressions de table</title>

  <indexterm zone="queries-table-expressions">
   <primary>expression de table</primary>
  </indexterm>

  <para>
   Une <firstterm>expression de table</firstterm> calcule une table.
   L'expression de table contient une clause <literal>FROM</literal> qui peut être
   suivie des clauses <literal>WHERE</literal>, <literal>GROUP BY</literal> et
   <literal>HAVING</literal>. Les expressions triviales de table font simplement
   référence à une table sur le disque, une table de base, mais des expressions
   plus complexes peuvent être utilisées pour modifier ou combiner des tables
   de base de différentes façons.
  </para>

  <para>
   Les clauses optionnelles <literal>WHERE</literal>, <literal>GROUP BY</literal> et
   <literal>HAVING</literal> dans l'expression de table spécifient un tube de
   transformations successives réalisées sur la table dérivée de la
   clause <literal>FROM</literal>. Toutes ces transformations produisent une table
   virtuelle fournissant les lignes à passer à la liste de sélection qui
   choisira les lignes à afficher de la requête.
  </para>
	
  <sect2 id="queries-from">
   <title>Clause <literal>FROM</literal></title>
 
   <para>
    La <xref linkend="sql-from" endterm="sql-from-title"/> dérive une
    table à partir d'une ou plusieurs tables données dans une liste de
    référence dont les tables sont séparées par des virgules.
<synopsis>FROM <replaceable>reference_table</replaceable> <optional>, <replaceable>reference_table</replaceable> <optional>, ...</optional></optional></synopsis>

    Une référence de table pourrait être un nom de table (avec en option
    le nom du schéma) ou une table dérivée comme une sous-requête, une table
    jointe ou une combinaison complexe de celles-ci. Si plus d'une référence de
    tables est listée dans la clause <literal>FROM</literal>, elle sont jointes pour
    former une table virtuelle intermédiaire qui pourrait être le sujet des
    transformations des clauses <literal>WHERE</literal>, <literal>GROUP BY</literal>
    et <literal>HAVING</literal>, et est finalement le résultat des expressions de
    table.
   </para>

   <indexterm>
    <primary>ONLY</primary>
   </indexterm>

   <para>
    Lorsqu'une référence de table nomme une table qui est la table parent d'une
    table suivant la hiérarchie de l'héritage, la référence de table produit les
    lignes non seulement de la table mais aussi des descendants de cette table
    sauf si le mot clé <literal>ONLY</literal> précède le nom de la table. Néanmoins,
    la référence produit seulement les colonnes qui apparaissent dans la table
    nommée... toute colonne ajoutée dans une sous-table est ignorée.
   </para>

   <sect3 id="queries-join">
    <title>Tables jointes</title>

    <indexterm zone="queries-join">
     <primary>join</primary>
    </indexterm>

    <para>
     Une table jointe est une table dérivée de deux autres tables (réelles ou
     dérivées) suivant les règles du type de jointure particulier. Les
     jointures internes (inner), externes (outer) et croisées (cross) sont
     disponibles.
    </para>

    <variablelist>
     <title>Types de jointures</title>

     <varlistentry>
      <term>Jointure croisée (cross join)</term>

      <listitem>
      <indexterm>
       <primary>jointure</primary>
       <secondary>croisée</secondary>
      </indexterm>

      <indexterm>
       <primary>join</primary>
       <secondary>cross</secondary>
      </indexterm>

      <indexterm>
       <primary>jointure croisée</primary>
      </indexterm>

      <indexterm>
       <primary>crossed joind</primary>
      </indexterm>

<synopsis><replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable></synopsis>

       <para>
        Pour chaque combinaison de lignes provenant de
        <replaceable>T1</replaceable> et <replaceable>T2</replaceable>, la
        table dérivée contiendra une ligne consistant de toutes les colonnes de
        <replaceable>T1</replaceable> suivies de toutes les colonnes de
        <replaceable>T2</replaceable>. Si les tables ont respectivement N et M
        lignes, la table jointe en aura N * M.
       </para>

       <para>
        <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
        <replaceable>T2</replaceable></literal> est équivalent à
        <literal>FROM <replaceable>T1</replaceable>,
        <replaceable>T2</replaceable></literal>.  C'est aussi équivalent à
        <literal>FROM <replaceable>T1</replaceable> INNER JOIN
        <replaceable>T2</replaceable> ON TRUE</literal> (voir ci-dessous).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Jointures qualifiées (qualified joins)</term>

      <listitem>

      <indexterm>
       <primary>join</primary>
       <secondary>outer</secondary>
      </indexterm>

      <indexterm>
       <primary>outer join</primary>
      </indexterm>

      <indexterm>
       <primary>jointure</primary>
       <secondary>externe</secondary>
      </indexterm>

      <indexterm>
       <primary>jointure externe</primary>
      </indexterm>

<synopsis><replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> ON <replaceable>expression_booleenne</replaceable>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> USING ( <replaceable>liste des colonnes jointes</replaceable> )
<replaceable>T1</replaceable> NATURAL { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable></synopsis>

       <para>
        Les mots <literal>INNER</literal> et
        <literal>OUTER</literal> sont optionnels dans toutes les formes.
        <literal>INNER</literal> est la valeur par défaut&nbsp;;
        <literal>LEFT</literal>, <literal>RIGHT</literal> et
        <literal>FULL</literal> impliquent une jointure externe.
       </para>

       <para>
        La <firstterm>condition de la jointure</firstterm> est spécifiée dans
        la clause <literal>ON</literal> ou <literal>USING</literal>, ou implicitement par le
        mot <literal>NATURAL</literal>. La condition de jointure détermine les lignes
        des deux tables source considérées comme <quote>correspondante</quote>,
        comme l'explique le paragraphe ci-dessous.
       </para>

       <para>
        La clause <literal>ON</literal> est le type le plus général de condition de 
        jointure&nbsp;: il prend une expression booléenne du même genre que
        celle utilisée dans une clause <literal>WHERE</literal>. Une paires de lignes
        de <replaceable>T1</replaceable> et <replaceable>T2</replaceable> correspondent si
        l'expression <literal>ON</literal> est évaluée à vraie (true) pour ces deux
        lignes.
       </para>

       <para>
        <literal>USING</literal> est la notation raccourcie&nbsp;: elle prend une
        liste de noms de colonnes, séparés par des virgules, que les tables
        jointes ont en commun, et forme une condition de jointure spécifiant
        l'égalité de chacune de ces paires de colonnes. De plus, la sortie de
        <literal>JOIN USING</literal> a une colonne pour chaque paires égales des
        colonnes en entrée, suivies par toutes les autres colonnes de chaque
        table. Du coup, <literal>USING (a, b, c)</literal> est équivalent à
        <literal>ON (t1.a = t2.a AND t1.b = t2.b AND t1.c = t2.c)</literal> avec
        l'exception que si <literal>ON</literal> est utilisé, il y aura deux colonnes
        <literal>a</literal>, <literal>b</literal>, puis <literal>c</literal> dans le résultat, alors
        qu'avec <literal>USING</literal>, il n'y en aurait eu qu'une de chaque.
       </para>

       <para>
        <indexterm>
	 <primary>join</primary>
	 <secondary>natural</secondary>
	</indexterm>
        <indexterm>
	 <primary>natural join</primary>
	</indexterm>
        <indexterm>
	 <primary>jointure</primary>
	 <secondary>naturelle</secondary>
	</indexterm>
        <indexterm>
	 <primary>jointure naturelle</primary>
	</indexterm>
        Enfin, <literal>NATURAL</literal> est un format raccourci de
        <literal>USING</literal>&nbsp;: il forme une liste <literal>USING</literal>
        consistant exactement des noms de colonnes apparaissant à la fois dans
        les deux tables en entrée. Comme avec <literal>USING</literal>, ces colonnes
        apparaissent seulement une fois dans la table de sortie.
       </para>

       <para>
        Les types possibles de jointures qualifiées sont&nbsp;:

       <variablelist>
        <varlistentry>
         <term><literal>INNER JOIN</literal></term>

         <listitem>
          <para>
           Pour chaque ligne R1 de T1, la table jointe a une ligne pour chaque
           ligne de T2 satisfaisant la condition de jointure avec R1.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>LEFT OUTER JOIN</literal></term>

         <listitem>
         <indexterm>
          <primary>join</primary>
          <secondary>left</secondary>
         </indexterm>

         <indexterm>
          <primary>left join</primary>
         </indexterm>

         <indexterm>
          <primary>jointure</primary>
          <secondary>gauche</secondary>
         </indexterm>

         <indexterm>
          <primary>jointure gauche</primary>
         </indexterm>

          <para>
           Tout d'abord, une jointure interne est réalisée. Puis, pour chaque
           ligne de T1 qui ne satisfait pas la condition de jointure avec
           les lignes de T2, une ligne jointe est ajoutée avec des valeurs
           NULL dans les colonnes de T2. Du coup, la table jointe a au moins
           une ligne pour chaque ligne de T1 quelque soient les conditions.
          </para>
         </listitem>
        </varlistentry>
         
        <varlistentry>
         <term><literal>RIGHT OUTER JOIN</literal></term>

         <listitem>
         <indexterm>
          <primary>join</primary>
          <secondary>right</secondary>
         </indexterm>

         <indexterm>
          <primary>right join</primary>
         </indexterm>

         <indexterm>
          <primary>jointure</primary>
          <secondary>droite</secondary>
         </indexterm>

         <indexterm>
          <primary>jointure droite</primary>
         </indexterm>

          <para>
           Tout d'abord, une jointure interne est réalisée. Puis, pour chaque
           ligne de T2 qui ne satisfait pas la condition de jointure avec les
           lignes de T1, une ligne jointe est ajoutée avec des valeurs NULL
           dans les colonnes de T1. C'est l'inverse d'une jointure gauche&nbsp;:
           la table résultante aura une ligne pour chaque ligne de T2 quelque
           soient les conditions.
          </para>
         </listitem>
        </varlistentry>
         
        <varlistentry>
         <term><literal>FULL OUTER JOIN</literal></term>

         <listitem>
          <para>
           Tout d'abord, une jointure interne est réalisée. Puis, pour chaque
           ligne de T1 qui ne satisfait pas la condition de jointure avec les
           lignes de T2, une ligne jointe est ajoutée avec des valeurs NULL dans
           les colonnes de T2. De plus, pour chaque ligne de T2 qui ne satisfait
           pas la condition de jointure avec les lignes de T1, une ligne jointe
           est ajoutée avec des valeurs NULL dans les colonnes de T1.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
     Les jointures de tous les types peuvent être chaînées ensemble ou
     imbriquées&nbsp;: soit les deux soit une des deux, parmi
     <replaceable>T1</replaceable> et <replaceable>T2</replaceable>, peuvent
     être des tables. Les parenthèses peuvent être utilisées autour des clauses
     <literal>JOIN</literal> pour contrôler l'ordre de jointure. En l'absence de
     parenthèses, les clauses <literal>JOIN</literal> sont imbriquées de gauche à
     droite.
    </para>

    <para>
     Pour rassembler tout ceci, supposons que nous avons une table
     <literal>t1</literal>&nbsp;:
<programlisting> no | nom
----+------
  1 | a
  2 | b
  3 | c</programlisting>
     et une table <literal>t2</literal>&nbsp;:
<programlisting> no | valeur
----+-------
  1 | xxx
  3 | yyy
  5 | zzz</programlisting>
     nous obtenons les résultats suivants pour les différentes jointures&nbsp;:
<screen><prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 CROSS JOIN t2;</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  1 | a   |  3 | yyy
  1 | a   |  5 | zzz
  2 | b   |  1 | xxx
  2 | b   |  3 | yyy
  2 | b   |  5 | zzz
  3 | c   |  1 | xxx
  3 | c   |  3 | yyy
  3 | c   |  5 | zzz
(9 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.no = t2.no;</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  3 | c   |  3 | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (no);</userinput>
 no | nom | valeur
----+-----+-------
  1 | a   | xxx
  3 | c   | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</userinput>
 no | nom | valeur
----+-----+-------
  1 | a   | xxx
  3 | c   | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.no = t2.no;</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  2 | b   |    |
  3 | c   |  3 | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (no);</userinput>
 no | nom | valeur
----+-----+-------
  1 | a   | xxx
  2 | b   |
  3 | c   | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.no = t2.no;</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  3 | c   |  3 | yyy
    |     |  5 | zzz
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.no = t2.no;</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  2 | b   |    |
  3 | c   |  3 | yyy
    |     |  5 | zzz
(4 rows)</screen>
    </para>

    <para>
     La condition de jointure spécifiée avec <literal>ON</literal> peut aussi contenir
     des conditions sans relation directe avec la jointure. Ceci est utile
     pour quelques requêtes mais son utilisation doit avoir été réfléchie. Par
     exemple&nbsp;:
<screen><prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.no = t2.no AND t2.valeur = 'xxx';</userinput>
 no | nom | no | valeur
----+-----+----+-------
  1 | a   |  1 | xxx
  2 | b   |    |
  3 | c   |    |
(3 rows)</screen>
    </para>
   </sect3>

   <sect3 id="queries-table-aliases">
    <title>Alias de table et de colonne</title>

    <indexterm zone="queries-table-aliases">
     <primary>alias</primary>
     <secondary>dans la clause FROM</secondary>
    </indexterm>

    <indexterm>
     <primary>label</primary>
     <see>alias</see>
    </indexterm>

    <para>
     Un nom temporaire peut être donné aux tables et aux références de tables
     complexe, qui sera ensuite utilisé pour référencer la table dérivée dans la
     suite de la requête. Cela s'appelle un <firstterm>alias de
     table</firstterm>.
    </para>

    <para>
     Pour créer un alias de table, écrivez
<synopsis>FROM <replaceable>reference_table</replaceable> AS <replaceable>alias</replaceable></synopsis>
     ou
<synopsis>FROM <replaceable>reference_table</replaceable> <replaceable>alias</replaceable></synopsis>
     Le mot clé <literal>AS</literal> n'est pas obligatoire.
     <replaceable>alias</replaceable> peut être tout identifiant.
    </para>

    <para>
     Une application typique des alias de table est l'affectation d'identifieurs
     courts pour les noms de tables longs, ce qui permet de garder des clauses de
     jointures lisibles. Par exemple&nbsp;:
<programlisting>SELECT * FROM nom_de_table_tres_tres_long s
  JOIN un_autre_nom_tres_long a ON s.id = a.no;</programlisting>
    </para>

    <para>
     L'alias devient le nouveau nom de référence de la table pour la requête
     courante &mdash; il n'est plus possible de référencer la table avec son nom
     d'origine. Du coup&nbsp;:
<programlisting>SELECT * FROM ma_table AS m WHERE ma_table.a &gt; 5;</programlisting>
     n'est pas valide suivant le standard SQL. Dans
     <productname>PostgreSQL</productname>, ceci amènera une erreur si la variable
     <xref linkend="guc-add-missing-from"/> est désactivée (<literal>off</literal>,
     valeur par défaut).
     S'il est activé (<literal>on</literal>), une référence vers une table
     implicite sera ajoutée à la clause <literal>FROM</literal>, de façon à ce que
     la requête soit exécutée comme si elle était écrite ainsi&nbsp;:
<programlisting>SELECT * FROM ma_table AS m, ma_table AS ma_table WHERE ma_table.a &gt; 5;</programlisting>
     Cela résultera en une jointure croisée, ce qui n'est habituellement pas
     ce que vous voulez.
    </para>

    <para>
     Les alias de table sont disponibles principalement pour aider à l'écriture
     de requête mais ils deviennent nécessaires pour joindre une table avec
     elle-même, par exemple&nbsp;:
<programlisting>SELECT * FROM personnes AS mere JOIN personnes AS enfant ON mere.id = enfant.mere_id;
</programlisting>
     De plus, un alias est requis si la référence de la table est une
     sous-requête (voir la <xref linkend="queries-subqueries"/>).
    </para>

    <para>
     Les parenthèses sont utilisées pour résoudre les ambiguïtés. Dans l'exemple
     suivant, la première instruction affecte l'alias <literal>b</literal> à la
     deuxième instance de <literal>ma_table</literal> mais la deuxième instruction
     affecte l'alias au résultat de la jonction&nbsp;:
<programlisting>SELECT * FROM ma_table AS a CROSS JOIN ma_table AS b ...
SELECT * FROM (ma_table AS a CROSS JOIN ma_table) AS b ...</programlisting>
    </para>

    <para>
     Une autre forme d'alias de tables donne des noms temporaires aux colonnes
     de la table ainsi qu'à la table&nbsp;:
<synopsis>FROM <replaceable>reference_table</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> ( <replaceable>colonne1</replaceable> <optional>, <replaceable>colonne2</replaceable> <optional>, ...</optional></optional> )</synopsis>
     Si le nombre d'alias de colonnes spécifié est plus petit que le nombre
     de colonnes dont dispose la table réelle, les colonnes suivantes ne sont
     pas renommées. Cette syntaxe est particulièrement utile dans le cas de
     jointure avec la même table ou dans le cas de sous-requêtes.
    </para>

    <para>
     Quand un alias est appliqué à la sortie d'une clause <literal>JOIN</literal> en
utilisant n'importe laquelle de ces formes, l'alias cache le nom original à
l'intérieur du <literal>JOIN</literal>. Par exemple&nbsp;:
<programlisting>SELECT a.* FROM ma_table AS a JOIN ta_table AS b ON ...</programlisting>
     est du SQL valide mais&nbsp;:
<programlisting>SELECT a.* FROM (ma_table AS a JOIN ta_table AS b ON ...) AS c</programlisting>
     n'est pas valide&nbsp;: l'alias de table <literal>a</literal> n'est pas visible
     en dehors de l'alias <literal>c</literal>.
    </para>
   </sect3>

   <sect3 id="queries-subqueries">
    <title>Sous-requêtes</title>

    <indexterm zone="queries-subqueries">
     <primary>sous-requête</primary>
    </indexterm>

    <para>
     Une sous-requête spécifiant une table dérivée doit être enfermée 
     dans des parenthèses et <emphasis>doit</emphasis> se voir affecté un alias
     de table (voir la <xref linkend="queries-table-aliases"/>). Par
     exemple&nbsp;:
<programlisting>FROM (SELECT * FROM table1) AS nom_alias</programlisting>
    </para>

    <para>
     Cet exemple est équivalent à <literal>FROM table1 AS
     nom_alias</literal>. Des cas plus intéressants, qui ne peuvent pas être
     réduit à une jointure pleine, surviennent quand la sous-requête implique un
     groupement ou un agrégat.
    </para>

    <para>
     Uns sous-requête peut aussi être une liste <command>VALUES</command>&nbsp;:
<programlisting>
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS noms(prenom, nom)
</programlisting>
     De nouveau, un alias de table est requis. Affecter des noms d'alias aux
     colonnes de la liste <command>VALUES</command> est en option mais c'est
     une bonne pratique. Pour plus d'informations, voir
     <xref linkend="queries-values"/>.
    </para>
   </sect3>

   <sect3 id="queries-tablefunctions">
    <title>Fonctions de table</title>

    <indexterm zone="queries-tablefunctions"><primary>fonction de table</primary></indexterm>

    <indexterm zone="queries-tablefunctions">
     <primary>fonction</primary>
     <secondary>dans la clause FROM</secondary>
    </indexterm>

    <para>
     Les fonctions de table sont des fonctions produisant un ensemble de
     lignes composées de types de données de base (types scalaires) ou de types
     de données composites (lignes de table). Elles sont utilisées comme une
     table, une vue ou une sous-requête de la clause <literal>FROM</literal> d'une
     requête. Les colonnes renvoyées par les fonctions de table peuvent être
     incluses dans une clause <literal>SELECT</literal>, <literal>JOIN</literal> ou
     <literal>WHERE</literal> de la même manière qu'une colonne de table, vue ou
     sous-requête.
    </para>

    <para>
     Si une fonction de table renvoie un type de données de base, la colonne
     de résultat est nommée comme la fonction. Si la fonction renvoie un type
     composite, les colonnes résultantes ont le même nom que les attributs
     individuels du type.
    </para>

    <para>
     Une fonction de table peut avoir un alias dans la clause
     <literal>FROM</literal> mais elle peut être laissée sans alias. Si une
     fonction est utilisée dans la clause <literal>FROM</literal> sans alias, le nom de
     la fonction est utilisé comme nom de table résultante.
    </para>

    <para>
     Quelques exemples&nbsp;:
<programlisting>CREATE TABLE truc (trucid int, trucsousid int, trucnom text);

CREATE FUNCTION recuptruc(int) RETURNS SETOF foo AS $$
    SELECT * FROM truc WHERE trucid = $1;
$$ LANGUAGE SQL;

SELECT * FROM recuptruc(1) AS t1;

SELECT * FROM truc
    WHERE trucsousid IN (select trucsousid from recuptruc(truc.trucid) z
                           where z.trucid = truc.trucid);

CREATE VIEW vue_recuptruc AS SELECT * FROM recuptruc(1);
SELECT * FROM vue_recuptruc;</programlisting>
    </para>

    <para>
     Dans certains cas, il est utile de définir des fonctions de table pouvant
     renvoyer des ensembles de colonnes différentes suivant la façon dont elles
     sont appelées. Pour supporter ceci, la fonction de table est déclarée comme
     renvoyant le pseudotype <type>record</type>. Quand une telle fonction est
     utilisée dans une requête, la structure de ligne attendue doit être
     spécifiée dans la requête elle-même, de façon à ce que le système sache
     comment analyser et planifier la requête. Considérez cet exemple&nbsp;:
<programlisting>SELECT *
    FROM dblink('dbname=mabd', 'select proname, prosrc from pg_proc')
      AS t1(proname nom, prosrc text)
    WHERE proname LIKE 'bytea%';</programlisting>
     La fonction <literal>dblink</literal> exécute une requête distante (voir
     <filename>contrib/dblink</filename>). Elle déclare renvoyer le type
     <type>record</type> car elle pourrait être utilisée pour tout type de requête.
     L'ensemble de colonnes réelles doit être spécifié dans la requête
     appelante de façon à ce que l'analyseur sache, par exemple, comment
     étendre <literal>*</literal>.
    </para>
   </sect3>
  </sect2>

  <sect2 id="queries-where">
   <title>Clause <literal>WHERE</literal></title>

   <indexterm zone="queries-where">
    <primary>WHERE</primary>
   </indexterm>

   <para>
    La syntaxe de la <xref linkend="sql-where" endterm="sql-where-title"/> est
<synopsis>WHERE <replaceable>condition_recherche</replaceable></synopsis>
    où <replaceable>condition_recherche</replaceable> est toute expression de
    valeur (voir la <xref linkend="sql-expressions"/>) renvoyant une valeur
    de type <type>boolean</type>.
   </para>

   <para>
    Après le traitement de la clause <literal>FROM</literal>, chaque ligne de la
    table virtuelle dérivée est vérifiée avec la condition de recherche. Si le
    résultat de la vérification est positif (true), la ligne est conservée dans
    la table de sortie, sinon (c'est-à-dire si le résultat est faux ou nul), la
    ligne est abandonnée. La condition de recherche référence typiquement au
    moins quelques colonnes de la table générée dans la clause
    <literal>FROM</literal>&nbsp;; ceci n'est pas requis mais, dans le cas contraire,
    la clause <literal>WHERE</literal> n'aurait aucune utilité.
   </para>

   <note>
    <para>
     La condition de jointure d'une jointure interne peut être écrite soit dans
     la clause <literal>WHERE</literal> soit dans la clause <literal>JOIN</literal>. Par
     exemple, ces expressions de tables sont équivalentes&nbsp;:
<programlisting>FROM a, b WHERE a.id = b.id AND b.val &gt; 5</programlisting>
     et&nbsp;:
<programlisting>FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5</programlisting>
     ou même peut-être&nbsp;:
<programlisting>FROM a NATURAL JOIN b WHERE b.val &gt; 5</programlisting>
     Laquelle vous utilisez est plutôt une affaire de style. La syntaxe
     <literal>JOIN</literal> dans la clause <literal>FROM</literal> n'est probablement pas
     aussi portable vers les autres systèmes de gestion de bases de données SQL.
     Pour les jointures externes, il n'y a pas d'autres choix&nbsp;: elles
     doivent être faites dans la clause <literal>FROM</literal>. Une clause
     <literal>ON</literal>/<literal>USING</literal> d'une jointure externe n'est
     <emphasis>pas</emphasis> équivalente à une condition <literal>WHERE</literal> parce
     qu'elle détermine l'ajout de lignes (pour les lignes qui ne correspondent
     pas en entrée) ainsi que pour la suppression de lignes dans le résultat
     final.
    </para>
   </note>

   <para>
    Voici quelques exemples de clauses <literal>WHERE</literal>&nbsp;:
<programlisting>SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)</programlisting>
    <literal>fdt</literal> est la table dérivée dans la clause
    <literal>FROM</literal>. Les lignes qui ne correspondent pas à la condition de
    recherche de la clause <literal>WHERE</literal> sont éliminées de la table
    <literal>fdt</literal>. Notez l'utilisation de sous-requêtes scalaires en
    tant qu'expressions de valeurs. Comme n'importe quelle autre requête, les
    sous-requêtes peuvent employer des expressions de tables complexes. Notez
    aussi comment <literal>fdt</literal> est référencée dans les sous-requêtes.
    Qualifier <literal>c1</literal> comme <literal>fdt.c1</literal> est seulement nécessaire
    si <literal>c1</literal> est aussi le nom d'une colonne dans la table d'entrée
    dérivée de la sous-requête. Mais qualifier le nom de colonne ajoute à la
    clarté même lorsque cela n'est pas nécessaire. Cet exemple montre comment
    le nom de colonne d'une requête externe est étendue dans les requêtes
    internes.
   </para>
  </sect2>


  <sect2 id="queries-group">
   <title>Clauses <literal>GROUP BY</literal> et
<literal>HAVING</literal></title>

   <indexterm zone="queries-group">
    <primary>GROUP BY</primary>
   </indexterm>

   <indexterm zone="queries-group">
    <primary>groupement</primary>
   </indexterm>

   <para>
    Après avoir passé le filtre <literal>WHERE</literal>, la table d'entrée dérivée
    peut être sujette à un regroupement en utilisant la clause <literal>GROUP
    BY</literal> et à une élimination de groupe de lignes avec la clause
    <literal>HAVING</literal>.
   </para>

<synopsis>SELECT <replaceable>liste_selection</replaceable>
    FROM ...
    <optional>WHERE ...</optional>
    GROUP BY <replaceable>reference_colonne_regroupement</replaceable><optional>,<replaceable>reference_colonne_regroupement</replaceable></optional>...</synopsis>

   <para>
    La <xref linkend="sql-groupby" endterm="sql-groupby-title"/> est
    utilisée pour regrouper les lignes d'une table partageant les mêmes valeurs
    dans toutes les colonnes précisées. L'ordre dans lequel ces colonnes sont
    indiquées importe peu. L'effet est de combiner chaque ensemble de lignes
    partageant des valeurs communes en un seul groupe de ligne représentant
    toutes les lignes du groupe. Ceci est fait pour éliminer les redondances dans
    la sortie et/ou pour calculer les agrégats s'appliquant à ces groupes. Par
    exemple&nbsp;:
<screen><prompt>=&gt;</prompt> <userinput>SELECT * FROM test1;</userinput>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x FROM test1 GROUP BY x;</userinput>
 x
---
 a
 b
 c
(3 rows)</screen>
   </para>
	  
   <para>
    Dans la seconde requête, nous n'aurions pas pu écrire <literal>SELECT *
    FROM test1 GROUP BY x</literal> parce qu'il n'existe pas une seule valeur
    pour la colonne <literal>y</literal> pouvant être associé avec chaque autre groupe.
    Les colonnes de regroupement peuvent être référencées dans la liste de
    sélection car elles ont une valeur constante unique par groupe.
   </para>

   <para>
    En général, si une table est groupée, les colonnes qui ne sont pas
    utilisées dans le regroupement ne peuvent pas être référencées sauf dans les
    expressions d'agrégats. Voici un exemple d'expressions d'agrégat&nbsp;:
<screen><prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)</screen>
    Ici, <literal>sum</literal> est la fonction d'agrégat qui calcule une seule
    valeur pour le groupe entier. La <xref linkend="functions-aggregate"/>
    propose plus d'informations sur les fonctions d'agrégats disponibles.
   </para>

   <tip>
    <para>
     Le regroupement sans expressions d'agrégats calcule effectivement
     l'ensemble les valeurs distinctes d'une colonne. Ceci peut aussi se faire
     en utilisant la clause <literal>DISTINCT</literal> (voir la <xref
     linkend="queries-distinct"/>).
    </para>
   </tip>

   <para>
    Voici un autre exemple&nbsp;: il calcule les ventes totales pour chaque
    produit (plutôt que le total des ventes sur tous les produits)&nbsp;:
<programlisting>SELECT produit_id, p.nom, (sum(v.unite) * p.prix) AS ventes
    FROM produits p LEFT JOIN ventes v USING (produit_id)
    GROUP BY produit_id, p.nom, p.prix;</programlisting>
    Dans cet exemple, les colonnes <literal>produit_id</literal>,
    <literal>p.nom</literal> et <literal>p.prix</literal> doivent être dans la
    clause <literal>GROUP BY</literal> car elles sont référencées dans la liste de
    sélection de la requête (suivant la façon dont est conçue la table
    produits, le nom et le prix pourraient être totalement dépendants de l'ID du
    produit, donc des regroupements supplémentaires pourraient théoriquement
    être inutiles mais ceci n'est pas encore implémenté). La colonne
    <literal>s.unite</literal> n'a pas besoin d'être dans la liste <literal>GROUP
    BY</literal> car elle est seulement utilisée dans l'expression de l'agrégat
    (<literal>sum(...)</literal>) représentant les ventes d'un produit. Pour
    chaque produit, la requête renvoie une ligne de résumé sur les ventes de ce
    produit.
   </para>

   <para>
    En SQL strict, <literal>GROUP BY</literal> peut seulement grouper les colonnes de
    la table source mais <productname>PostgreSQL</productname> étend ceci en
    autorisant <literal>GROUP BY</literal> à grouper aussi les colonnes de la liste de
    sélection. Grouper par expressions de valeurs au lieu de simples noms de
    colonnes est aussi permis.
   </para>

   <indexterm>
    <primary>HAVING</primary>
   </indexterm>

   <para>
    Si une table a été groupée en utilisant la clause <literal>GROUP
    BY</literal> mais que seuls certains groupes sont intéressants, la clause
    <literal>HAVING</literal> peut être utilisée, comme une clause
    <literal>WHERE</literal>, pour éliminer les groupes d'une table groupée. Voici la
    syntaxe&nbsp;:
<synopsis>SELECT <replaceable>liste_selection</replaceable> FROM ... <optional>WHERE ...</optional> GROUP BY ... HAVING <replaceable>expression_booléenne</replaceable></synopsis>
    Les expressions de la clause <literal>HAVING</literal> peuvent référer à la fois
    aux expressions groupées et aux expressions non groupées (ce qui impliquent
    nécessairement une fonction d'agrégat).
   </para>

   <para>
    Exemple&nbsp;:
<screen><prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)</screen>
   </para>

   <para>
    De nouveau, un exemple plus réaliste&nbsp;:
<programlisting>SELECT produit_id, p.nom, (sum(v.unite) * (p.prix - p.cout)) AS profit
    FROM produits p LEFT JOIN ventes v USING (produit_id)
    WHERE v.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY produit_id, p.nom, p.prix, p.cout
    HAVING sum(p.prix * s.unite) &gt; 5000;</programlisting>
    Dans l'exemple ci-dessus, la clause <literal>WHERE</literal> sélectionne les
    lignes par une colonne qui n'est pas groupée (l'expression est vraie
    seulement pour les ventes des quatre dernières semaines) alors que la
    clause <literal>HAVING</literal> restreint la sortie aux groupes dont le total des
    ventes dépasse 5000. Notez que les expressions d'agrégats n'ont pas besoin
    d'être identiques dans toutes les parties d'une requête.
   </para>

   <para>
    If a query contains aggregate function calls, but no <literal>GROUP BY</>
    clause, grouping still occurs: the result is a single group row (or
    perhaps no rows at all, if the single row is then eliminated by
    <literal>HAVING</>).
    The same is true if it contains a <literal>HAVING</> clause, even
    without any aggregate function calls or <literal>GROUP BY</> clause.
   </para>
  </sect2>

  <sect2 id="queries-window">
   <title>Window Function Processing</>

   <indexterm zone="queries-window">
    <primary>window function</primary>
    <secondary>order of execution</>
   </indexterm>

   <para>
    If the query contains any window functions (see
    <xref linkend="tutorial-window"> and
    <xref linkend="syntax-window-functions">), these functions are evaluated
    after any grouping, aggregation, and <literal>HAVING</> filtering is
    performed.  That is, if the query uses any aggregates, <literal>GROUP
    BY</>, or <literal>HAVING</>, then the rows seen by the window functions
    are the group rows instead of the original table rows from
    <literal>FROM</>/<literal>WHERE</>.
   </para>

   <para>
    When multiple window functions are used, all the window functions having
    syntactically equivalent <literal>PARTITION BY</> and <literal>ORDER BY</>
    clauses in their window definitions are guaranteed to be evaluated in a
    single pass over the data. Therefore they will see the same sort ordering,
    even if the <literal>ORDER BY</> does not uniquely determine an ordering.
    However, no guarantees are made about the evaluation of functions having
    different <literal>PARTITION BY</> or <literal>ORDER BY</> specifications.
    (In such cases a sort step is typically required between the passes of
    window function evaluations, and the sort is not guaranteed to preserve
    ordering of rows that its <literal>ORDER BY</> sees as equivalent.)
   </para>

   <para>
    Currently, window functions always require presorted data, and so the
    query output will be ordered according to one or another of the window
    functions' <literal>PARTITION BY</>/<literal>ORDER BY</> clauses.
    It is not recommendable to rely on this, however.  Use an explicit
    top-level <literal>ORDER BY</> clause if you want to be sure the
    results are sorted in a particular way.
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-select-lists">
  <title>Listes de sélection</title>

  <indexterm>
   <primary>SELECT</primary>
   <secondary>liste de sélection</secondary>
  </indexterm>

  <para>
   Comme montré dans la section précédente, l'expression de table pour la
commande <command>SELECT</command> construit une table virtuelle intermédiaire
en combinant les tables, vues, en éliminant les lignes, en groupant, etc. Cette
table est finalement passée à la réalisation de la <firstterm>liste de
sélection</firstterm>. Cette liste détermine les <emphasis>colonnes</emphasis>
de la table intermédiaire à afficher.
  </para>

  <sect2 id="queries-select-list-items">
   <title>Éléments de la liste de sélection</title>

   <indexterm>
    <primary>*</primary>
   </indexterm>

   <para>
    La forme la plus simple de liste de sélection est <literal>*</literal>.
    C'est un raccourci pour indiquer toutes les colonnes que l'expression de
    table produit. Sinon, une liste de sélection est une liste d'expressions
    de valeurs séparées par des virgules (comme défini dans la <xref
    linkend="sql-expressions"/>). Par exemple, cela pourrait être une liste des
    noms de colonnes&nbsp;:
<programlisting>SELECT a, b, c FROM ...</programlisting>
     Les noms de colonnes <literal>a</literal>, <literal>b</literal> et <literal>c</literal> sont
     soit les noms actuels des colonnes des tables référencées dans la clause
     <literal>FROM</literal> soit les alias qui leur ont été donnés (voir l'explication
     dans <xref linkend="queries-table-aliases"/>). L'espace de nom disponible
     dans la liste de sélection est le même que dans la clause <literal>WHERE</literal>
     sauf si le regroupement est utilisé, auquel cas c'est le même que dans la
     clause <literal>HAVING</literal>.
   </para>

   <para>
    Si plus d'une table a une colonne du même nom, le nom de la table doit
aussi être donné comme dans&nbsp;:
<programlisting>SELECT tbl1.a, tbl2.a, tbl1.b FROM ...</programlisting>
    En travaillant avec plusieurs tables, il est aussi utile de demander toutes
    les colonnes d'une table particulière&nbsp;:
<programlisting>SELECT tbl1.*, tbl2.a FROM ...</programlisting>
    (voir aussi la <xref linkend="queries-where"/>)
   </para>

   <para>
    Si une expression de valeur arbitraire est utilisée dans la liste de
    sélection, il ajoute conceptuellement une nouvelle colonne virtuelle dans la
    table renvoyée. L'expression de valeur est évaluée une fois pour chaque
    ligne avec une substitution des valeurs de lignes avec les références de
    colonnes. Mais les expressions de la liste de sélection n'ont pas à
    référencer les colonnes dans l'expression de la table de la clause
    <literal>FROM</literal>&nbsp;; elles pourrait être des expressions arithmétiques
    constantes, par exemple.
   </para>
  </sect2>

  <sect2 id="queries-column-labels">
   <title>Labels de colonnes</title>

   <indexterm zone="queries-column-labels">
    <primary>alias</primary>
    <secondary>dans la liste de sélection</secondary>
   </indexterm>

   <para>
    Les entrées de la liste de sélection peuvent se voir affecter des noms
    pour la suite de l'exécution. Dans ce cas, la <quote>suite de
    l'exécution</quote> est une spécification optionnelle du tri et
    l'application client (c'est-à-dire les en-têtes de colonne pour
    l'affichage). Par exemple&nbsp;:
<programlisting>SELECT a AS valeur, b + c AS sum FROM ...</programlisting>
   </para>

   <para>
    Si aucun nom de colonne en sortie n'est spécifié en utilisant
    <literal>AS</literal>, le système affecte un nom de colonne par défaut.
    Pour les références de
    colonne simple, c'est le nom de la colonne référencée. Pour les appels de
    fonction, il s'agit du nom de la fonction. Pour les expressions complexes,
    le système générera un nom générique.
   </para>

   <para>
    The <literal>AS</> keyword is optional, but only if the new column
    name does not match any
    <productname>PostgreSQL</productname> keyword (see <xref
    linkend="sql-keywords-appendix">).  To avoid an accidental match to
    a keyword, you can double-quote the column name.  For example,
    <literal>VALUE</> is a keyword, so this does not work:
<programlisting>
SELECT a value, b + c AS sum FROM ...
</programlisting>
    but this does:
<programlisting>
SELECT a "value", b + c AS sum FROM ...
</programlisting>
    For protection against possible
    future keyword additions, it is recommended that you always either
    write <literal>AS</literal> or double-quote the output column name.
   </para>

   <note>
    <para>
     Le nom des colonnes en sortie est différent ici de ce qui est fait dans la
     clause <literal>FROM</literal> (voir la <xref linkend="queries-table-aliases"/>).
     Ce tube vous permettra en fait de renommer deux fois la même colonne mais
     le nom choisi dans la liste de sélection est celui qui sera passé.
    </para>
   </note>
  </sect2>

  <sect2 id="queries-distinct">
   <title><literal>DISTINCT</literal></title>

   <indexterm zone="queries-distinct">
    <primary>DISTINCT</primary>
   </indexterm>

   <indexterm zone="queries-distinct">
    <primary>duplication</primary>
   </indexterm>

   <para>
    Après le traitement de la liste de sélection, la table résultant pourrait
    être optionnellement sujet à l'élimination des lignes dupliquées. Le mot clé
    <literal>DISTINCT</literal> est écrit directement après
    <literal>SELECT</literal> pour spécifier ceci&nbsp;:
<synopsis>SELECT DISTINCT <replaceable>liste_selection</replaceable> ...</synopsis>
    (au lieu de <literal>DISTINCT</literal>, le mot clé <literal>ALL</literal> peut être
    utilisé pour spécifier le comportement par défaut, la récupération de
    toutes les lignes)
   </para>

   <para>
    <indexterm><primary>valeur NULL</primary><secondary sortas="DISTINCT">dans
    DISTINCT</secondary></indexterm>
    Évidemment, les deux lignes sont considérées distinctes si elles diffèrent
    dans au moins une valeur de colonne. Les valeurs NULL sont considérées
    égales dans cette comparaison.
   </para>

   <para>
    Autrement, une expression arbitraire peut déterminer quelles lignes
    doivent être considérées distinctes&nbsp;:
<synopsis>SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ...</optional>) <replaceable>liste_selection</replaceable> ... </synopsis>
    Ici, <replaceable>expression</replaceable> est une expression de valeur
    arbitraire, évaluée pour toutes les lignes. Les lignes dont toutes les
    expressions sont égales sont considérées comme dupliquées et seule la
    première ligne de cet ensemble est conservée dans la sortie. Notez que la
    <quote>première ligne</quote> d'un ensemble est non prévisible sauf si la
    requête est triée sur assez de colonnes pour garantir un ordre unique des
    colonnes arrivant dans le filtre <literal>DISTINCT</literal> (le traitement de
    <literal>DISTINCT ON</literal> parvient après le tri de <literal>ORDER BY</literal>).
   </para>

   <para>
    La clause <literal>DISTINCT ON</literal> ne fait pas partie du standard SQL et est
    quelque fois considérée comme étant un mauvais style à cause de la nature
    potentiellement indéterminée de ses résultats. Avec l'utilisation judicieuse
    de <literal>GROUP BY</literal> et de sous-requêtes dans <literal>FROM</literal>, la
    construction peut être évitée mais elle représente souvent l'alternative la
    plus agréable.
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-union">
  <title>Combiner des requêtes</title>

  <indexterm zone="queries-union">
   <primary>UNION</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>INTERSECT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>EXCEPT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set union</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set intersection</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set difference</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set operation</primary>
  </indexterm>

  <para>
   Les résultats de deux requêtes peuvent être combinés en utilisant les 
   opérations d'ensemble&nbsp;: union, intersection et différence. La syntaxe
   est
<synopsis><replaceable>requete1</replaceable> UNION <optional>ALL</optional> <replaceable>requete2</replaceable>
<replaceable>requete1</replaceable> INTERSECT <optional>ALL</optional> <replaceable>requete2</replaceable>
<replaceable>requete1</replaceable> EXCEPT <optional>ALL</optional> <replaceable>requete2</replaceable></synopsis>
   <replaceable>requete1</replaceable> et
   <replaceable>requete2</replaceable> sont les requêtes pouvant utiliser
   toutes les fonctionnalités discutées ici. Les opérations d'ensemble peuvent
   aussi être combinées et chaînées, par exemple
<synopsis><replaceable>requete1</replaceable> UNION <replaceable>requete2</replaceable> UNION <replaceable>requete3</replaceable></synopsis>
   signifie réellement
<synopsis>(<replaceable>requete1</replaceable> UNION <replaceable>requete2</replaceable>) UNION <replaceable>requete3</replaceable></synopsis>
  </para>

  <para>
   <literal>UNION</literal> ajoute effectivement le résultat de
   <replaceable>requete2</replaceable> au résultat de
   <replaceable>requete1</replaceable> (bien qu'il n'y ait pas de garantie
   qu'il s'agit de l'ordre dans lequel les lignes sont réellement renvoyées). De
   plus, il élimine les lignes dupliquées du résultat, de la même façon que
   <literal>DISTINCT</literal>, sauf si <literal>UNION ALL</literal> est utilisée.
  </para>

  <para>
   <literal>INTERSECT</literal> renvoie toutes les lignes qui sont à la fois dans le
   résultat de <replaceable>requete1</replaceable> et dans le résultat de
   <replaceable>requete2</replaceable>. Les lignes dupliquées sont éliminées
   sauf si <literal>INTERSECT ALL</literal> est utilisé.
  </para>

  <para>
   <literal>EXCEPT</literal> renvoie toutes les lignes qui sont dans le résultat de
   <replaceable>requete1</replaceable> mais pas dans le résultat de
   <replaceable>requete2</replaceable> (ceci est quelque fois appelé la
   <firstterm>différence</firstterm> entre deux requêtes). De nouveau, les lignes
   dupliquées sont éliminées sauf si <literal>EXCEPT ALL</literal> est utilisé.
  </para>

  <para>
   Pour calculer l'union, l'intersection ou la différence de deux requêtes, les
   deux requêtes doivent être <quote>compatibles pour une union</quote>, ce qui
   signifie qu'elles doivent renvoyer le même nombre de colonnes et que les
   colonnes correspondantes doivent avoir des types de données compatibles,
   comme décrit dans la <xref linkend="typeconv-union-case"/>.
  </para>
 </sect1>


 <sect1 id="queries-order">
  <title>Tri des lignes</title>

  <indexterm zone="queries-order">
   <primary>tri</primary>
  </indexterm>

  <indexterm zone="queries-order">
   <primary>ORDER BY</primary>
  </indexterm>
	   
  <para>
   Après qu'une requête ait produit une table en sortie (après que la liste de
   sélection ait été traitée), elle peut être optionnellement triée. Si le tri
   n'a pas été choisi, les lignes sont renvoyées dans un ordre non spécifié.
   Dans ce cas, l'ordre réel dépendra des types de plan de parcours et de
   jointure et de l'ordre sur le disque mais vous ne devez pas vous y fier. Un
   tri particulier en sortie peut seulement être garantie si l'étape de tri est
   choisie explicitement.
  </para>

  <para>
   La clause <literal>ORDER BY</literal> spécifie l'ordre de tri&nbsp;:
<synopsis>SELECT <replaceable>liste_selection</replaceable>
    FROM <replaceable>expression_table</replaceable>
    ORDER BY <replaceable>expression_tri1</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional>
<optional>, <replaceable>expression_tri2</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional> ...</optional>
</synopsis>

   Les expressions de tri peuvent être toute expression qui serait valide dans
   la liste de sélection des requêtes. Voici un exemple&nbsp;:
<programlisting>
SELECT a, b FROM table1 ORDER BY a + b, c;
</programlisting>
   Quand plus d'une expression est indiquée, les valeurs suivantes sont
   utilisées pour trier les lignes qui sont identiques aux valeurs précédentes.
   Chaque expression pourrait être suivie d'un
   <literal>ASC</literal> ou <literal>DESC</literal> optionnel pour configurer la
   direction du tri (ascendant ou descendant). L'ordre <literal>ASC</literal> est la
   valeur par défaut. L'ordre ascendant place les plus petites valeurs en
   premier où <quote>plus petit</quote> est défini avec l'opérateur
   <literal>&lt;</literal>. De façon similaire, l'ordre descendant est
   déterminé avec l'opérateur <literal>&gt;</literal>.
    <footnote>
     <para>
      En fait, <productname>PostgreSQL</productname> utilise la <firstterm>classe
      d'opérateur B-tree par défaut</firstterm> pour le type de données de
      l'expression pour déterminer l'ordre de tri avec <literal>ASC</literal>
      et <literal>DESC</literal>.
      De façon conventionnelle, les types de données seront initialisés de
      façon à ce que les opérateurs <literal>&lt;</literal> et
      <literal>&gt;</literal> correspondent à cet ordre de tri mais un
      concepteur des types de données définis par l'utilisateur pourrait choisir
      de faire quelque chose de différent.
     </para>
    </footnote>
  </para>

  <para>
   Les options <literal>NULLS FIRST</literal> et <literal>NULLS LAST</literal>
   sont utilisées pour déterminer si les valeurs NULL apparaissent avant ou
   après les valeurs non NULL après un tri. Par défaut, les valeurs NULL sont
   triées comme si elles avaient une valeur plus importante que les valeurs non
   NULL&nbsp;; autrement dit <literal>NULLS FIRST</literal> est la valeur par
   défaut pour un tri descendant, alors que <literal>NULLS LAST</literal> est
   la valeur par défaut pour un tri ascendant.
  </para>

  <para>
   Notez que les options de tri sont considérées indépendament pour chaque
   colonne triée. Par exemple, <literal>ORDER BY x, y DESC</literal> signifie
   en fait <literal>ORDER BY x ASC, y DESC</literal>, ce qui est différent de
   <literal>ORDER BY x DESC, y DESC</literal>.
  </para>

  <para>
   Pour une compatibilité ascendante avec la version SQL92 du standard,
   une <replaceable>expression_tri</replaceable> peut être à la place le nom
   ou le numéro d'une colonne en sortie, par exemple&nbsp;:
<programlisting>SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;
</programlisting>
   les deux triant par la première colonne en sortie. Notez qu'un nom de colonne
   en sortie doit être unique, il ne doit pas faire partie d'une expression
   &mdash; par exemple, ceci n'est <emphasis>pas</emphasis> correct&nbsp;:
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -- mauvais
</programlisting>
   Cette restriction est là pour réduire l'ambiguïté. Il y en a toujours si un
   élément <literal>ORDER BY</literal> est un simple nom qui pourrait
   correspondre soit à un nom de colonne en sortie soit à une colonne d'une
   expression de table. La colonne en sortie est utilisée dans de tels cas.
   Cela causera seulement de la confusion si vous utilisez <literal>AS</literal>
   pour renommer une colonne en sortie qui correspondra à un autre nom de
   colonne d'une table.
  </para>

  <para>
   <literal>ORDER BY</literal> peut être appliqué au résultat d'une combinaison
   <literal>UNION</literal>, d'une combinaison<literal>INTERSECT</literal> ou
   d'une combinaison <literal>EXCEPT</literal> mais, dans ce cas, il est
   seulement permis de trier par les noms ou numéros de colonnes, pas par les
   expressions.
  </para>
 </sect1>


 <sect1 id="queries-limit">
  <title><literal>LIMIT</literal> et <literal>OFFSET</literal></title>

  <indexterm zone="queries-limit">
   <primary>LIMIT</primary>
  </indexterm>

  <indexterm zone="queries-limit">
   <primary>OFFSET</primary>
  </indexterm>

  <para>
   <literal>LIMIT</literal> et <literal>OFFSET</literal> vous permet de retrouver seulement 
   une portion des lignes générées par le reste de la requête&nbsp;:
<synopsis>SELECT <replaceable>liste_selection</replaceable>
    FROM <replaceable>expression_table</replaceable>
    <optional> ORDER BY ...</optional>
    <optional> LIMIT { <replaceable>nombre</replaceable> | ALL } </optional> <optional>OFFSET <replaceable>nombre</replaceable></optional></synopsis>
  </para>

  <para>
   Si un nombre limite est donné, pas plus que ce nombre de lignes sera renvoyé
   (mais peut-être moins si la requête récupère moins de lignes). <literal>LIMIT
   ALL</literal> est identique à ne pas spécifier la clause <literal>LIMIT</literal>.
  </para>

  <para>
   <literal>OFFSET</literal> indique de passer ce nombre de lignes avant de renvoyer 
   les lignes restantes. <literal>OFFSET 0</literal> revient à oublier la clause
   <literal>OFFSET</literal>, and <literal>LIMIT NULL</> is the same
   as omitting the <literal>LIMIT</> clause. Si à la fois <literal>OFFSET</literal> et <literal>LIMIT</literal>
   apparaissent, alors les <literal>OFFSET</literal> lignes sont laissées avant de
   commencer le renvoi des <literal>LIMIT</literal> lignes.
  </para>

  <para>
   Lors de l'utilisation de <literal>LIMIT</literal>, il est important d'utiliser une
   clause <literal>ORDER BY</literal> contraignant les lignes résultantes dans un ordre
   unique. Sinon, vous obtiendrez un sous-ensemble non prévisible de lignes de
   la requête. Vous pourriez demander les lignes de 10 à 20 mais dans quel
   ordre&nbsp;? L'ordre est inconnu si vous ne spécifiez pas <literal>ORDER
   BY</literal>.
  </para>

  <para>
   L'optimiseur de requêtes prend <literal>LIMIT</literal> en compte lors de la
   génération d'un plan de requêtes, de façon à ce que vous obteniez
   différents plans (avec différents ordres de lignes) suivant ce que vous
   donnez à <literal>LIMIT</literal> et <literal>OFFSET</literal>. Du coup, utiliser des
   valeurs <literal>LIMIT</literal>/<literal>OFFSET</literal> différentes pour sélectionner
   des sous-ensembles différents d'un résultat de requête <emphasis>donnera des
   résultats inconsistants</emphasis> sauf si vous forcez un ordre de
   résultat prévisible avec <literal>ORDER BY</literal>. Ceci n'est pas un bogue&nbsp;;
   c'est une conséquence inhérente du fait que le SQL ne promette par de
   délivrer les résultats d'une requête dans un ordre particulier sauf si
   <literal>ORDER BY</literal> est utilisé pour contraindre l'ordre.
  </para>

  <para>
   Les lignes passées par une clause <literal>OFFSET</literal> devront toujours être
   traitées à l'intérieur du serveur&nbsp;; du coup, un <literal>OFFSET</literal>
   important peut être inefficace.
  </para>
 </sect1>


 <sect1 id="queries-values">
  <title>Listes <literal>VALUES</literal></title>

  <indexterm zone="queries-values">
   <primary>VALUES</primary>
  </indexterm>

  <para>
   <literal>VALUES</literal> fournit une façon de générer une table de
   <quote>constantes</quote> qui peut être utilisé dans une requête sans
   avoir à réellement créer et peupler une table sur disque. La syntaxe est
<synopsis>
VALUES ( <replaceable class="parameter">expression</replaceable> [, ...] ) [, ...]
</synopsis>
   Chaque liste d'expressions entre parenthèses génère une ligne dans la table.
   Les listes doivent toutes avoir le même nombre d'éléments (c'est-à-dire une
   liste de colonnes dans la table), et les entrées correspondantes dans chaque
   liste doivent avoir des types compatibles. Le type réel affecté à chaque colonne
   du résultat est déterminé en utilisant les mêmes règles que pour
   <literal>UNION</literal> (voir <xref linkend="typeconv-union-case"/>).
  </para>

  <para>
   Voici un exemple&nbsp;:

<programlisting>VALUES (1, 'un'), (2, 'deux'), (3, 'trois');
</programlisting>

   renverra une table de deux colonnes et trois lignes. C'est équivalent à&nbsp;:

<programlisting>SELECT 1 AS column1, 'un' AS column2
UNION ALL
SELECT 2, 'deux'
UNION ALL
SELECT 3, 'trois';
</programlisting>

   Par défaut, <productname>PostgreSQL</productname> affecte les noms
   <literal>column1</literal>, <literal>column2</literal>, etc. aux colonnes
   d'une table <literal>VALUES</literal>. Les noms des colonnes ne sont pas
   spécifiés par le standard SQL et les différents SGBD le font de façon
   différente. Donc, il est généralement mieux de surcharger les noms par
   défaut avec une liste d'alias.
  </para>

  <para>
   Syntaxiquement, <literal>VALUES</literal> suivi par une liste d'expressions
   est traité de la même façon que
<synopsis>SELECT <replaceable>liste_select</replaceable> FROM <replaceable>expression_table</replaceable>
</synopsis>
   et peut apparaître partout où un <literal>SELECT</literal> le peut. Par
   exemple, vous pouvez l'utiliser comme élément d'un <literal>UNION</literal>
   ou y attacher une <replaceable>spécification de tri</replaceable>
   (<literal>ORDER BY</literal>, <literal>LIMIT</literal> et/ou <literal>OFFSET</literal>).
   <literal>VALUES</literal> est habituellement utilisée comme source de données
   dans une commande <command>INSERT</command> command, mais aussi dans une
   sous-requête.
  </para>

  <para>
   Pour plus d'informations, voir <xref linkend="sql-values"
   endterm="sql-values-title"/>.
  </para>

 </sect1>


 <sect1 id="queries-with">
  <title><literal>WITH</literal> Queries</title>

  <indexterm zone="queries-with">
   <primary>WITH</primary>
   <secondary>in SELECT</secondary>
  </indexterm>

  <indexterm>
   <primary>common table expression</primary>
   <see>WITH</see>
  </indexterm>

  <para>
   <literal>WITH</> provides a way to write subqueries for use in a larger
   <literal>SELECT</> query.  The subqueries can be thought of as defining
   temporary tables that exist just for this query.  One use of this feature
   is to break down complicated queries into simpler parts.  An example is:

<programlisting>
WITH regional_sales AS (
        SELECT region, SUM(amount) AS total_sales
        FROM orders
        GROUP BY region
     ), top_regions AS (
        SELECT region
        FROM regional_sales
        WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)
     )
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
</programlisting>

   which displays per-product sales totals in only the top sales regions.
   This example could have been written without <literal>WITH</>,
   but we'd have needed two levels of nested sub-SELECTs.  It's a bit
   easier to follow this way.
  </para>

  <para>
   The optional <literal>RECURSIVE</> modifier changes <literal>WITH</>
   from a mere syntactic convenience into a feature that accomplishes
   things not otherwise possible in standard SQL.  Using
   <literal>RECURSIVE</>, a <literal>WITH</> query can refer to its own
   output.  A very simple example is this query to sum the integers from 1
   through 100:

<programlisting>
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n &lt; 100
)
SELECT sum(n) FROM t;
</programlisting>

   The general form of a recursive <literal>WITH</> query is always a
   <firstterm>non-recursive term</>, then <literal>UNION</> (or
   <literal>UNION ALL</>), then a
   <firstterm>recursive term</>, where only the recursive term can contain
   a reference to the query's own output.  Such a query is executed as
   follows:
  </para>

  <procedure>
   <title>Recursive Query Evaluation</title>

   <step performance="required">
    <para>
     Evaluate the non-recursive term.  For <literal>UNION</> (but not
     <literal>UNION ALL</>), discard duplicate rows.  Include all remaining
     rows in the result of the recursive query, and also place them in a
     temporary <firstterm>working table</>.
    </para>
   </step>

   <step performance="required">
    <para>
     So long as the working table is not empty, repeat these steps:
    </para>
    <substeps>
     <step performance="required">
      <para>
       Evaluate the recursive term, substituting the current contents of
       the working table for the recursive self-reference.
       For <literal>UNION</> (but not <literal>UNION ALL</>), discard
       duplicate rows and rows that duplicate any previous result row.
       Include all remaining rows in the result of the recursive query, and
       also place them in a temporary <firstterm>intermediate table</>.
      </para>
     </step>

     <step performance="required">
      <para>
       Replace the contents of the working table with the contents of the
       intermediate table, then empty the intermediate table.
      </para>
     </step>
    </substeps>
   </step>
  </procedure>

  <note>
   <para>
    Strictly speaking, this process is iteration not recursion, but
    <literal>RECURSIVE</> is the terminology chosen by the SQL standards
    committee.
   </para>
  </note>

  <para>
   In the example above, the working table has just a single row in each step,
   and it takes on the values from 1 through 100 in successive steps.  In
   the 100th step, there is no output because of the <literal>WHERE</>
   clause, and so the query terminates.
  </para>

  <para>
   Recursive queries are typically used to deal with hierarchical or
   tree-structured data.  A useful example is this query to find all the
   direct and indirect sub-parts of a product, given only a table that
   shows immediate inclusions:

<programlisting>
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
  )
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
</programlisting>
  </para>

  <para>
   When working with recursive queries it is important to be sure that
   the recursive part of the query will eventually return no tuples,
   or else the query will loop indefinitely.  Sometimes, using
   <literal>UNION</> instead of <literal>UNION ALL</> can accomplish this
   by discarding rows that duplicate previous output rows.  However, often a
   cycle does not involve output rows that are completely duplicate: it may be
   necessary to check just one or a few fields to see if the same point has
   been reached before.  The standard method for handling such situations is
   to compute an array of the already-visited values.  For example, consider
   the following query that searches a table <structname>graph</> using a
   <structfield>link</> field:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth) AS (
        SELECT g.id, g.link, g.data, 1
        FROM graph g
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1
        FROM graph g, search_graph sg
        WHERE g.id = sg.link
)
SELECT * FROM search_graph;
</programlisting>

   This query will loop if the <structfield>link</> relationships contain
   cycles.  Because we require a <quote>depth</> output, just changing
   <literal>UNION ALL</> to <literal>UNION</> would not eliminate the looping.
   Instead we need to recognize whether we have reached the same row again
   while following a particular path of links.  We add two columns
   <structfield>path</> and <structfield>cycle</> to the loop-prone query:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
        SELECT g.id, g.link, g.data, 1,
          ARRAY[g.id],
          false
        FROM graph g
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1,
          path || g.id,
          g.id = ANY(path)
        FROM graph g, search_graph sg
        WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>

   Aside from preventing cycles, the array value is often useful in its own
   right as representing the <quote>path</> taken to reach any particular row.
  </para>

  <para>
   In the general case where more than one field needs to be checked to
   recognize a cycle, use an array of rows.  For example, if we needed to
   compare fields <structfield>f1</> and <structfield>f2</>:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
        SELECT g.id, g.link, g.data, 1,
          ARRAY[ROW(g.f1, g.f2)],
          false
        FROM graph g
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1,
          path || ROW(g.f1, g.f2),
          ROW(g.f1, g.f2) = ANY(path)
        FROM graph g, search_graph sg
        WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>
  </para>

  <tip>
   <para>
    Omit the <literal>ROW()</> syntax in the common case where only one field
    needs to be checked to recognize a cycle.  This allows a simple array
    rather than a composite-type array to be used, gaining efficiency.
   </para>
  </tip>

  <tip>
   <para>
    The recursive query evaluation algorithm produces its output in
    breadth-first search order.  You can display the results in depth-first
    search order by making the outer query <literal>ORDER BY</> a
    <quote>path</> column constructed in this way.
   </para>
  </tip>

  <para>
   A helpful trick for testing queries
   when you are not certain if they might loop is to place a <literal>LIMIT</>
   in the parent query.  For example, this query would loop forever without
   the <literal>LIMIT</>:

<programlisting>
WITH RECURSIVE t(n) AS (
    SELECT 1
  UNION ALL
    SELECT n+1 FROM t
)
SELECT n FROM t LIMIT 100;
</programlisting>

   This works because <productname>PostgreSQL</productname>'s implementation
   evaluates only as many rows of a <literal>WITH</> query as are actually
   fetched by the parent query.  Using this trick in production is not
   recommended, because other systems might work differently.  Also, it
   usually won't work if you make the outer query sort the recursive query's
   results or join them to some other table.
  </para>

  <para>
   A useful property of <literal>WITH</> queries is that they are evaluated
   only once per execution of the parent query, even if they are referred to
   more than once by the parent query or sibling <literal>WITH</> queries.
   Thus, expensive calculations that are needed in multiple places can be
   placed within a <literal>WITH</> query to avoid redundant work.  Another
   possible application is to prevent unwanted multiple evaluations of
   functions with side-effects.
   However, the other side of this coin is that the optimizer is less able to
   push restrictions from the parent query down into a <literal>WITH</> query
   than an ordinary sub-query.  The <literal>WITH</> query will generally be
   evaluated as stated, without suppression of rows that the parent query
   might discard afterwards.  (But, as mentioned above, evaluation might stop
   early if the reference(s) to the query demand only a limited number of
   rows.)
  </para>

 </sect1>

</chapter>
