<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<refentry id="sql-alteropfamily">
 <refmeta>
  <refentrytitle id="sql-alteropfamily-title">ALTER OPERATOR FAMILY</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage SQL</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>ALTER OPERATOR FAMILY</refname>
  <refpurpose>Modifier la définition d'une famille d'opérateur</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
 
	 <indexterm zone="sql-alteropfamily">
	  <primary>ALTER OPERATOR FAMILY</primary>
	 </indexterm>
 
<synopsis>
ALTER OPERATOR FAMILY <replaceable>nom</replaceable> USING <replaceable class="parameter">methode_indexage</replaceable> ADD
  {  OPERATOR <replaceable class="parameter">numero_strategie</replaceable> <replaceable class="parameter">nom_operateur</replaceable> ( <replaceable class="parameter">tpe_op</replaceable>, <replaceable class="parameter">type_op</replaceable> )
   | FUNCTION <replaceable class="parameter">numero_support</replaceable> [ ( <replaceable class="parameter">type_op</replaceable> [ , <replaceable class="parameter">type_op</replaceable> ] ) ] <replaceable class="parameter">nom_fonction</replaceable> ( <replaceable class="parameter">type_argument</replaceable> [, ...] )
  } [, ... ]
ALTER OPERATOR FAMILY <replaceable>nom</replaceable> USING <replaceable class="parameter">methode_indexage</replaceable> DROP
  {  OPERATOR <replaceable class="parameter">numero_strategie</replaceable> ( <replaceable class="parameter">type_op</replaceable> [ , <replaceable class="parameter">type_op</replaceable> ] )
   | FUNCTION <replaceable class="parameter">numero_support</replaceable> ( <replaceable class="parameter">type_op</replaceable> [ , <replaceable class="parameter">type_op</replaceable> ] )
  } [, ... ]
ALTER OPERATOR FAMILY <replaceable>nom</replaceable> USING <replaceable class="parameter">methode_indexage</replaceable> RENAME TO <replaceable>nouveau_nom</replaceable>
ALTER OPERATOR FAMILY <replaceable>nom</replaceable> USING <replaceable class="parameter">methode_indexage</replaceable> OWNER TO <replaceable>nouveau_proprietaire</replaceable>
</synopsis>
 </refsynopsisdiv>
  
 <refsect1>
  <title>Description</title>

  <para>
   <command>ALTER OPERATOR FAMILY</command> modifie la définition d'une famille
   d'opérateur. Vous pouvez ajouter des opérateurs et des fonctions du support à
   la famille, les supprimer ou modifier le nom et le propriétaire de la
   famille.
  </para>

  <para>
   Quand les opérateurs et fonctions de support sont ajoutés à une famille avec
   la commande <command>ALTER OPERATOR FAMILY</command>, ils ne font partie
   d'aucune classe d'opérateur spécifique à l'intérieur de la famille. Ils
   sont <quote>lÃ¢ches</quote> dans la famille. Ceci indique que ces opérateurs
   et fonctions sont compatibles avec la sémantique de la famille but qu'ils
   ne sont pas requis pour un fonctionnement correct d'un index spécifique.
   (Les opérateurs et fonctions qui sont ainsi nécessaires doivent être
   déclarés comme faisant partie d'une classe d'opérateur&nbsp;; voir
   <xref linkend="sql-createopclass" endterm="sql-createopclass-title"/>.)
   <productname>PostgreSQL</productname> la suppression des membres lÃ¢ches
   d'une famille à tout moment, mais les membres d'une classe d'opérateur ne
   peuvent pas être supprimés sans supprimer toute la classe et les index
   qui en dépendent. Typiquement, les opérateurs et fonctions sur un seul type
   de données font partie des classes d'opérateurs car ils ont besoin de
   supporter un index sur ce type de données spécifique alors que les opérateurs
   et familles inter-types sont fait de membres lÃ¢ches de la famille.
  </para>

  <para>
   Vous devez être superutilisateur pour utiliser <command>ALTER OPERATOR
   FAMILY</command>.
   (Cette restriction est faite parce qu'une définition erronée d'une famille
   d'opérateur pourrait gêner voire même arrêter brutalement le serveur.)
  </para>

  <para>
   <command>ALTER OPERATOR FAMILY</command> ne vérifie pas encore si la définition
   de l'opérateur de famille inclut tous les opérateurs et fonctions requis par
   la méthode d'indexage, ni si les opérateurs et les fonctions forment un
   ensemble cohérent et suffisant. C'est de la responsabilité de l'utilisateur
   de définir une famille d'opérateur valide.
  </para>

  <para>
   Voir <xref linkend="xindex"/> pour plus d'informations.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom d'une famille d'opérateur (pouvant être qualifié du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">methode_indexage</replaceable></term>
    <listitem>
     <para>
      Le nom de la méthode d'indexage.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">numero_strategie</replaceable></term>
    <listitem>
     <para>
      Le numéro de stratégie de la méthode d'indexage pour un opérateur
      associé avec la famille.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_operateur</replaceable></term>
    <listitem>
     <para>
      Le nom d'un opérateur (pouvant être qualifié du schéma) associé avec la
      famille d'opérateur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_op</replaceable></term>
    <listitem>
     <para>
      Dans une clause <literal>OPERATOR</literal>, les types de données en
      opérande de l'opérateur, ou <literal>NONE</literal> pour signifier un
      opérateur unaire. Contrairement à la syntaxe comparable de <command>CREATE
      OPERATOR CLASS</command>, les types de données en opérande doivent
      toujours être précisés.
     </para>

     <para>
      Dans une clause <literal>ADD FUNCTION</literal>, les types de données des
      opérandes que la fonction est sensée supporter, si différent des types de
      données en entrée de la fonction. Pour les index B-tree et hash, il n'est
      pas strictement nécessaire de spécifier <replaceable
      class="parameter">op_type</replaceable> car les types de données en entrée
      de la fonction sont toujours les bons à utiliser. Pour les index GIN et
      GiST, il est nécessaire de spécifier le type de données en entrée qui sera
      utilisé par la fonction.
     </para>

     <para>
      Dans une clause <literal>DROP FUNCTION</literal>, les types de données
      en opérande que la fonction est sensée supportée doivent être
      précisés.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">numero_support</replaceable></term>
    <listitem>
     <para>
      Le numéro de la procédure de support de la méthode d'indexage associé
      avec la famille d'opérateur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_fonction</replaceable></term>
    <listitem>
     <para>
      Le nom (pouvant être qualifié du schéma) d'une fonction qui est une
      procédure de support de la méthode d'indexage pour la famille
      d'opérateur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">argument_types</replaceable></term>
    <listitem>
     <para>
      Les types de données pour les arguments de la fonction.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nouveau_nom</replaceable></term>
    <listitem>
     <para>
      Le nouveau nom de la famille d'opérateur
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nouveau_proprietaire</replaceable></term>
    <listitem>
     <para>
      Le nouveau propriétaire de la famille d'opérateur
     </para>
    </listitem>
   </varlistentry>
 </variablelist>

  <para>
   Les clauses <literal>OPERATOR</literal> et <literal>FUNCTION</literal>
   peuvent apparaÃ®tre dans n'importe quel ordre.
  </para>

 </refsect1>
  
 <refsect1>
  <title>Notes</title>

  <para>
   Notez que la syntaxe <literal>DROP</literal> spécifie uniquement le
   <quote>slot</quote> dans la famille d'opérateur, par stratégie ou numéro
   de support et types de données en entrée. Le nom de l'opérateur ou de la
   fonction occupant le slot n'est pas mentionné. De plus, pour <literal>DROP
   FUNCTION</literal>, les types à spécifier sont les types de données en
   entrée que la fonction doit supporter&nbsp;; pour les index GIN et GiST,
   ceci pourrait ne rien avoir à faire avec les types d'argument en entrée
   de la fonction.
  </para>

  <para>
   Comme le processus des index ne vérifie pas les droits sur les fonctions
   avant de les utiliser, inclure une fonction ou un opérateur dans une famille
   d'opérateur est équivalent à donner le droit d'exécution à public. Ceci n'est
   généralement pas un problème pour les tris de fonction qui sont utiles à une
   famille d'opérateur.
  </para>

  <para>
   Les opérateurs ne doivent pas être définis par des fonctions SQL. Une
   fonction SQL risque d'être remplacée dans la requête appelante, ce qui
   empêchera l'optimiseur de savoir si la requête peut utiliser un index.
  </para>
  
  <para>
   Before <productname>PostgreSQL</productname> 8.4, the <literal>OPERATOR</>
   clause could include a <literal>RECHECK</> option.  This is no longer
   supported because whether an index operator is <quote>lossy</> is now
   determined on-the-fly at runtime.  This allows efficient handling of
   cases where an operator might or might not be lossy.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Exemples</title>

  <para>
   La commande exemple suivant ajoute des opérateurs inter-type de données et
   ajoute les fonctions de support pour une famille d'opérateur qui contient
   déjà les classes d'opérateur B_tree pour les types de données
   <type>int4</type> et <type>int2</type>.
  </para>

<programlisting>
ALTER OPERATOR FAMILY integer_ops USING btree ADD

  -- int4 vs int2
  OPERATOR 1 &lt; (int4, int2) ,
  OPERATOR 2 &lt;= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 &gt;= (int4, int2) ,
  OPERATOR 5 &gt; (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  -- int2 vs int4
  OPERATOR 1 &lt; (int2, int4) ,
  OPERATOR 2 &lt;= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 &gt;= (int2, int4) ,
  OPERATOR 5 &gt; (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ;
</programlisting>  

  <para>
   Pour supprimer de nouveau ces entrées&nbsp;:
  </para>

<programlisting>
ALTER OPERATOR FAMILY integer_ops USING btree DROP

  -- int4 vs int2
  OPERATOR 1 (int4, int2) ,
  OPERATOR 2 (int4, int2) ,
  OPERATOR 3 (int4, int2) ,
  OPERATOR 4 (int4, int2) ,
  OPERATOR 5 (int4, int2) ,
  FUNCTION 1 (int4, int2) ,

  -- int2 vs int4
  OPERATOR 1 (int2, int4) ,
  OPERATOR 2 (int2, int4) ,
  OPERATOR 3 (int2, int4) ,
  OPERATOR 4 (int2, int4) ,
  OPERATOR 5 (int2, int4) ,
  FUNCTION 1 (int2, int4) ;
</programlisting>  
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas d'instruction <command>ALTER OPERATOR FAMILY</command> dans
   le standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createopfamily" endterm="sql-createopfamily-title"/></member>
   <member><xref linkend="sql-dropopfamily" endterm="sql-dropopfamily-title"/></member>
   <member><xref linkend="sql-createopclass" endterm="sql-createopclass-title"/></member>
   <member><xref linkend="sql-alteropclass" endterm="sql-alteropclass-title"/></member>
   <member><xref linkend="sql-dropopclass" endterm="sql-dropopclass-title"/></member>
  </simplelist>
 </refsect1>
</refentry>
