<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/alter_table.sgml,v 1.10 2005/09/15 07:03:25 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-ALTERTABLE">
 <refmeta>
  <refentrytitle id="sql-altertable-title">ALTER TABLE</refentrytitle>
  <refmiscinfo>SQL - Commandes du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>ALTER TABLE</refname>
  <refpurpose>change la définition d'une table</refpurpose>
 </refnamediv>

 <indexterm zone="sql-altertable">
  <primary>ALTER TABLE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
ALTER TABLE [ ONLY ] <replaceable class="PARAMETER">nom</replaceable> [ * ]
    <replaceable class="PARAMETER">action</replaceable> [, ... ]
ALTER TABLE [ ONLY ] <replaceable class="PARAMETER">nom</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="PARAMETER">colonne</replaceable> TO <replaceable class="PARAMETER">nouvelle_colonne</replaceable>
ALTER TABLE <replaceable class="PARAMETER">nom</replaceable>
    RENAME TO <replaceable class="PARAMETER">nouveau_nom</replaceable>
ALTER TABLE <replaceable class="PARAMETER">nom</replaceable>
    SET SCHEMA <replaceable class="PARAMETER">nouveau_schema</replaceable>

où <replaceable class="PARAMETER">action</replaceable> fait partie de :

    ADD [ COLUMN ] <replaceable class="PARAMETER">colonne</replaceable> <replaceable class="PARAMETER">type</replaceable> [ <replaceable class="PARAMETER">contrainte_colonne</replaceable> [ ... ] ]
    DROP [ COLUMN ] <replaceable class="PARAMETER">colonne</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="PARAMETER">colonne</replaceable> TYPE <replaceable class="PARAMETER">type</replaceable> [ USING <replaceable class="PARAMETER">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="PARAMETER">colonne</replaceable> SET DEFAULT <replaceable class="PARAMETER">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="PARAMETER">colonne</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="PARAMETER">colonne</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="PARAMETER">colonne</replaceable> SET STATISTICS <replaceable class="PARAMETER">entier</replaceable>
    ALTER [ COLUMN ] <replaceable class="PARAMETER">colonne</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <replaceable class="PARAMETER">contrainte_table</replaceable>
    DROP CONSTRAINT <replaceable class="PARAMETER">nom_contrainte</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="PARAMETER">nom_declencheur</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="PARAMETER">nom_declencheur</replaceable> | ALL | USER ]
    CLUSTER ON <replaceable class="PARAMETER">nom_index</replaceable>
    SET WITHOUT CLUSTER
    SET WITHOUT OIDS
    OWNER TO <replaceable class="PARAMETER">nouveau_proprietaire</replaceable>
    SET TABLESPACE <replaceable class="PARAMETER">nouvel_espacelogique</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>ALTER TABLE</command> change la définition d'une table existante.
   Il existe plusieurs variantes :

  <variablelist>
   <varlistentry>
    <term><literal>ADD COLUMN</literal></term>
    <listitem>
     <para>
      Cette variante ajoute une nouvelle colonne à la table en utilisant la même syntaxe que
       <xref linkend="SQL-CREATETABLE" endterm="SQL-CREATETABLE-TITLE">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP COLUMN</literal></term>
    <listitem>
     <para>
      Cette variante supprime une colonne d'une table. Les index et les 
      contraintes de table référençant cette colonne sont automatiquement supprimés.
      Il faut utiliser l'option <literal>CASCADE</> si certains objets hors
      de la table dépendent de cette colonne, comme par exemple des références
      de clés étrangères ou des vues.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ALTER COLUMN TYPE</literal></term>
    <listitem>
     <para>
      Cette variante modifie le type d'une colonne de la table. Les index et
      les contraintes de table simples impliquant la colonne seront
      automatiquement convertis pour utiliser le nouveau type de la colonne en
      réanalysant l'expression fournie au départ. La clause
      <literal>USING</literal> optionnelle spécifie comment calculer la nouvelle
      valeur de la colonne à partir de l'ancienne ; en cas d'omission, la
      conversion par défaut est identique à une affectation de l'ancien type
      vers le nouveau. Une clause <literal>USING</literal> doit être fournie
      s'il n'existe pas de conversion implicite de l'ancien vers le nouveau
      type.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
    <listitem>
     <para>
      Ces variantes ajoutent ou enlèvent des valeurs par défaut pour une colonne.
      Ces valeurs par défaut ne s'appliquent qu'aux prochaines commandes
      <command>INSERT</command>. Elles ne modifient pas les lignes déjà 
      présentes dans la table. Des valeurs par défaut peuvent aussi être créées
      pour les vues. Dans ce cas, elles sont ajoutées aux commandes 
      <command>INSERT</> de la vue avant que la règle 
      <literal>ON INSERT</literal> de la vue ne soit appliquée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
    <listitem>
     <para>
      Ces variantes changent le fait que la colonne indique autoriser les
      valeurs NULL ou non. <literal>SET NOT NULL</> ne peut être utilisé que
      si la colonne ne contient pas de valeurs NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
     <para>
      Cette variante permet de modifier l'objectif de collecte de statistiques
      par colonne pour les opérations d'analyse 
      (<xref linkend="sql-analyze" endterm="sql-analyze-title">) à venir.
      L'objectif prend une valeur entre 0 et 1000. Le mettre à -1 pour utiliser
      l'objectif de statistiques par défaut du système (<xref
      linkend="guc-default-statistics-target">). Pour plus d'informations sur
      l'utilisation des statistiques par le planificateur de requêtes de
      <productname>PostgreSQL</productname>, référez-vous à <xref
      linkend="planner-stats">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <indexterm>
     <primary>TOAST</primary>
     <secondary>configuration de stockage par colonne</secondary>
    </indexterm>

    <term><literal>SET STORAGE</literal></term>
    <listitem>
     <para>
      Ces variantes changent le mode de stockage pour une colonne. Cela permet de
      contrôler si cette colonne est gardée en ligne dans la table ou bien
      externalisée dans une table supplémentaire, et si les données doivent
      être compressées ou non. 
      <literal>PLAIN</literal> doit être utilisé pour les valeurs
      de longueur fixe, comme les <type>integer</type> et est en ligne non
      compressé. <literal>MAIN</literal> est pour les données en ligne 
      compressibles. <literal>EXTERNAL</literal> est pour les données externes
      non compressées. <literal>EXTENDED</literal> est pour les données externes 
      compressées. <literal>EXTENDED</literal> est la valeur par défaut pour la
      plupart des types qui supportent les autres stockages que
      <literal>PLAIN</literal>. Utiliser <literal>EXTERNAL</literal> rendra les
      opérations d'extraction de sous-chaînes <type>text</type> et
      <type>bytea</type> plus rapides mais utilisera plus d'espace de stockage.
      Notez que <literal>SET STORAGE</> ne modifie rien dans la table, il
      configure la stratégie à poursuivre lors des prochaines mises à jour de
      tables. Voir <xref linkend="storage-toast"> pour plus d'informations.
      
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable
	class="PARAMETER">contrainte_table</replaceable></literal></term>
    <listitem>
     <para>
      Cette variante ajoute une nouvelle contrainte à une table en utilisant la
      même syntaxe que <xref linkend="SQL-CREATETABLE"
      endterm="SQL-CREATETABLE-TITLE">. 
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP CONSTRAINT</literal></term>
    <listitem>
     <para>
      Cette forme supprime la contrainte spécifiée d'une table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE TRIGGER</literal></term>
    <listitem>
     <para>
      Ces formes désactivent ou activent le(s) déclencheur(s) appartenant à la
      table. Un déclencheur désactivé est toujours connu par le système mais
      il n'est plus exécuté lorsque l'événement déclencheur survient. Pour un
      déclencheur déferré, le statut actif est vérifié au moment où l'événement
      se passe, pas quand la fonction du déclencheur est réellement exécutée.
      Il est possible de désactiver ou d'activer un déclencheur spécifique, tous
      les déclencheurs d'une table ou seulement les déclencheurs utilisateur
      de cette table (cette option exclut les déclencheurs utilisés pour
      implémenter les contraintes de clés étrangères). Désactiver ou activer
      les déclencheurs de contraintes demande des droits de
      superutilisateur ; cela ne peut pas se faire sans précaution car,
      bien sûr, l'intégrité de la contrainte ne peut pas être garantie si les
      déclencheurs ne sont pas exécutés.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CLUSTER</literal></term>
    <listitem>
     <para>
      Cette variante sélectionne l'index par défaut pour les prochaines
      opérations <xref linkend="SQL-CLUSTER" endterm="sql-cluster-title">. Il
      ne ré-exécute pas la commande CLUSTER.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
     <para>
      Cette variante supprime la spécification d'index <xref
      linkend="SQL-CLUSTER" endterm="sql-cluster-title"> la plus récemment
      utilisée à partir de cette table. Ceci affecte les prochaines opérations
      CLUSTER qui ne spécifient pas d'index.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      Cette variante supprime la colonne système <literal>oid</literal> de la
      table. Ceci est strictement équivalent à <literal>DROP COLUMN oid
      RESTRICT</literal>, sauf qu'il ne se plaindra pas s'il existe déjà une
      colonne <literal>oid</literal>.
     </para>

     <para>
      Notez qu'il n'existe pas de variante de <command>ALTER TABLE</command>
      qui autoriserait la restauration des OID d'une table, une fois ceux-ci
      supprimés.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OWNER</literal></term>
    <listitem>
     <para>
      Cette variante change le propriétaire d'une table, d'une
      séquence ou d'une vue. Le nouveau propriétaire est celui passé 
      en paramètre.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <para>
      Cette forme modifie l'espace logique de la table par l'espace logique
      spécifié et déplace le(s) fichier(s) de données associé(s) avec la table
      vers le nouvel espace logique. Les index de la table, s'il y en a, ne
      sont pas déplacés ; mais ils peuvent l'être séparément avec des
      commandes <literal>SET TABLESPACE</literal> supplémentaires. Voir aussi
      <xref linkend="SQL-CREATETABLESPACE"
      endterm="sql-createtablespace-title">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RENAME</literal></term>
    <listitem>
     <para>
      La forme <literal>RENAME</literal> modifie le nom d'une table
      (ou d'un index, séquence ou vue) ou le nom d'une colonne individuelle
      d'une table. Elle n'a aucun effet sur la donnée stockée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET SCHEMA</literal></term>
    <listitem>
     <para>
      Cette forme déplace la table dans un autre schéma. Les index,
      contraintes et séquences de colonnes de type SERIAL associés sont aussi
      déplacés.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
  </para>

  <para>
   Toutes les actions à l'exception de <literal>RENAME</literal> et
   <literal>SET SCHEMA</literal> peuvent être
   combinées dans une liste de plusieurs altérations à appliquer en parallèle.
   Par exemple, il est possible d'ajouter plusieurs colonnes et/ou modifier le
   type de plusieurs colonnes en une seule commande. Ceci est particulièrement
   utile avec les grosses tables car seule une passe sur la table sera
   nécessaire.
  </para>

  <para>
   Il faut être propriétaire de la table pour utiliser <command>ALTER TABLE</>.
   Pour modifier le schéma d'une table, vous devez avoir le droit
   <literal>CREATE</literal> sur le nouveau schéma. Pour modifier le
   propriétaire, vous devez aussi être un membre direct ou indirect du nouveau
   rôle et ce dernier doit avoir le droit <literal>CREATE</literal> sur le
   schéma de la table. (Ces restrictions assurent que la modification du
   propriétaire ne fasse rien de plus que vous ne pourriez faire en supprimant
   puis en re-créant la table. Néanmoins, un superutilisateur peut modifier
   le propriétaire de toute table.)
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

    <variablelist>

     <varlistentry>
      <term><replaceable class="PARAMETER">nom</replaceable></term>
      <listitem>
       <para>
    Le nom (éventuellement précisé par un schéma) d'une table existante,
    que l'on veut modifier. Si <literal>ONLY</> est indiqué, cette table
    seulement est modifiée. Si <literal>ONLY</> est absent, alors la table
    et toutes ses tables filles (s'il y en a) sont modifiées.
    <literal>*</> peut être ajouté au nom de la table pour indiquer que ses
    tables descendantes doivent être modifiées. Dans la version courante,
    c'est le comportement par défaut. Dans les versions antérieures à la
    7.1, <literal>ONLY</> était le comportement par défaut.
    Le comportement par défaut peut être modifié en changeant le paramètre
    de configuration <xref linkend="guc-sql-inheritance">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">colonne</replaceable></term>
      <listitem>
       <para>
    Nom d'une colonne existante ou nouvelle.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
        class="PARAMETER">nouvelle_colonne</replaceable></term>
      <listitem>
       <para>
        Nouveau nom d'une colonne existante.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">nouveau_nom</replaceable></term>
      <listitem>
       <para>
        Nouveau nom de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">type</replaceable></term>
      <listitem>
       <para>
        Type de donnée de la nouvelle colonne, ou nouveau type de données d'une
        colonne existante.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
class="PARAMETER">contraintedetable</replaceable></term>
      <listitem>
       <para>
    Nouvelle contrainte de table pour la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">nomdecontrainte</replaceable></term>
      <listitem>
       <para>
    Nom d'une contrainte existante à supprimer
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CASCADE</literal></term>
      <listitem>
       <para>
        Supprime automatiquement les objets dépendant de la colonne ou
        contrainte supprimée (par exemple, les vues référençant la colonne).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RESTRICT</literal></term>
      <listitem>
       <para>
        Refuse de supprimer la colonne ou la contrainte si des objets en
        dépendent. Ceci est le comportement par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">nom_declencheur</replaceable></term>
      <listitem>
       <para>
        Nom d'un seul déclencheur à désactiver ou activer.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
       <para>
        Désactive ou active tous les déclencheurs appartenant à la table.
        (Ceci requiert les droits du superutilisateur si un des déclencheurs
        concerne une contrainte de clé étrangère.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USER</literal></term>
      <listitem>
       <para>
        Désactive ou active tous les déclencheurs appartenant à la table sauf
        ceux concernant des contraintes de clés étrangères.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">nomindex</replaceable></term>
      <listitem>
       <para>
    Nom de l'index sur lequel la table doit être réorganisée en cluster.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="PARAMETER">nouveau_propriétaire</replaceable></term>
      <listitem>
       <para>
        Le nom du nouveau propriétaire de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="PARAMETER">nouvel_espacelogique</replaceable></term>
      <listitem>
       <para>
        Le nom de l'espace logique où sera déplacé la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="PARAMETER">nouveau_schema</replaceable></term>
      <listitem>
       <para>
        Le nom du schéma où sera déplacé la table.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    Le mot clé <literal>COLUMN</literal> n'est pas nécessaire. Il peut
    être omis.
   </para>

   <para>
    Quand une colonne est ajoutée avec <literal>ADD COLUMN</literal>, toutes
    les lignes existantes de cette table sont initialisées avec la valeur par
    défaut de la colonne (NULL si aucune clause <literal>DEFAULT</> n'a été
    définie).
   </para>

   <para>
    Ajouter une colonne avec une valeur par défaut différente de NULL ou
    modifier le type d'une colonne existante requiert que la table entière soit
    ré-écrite. Ceci pourrait prendre un temps considérable pour une grande
    table ; et cela demandera temporairement le double d'espace disque.
   </para>

   <para>
    Ajouter une contrainte <literal>CHECK</> ou <literal>NOT NULL</> requiert
    de parcourir la table pour vérifier que les lignes existantes respectent
    cette contrainte.
   </para>

   <para>
    La raison principale pour fournir l'option de spécification de changements
    multiples en une seule commande <command>ALTER TABLE</> est que les
    parcours ou ré-écritures multiples de table peuvent être combinés en une
    seule passe sur la table.
   </para>

   <para>
    La forme <literal>DROP COLUMN</literal> ne supprime pas physiquement la 
    colonne, mais la rend simplement invisible au SQL.
    Par la suite, les ordres d'insertion et de mise à jour sur cette table 
    stockeront une valeur NULL pour la colonne.
    Du coup, supprimer une colonne ne réduit pas immédiatement la taille de la
    table sur le disque car l'espace occupé par la colonne n'est pas 
    récupéré. Cet espace sera récupéré petit à petit, au fur et à mesure des 
    mises à jour des lignes de la table.
   </para>
    
   <para>
    Le fait qu'<literal>ALTER TYPE</> requiert la ré-écriture de la table
    entière est quelque fois un avantage car le processus de ré-écriture
    élimine tout espace mort dans la table. Par exemple, pour réclamer
    immédiatement la place occupée par une colonne supprimée, la façon la plus
    rapide est
<programlisting>
ALTER TABLE table ALTER COLUMN toutecolonne TYPE touttype;
</programlisting>
    où <literal>toutecolonne</> est toute colonne de table restante et
    <literal>touttype</> est le même type que ce que possède déjà la colonne.
    Cela résulte en des modifications sémantiquement visibles dans la table mais
    la commande force la ré-écriture, qui oublie toute donnée inutile.
   </para>

   <para>
    L'option <literal>USING</literal> d'<literal>ALTER TYPE</> peut en fait
    spécifier toute expression impliquant les anciennes valeurs de la
    ligne ; c'est-à-dire qu'il peut référencer les autres colonnes ainsi
    que celle en cours de conversion. Ceci permet des conversions très
    générales grâce à la syntaxe <literal>ALTER TYPE</>. À cause de cette
    flexibilité, l'expression <literal>USING</literal> n'est pas appliquée à la
    valeur par défaut de la colonne (si elle en a) ; le résultat pourrait
    ne pas être une expression constante requise pour une valeur par défaut.
    Cela signifie que, quand il n'existe pas de conversion implicite ou
    d'affectation de l'ancien au nouveau type, <literal>ALTER TYPE</> pourrait
    échouer dans sa conversion de la valeur par défaut bien que la clause
    <literal>USING</literal> soit spécifiée. Dans de tels cas, supprimez la
    valeur par défaut avec <literal>DROP DEFAULT</>, exécutez le <literal>ALTER
    TYPE</> et enfin utilisez <literal>SET DEFAULT</> pour ajouter une nouvelle
    valeur par défaut convenable. Des considérations similaires s'appliquent aux
    index et contraintes impliquant la colonne.
   </para>

   <para>
    Si une table a des tables descendantes, il n'est pas possible d'ajouter,
    de renommer ou de modifier le type d'une colonne dans la table parent sans
    le faire aussi pour ses descendantes. Donc, la commande <command>ALTER TABLE
    ONLY</command> est rejetée. Ceci assure que les descendantes ont toujours
    des colonnes correspondant à celles de la table parente.
   </para>

   <para>
    Un appel récursif à <literal>DROP COLUMN</literal> supprimera une colonne
    d'une table descendante si et seulement si la table descendante n'hérite 
    pas de cette colonne d'une autre table et n'a jamais eu de définition 
    indépendante de la colonne.
    Une suppression de colonne non récursive (c'est à dire une commande
    <command>ALTER TABLE ONLY ... DROP COLUMN</command>) ne supprime
    jamais les colonnes descendantes mais les marque comme définies 
    de manière indépendante, plutôt qu'héritées.
   </para>

   <para>
    Les actions <literal>TRIGGER</>, <literal>CLUSTER</>, <literal>OWNER</>,
    et <literal>TABLESPACE</> ne sont pas récursives avec les tables
    descendantes ; c'est-à-dire qu'elles agissent comme si
    <literal>ONLY</> avait été spécifié.
    Ajouter une contrainte peut impliquer une récursion uniquement pour les
    contraintes <literal>CHECK</>.
   </para>

   <para>
    On ne peut pas changer quoi que ce soit dans une table du catalogue
    système.
   </para>

   <para>
    Voir la commande <xref linkend="sql-createtable"
    endterm="sql-createtable-title"> pour avoir une 
    description plus complète des paramètres valides.
    <xref linkend="ddl"> donne plus d'informations sur l'héritage.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Pour ajouter une colonne de type <type>varchar</type> à une table :
<programlisting>
ALTER TABLE distributeurs ADD COLUMN adresse varchar(30);
</programlisting>
  </para>

  <para>
   Pour supprimer une colonne d'une table :
<programlisting>
ALTER TABLE distributeurs DROP COLUMN adresse RESTRICT;
</programlisting>
  </para>

  <para>
   Pour modifier les types de deux colonnes existantes en une opération :
<programlisting>
ALTER TABLE distributeurs
    ALTER COLUMN adresse TYPE varchar(80),
    ALTER COLUMN nom TYPE varchar(100);
</programlisting>
  </para>

  <para>
   Pour modifier une colonne de type entier contenant une date/heure UNIX en
   <type>timestamp with time zone</type> avec une clause
   <literal>USING</literal> :
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>

  <para>
   Pour renommer une colonne existante :
<programlisting>
ALTER TABLE distributeurs RENAME COLUMN adresse TO city;
</programlisting>
  </para>

  <para>
   Pour renommer une table existante :
<programlisting>
ALTER TABLE distributeurs RENAME TO suppliers;
</programlisting>
  </para>

  <para>
   Pour ajouter une contrainte NOT NULL à une colonne :
<programlisting>
ALTER TABLE distributeurs ALTER COLUMN rue SET NOT NULL;
</programlisting>
   Pour supprimer une contrainte NOT NULL d'une colonne :
<programlisting>
ALTER TABLE distributeurs ALTER COLUMN rue DROP NOT NULL;
</programlisting>
  </para>

  <para> 
   Pour ajouter une contrainte de vérification sur une table :
<programlisting>
ALTER TABLE distributeurs ADD CONSTRAINT verif_zip CHECK (char_length(zipcode) = 5);
</programlisting>
  </para>

  <para> 
   Pour supprimer une contrainte de vérification d'une table et de toutes ses
   tables filles :
<programlisting>
ALTER TABLE distributeurs DROP CONSTRAINT verif_zip;
</programlisting>
  </para>

  <para> 
   Pour ajouter une contrainte de clé étrangère à une table :
<programlisting>
ALTER TABLE distributeurs ADD CONSTRAINT distfk FOREIGN KEY (adresse) REFERENCES adresses (adresse) MATCH FULL;
</programlisting>
  </para>

  <para> 
   Pour ajouter une contrainte unique (multicolonnes) à une table :
<programlisting>
ALTER TABLE distributeurs ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
</programlisting>
  </para>

  <para> 
   Pour ajouter une clé primaire nommée automatiquement à une table.
   Remarque : une table ne peut avoir qu'une seule clé primaire dans toute 
   sa vie.
<programlisting>
ALTER TABLE distributeurs ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>
  
  <para> 
        Pour déplacer une table dans un espace logique différent :
<programlisting>
ALTER TABLE distributeurs SET TABLESPACE espacelogiquerapide;
</programlisting>
  </para>

  <para> 
   Pour déplacer une table dans un schéma différent :
<programlisting>
ALTER TABLE mon_schema.distributeurs SET SCHEMA votre_schema;
</programlisting>
  </para>

 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Les formes <literal>ADD</literal>, <literal>DROP</> et <literal>SET
   DEFAULT</> se conforment au standard SQL. Les autres formes sont des
   extensions <productname>PostgreSQL</productname> au standard SQL. De plus,
   la capacité à spécifier plus d'une manipulation en une seule commande
   <command>ALTER TABLE</> est une extension.
  </para>

  <para>
   <command>ALTER TABLE DROP COLUMN</> peut être utilisé pour supprimer
   la seule colonne d'une table, laissant une table sans colonne.
   C'est une extension de SQL, qui ne permet pas les tables sans colonne.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->

