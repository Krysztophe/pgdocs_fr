<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060616 -->

<refentry id="sql-altertable">
 <refmeta>
  <refentrytitle id="sql-altertable-title">ALTER TABLE</refentrytitle>
  <refmiscinfo>SQL - Commandes du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>ALTER TABLE</refname>
  <refpurpose>Modifier la définition d'une table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>ALTER TABLE [ ONLY ] <replaceable class="parameter">nom</replaceable> [ * ]
    <replaceable class="parameter">action</replaceable> [, ... ]
ALTER TABLE [ ONLY ] <replaceable class="parameter">nom</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="parameter">colonne</replaceable> TO <replaceable class="parameter">nouvelle_colonne</replaceable>
ALTER TABLE <replaceable class="parameter">nom</replaceable>
    RENAME TO <replaceable class="parameter">nouveau_nom</replaceable>
ALTER TABLE <replaceable class="parameter">nom</replaceable>
    SET SCHEMA <replaceable class="parameter">nouveau_schema</replaceable>

où <replaceable class="parameter">action</replaceable> peut être&nbsp;:

    ADD [ COLUMN ] <replaceable class="parameter">colonne</replaceable> <replaceable class="parameter">type</replaceable> [ <replaceable class="parameter">contrainte_colonne</replaceable> [ ... ] ]
    DROP [ COLUMN ] <replaceable class="parameter">colonne</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> TYPE <replaceable class="parameter">type</replaceable> [ USING <replaceable class="parameter">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> SET DEFAULT <replaceable class="parameter">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> SET STATISTICS <replaceable class="parameter">entier</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <replaceable class="parameter">contrainte_table</replaceable>
    DROP CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="parameter">nom_declencheur</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="parameter">nom_declencheur</replaceable> | ALL | USER ]
    ENABLE REPLICA TRIGGER <replaceable class="parameter">nom_trigger</replaceable>
    ENABLE ALWAYS TRIGGER <replaceable class="parameter">nom_trigger</replaceable>
    DISABLE RULE <replaceable class="parameter">nom_regle_reecriture</replaceable>
    ENABLE RULE <replaceable class="parameter">nom_regle_reecriture</replaceable>
    ENABLE REPLICA RULE <replaceable class="parameter">nom_regle_reecriture</replaceable>
    ENABLE ALWAYS RULE <replaceable class="parameter">nom_regle_reecriture</replaceable>
    CLUSTER ON <replaceable class="parameter">nom_index</replaceable>
    SET WITHOUT CLUSTER
    SET WITHOUT OIDS
    SET ( <replaceable class="parameter">paramètre_stockage</replaceable> = <replaceable class="parameter">valeur</replaceable> [, ... ] )
    RESET ( <replaceable class="parameter">paramètre_stockage</replaceable> [, ... ] )
    INHERIT <replaceable class="parameter">table_parent</replaceable>
    NO INHERIT <replaceable class="parameter">table_parent</replaceable>
    OWNER TO <replaceable class="parameter">nouveau_proprietaire</replaceable>
    SET TABLESPACE <replaceable class="parameter">nouvel_espacelogique</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-altertable">
   <primary>ALTER TABLE</primary>
  </indexterm>

  <para>
   <command>ALTER TABLE</command> modifie la définition d'une table existante.
   Il existe plusieurs variantes&nbsp;:

  <variablelist>
   <varlistentry>
    <term><literal>ADD COLUMN</literal></term>
    <listitem>
     <para>
      Ajoute une nouvelle colonne à la table en utilisant une syntaxe identique à celle de
       <xref linkend="sql-createtable" endterm="sql-createtable-title"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP COLUMN</literal></term>
    <listitem>
     <para>
      Supprime une colonne de la table. Les index et les 
      contraintes de table référençant cette colonne sont automatiquement supprimés.
      L'option <literal>CASCADE</literal> doit être utilisée lorsque des objets en dehors
      de la table dépendent de cette colonne, comme par exemple des références
      de clés étrangères ou des vues.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ALTER COLUMN TYPE</literal></term>
    <listitem>
     <para>
      Change le type d'une colonne de la table. Les index et
      les contraintes simples de table qui impliquent la colonne sont
      automatiquement convertis pour utiliser le nouveau type de la colonne en
      réanalysant l'expression d'origine. La clause
      optionnelle <literal>USING</literal> précise comment calculer la nouvelle
      valeur de la colonne à partir de l'ancienne&nbsp;; en cas d'omission, la
      conversion par défaut est identique à une affectation de transtypage de l'ancien type
      vers le nouveau. Une clause <literal>USING</literal> doit être fournie
      s'il n'existe pas de conversion implicite ou d'assignement entre les deux types.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
    <listitem>
     <para>
      Ajoute ou supprime les valeurs par défaut d'une colonne.
      Les valeurs par défaut ne s'appliquent qu'aux commandes
      <command>INSERT</command> ultérieures. Elles ne modifient pas les lignes déjà 
      présentes dans la table. Des valeurs par défaut peuvent aussi être créées
      pour les vues. Dans ce cas, elles sont ajoutées aux commandes 
      <command>INSERT</command> de la vue avant que la règle 
      <literal>ON INSERT</literal> de la vue ne soit appliquée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
    <listitem>
     <para>
      Modifie l'autorisation de
      valeurs NULL. <literal>SET NOT NULL</literal> ne peut être utilisé que
      si la colonne ne contient pas de valeurs NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
     <para>
      Permet de modifier l'objectif de collecte de statistiques
      par colonne pour les opérations d'analyse 
      (<xref linkend="sql-analyze" endterm="sql-analyze-title"/>) ultérieures.
      L'objectif prend une valeur entre 0 et 1000. il est positionné à -1 pour utiliser
      l'objectif de statistiques par défaut du système
      (<xref linkend="guc-default-statistics-target"/>). Pour plus d'informations sur
      l'utilisation des statistiques par le planificateur de requêtes de
      <productname>PostgreSQL</productname>, voir <xref linkend="planner-stats"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STORAGE</literal></term>
    <listitem>
    <indexterm>
     <primary>TOAST</primary>
     <secondary>configuration de stockage par colonne</secondary>
    </indexterm>

     <para>
      Modifie le mode de stockage pour une colonne. Cela permet de
      contrôler si cette colonne est conservée en ligne ou 
      dans une table supplémentaire, et si les données sont ou non
      compressées. 
      <literal>PLAIN</literal>, en ligne, non compressé, est utilisé pour les valeurs
      de longueur fixe, comme les <type>integer</type>.
      <literal>MAIN</literal> convient pour les données en ligne,
      compressibles. <literal>EXTERNAL</literal> est fait pour les données externes
      non compressées, <literal>EXTENDED</literal> pour les données externes 
      compressées. <literal>EXTENDED</literal> est la valeur par défaut pour la
      plupart des types qui supportent les stockages différents de
      <literal>PLAIN</literal>. L'utilisation d'<literal>EXTERNAL</literal> 
      permet d'accélérer les
      opérations d'extraction de sous-chaînes sur les colonnes de types <type>text</type> et
      <type>bytea</type> mais utilise plus d'espace de stockage.
      <literal>SET STORAGE</literal> ne modifie rien dans la table, il
      configure la stratégie à poursuivre lors des mises à jour de
      tables suivantes. Voir <xref linkend="storage-toast"/> pour plus d'informations.
      
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">contrainte_table</replaceable></literal></term>
    <listitem>
     <para>
      Ajoute une nouvelle contrainte à une table en utilisant une
      syntaxe identique à <xref linkend="sql-createtable" endterm="sql-createtable-title"/>. 
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP CONSTRAINT</literal></term>
    <listitem>
     <para>
      Supprime la contrainte de table précisée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] TRIGGER</literal></term>
    <listitem>
     <para>
      Configure l'exécution des déclencheurs définis sur la
      table. Un déclencheur désactivé est toujours connu par le système mais
      n'est plus exécuté lorsque l'événement déclencheur survient. Pour un
      déclencheur retardé, le statut d'activité est vérifié au moment où survient l'événement,
      et non quand la fonction du déclencheur est réellement exécutée.
      Il est possible de désactiver ou d'activer un déclencheur spécifique (précisé par son nom),
	  tous les déclencheurs d'une table ou seulement les déclencheurs utilisateur
      de cette table (cette option exclut les déclencheurs utilisés pour
      implanter les contraintes de clés étrangères). Désactiver ou activer
      les déclencheurs de contraintes requiert des droits de
      superutilisateur&nbsp;; cela doit se faire avec précaution car
      l'intégrité de la contrainte ne peut pas être garantie si les
      déclencheurs ne sont pas exécutés.
      Le mécanisme de déclenchement des triggers est aussi affecté par la
      variable de configuration <xref linkend="guc-session-replication-role"/>.
      Les triggers activés (<literal>ENABLE</literal>) se déclencheront quand
      le rôle de réplication est <quote>origin</quote> (la valeur par défaut)
      ou <quote>local</quote>. Les triggers configurés <literal>ENABLE
      REPLICA</literal> se déclencheront seulement si la session est en mode
      <quote>replica</quote> et les triggers <literal>ENABLE ALWAYS</literal>
      se déclencheront à chaque fois, quelque soit le mode de réplication.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] RULE</literal></term>
    <listitem>
     <para>
      Ces formes configurent le déclenchement des règles de ré-écriture
      appartenant à la table. Une règle désactivée est toujours connue par le
      système mais non appliquée lors de la ré-écriture de la requête. La
      sémantique est identique celles des triggers activés/désactivés. Cette
      configuration est ignorée pour les règles <literal>ON SELECT</literal>
      qui sont toujours appliqués pour conserver le bon fonctionnement des
      vues même si la session actuelle n'est pas dans le rôle de réplication
      par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CLUSTER</literal></term>
    <listitem>
     <para>
      Sélectionne l'index par défaut pour les prochaines
      opérations <xref linkend="sql-cluster" endterm="sql-cluster-title"/>.
      La table n'est pas réorganisée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
     <para>
      Supprime de la table la spécification d'index
	  <xref linkend="sql-cluster" endterm="sql-cluster-title"/> la plus récemment
      utilisée. Cela agit sur les opérations de réorganisation suivantes qui ne spécifient pas d'index.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      Supprime la colonne système <literal>oid</literal> de la
      table. Cela est strictement équivalent à <literal>DROP COLUMN oid RESTRICT</literal>,
      à ceci près qu'aucun avertissement n'est émis si la colonne <literal>oid</literal> n'existe plus.
     </para>

     <para>
      Il n'existe pas de variante d'<command>ALTER TABLE</command>
      qui autorise la restauration des OID d'une table après leur suppression.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="parameter">paramètre_stockage</replaceable> = <replaceable class="parameter">valeur</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      Cette forme modifie un ou plusieurs paramètres de stockage pour la table.
      Voir <xref linkend="sql-createtable" endterm="sql-createtable-title"/>
      pour les détails sur les paramètres disponibles. Notez que le contenu de
      la table ne sera pas modifié immédiatement par cette commande&nbsp;;
      suivant le paramètre, vous aurez besoin de réécrire la table pour
      obtenir les effets désirés. Ceci peut se faire avec <xref
      linkend="sql-cluster" endterm="sql-cluster-title"/> ou une des formes
      d'<command>ALTER TABLE</command> qui force une réécriture de la table.
     </para>

     <note>
      <para>
       Bien que <command>CREATE TABLE</command> autorise la spécification de
       <literal>OIDS</literal> avec la syntaxe <literal>WITH (<replaceable
       class="parameter">paramètre_stockage</replaceable>)</literal>,
       <command>ALTER TABLE</command> ne traite pas les <literal>OIDS</literal>
       comme un paramètre de stockage.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESET ( <replaceable class="parameter">paramètre_stockage</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      Cette forme réinitialise un ou plusieurs paramètres de stockage à leur
      valeurs par défaut. Comme avec <literal>SET</literal>, une réécriture de
      table pourrait être nécessaire pour mettre à jour entièrement la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERIT <replaceable class="parameter">table_parent</replaceable></literal></term>
    <listitem>
     <para>
      Cette forme ajoute la table cible comme nouvel enfant à la table parent
      indiquée. En conséquence, les requêtes concernant le parent ajouteront
      les enregistrements de la table cible. Pour être ajoutée en tant
      qu'enfant, la table cible doit déjà contenir toutes les colonnes de la
      table parent (elle peut avoir des colonnes supplémentaires). Les colonnes
      doivent avoir des types qui correspondent, et s'il y a des contraintes
      <literal>NOT NULL</literal> défini pour le parent, alors elles doivent
      aussi avoir les contraintes <literal>NOT NULL</literal> pour l'enfant.
     </para>

     <para>
      Il doit y avoir aussi une correspondance des contraintes de tables enfants
      pour toutes les contraintes <literal>CHECK</literal>. Actuellement, les
      contraintes <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>
      et <literal>FOREIGN KEY</literal> ne sont pas prises en compte mais ceci
      pourrait changer dans le futur.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO INHERIT <replaceable class="parameter">table_parent</replaceable></literal></term>
    <listitem>
     <para>
      Cette forme supprime une table cible de la liste des enfants de la table
      parent indiquée.
      Les requêtes envers la table parent n'inclueront plus les enregistrements
      de la table cible.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OWNER</literal></term>
    <listitem>
     <para>
      Change le propriétaire d'une table, d'une
      séquence ou d'une vue. Le nouveau propriétaire est celui passé 
      en paramètre.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <para>
      Remplace le tablespace de la table par le tablespace
      spécifié et déplace le(s) fichier(s) de données associé(s) à la table
      vers le nouveau tablespace. Les index de la table, s'il y en a, ne
      sont pas déplacés&nbsp;; mais ils peuvent l'être séparément à l'aide
      de commandes <literal>SET TABLESPACE</literal> supplémentaires. Voir aussi
      <xref linkend="sql-createtablespace" endterm="sql-createtablespace-title"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RENAME</literal></term>
    <listitem>
     <para>
      Change le nom d'une table (d'un index, d'une séquence ou d'une vue) ou le nom d'une colonne individuelle
      de la table. Cela n'a aucun effet sur la donnée stockée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET SCHEMA</literal></term>
    <listitem>
     <para>
      Déplace la table dans un autre schéma. Les index, les contraintes et les
      séquences utilisées dans les colonnes de table sont également déplacés.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
  </para>

  <para>
   Toutes les actions à l'exception de <literal>RENAME</literal> et
   <literal>SET SCHEMA</literal> peuvent être
   combinées dans une liste d'altérations à appliquer en parallèle.
   Par exemple, il est possible d'ajouter plusieurs colonnes et/ou de modifier le
   type de plusieurs colonnes en une seule commande. Ceci est particulièrement
   utile avec les grosses tables car une seule passe sur la table est alors
   nécessaire.
  </para>

  <para>
   Il faut être propriétaire de la table pour utiliser <command>ALTER TABLE</command>.
   Pour modifier le schéma d'une table, le droit <literal>CREATE</literal> sur
   le nouveau schéma est requis.
   Pour ajouter la table en tant que nouvel enfant d'une table parent, vous devez
   aussi être propriétaire de la table parent.
   Pour modifier le propriétaire, il est nécessaire d'être un membre direct ou
   indirect du nouveau rôle et ce dernier doit avoir le droit
   <literal>CREATE</literal> sur le schéma de la table. (Ces restrictions
   assurent que la modification du propriétaire ne diffère en rien de ce qu'il
   est possible de faire par la suppression et le re-création de la table.
   Néanmoins, un superutilisateur peut modifier le propriétaire de n'importe
   quelle table.)
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

    <variablelist>

     <varlistentry>
      <term><replaceable class="parameter">nom</replaceable></term>
      <listitem>
       <para>
        Le nom (éventuellement qualifié du nom du schéma) de la table à modifier.
        Si <literal>ONLY</literal> est indiqué avant le nom de la table, seule
        cette table est modifiée. Dans le cas contraire, la table et toutes ses
        tables filles (s'il y en a) sont modifiées. En option,
        <literal>*</literal> peut être ajouté après le nom de la table pour
        indiquer explicitement que les tables descendantes doivent être inclues.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">colonne</replaceable></term>
      <listitem>
       <para>
        Le nom d'une colonne, existante ou nouvelle.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
        class="parameter">nouvelle_colonne</replaceable></term>
      <listitem>
       <para>
        Le nouveau nom d'une colonne existante.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nouveau_nom</replaceable></term>
      <listitem>
       <para>
        Le nouveau nom de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">type</replaceable></term>
      <listitem>
       <para>
        Le type de données de la nouvelle colonne, ou le nouveau type de données d'une
        colonne existante.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">contraintedetable</replaceable></term>
      <listitem>
       <para>
        Une nouvelle contrainte de table pour la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nomdecontrainte</replaceable></term>
      <listitem>
       <para>
        Le nom d'une contrainte existante à supprimer.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CASCADE</literal></term>
      <listitem>
       <para>
        Les objets qui dépendent de la colonne ou
        de la contrainte supprimée sont automatiquement supprimés
		(par exemple, les vues référençant la colonne).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RESTRICT</literal></term>
      <listitem>
       <para>
        La colonne ou la contrainte n'est pas supprimée si des objets en
        dépendent. C'est le comportement par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_declencheur</replaceable></term>
      <listitem>
       <para>
        Le nom d'un déclencheur isolé à désactiver ou activer.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
       <para>
        Désactiver ou activer tous les déclencheurs appartenant à la table.
        (Les droits de superutilisateur sont nécessaires si l'un des déclencheurs
        concerne une contrainte de clé étrangère.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USER</literal></term>
      <listitem>
       <para>
        Désactiver ou activer tous les déclencheurs appartenant à la table à l'exception de
        ceux concernant des contraintes de clés étrangères.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nomindex</replaceable></term>
      <listitem>
       <para>
        Le nom de l'index sur lequel la table doit être réorganisée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">paramètre_stockage</replaceable></term>
      <listitem>
       <para>
        Le nom d'un paramètre de stockage de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">valeur</replaceable></term>
      <listitem>
       <para>
        La nouvelle valeur d'un paramètre de stockage de la table. Cela peut
        être un nombre ou un mot suivant le paramètre.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">table_parent</replaceable></term>
      <listitem>
       <para>
        Une table parent à associer ou dissocier de cette table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="parameter">nouveau_propriétaire</replaceable></term>
      <listitem>
       <para>
        Le nom du nouveau propriétaire de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="parameter">nouvel_espacelogique</replaceable></term>
      <listitem>
       <para>
        Le nom du tablespace où déplacer la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="parameter">nouveau_schema</replaceable></term>
      <listitem>
       <para>
        Le nom du schéma où déplacer la table.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    Le mot clé <literal>COLUMN</literal> n'est pas nécessaire. Il peut
    être omis.
   </para>

   <para>
    Quand une colonne est ajoutée avec <literal>ADD COLUMN</literal>, toutes
    les lignes existantes de cette table sont initialisées avec la valeur par
    défaut de la colonne (NULL si aucune clause <literal>DEFAULT</literal> n'a été
    définie).
   </para>

   <para>
    Ajouter une colonne avec une valeur par défaut différente de NULL ou
    modifier le type d'une colonne existante requiert que la table entière soit
    réécrite. Cela peut prendre un temps considérable pour une grande
    table&nbsp;; et cela demande temporairement le double d'espace disque.
   </para>

   <para>
    Ajouter une contrainte <literal>CHECK</literal> ou <literal>NOT NULL</literal> requiert
    de parcourir la table pour vérifier que les lignes existantes respectent
    cette contrainte.
   </para>

   <para>
    La raison principale de la possibilité de spécifier des changements multiples
    à l'aide d'une seule commande <command>ALTER TABLE</command> est la combinaison
    en une seule passe sur la table de plusieurs parcours et réécritures.
   </para>

   <para>
    La forme <literal>DROP COLUMN</literal> ne supprime pas physiquement la 
    colonne, mais la rend simplement invisible aux opérations SQL.
    Par la suite, les ordres d'insertion et de mise à jour sur cette table 
    stockent une valeur NULL pour la colonne.
    Ainsi, supprimer une colonne ne réduit pas immédiatement la taille de la
    table sur disque car l'espace occupé par la colonne n'est pas 
    récupéré. Cet espace est récupéré au fur et à mesure des 
    mises à jour des lignes de la table.
   </para>
    
   <para>
    Le fait qu'<literal>ALTER TYPE</literal> requiert la réécriture de toute la table
    est parfois un avantage car le processus de réécriture
    élimine tout espace mort dans la table. Par exemple, pour réclamer
    immédiatement la place occupée par une colonne supprimée, la façon la plus
    rapide est&nbsp;:
<programlisting>ALTER TABLE table ALTER COLUMN toutecolonne TYPE touttype;
</programlisting>
    où <literal>toutecolonne</literal> est une colonne conservée de la table et
    <literal>touttype</literal> est le type courant de la colonne.
    Sémantiquement, aucune modification n'est visible, mais
    la commande force la réécriture, ce qui supprime toute donnée devenue inutile.
   </para>

   <para>
    L'option <literal>USING</literal> d'<literal>ALTER TYPE</literal> peut en fait
    utiliser une expression qui implique d'anciennes valeurs de la
    ligne&nbsp;; c'est-à-dire qu'il peut être fait référence aussi bien aux autres colonnes 
    qu'à celle en cours de conversion. Cela permet d'effectuer des conversions très
    générales à l'aide de la syntaxe <literal>ALTER TYPE</literal>. À cause de cette
    flexibilité, l'expression <literal>USING</literal> n'est pas appliquée à la
    valeur par défaut de la colonne (s'il y en a une)&nbsp;: le résultat pourrait
    ne pas être une expression constante requise pour une valeur par défaut.
    Lorsqu'il n'existe pas de transtypage, implicite ou
    d'affectation, entre les deux types, <literal>ALTER TYPE</literal> peut
    échouer à convertir la valeur par défaut alors même que la clause
    <literal>USING</literal> est spécifiée. Dans de ce cas, il convient de supprimer
    valeur par défaut avec <literal>DROP DEFAULT</literal>, d'exécuter
    <literal>ALTER TYPE</literal> et enfin d'utiliser <literal>SET DEFAULT</literal>
    pour ajouter une valeur par défaut appropriée. Des considérations similaires s'appliquent aux
    index et contraintes qui impliquent la colonne.
   </para>

   <para>
    Si une table est héritée, il n'est pas possible d'ajouter,
    de renommer ou de modifier le type d'une colonne dans la table parent sans
    le faire aussi pour ses descendantes. De ce fait, la commande
    <command>ALTER TABLE ONLY</command> est rejetée. Cela assure que les colonnes
    des tables descendantes correspondent toujours
    à celles de la table parent.
   </para>

   <para>
    Un appel récursif à <literal>DROP COLUMN</literal> supprime la colonne
    d'une table descendante si et seulement si cette table n'hérite 
    pas cette colonne d'une autre table et que la colonne n'y a pas été
    définie indépendamment de tout héritage.
    Une suppression non récursive de colonne
    (<command>ALTER TABLE ONLY ... DROP COLUMN</command>) ne supprime
    jamais les colonnes descendantes&nbsp;; elles sont marquées comme définies 
    de manière indépendante, plutôt qu'héritées.
   </para>

   <para>
    Les actions <literal>TRIGGER</literal>, <literal>CLUSTER</literal>, <literal>OWNER</literal>,
    et <literal>TABLESPACE</literal> ne sont jamais propagées aux tables
    descendantes&nbsp;; c'est-à-dire qu'elles agissent comme si
    <literal>ONLY</literal> est spécifié.
    Seules les ajouts de contraintes <literal>CHECK</literal> peuvent être propagés.
   </para>

   <para>
    Tout changement sur une table du catalogue système est interdit.
   </para>

   <para>
    Voir la commande <xref linkend="sql-createtable" endterm="sql-createtable-title"/> pour avoir une 
    description plus complète des paramètres valides.
    <xref linkend="ddl"/> fournit de plus amples informations sur l'héritage.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Ajouter une colonne de type <type>varchar</type> à une table&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD COLUMN adresse varchar(30);
</programlisting>
  </para>

  <para>
   Supprimer une colonne de table&nbsp;:
<programlisting>ALTER TABLE distributeurs DROP COLUMN adresse RESTRICT;
</programlisting>
  </para>

  <para>
   Changer les types de deux colonnes en une seule opération&nbsp;:
<programlisting>ALTER TABLE distributeurs
    ALTER COLUMN adresse TYPE varchar(80),
    ALTER COLUMN nom TYPE varchar(100);
</programlisting>
  </para>

  <para>
   Convertir une colonne de type integer (entier) contenant une estampille
   temporelle UNIX en <type>timestamp with time zone</type> à l'aide d'une clause
   <literal>USING</literal>&nbsp;:
<programlisting>ALTER TABLE foo
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>

  <para>
   La même, quand la colonne a une expression par défaut qui ne sera pas
   convertie automatiquement vers le nouveau type de données&nbsp;:
<programlisting>ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();
</programlisting>
  </para>

  <para>
   Renommer une colonne existante&nbsp;:
<programlisting>ALTER TABLE distributeurs RENAME COLUMN adresse TO city;
</programlisting>
  </para>

  <para>
   Renommer une table existante&nbsp;:
<programlisting>ALTER TABLE distributeurs RENAME TO fournisseurs;
</programlisting>
  </para>

  <para>
   Ajouter une contrainte NOT NULL à une colonne&nbsp;:
<programlisting>ALTER TABLE distributeurs ALTER COLUMN rue SET NOT NULL;
</programlisting>
   Supprimer la contrainte NOT NULL d'une colonne&nbsp;:
<programlisting>ALTER TABLE distributeurs ALTER COLUMN rue DROP NOT NULL;
</programlisting>
  </para>

  <para> 
   Ajouter une contrainte de vérification sur une table&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD CONSTRAINT verif_cp CHECK (char_length(code_postal) = 5);
</programlisting>
  </para>

  <para> 
   Supprimer une contrainte de vérification d'une table et de toutes ses
   tables filles&nbsp;:
<programlisting>ALTER TABLE distributeurs DROP CONSTRAINT verif_cp;
</programlisting>
  </para>

  <para> 
   Ajouter une contrainte de clé étrangère à une table&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD CONSTRAINT dist_fk FOREIGN KEY (adresse) REFERENCES adresses (adresse) MATCH FULL;
</programlisting>
  </para>

  <para> 
   Ajouter une contrainte unique (multicolonnes) à une table&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD CONSTRAINT dist_id_codepostal_key UNIQUE (dist_id, code_postal);
</programlisting>
  </para>

  <para> 
   Ajouter une clé primaire nommée automatiquement à une table.
   Une table ne peut jamais avoir qu'une seule clé primaire.
<programlisting>ALTER TABLE distributeurs ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>
  
  <para> 
   Déplacer une table dans un tablespace différent&nbsp;:
<programlisting>ALTER TABLE distributeurs SET TABLESPACE tablespacerapide;
</programlisting>
  </para>

  <para> 
   Déplacer une table dans un schéma différent&nbsp;:
<programlisting>ALTER TABLE mon_schema.distributeurs SET SCHEMA votre_schema;
</programlisting>
  </para>

 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Les formes <literal>ADD</literal>, <literal>DROP</literal> et
   <literal>SET DEFAULT</literal> se conforment au standard SQL. Les autres formes sont des
   extensions <productname>PostgreSQL</productname>, tout comme
   la possibilité de spécifier plusieurs manipulations en une seule commande
   <command>ALTER TABLE</command>.
  </para>

  <para>
   <command>ALTER TABLE DROP COLUMN</command> peut être utilisé pour supprimer
   la seule colonne d'une table, laissant une table dépourvue de colonne.
   C'est une extension au SQL, qui n'autorise pas les tables sans colonne.
  </para>
 </refsect1>
</refentry>
