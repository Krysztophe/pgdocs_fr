<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/alter_table.sgml,v 1.10 2005/09/15 07:03:25 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060616 -->

<refentry id="sql-altertable">
 <refmeta>
  <refentrytitle id="sql-altertable-title">ALTER TABLE</refentrytitle>
  <refmiscinfo>SQL - Commandes du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>ALTER TABLE</refname>
  <refpurpose>Modifier la définition d'une table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>ALTER TABLE [ ONLY ] <replaceable class="parameter">nom</replaceable> [ * ]
    <replaceable class="parameter">action</replaceable> [, ... ]
ALTER TABLE [ ONLY ] <replaceable class="parameter">nom</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="parameter">colonne</replaceable> TO <replaceable class="parameter">nouvelle_colonne</replaceable>
ALTER TABLE <replaceable class="parameter">nom</replaceable>
    RENAME TO <replaceable class="parameter">nouveau_nom</replaceable>
ALTER TABLE <replaceable class="parameter">nom</replaceable>
    SET SCHEMA <replaceable class="parameter">nouveau_schema</replaceable>

où <replaceable class="parameter">action</replaceable> peut être&nbsp;:

    ADD [ COLUMN ] <replaceable class="parameter">colonne</replaceable> <replaceable class="parameter">type</replaceable> [ <replaceable class="parameter">contrainte_colonne</replaceable> [ ... ] ]
    DROP [ COLUMN ] <replaceable class="parameter">colonne</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> TYPE <replaceable class="parameter">type</replaceable> [ USING <replaceable class="parameter">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> SET DEFAULT <replaceable class="parameter">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> SET STATISTICS <replaceable class="parameter">entier</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">colonne</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <replaceable class="parameter">contrainte_table</replaceable>
    DROP CONSTRAINT <replaceable class="parameter">nom_contrainte</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="parameter">nom_declencheur</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="parameter">nom_declencheur</replaceable> | ALL | USER ]
    CLUSTER ON <replaceable class="parameter">nom_index</replaceable>
    SET WITHOUT CLUSTER
    SET WITHOUT OIDS
    SET ( <replaceable class="PARAMETER">storage_parameter</replaceable> = <replaceable class="PARAMETER">value</replaceable> [, ... ] )
    RESET ( <replaceable class="PARAMETER">storage_parameter</replaceable> [, ... ] )
    INHERIT <replaceable class="PARAMETER">parent_table</replaceable>
    NO INHERIT <replaceable class="PARAMETER">parent_table</replaceable>
    OWNER TO <replaceable class="parameter">nouveau_proprietaire</replaceable>
    SET TABLESPACE <replaceable class="parameter">nouvel_espacelogique</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-altertable">
   <primary>ALTER TABLE</primary>
  </indexterm>

  <para>
   <command>ALTER TABLE</command> modifie la définition d'une table existante.
   Il existe plusieurs variantes&nbsp;:

  <variablelist>
   <varlistentry>
    <term><literal>ADD COLUMN</literal></term>
    <listitem>
     <para>
      Ajoute une nouvelle colonne à la table en utilisant une syntaxe identique à celle de
       <xref linkend="sql-createtable" endterm="sql-createtable-title"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP COLUMN</literal></term>
    <listitem>
     <para>
      Supprime une colonne de la table. Les index et les 
      contraintes de table référençant cette colonne sont automatiquement supprimés.
      L'option <literal>CASCADE</literal> doit être utilisée lorsque des objets en dehors
      de la table dépendent de cette colonne, comme par exemple des références
      de clés étrangères ou des vues.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ALTER COLUMN TYPE</literal></term>
    <listitem>
     <para>
      Change le type d'une colonne de la table. Les index et
      les contraintes simples de table qui impliquent la colonne sont
      automatiquement convertis pour utiliser le nouveau type de la colonne en
      réanalysant l'expression d'origine. La clause
      optionnelle <literal>USING</literal> précise comment calculer la nouvelle
      valeur de la colonne à partir de l'ancienne&nbsp;; en cas d'omission, la
      conversion par défaut est identique à une affectation de transtypage de l'ancien type
      vers le nouveau. Une clause <literal>USING</literal> doit être fournie
      s'il n'existe pas de conversion implicite ou d'assignement entre les deux types.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
    <listitem>
     <para>
      Ajoute ou supprime les valeurs par défaut d'une colonne.
      Les valeurs par défaut ne s'appliquent qu'aux commandes
      <command>INSERT</command> ultérieures. Elles ne modifient pas les lignes déjà 
      présentes dans la table. Des valeurs par défaut peuvent aussi être créées
      pour les vues. Dans ce cas, elles sont ajoutées aux commandes 
      <command>INSERT</command> de la vue avant que la règle 
      <literal>ON INSERT</literal> de la vue ne soit appliquée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
    <listitem>
     <para>
      Modifie l'autorisation de
      valeurs NULL. <literal>SET NOT NULL</literal> ne peut être utilisé que
      si la colonne ne contient pas de valeurs NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
     <para>
      Permet de modifier l'objectif de collecte de statistiques
      par colonne pour les opérations d'analyse 
      (<xref linkend="sql-analyze" endterm="sql-analyze-title"/>) ultérieures.
      L'objectif prend une valeur entre 0 et 1000. il est positionné à -1 pour utiliser
      l'objectif de statistiques par défaut du système
      (<xref linkend="guc-default-statistics-target"/>). Pour plus d'informations sur
      l'utilisation des statistiques par le planificateur de requêtes de
      <productname>PostgreSQL</productname>, voir <xref linkend="planner-stats"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STORAGE</literal></term>
    <listitem>
    <indexterm>
     <primary>TOAST</primary>
     <secondary>configuration de stockage par colonne</secondary>
    </indexterm>

     <para>
      Modifie le mode de stockage pour une colonne. Cela permet de
      contrôler si cette colonne est conservée en ligne ou 
      dans une table supplémentaire, et si les données sont ou non
      compressées. 
      <literal>PLAIN</literal>, en ligne, non compressé, est utilisé pour les valeurs
      de longueur fixe, comme les <type>integer</type>.
      <literal>MAIN</literal> convient pour les données en ligne,
      compressibles. <literal>EXTERNAL</literal> est fait pour les données externes
      non compressées, <literal>EXTENDED</literal> pour les données externes 
      compressées. <literal>EXTENDED</literal> est la valeur par défaut pour la
      plupart des types qui supportent les stockages différents de
      <literal>PLAIN</literal>. L'utilisation d'<literal>EXTERNAL</literal> 
      permet d'accélérer les
      opérations d'extraction de sous-chaînes sur les colonnes de types <type>text</type> et
      <type>bytea</type> mais utilise plus d'espace de stockage.
      <literal>SET STORAGE</literal> ne modifie rien dans la table, il
      configure la stratégie à poursuivre lors des mises à jour de
      tables suivantes. Voir <xref linkend="storage-toast"/> pour plus d'informations.
      
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">contrainte_table</replaceable></literal></term>
    <listitem>
     <para>
      Ajoute une nouvelle contrainte à une table en utilisant une
      syntaxe identique à <xref linkend="sql-createtable" endterm="sql-createtable-title"/>. 
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP CONSTRAINT</literal></term>
    <listitem>
     <para>
      Supprime la contrainte de table précisée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE TRIGGER</literal></term>
    <listitem>
     <para>
      Désactive ou active les déclencheurs définis sur la
      table. Un déclencheur désactivé est toujours connu par le système mais
      n'est plus exécuté lorsque l'événement déclencheur survient. Pour un
      déclencheur retardé, le statut d'activité est vérifié au moment où survient l'événement,
      et non quand la fonction du déclencheur est réellement exécutée.
      Il est possible de désactiver ou d'activer un déclencheur spécifique (précisé par son nom),
	  tous les déclencheurs d'une table ou seulement les déclencheurs utilisateur
      de cette table (cette option exclut les déclencheurs utilisés pour
      implanter les contraintes de clés étrangères). Désactiver ou activer
      les déclencheurs de contraintes requiert des droits de
      superutilisateur&nbsp;; cela doit se faire avec précaution car
      l'intégrité de la contrainte ne peut pas être garantie si les
      déclencheurs ne sont pas exécutés.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CLUSTER</literal></term>
    <listitem>
     <para>
      Sélectionne l'index par défaut pour les prochaines
      opérations <xref linkend="sql-cluster" endterm="sql-cluster-title"/>.
      La table n'est pas réorganisée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
     <para>
      Supprime de la table la spécification d'index
	  <xref linkend="sql-cluster" endterm="sql-cluster-title"/> la plus récemment
      utilisée. Cela agit sur les opérations de réorganisation suivantes qui ne spécifient pas d'index.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      Supprime la colonne système <literal>oid</literal> de la
      table. Cela est strictement équivalent à <literal>DROP COLUMN oid RESTRICT</literal>,
      à ceci près qu'aucun avertissement n'est émis si la colonne <literal>oid</literal> n'existe plus.
     </para>

     <para>
      Il n'existe pas de variante d'<command>ALTER TABLE</command>
      qui autorise la restauration des OID d'une table après leur suppression.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="PARAMETER">storage_parameter</replaceable> = <replaceable class="PARAMETER">value</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      This form changes one or more storage parameters for the table.  See
      <xref linkend="SQL-CREATETABLE" endterm="sql-createtable-title"/>
      for details on the available parameters.  Note that the table contents
      will not be modified immediately by this command; depending on the
      parameter you may need to rewrite the table to get the desired effects.
      That can be done with <xref linkend="SQL-CLUSTER"
      endterm="sql-cluster-title"/> or one of the forms of <command>ALTER
      TABLE</command> that forces a table rewrite.
     </para>

     <note>
      <para>
       While <command>CREATE TABLE</command> allows <literal>OIDS</literal> to be specified
       in the <literal>WITH (<replaceable
       class="PARAMETER">storage_parameter</replaceable>)</literal> syntax,
       <command>ALTER TABLE</command> does not treat <literal>OIDS</literal> as a
       storage parameter.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESET ( <replaceable class="PARAMETER">storage_parameter</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      This form resets one or more storage parameters to their
      defaults.  As with <literal>SET</literal>, a table rewrite may be
      needed to update the table entirely.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERIT <replaceable class="PARAMETER">parent_table</replaceable></literal></term>
    <listitem>
     <para>
      This form adds a new parent table to the table. This won't add new
      columns to the child table, instead all columns of the parent table must
      already exist in the child table. They must have matching data types,
      and if they have <literal>NOT NULL</literal> constraints in the parent
      then they must also have <literal>NOT NULL</literal> constraints in the
      child.
     </para>

     <para>
      There must also be matching table constraints for all
      <literal>CHECK</literal> table constraints of the parent. Currently
      <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and
      <literal>FOREIGN KEY</literal> constraints are ignored however this may
      change in the future.
     </para>

     <para>
      The easiest way to create a suitable table is to create a table using
      <literal>INHERITS</literal> and then remove it via <literal>NO
      INHERIT</literal>. Alternatively create a table using
      <literal>LIKE</literal> however note that <literal>LIKE</literal> does
      not create the necessary constraints.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO INHERIT <replaceable class="PARAMETER">parent_table</replaceable></literal></term>
    <listitem>
     <para>
      This form removes a parent table from the list of parents of the table.
      Queries against the parent table will no longer include records drawn
      from the target table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OWNER</literal></term>
    <listitem>
     <para>
      Change le propriétaire d'une table, d'une
      séquence ou d'une vue. Le nouveau propriétaire est celui passé 
      en paramètre.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <para>
      Remplace l'espace logique de la table par l'espace logique
      spécifié et déplace le(s) fichier(s) de données associé(s) à la table
      vers le nouvel espace logique. Les index de la table, s'il y en a, ne
      sont pas déplacés&nbsp;; mais ils peuvent l'être séparément à l'aide
      de commandes <literal>SET TABLESPACE</literal> supplémentaires. Voir aussi
      <xref linkend="sql-createtablespace" endterm="sql-createtablespace-title"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RENAME</literal></term>
    <listitem>
     <para>
      Change le nom d'une table (d'un index, d'une séquence ou d'une vue) ou le nom d'une colonne individuelle
      de la table. Cela n'a aucun effet sur la donnée stockée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET SCHEMA</literal></term>
    <listitem>
     <para>
      Déplace la table dans un autre schéma. Les index, les contraintes et les
      séquences utilisées dans les colonnes de table sont également déplacés.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
  </para>

  <para>
   Toutes les actions à l'exception de <literal>RENAME</literal> et
   <literal>SET SCHEMA</literal> peuvent être
   combinées dans une liste d'altérations à appliquer en parallèle.
   Par exemple, il est possible d'ajouter plusieurs colonnes et/ou de modifier le
   type de plusieurs colonnes en une seule commande. Ceci est particulièrement
   utile avec les grosses tables car une seule passe sur la table est alors
   nécessaire.
  </para>

  <para>
   Il faut être propriétaire de la table pour utiliser <command>ALTER TABLE</command>.
   Pour modifier le schéma d'une table, le droit
   <literal>CREATE</literal> sur le nouveau schéma est requis. Pour modifier le
   propriétaire, il est nécessaire d'être un membre direct ou indirect du nouveau
   rôle et ce dernier doit avoir le droit <literal>CREATE</literal> sur le
   schéma de la table. (Ces restrictions assurent que la modification du
   propriétaire ne diffère en rien de ce qu'il est possible de faire par la suppression
   et le re-création de la table. Néanmoins, un superutilisateur peut modifier
   le propriétaire de n'importe quelle table.)
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

    <variablelist>

     <varlistentry>
      <term><replaceable class="parameter">nom</replaceable></term>
      <listitem>
       <para>
        Le nom (éventuellement qualifié du nom du schéma) de la table à modifier.
        Si <literal>ONLY</literal> est indiqué, seule cette table
        est modifiée. Dans le cas contraire, la table
        et toutes ses tables filles (s'il y en a) sont modifiées.
        <literal>*</literal> peut être ajouté au nom de la table pour indiquer que ses
        tables descendantes doivent être modifiées. C'est le comportement par défaut dans la version actuelle.
        Dans les versions antérieures à la
        7.1, <literal>ONLY</literal> était le comportement par défaut.
        Le comportement par défaut est modifiable par le paramètre
        de configuration <xref linkend="guc-sql-inheritance"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">colonne</replaceable></term>
      <listitem>
       <para>
        Le nom d'une colonne, existante ou nouvelle.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
        class="parameter">nouvelle_colonne</replaceable></term>
      <listitem>
       <para>
        Le nouveau nom d'une colonne existante.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nouveau_nom</replaceable></term>
      <listitem>
       <para>
        Le nouveau nom de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">type</replaceable></term>
      <listitem>
       <para>
        Le type de données de la nouvelle colonne, ou le nouveau type de données d'une
        colonne existante.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">contraintedetable</replaceable></term>
      <listitem>
       <para>
        Une nouvelle contrainte de table pour la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nomdecontrainte</replaceable></term>
      <listitem>
       <para>
        Le nom d'une contrainte existante à supprimer.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CASCADE</literal></term>
      <listitem>
       <para>
        Les objets qui dépendent de la colonne ou
        de la contrainte supprimée sont automatiquement supprimés
		(par exemple, les vues référençant la colonne).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RESTRICT</literal></term>
      <listitem>
       <para>
        La colonne ou la contrainte n'est pas supprimée si des objets en
        dépendent. C'est le comportement par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_declencheur</replaceable></term>
      <listitem>
       <para>
        Le nom d'un déclencheur isolé à désactiver ou activer.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
       <para>
        Désactiver ou activer tous les déclencheurs appartenant à la table.
        (Les droits de superutilisateur sont nécessaires si l'un des déclencheurs
        concerne une contrainte de clé étrangère.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USER</literal></term>
      <listitem>
       <para>
        Désactiver ou activer tous les déclencheurs appartenant à la table à l'exception de
        ceux concernant des contraintes de clés étrangères.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nomindex</replaceable></term>
      <listitem>
       <para>
        Le nom de l'index sur lequel la table doit être réorganisée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">storage_parameter</replaceable></term>
      <listitem>
       <para>
        The name of a table storage parameter.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
       <para>
        The new value for a table storage parameter.
        This might be a number or a word depending on the parameter.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">parent_table</replaceable></term>
      <listitem>
       <para>
        A parent table to associate or de-associate with this table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="parameter">nouveau_propriétaire</replaceable></term>
      <listitem>
       <para>
        Le nom du nouveau propriétaire de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="parameter">nouvel_espacelogique</replaceable></term>
      <listitem>
       <para>
        Le nom de l'espace logique où déplacer la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable
	class="parameter">nouveau_schema</replaceable></term>
      <listitem>
       <para>
        Le nom du schéma où déplacer la table.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    Le mot clé <literal>COLUMN</literal> n'est pas nécessaire. Il peut
    être omis.
   </para>

   <para>
    Quand une colonne est ajoutée avec <literal>ADD COLUMN</literal>, toutes
    les lignes existantes de cette table sont initialisées avec la valeur par
    défaut de la colonne (NULL si aucune clause <literal>DEFAULT</literal> n'a été
    définie).
   </para>

   <para>
    Ajouter une colonne avec une valeur par défaut différente de NULL ou
    modifier le type d'une colonne existante requiert que la table entière soit
    réécrite. Cela peut prendre un temps considérable pour une grande
    table&nbsp;; et cela demande temporairement le double d'espace disque.
   </para>

   <para>
    Ajouter une contrainte <literal>CHECK</literal> ou <literal>NOT NULL</literal> requiert
    de parcourir la table pour vérifier que les lignes existantes respectent
    cette contrainte.
   </para>

   <para>
    La raison principale de la possibilité de spécifier des changements multiples
    à l'aide d'une seule commande <command>ALTER TABLE</command> est la combinaison
    en une seule passe sur la table de plusieurs parcours et réécritures.
   </para>

   <para>
    La forme <literal>DROP COLUMN</literal> ne supprime pas physiquement la 
    colonne, mais la rend simplement invisible aux opérations SQL.
    Par la suite, les ordres d'insertion et de mise à jour sur cette table 
    stockent une valeur NULL pour la colonne.
    Ainsi, supprimer une colonne ne réduit pas immédiatement la taille de la
    table sur disque car l'espace occupé par la colonne n'est pas 
    récupéré. Cet espace est récupéré au fur et à mesure des 
    mises à jour des lignes de la table.
   </para>
    
   <para>
    Le fait qu'<literal>ALTER TYPE</literal> requiert la réécriture de toute la table
    est parfois un avantage car le processus de réécriture
    élimine tout espace mort dans la table. Par exemple, pour réclamer
    immédiatement la place occupée par une colonne supprimée, la façon la plus
    rapide est
<programlisting>ALTER TABLE table ALTER COLUMN toutecolonne TYPE touttype;
</programlisting>
    où <literal>toutecolonne</literal> est une colonne conservée de la table et
    <literal>touttype</literal> est le type courant de la colonne.
    Sémantiquement, aucune modification n'est visible, mais
    la commande force la réécriture, ce qui supprime toute donnée devenue inutile.
   </para>

   <para>
    L'option <literal>USING</literal> d'<literal>ALTER TYPE</literal> peut en fait
    utiliser une expression qui implique d'anciennes valeurs de la
    ligne&nbsp;; c'est-à-dire qu'il peut être fait référence aussi bien aux autres colonnes 
    qu'à celle en cours de conversion. Cela permet d'effectuer des conversions très
    générales à l'aide de la syntaxe <literal>ALTER TYPE</literal>. À cause de cette
    flexibilité, l'expression <literal>USING</literal> n'est pas appliquée à la
    valeur par défaut de la colonne (s'il y en a une)&nbsp;: le résultat pourrait
    ne pas être une expression constante requise pour une valeur par défaut.
    Lorsqu'il n'existe pas de transtypage, implicite ou
    d'affectation, entre les deux types, <literal>ALTER TYPE</literal> peut
    échouer à convertir la valeur par défaut alors même que la clause
    <literal>USING</literal> est spécifiée. Dans de ce cas, il convient de supprimer
    valeur par défaut avec <literal>DROP DEFAULT</literal>, d'exécuter
    <literal>ALTER TYPE</literal> et enfin d'utiliser <literal>SET DEFAULT</literal>
    pour ajouter une valeur par défaut appropriée. Des considérations similaires s'appliquent aux
    index et contraintes qui impliquent la colonne.
   </para>

   <para>
    Si une table est héritée, il n'est pas possible d'ajouter,
    de renommer ou de modifier le type d'une colonne dans la table parent sans
    le faire aussi pour ses descendantes. De ce fait, la commande
    <command>ALTER TABLE ONLY</command> est rejetée. Cela assure que les colonnes
    des tables descendantes correspondent toujours
    à celles de la table parent.
   </para>

   <para>
    Un appel récursif à <literal>DROP COLUMN</literal> supprime la colonne
    d'une table descendante si et seulement si cette table n'hérite 
    pas cette colonne d'une autre table et que la colonne n'y a pas été
    définie indépendamment de tout héritage.
    Une suppression non récursive de colonne
    (<command>ALTER TABLE ONLY ... DROP COLUMN</command>) ne supprime
    jamais les colonnes descendantes&nbsp;; elles sont marquées comme définies 
    de manière indépendante, plutôt qu'héritées.
   </para>

   <para>
    Les actions <literal>TRIGGER</literal>, <literal>CLUSTER</literal>, <literal>OWNER</literal>,
    et <literal>TABLESPACE</literal> ne sont jamais propagées aux tables
    descendantes&nbsp;; c'est-à-dire qu'elles agissent comme si
    <literal>ONLY</literal> est spécifié.
    Seules les ajouts de contraintes <literal>CHECK</literal> peuvent être propagés.
   </para>

   <para>
    Tout changement sur une table du catalogue système est interdit.
   </para>

   <para>
    Voir la commande <xref linkend="sql-createtable" endterm="sql-createtable-title"/> pour avoir une 
    description plus complète des paramètres valides.
    <xref linkend="ddl"/> fournit de plus amples informations sur l'héritage.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Ajouter une colonne de type <type>varchar</type> à une table&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD COLUMN adresse varchar(30);
</programlisting>
  </para>

  <para>
   Supprimer une colonne de table&nbsp;:
<programlisting>ALTER TABLE distributeurs DROP COLUMN adresse RESTRICT;
</programlisting>
  </para>

  <para>
   Changer les types de deux colonnes en une seule opération&nbsp;:
<programlisting>ALTER TABLE distributeurs
    ALTER COLUMN adresse TYPE varchar(80),
    ALTER COLUMN nom TYPE varchar(100);
</programlisting>
  </para>

  <para>
   Convertir une colonne de type integer (entier) contenant une estampille
   temporelle UNIX en <type>timestamp with time zone</type> à l'aide d'une clause
   <literal>USING</literal>&nbsp;:
<programlisting>ALTER TABLE foo
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>

  <para>
   The same, when the column has a default expression that won't automatically
   cast to the new datatype:
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();
</programlisting>
  </para>

  <para>
   Renommer une colonne existante&nbsp;:
<programlisting>ALTER TABLE distributeurs RENAME COLUMN adresse TO city;
</programlisting>
  </para>

  <para>
   Renommer une table existante&nbsp;:
<programlisting>ALTER TABLE distributeurs RENAME TO fournisseurs;
</programlisting>
  </para>

  <para>
   Ajouter une contrainte NOT NULL à une colonne&nbsp;:
<programlisting>ALTER TABLE distributeurs ALTER COLUMN rue SET NOT NULL;
</programlisting>
   Supprimer la contrainte NOT NULL d'une colonne&nbsp;:
<programlisting>ALTER TABLE distributeurs ALTER COLUMN rue DROP NOT NULL;
</programlisting>
  </para>

  <para> 
   Ajouter une contrainte de vérification sur une table&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD CONSTRAINT verif_cp CHECK (char_length(code_postal) = 5);
</programlisting>
  </para>

  <para> 
   Supprimer une contrainte de vérification d'une table et de toutes ses
   tables filles&nbsp;:
<programlisting>ALTER TABLE distributeurs DROP CONSTRAINT verif_cp;
</programlisting>
  </para>

  <para> 
   Ajouter une contrainte de clé étrangère à une table&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD CONSTRAINT dist_fk FOREIGN KEY (adresse) REFERENCES adresses (adresse) MATCH FULL;
</programlisting>
  </para>

  <para> 
   Ajouter une contrainte unique (multicolonnes) à une table&nbsp;:
<programlisting>ALTER TABLE distributeurs ADD CONSTRAINT dist_id_codepostal_key UNIQUE (dist_id, code_postal);
</programlisting>
  </para>

  <para> 
   Ajouter une clé primaire nommée automatiquement à une table.
   Une table ne peut jamais avoir qu'une seule clé primaire.
<programlisting>ALTER TABLE distributeurs ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>
  
  <para> 
   Déplacer une table dans un espace logique différent&nbsp;:
<programlisting>ALTER TABLE distributeurs SET TABLESPACE espacelogiquerapide;
</programlisting>
  </para>

  <para> 
   Déplacer une table dans un schéma différent&nbsp;:
<programlisting>ALTER TABLE mon_schema.distributeurs SET SCHEMA votre_schema;
</programlisting>
  </para>

 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Les formes <literal>ADD</literal>, <literal>DROP</literal> et
   <literal>SET DEFAULT</literal> se conforment au standard SQL. Les autres formes sont des
   extensions <productname>PostgreSQL</productname>, tout comme
   la possibilité de spécifier plusieurs manipulations en une seule commande
   <command>ALTER TABLE</command>.
  </para>

  <para>
   <command>ALTER TABLE DROP COLUMN</command> peut être utilisé pour supprimer
   la seule colonne d'une table, laissant une table dépourvue de colonne.
   C'est une extension au SQL, qui n'autorise pas les tables sans colonne.
  </para>
 </refsect1>
</refentry>
