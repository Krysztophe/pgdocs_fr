<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/cluster.sgml,v 1.9 2005/03/14 06:03:51 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060616 -->

<refentry id="sql-cluster">
 <refmeta>
  <refentrytitle id="sql-cluster-title">CLUSTER</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CLUSTER</refname>
  <refpurpose>Réorganiser une table en fonction d'un index</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CLUSTER <replaceable class="parameter">nomindex</replaceable> ON <replaceable class="parameter">nomtable</replaceable>
CLUSTER <replaceable class="parameter">nomtable</replaceable>
CLUSTER
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-cluster">
   <primary>CLUSTER</primary>
  </indexterm>

  <para>
   <command>CLUSTER</command> réorganise (regroupe) la table 
   <replaceable class="parameter">nomtable</replaceable>
   en fonction de l'index <replaceable class="parameter">nomindex</replaceable>. L'index doit avoir été 
   préalablement défini sur <replaceable class="parameter">nomtable</replaceable>.
  </para>

  <para>
   Une table regroupée est physiquement réordonnée en fonction des informations de l'index.
   Ce regroupement est une opération unique&nbsp;:
   les modifications issues de mises à jour postérieures au groupage ne
   sont pas réorganisées. C'est-à-dire qu'aucune tentative n'est
   réalisée pour stocker les données nouvelles ou mises à jour
   d'après l'ordre de l'index. Une réorganisation périodique peut être
   obtenue en relançant la commande aussi souvent que souhaité.
  </para>

  <para>
   Quand une table est groupée, <productname>PostgreSQL</productname> 
   enregistre l'index qui a servi à la réorganisation. La forme
   <command>CLUSTER <replaceable class="parameter">nomtable</replaceable></command>
   regroupe la table suivant ce même index.
  </para>

  <para>
   <command>CLUSTER</command>, sans paramètre, groupe toutes les
   tables de la base de données courante dont l'utilisateur est
   propriétaire, ou toutes les tables s'il s'agit d'un superutilisateur. (Les
   tables qui n'ont jamais été groupées sont ignorées.) Cette forme de
   <command>CLUSTER</command> ne peut pas être exécutée à l'intérieur d'une
   transaction.
  </para>

  <para>
   Quand une table est en cours de regroupement, un verrou
   <literal>ACCESS EXCLUSIVE</literal> est acquis. Cela empêche toute opération
   sur la table (à la fois en lecture et en écriture) pendant l'exécution de 
   <command>CLUSTER</command>.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nomindex</replaceable></term>
    <listitem>
     <para>
      Le nom d'un index.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nomtable</replaceable></term>
    <listitem>
     <para>
      Le nom d'une table (éventuellement qualifié du nom du schéma).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    <command>CLUSTER</command> perd toute visibilité des lignes, ce qui fait
    que la table semble vide à toute image de la base prise avant la fin de
    la commande <command>CLUSTER</command>. Les applications ayant des
    transactions accèdant à une table en cours de clusterisation peuvent donc
    difficilement utiliser la commande <command>CLUSTER</command>. L'impact est
    encore plus important avec les transactions sérialisables car elles prennent
    seulement une image de la base, au début de la transaction. Cela étant dit,
    les transactions «&nbsp;read-committed&nbsp;» sont aussi affectées.
   </para>

   <para>
    Lorsque les lignes d'une table sont accédées aléatoirement et unitairement,
    l'ordre réel des données dans la table n'a que peu d'importance.
    Toutefois, si certaines données sont plus accédées que d'autres, et qu'un
    index les groupe, l'utilisation de <command>CLUSTER</command> peut s'avérer
    bénéfique. Si une requête porte sur un ensemble de valeurs indexées ou sur
    une seule valeur pour laquelle plusieurs lignes de la table correspondent,
    <command>CLUSTER</command> se montre utile. En effet, lorsque l'index
    identifie la page de la table pour la première ligne correspondante, toutes
    les autres lignes correspondantes sont déjà probablement sur la même page
    de table, ce qui diminue les accès disque et accélère la requête.
   </para>

   <para>
    Lors de l'opération de réorganisation, une copie temporaire de la table 
    est créée qui contient les données de la table dans l'ordre de l'index. Des
    copies temporaires de chaque index de la table sont également créées. De ce fait, 
    un espace libre sur le disque au moins égal à la somme de la taille de la table
    et celles des index est nécessaire.
   </para>

   <para>
    Puisque <command>CLUSTER</command> enregistre les informations de
    réorganisation, il est possible de réorganiser manuellement les tables souhaitées
    la première fois et de planifier une réorganisation, à la façon d'un <command>VACUUM</command>.
    Les tables sont ainsi régulièrement regroupées.
   </para>

   <para>
    Comme le planificateur enregistre les statistiques d'ordonnancement
    des tables, il est conseillé de lancer
    <xref linkend="sql-analyze" endterm="sql-analyze-title"/> sur la table réorganisée.
    Dans le cas contraire, les plans de requêtes peuvent être mal choisis par le planificateur.
   </para>

   <para>
    Il existe une autre façon de grouper les données. En effet, la commande
    <command>CLUSTER</command> réorganise la table originale en la parcourant
    en suivant l'ordre de l'index indiqué&nbsp;;.cela peut devenir lent sur les
    grandes tables parce que les lignes sont parcourues au niveau de la table
    dans l'ordre de l'index et, si la table n'est pas ordonnée, les entrées sont
    disséminées
    dans des pages aléatoires. Une page disque est alors lue pour chaque
    ligne déplacée. (<productname>PostgreSQL</productname> dispose d'un cache mais une
    grande table n'y tient généralement pas dans sa totalité.) L'autre moyen de
    réorganiser une table est alors d'utiliser

<programlisting>CREATE TABLE <replaceable class="parameter">nouvelletable</replaceable> AS
    SELECT * FROM <replaceable class="parameter">table</replaceable> ORDER BY <replaceable class="parameter">listecolonnes</replaceable>;
</programlisting>

    qui utilise le code de tri de <productname>PostgreSQL</productname> pour
    créer l'ordre désiré&nbsp;; pour des données non triées, cela est
    généralement bien plus rapide qu'un parcours d'index sur des données
    non ordonnées.
    L'ancienne table peut alors être supprimée. <command>ALTER TABLE ... RENAME</command>
    est utilisé pour renommer <replaceable class="parameter">nouvelletable</replaceable>
    en <replaceable class="parameter">table</replaceable>. Il ne reste plus
    qu'à recréer les index de la table. Le gros inconvénient de cette approche
    est qu'elle ne préserve pas les OID, les contraintes, les relations de clés
    étrangères, les droits et autres propriétés de la table &mdash; tous ces
    éléments doivent être recréés manuellement. Un autre inconvénient est que
    cette façon nécessire un fichier temporaire de tri de la même taille que
    la table elle-même, donc l'utilisation limite du disque est d'environ
    trois la taille de la table au lieu de deux fois.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Grouper la table <literal>employes</literal> sur la base de son index
   <literal>emp_ind</literal>&nbsp;:
<programlisting>CLUSTER emp_ind ON employes;
</programlisting>
  </para>

  <para>
   Grouper la relation <literal>employes</literal> en utilisant le même index
   que précédemment&nbsp;:
<programlisting>CLUSTER employes;
</programlisting>
  </para>

  <para>
   Grouper toutes les tables de la base de données préalablement
   groupées&nbsp;:
<programlisting>CLUSTER;
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas d'instruction <command>CLUSTER</command> dans le standard
   SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="app-clusterdb" endterm="app-clusterdb-title"/></member>
  </simplelist>
 </refsect1>
</refentry>
