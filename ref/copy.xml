<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/copy.sgml,v 1.15 2005/09/22 18:34:45 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060616 -->

<refentry id="sql-copy">
 <refmeta>
  <refentrytitle id="sql-copy-title">COPY</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>COPY</refname>
  <refpurpose>Copier des données depuis/vers un fichier vers/depuis une table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>COPY <replaceable class="parameter">nomtable</replaceable> [ ( <replaceable class="parameter">colonne</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">nomfichier</replaceable>' | STDIN }
    [ [ WITH ] 
        [ BINARY ] 
	[ OIDS ]
	[ DELIMITER [ AS ] '<replaceable class="parameter">délimiteur</replaceable>' ]
	[ NULL [ AS ] '<replaceable class="parameter">chaîne NULL</replaceable>' ]
	[ CSV [ HEADER ]
	      [ QUOTE [ AS ] '<replaceable class="parameter">guillemet</replaceable>' ] 
	      [ ESCAPE [ AS ] '<replaceable class="parameter">échappement</replaceable>' ]
	      [ FORCE NOT NULL <replaceable class="parameter">colonne</replaceable> [, ...] ]

COPY { <replaceable class="parameter">nomtable</replaceable> [ ( <replaceable class="parameter">colonne</replaceable> [, ...] ) ] | ( <replaceable class="parameter">requête</replaceable> ) }
    TO { '<replaceable class="parameter">nomfichier</replaceable>' | STDOUT }
    [ [ WITH ] 
        [ BINARY ]
	[ HEADER ]
	[ OIDS ]
	[ DELIMITER [ AS ] '<replaceable class="parameter">délimiteur</replaceable>' ]
	[ NULL [ AS ] '<replaceable class="parameter">chaîne NULL</replaceable>' ]
	[ CSV [ HEADER ]
	      [ QUOTE [ AS ] '<replaceable class="parameter">guillemet</replaceable>' ] 
	      [ ESCAPE [ AS ] '<replaceable class="parameter">échappement</replaceable>' ]
	      [ FORCE QUOTE <replaceable class="parameter">colonne</replaceable> [, ...] ]
</synopsis>
 </refsynopsisdiv>
 
 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-copy">
   <primary>COPY</primary>
  </indexterm>

  <para>
   <command>COPY</command> transfert des données entre les tables de
   <productname>PostgreSQL</productname> et les fichiers du système de
   fichiers standard. <command>COPY TO</command> copie le contenu d'une table
   <emphasis>vers</emphasis> un fichier tandis que <command>COPY FROM</command> copie
   des données <emphasis>depuis</emphasis> un fichier vers une table (ajoutant les
   données à celles déjà dans la table). <command>COPY TO</command>
   peut aussi copier le résultat d'une requête <command>SELECT</command>.
  </para>

  <para>
   Si une liste de colonnes est précisée, <command>COPY</command> ne copie
   que les données des colonnes spécifiées vers ou depuis le fichier.
   <command>COPY FROM</command> insère les valeurs par défaut des
   colonnes qui ne sont pas précisées dans la liste.
  </para>

  <para>
   Si un nom de fichier est précisé, <command>COPY</command> lit ou écrit
   directement dans le fichier. Ce fichier doit être accessible par le
   serveur et son nom doit être spécifié du point de vue du serveur.
   Si <literal>STDIN</literal> ou <literal>STDOUT</literal> est indiqué,
   les données sont transmises au travers de la connexion entre le client et le serveur.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nomtable</replaceable></term>
    <listitem>
     <para>
     Le nom de la table (éventuellement qualifié du nom du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">colonne</replaceable></term>
     <listitem>
     <para>
      Une liste optionnelle de colonnes à copier. Sans précision,
      toutes les colonnes de la table seront copiées.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">query</replaceable></term>
    <listitem>
     <para>
      Une commande <xref linkend="sql-select" endterm="sql-select-title"/> ou
      <xref linkend="sql-values" endterm="sql-values-title"/> dont les résultats
      doivent être copiés. Notez que les parenthèses sont requises autour de la
      requête.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nomfichier</replaceable></term>
    <listitem>
     <para>
      Le chemin absolu du fichier en entrée ou en sortie. Les utilisateurs sous
      Windows peuvent avoir besoin d'utiliser une chaîne <literal>E''</literal>
      et de doubler les antislashs utilisés comme
      séparateurs de chemin.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>STDIN</literal></term>
    <listitem>
     <para>
      Les données en entrée proviennent de l'application cliente.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>STDOUT</literal></term>
    <listitem>
     <para>
      Les données en sortie vont sur l'application cliente.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BINARY</literal></term>
    <listitem>
     <para>
      Les données sont stockées ou lues au format binaire, non
      en texte. Les options
      <option>DELIMITER</option>, <option>NULL</option> ou <option>CSV</option>
      ne peuvent pas être utilisées dans ce mode.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OIDS</literal></term>
    <listitem>
     <para>
      Copie l'OID de chaque ligne. Une erreur est rapportée si
      <literal>OIDS</literal> est utilisé pour une table qui ne possède pas
      d'OID, ou dans le cas de la copie du résultat d'une <replaceable
      class="parameter">requête</replaceable>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">délimiteur</replaceable></term>
    <listitem>
     <para>
      Le caractère simple qui sépare les colonnes sur une ligne de
      fichier.
      En mode texte, la valeur par défaut est un caractère de tabulation.
      En mode <literal>CSV</literal>, c'est une virgule.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">chaîne NULL</replaceable></term>
    <listitem>
     <para>
      La chaîne qui représente une valeur NULL. Par défaut, 
      <literal>\N</literal> (antislash-N) en mode texte, une valeur vide sans
      guillemets en mode <literal>CSV</literal>.
      Il est possible d'utiliser une chaîne
      vide même en mode texte si la distinction entre valeurs NULL et chaînes vides
      n'est pas souhaitée.
     </para>

     <note>
      <para>
       Lors de l'utilisation de <command>COPY FROM</command>, tout élément de données
       qui correspond à cette chaîne est stocké comme valeur NULL. Il est donc utile
       de s'assurer que c'est la même chaîne que celle précisée pour le 
       <command>COPY TO</command> qui est utilisée.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CSV</literal></term>
    <listitem>
     <para>
      Mode <literal>CSV</literal> (NDT&nbsp;: Comma Separated Values, en anglais&nbsp;; soit en français, valeurs séparées par des virgules).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HEADER</literal></term>
    <listitem>
     <para>
      Le fichier contient une ligne d'en-tête avec les noms de chaque
      colonne. En sortie, la première ligne contient les noms de
      colonne de la table. En entrée, elle est ignorée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">quote</replaceable></term>
    <listitem>
     <para>
      Le caractère guillemet du mode <literal>CSV</literal>. Par
      défaut, il s'agit du guillemet double.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">escape</replaceable></term>
    <listitem>
     <para>
      Le caractère qui apparaît devant un caractère <literal>guillemet</literal> de données
      (<literal>QUOTE</literal>) en mode <literal>CSV</literal>. Par défaut, il s'agit de
      la valeur <literal>QUOTE</literal> (habituellement un guillemet double).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE QUOTE</literal></term>
    <listitem>
     <para>
      L'utilisation de guillemets autour des valeurs non-<literal>NULL</literal>
      de chaque colonne précisée est 
      forcée pour le mode <literal>CSV</literal> de <command>COPY TO</command>.
      Une sortie <literal>NULL</literal> n'est jamais entre guillemets.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE NOT NULL</literal></term>
    <listitem>
     <para>
      En mode <literal>CSV</literal> avec <command>COPY FROM</command> chaque colonne précisée
      est considérée entre guillemets, donc non-<literal>NULL</literal>.
      La chaîne NULL par défaut du mode <literal>CSV</literal> (<literal>''</literal>)
      est de ce fait comprise comme une chaîne de longueur nulle.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
  <title>Affichage</title>

  <para>
   En cas de succès, une commande <command>COPY</command> renvoie une balise
   de la forme
<screen>
COPY <replaceable class="parameter">nombre</replaceable>
</screen>
   Le <replaceable class="parameter">nombre</replaceable> correspond au nombre
   de lignes copiées.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    <command>COPY</command> ne peut être utilisé qu'avec des tables réelles,
    pas avec des vues. Néanmoins, vous pouvez écrire <literal>COPY (SELECT * FROM
    <replaceable class="parameter">nom_vue</replaceable>) TO ...</literal>.
   </para>

   <para>
    Le mot clé <literal>BINARY</literal> impose que les données soient
    stockées/lues dans un format binaire, non en texte. C'est quelque peu
    plus rapide qu'en mode texte, mais un fichier binaire est moins
    portable au travers des architectures machine et des versions de
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    Le droit SELECT est requis sur la table dont les valeurs sont
    lues par <command>COPY TO</command> et le droit INSERT sur la table dont les
    valeurs sont insérées par <command>COPY FROM</command>.
   </para>

   <para>
    Les fichiers nommés dans une commande <command>COPY</command> sont lus ou
    écrits directement par le serveur, non par l'application cliente. De ce fait,
    la machine hébergeant le serveur de
    bases de données doit les héberger ou pouvoir y accéder.
    L'utilisateur <productname>PostgreSQL</productname> (l'identifiant de
    l'utilisateur qui exécute le serveur), non le client, doit pouvoir
    y accéder et les lire ou les modifier.
    L'utilisation de <command>COPY</command> avec un fichier n'est autorisé qu'aux
    superutilisateurs de la base de données car <command>COPY</command> autorise la lecture et
    l'écriture de tout fichier accessible au serveur.
   </para>

   <para>
    Il ne faut pas confondre <command>COPY</command> et l'instruction
    <command>\copy</command> de <application>psql</application>.
    <command>\copy</command> appelle <command>COPY FROM STDIN</command> ou
    <command>COPY TO STDOUT</command>, puis lit/stocke les données dans un
    fichier accessible au client <application>psql</application>. 
    L'accès au fichier et les droits d'accès dépendent alors du client et non du
    serveur.
   </para>

   <para>
    Il est recommandé que le chemin absolu du fichier utilisé dans
    <command>COPY</command> soit toujours précisé. Ceci
    est assuré par le serveur dans le cas d'un <command>COPY TO</command>
    mais, pour les <command>COPY FROM</command>, il est possible de
    lire un fichier spécifié par un chemin relatif. Le chemin est
    interprété relativement au répertoire de travail du processus serveur
    (habituellement dans le répertoire des données), pas par rapport au répertoire
    de travail du client.
   </para>

   <para>
    <command>COPY FROM</command> appelle tous les déclencheurs et 
    contraintes de vérification sur la table de destination, mais pas les
    règles.
   </para>

   <para>
    L'entrée et la sortie de <command>COPY</command> sont sensibles à
    <varname>DateStyle</varname>. Pour assurer la portabilité vers
    d'autres installations de <productname>PostgreSQL</productname> qui
    éventuellement utilisent des paramétrages <varname>DateStyle</varname> différents de ceux
    par défaut, il est préférable de configurer <varname>DateStyle</varname> en
    <literal>ISO</literal> avant d'utiliser <command>COPY TO</command>.
   </para>

   <para>
    <command>COPY</command> stoppe l'opération à la première erreur. Si cela ne
    porte pas à conséquence dans le cas d'un <command>COPY TO</command>, il en va
    différemment dans le cas d'un <command>COPY FROM</command>. Dans ce cas, la table cible
    a déjà reçu les lignes précédentes. Ces lignes ne sont ni visibles, ni accessibles,
    mais occupent de l'espace disque. Il peut en résulter une perte importante 
    d'espace disque si l'échec se produit lors d'une copie volumineuse.
    L'espace perdu peut alors être récupéré avec la commande <command>VACUUM</command>.
   </para>
 </refsect1>

 <refsect1>
  <title>Formats de fichiers</title>

  <refsect2>
   <title>Format texte</title>

   <para>
    Lorsque <command>COPY</command> est utilisé sans l'option <literal>BINARY</literal>
    ou l'option <literal>CSV</literal>, les données sont lues ou écrites dans un 
    fichier texte, chauqe ligne correspondant à une ligne de la table. Les colonnes
    sont séparées, dans une ligne, par le caractère de délimitation. Les valeurs
    des colonnes sont des chaînes, engendrées par la fonction de sortie ou utilisables
    par celle d'entrée, correspondant au type de données des attributs. La chaîne 
    de spécification des valeurs NULL est utilisée en lieu et place des valeurs nulles.
    <command>COPY FROM</command> lève une erreur si une ligne du fichier ne contient
    pas le nombre de colonnes attendues. Si <literal>OIDS</literal> est précisé, 
    l'OID est lu ou écrit dans la première colonne, avant celles des données utilisateur.
   </para>

   <para>
    La fin des données peut être représentée par une ligne ne contenant
    qu'un antislash et un point (<literal>\.</literal>). Ce marqueur de fin de
    données n'est pas nécessaire lors de la lecture d'un fichier, la fin du
    fichier tenant ce rôle. Il n'est réellement nécessaire que lors d'une copie de
    données vers ou depuis une application cliente qui utilise un protocole
    client antérieur au 3.0.
   </para>

   <para>
    Les caractères antislash (<literal>\</literal>) peuvent être utilisés dans les
    données de <command>COPY</command> pour échapper les caractères qui,
    sans cela, seraient considérés comme des délimiteurs de ligne ou de
    colonne. Les caractères suivants, en particulier, <emphasis>doivent</emphasis> être
    précédés d'un antislash s'ils apparaissent dans la
    valeur d'une colonne&nbsp;: l'antislash lui-même, le saut de ligne, le retour
    chariot et le délimiteur courant.
   </para>

   <para>
    La chaîne NULL spécifiée est envoyée par <command>COPY TO</command> sans
    ajout d'antislash&nbsp;; au contraire, <command>COPY FROM</command>
    teste l'entrée au regard de la chaîne NULL avant la suppression des antislash.
    Ainsi, une chaîne NULL telle que <literal>\N</literal> ne peut pas être
    confondue avec la valeur de donnée réelle <literal>\N</literal> 
    (représentée dans ce cas par <literal>\\N</literal>).
   </para>

   <para>
    Les séquences spéciales suivantes sont reconnues par <command>COPY FROM</command>&nbsp;:

   <informaltable>
    <tgroup cols="2">
     <colspec colnum="1" colwidth="1*"/>
     <colspec colnum="2" colwidth="2*"/>
     <thead>
      <row>
       <entry>Séquence</entry>
       <entry>Représente</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\b</literal></entry>
       <entry>Retour arrière (<foreignphrase>backspace</foreignphrase>) (ASCII 8)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>Retour chariot (ASCII 12)</entry>
      </row>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>Nouvelle ligne (ASCII 10)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>Retour chariot (ASCII 13)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>Tabulation (ASCII 9)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>Tabulation verticale (ASCII 11)</entry>
      </row>
      <row>
       <entry><literal>\</literal><replaceable>chiffres</replaceable></entry>
       <entry>Antislash suivi d'un à trois chiffres en octal représente le
	 caractère qui possède ce code numérique</entry>
      </row>
      <row>
       <entry><literal>\x</literal><replaceable>digits</replaceable></entry>
       <entry>Antislash <literal>x</literal> suivi d'un ou deux chiffres hexadécimaux
        représente le caractère qui possède ce code numérique</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

    Actuellement, <command>COPY TO</command> n'émet pas de séquence
    octale ou hexadécimale mais utilise les autres séquences listées
    ci-dessus pour les caractères de contrôle.
   </para>

   <para>
    Tout autre caractère précédé d'un antislash se représente lui-même. 
    Cependant, il faut faire attention à ne pas ajouter d'antislash 
    qui ne soit pas absolument nécessaire afin d'éviter le risque
    d'obtenir accidentellement une correspondance avec
    le marqueur de fin de données (<literal>\.</literal>) ou la chaîne NULL
    (<literal>\N</literal> par défaut)&nbsp;; ces chaînes sont reconnues avant tout
    traitement des antislashs.
   </para>

   <para>
    Il est fortement recommandé que les applications qui engendrent des
    données <command>COPY</command> convertissent les données de nouvelle ligne
    et de retour chariot par les séquences respectives <literal>\n</literal> et <literal>\r</literal>.
    A l'heure actuelle, il est possible de représenter un retour chariot par
    un antislash et un retour chariot, et une nouvelle ligne par un antislash
    et une nouvelle ligne. Cependant, il n'est pas certain que ces représentations
    soient encore acceptées dans les prochaines versions. Celles-ci sont, de plus, 
    extrêmement sensibles à la corruption si le fichier de <command>COPY</command>
    est transféré sur d'autres plateformes (d'un Unix vers un Windows ou inversement, par exemple).
   </para>

   <para>
    <command>COPY TO</command> termine chaque ligne par une
    nouvelle ligne de style Unix (<quote><literal>\n</literal></quote>). Les serveurs
    fonctionnant sous Microsoft Windows engendrent un retour chariot/nouvelle ligne
    (<quote><literal>\r\n</literal></quote>), mais uniquement lorsque
    les données engendrées par <command>COPY</command> sont envoyées dans un
    fichier sur le serveur.
    Pour des raisons de cohérence entre les
    plateformes, <command>COPY TO STDOUT</command> envoie toujours
    <quote><literal>\n</literal></quote> quelque soit la plateforme du serveur.
    <command>COPY FROM</command> sait gérer les lignes terminant par une nouvelle
    ligne, un retour chariot ou un retour chariot suivi d'une nouvelle ligne.
    Afin de réduire les risques d'erreurs engendrées par des nouvelles lignes
    ou des retours chariot non précédés d'antislash, considéré de fait comme
    des données, <command>COPY FROM</command> émet un avertissement si les
    fins de lignes ne sont pas toutes identiques.
   </para>
  </refsect2>

  <refsect2>
  <title>Format CSV</title>

  <para>
   Ce format est utilisé pour importer et exporter des données au format 
   de fichier <literal>CSV</literal> (acronyme de
   <foreignphrase>Comma Separated Value</foreignphrase>, littéralement
   valeurs séparées par des virgules). Ce format est utilisé par un grand nombre de
   programmes, tels les tableurs. À la place de l'échappement utilisé par le mode
   texte standard de <productname>PostgreSQL</productname>, il produit et
   reconnaît le mécanisme d'échappement habituel de CSV.
  </para>

  <para>
   Les valeurs de chaque enregistrement sont séparées par le caractère
   <literal>DELIMITER</literal>. Si la valeur contient ce caractère, le caractère
   <literal>QUOTE</literal>, la chaîne <literal>NULL</literal>, un retour chariot
   ou un saut de ligne, la valeur complète est préfixée et suffixée
   par le caractère <literal>QUOTE</literal>. De plus, toute occurrence du caractère
   <literal>QUOTE</literal> ou du caractère <literal>ESCAPE</literal> est précédée du
   caractère d'échappement. <literal>FORCE QUOTE</literal> peut également être utilisé
   pour forcer les guillemets lors de l'affichage de valeur non-NULL dans
   des colonnes spécifiques.
  </para>

  <para>
   Le format <literal>CSV</literal> ne permet pas de distinguer de façon standard 
   une valeur <literal>NULL</literal> d'une chaîne vide. La commande <command>COPY</command>
   de <productname>PostgreSQL</productname> gère cela avec les guillemets. Un
   <literal>NULL</literal> est affiché par la chaîne <literal>NULL</literal> et n'est jamais
   entre guillemets. Ainsi, avec les paramètres par défaut,
   <literal>NULL</literal> est écrit comme une chaîne vide sans guillemets, alors qu'une
   chaîne vide est écrite avec des guillemets doubles (<literal>""</literal>). La lecture
   des valeurs suit des règles similaires. L'utilisation de <literal>FORCE NOT NULL</literal>
   permet de prévenir les comparaisons d'entrées <literal>NULL</literal> pour
   des colonnes particulières.
  </para>

   <para>
    L'antislash n'est pas un caractère spécial dans le format <literal>CSV</literal>.
    De ce fait, le marqueur de fin de données, <literal>\.</literal>, peut apparaître
    dans les donnée. Afin d'éviter toute mauvaise interprétation, une valeur <literal>\.</literal>
    qui apparaît seule sur une ligne est automatiquement placée
    entre guillemets en sortie. En entrée, si elle est entre guillemets, elle
    n'est pas interprétée comme un marqueur de fin de données.
    Lors du chargement d'un fichier qui ne contient qu'une colonne, dont les valeurs ne sont pas placées entre
    guillemets, créé par une autre application, qui contient une valeur 
    <literal>\.</literal>, il est nécessaire de placer cette valeur entre guillemets.
   </para>

   <note>
    <para>
     Dans le mode <literal>CSV</literal>, tous les caractères sont significatifs.
     Une valeur entre guillemets entourée d'espaces ou de tout
     autre caractère différent de <literal>DELIMITER</literal> inclut ces caractères.
     Cela peut être source d'erreurs en cas d'import de données à partir d'un système
     qui complète les lignes <literal>CSV</literal> avec des espaces fines pour
     atteindre une longueur fixée. Dans ce cas, il est nécessaire de pré-traiter
     le fichier <literal>CSV</literal> afin de supprimer les espaces de complètement
     avant d'insérer les données dans <productname>PostgreSQL</productname>.
    </para>
   </note>

  <note>
   <para>
    Le mode CSV sait reconnaître et produire des fichiers CSV dont les valeurs entre
    guillemets contiennent des retours chariot et des sauts de ligne. De ce fait,
    les fichiers ne contiennent pas strictement une ligne par ligne de table comme
    les fichiers du mode texte.
   </para>
  </note>

  <note>
   <para>
    Beaucoup de programmes produisent des fichiers CSV étranges et parfois pervers&nbsp;;
    le format de fichier est donc plus une convention qu'un standard.
    Il est alors possible de rencontrer des fichiers que ce mécanisme ne sait
    pas importer. De plus, <command>COPY</command> peut produire des fichiers 
    inutilisables par d'autres programmes.
   </para>
  </note>

  </refsect2>

  <refsect2>
   <title>Format binaire</title>

   <para>
    Le format de fichier utilisé pour <command>COPY BINARY</command> a été
    modifié dans <productname>PostgreSQL</productname> 7.4. Le nouveau format
    consiste en un en-tête de fichier, des tuples (éventuellement aucun) qui contiennent
    les données de la ligne et une queue de fichier. Les en-têtes et les données sont
    désormais dans l'ordre des octets réseau.
   </para>

   <refsect3>
    <title>Entête du fichier</title>

    <para>
     L'en-tête du fichier est constitutée de 15 octets de champs fixes, suivis par une
     aire d'extension de l'en-tête de longueur variable. Les champs fixes
     sont&nbsp;:

    <variablelist>
     <varlistentry>
      <term>Signature</term>
      <listitem>
       <para>
	séquence de 11 octets <literal>PGCOPY\n\377\r\n\0</literal> &mdash;
	l'octet zéro est une partie obligatoire de la signature. La signature est
	conçue pour permettre une identification aisée des fichiers qui ont été
	déteriorés par un transfert non respectueux des huit bits. Cette
	signature est modifiée par les filtres de traduction de fin de ligne,
	la suppression des octets zéro, la suppression des bits de poids forts ou
	la modification de la parité.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Champs de commutateurs</term>
      <listitem>
       <para>
	masque entier de 32 bits décrivant les aspects importants du format de
	fichier. Les bits sont numérotés de 0 (<acronym>LSB</acronym>,
	ou <foreignphrase>Least Significant Bit</foreignphrase>, bit de poids faible) à 31
	(<acronym>MSB</acronym>, ou <foreignphrase>Most Significant Bit</foreignphrase>, bit de poids fort).
	Ce champ est stocké dans l'ordre réseau des octets
	(l'octet le plus significatif en premier), comme le sont tous
	les champs entier utilisés dans le format de fichier. Les bits 16 à 31
	sont réservés aux problèmes critiques de format de
	fichier&nbsp;; tout lecteur devrait annuler l'opération s'il trouve un bit
	inattendu dans cet ensemble. Les bits 0 à 15 sont réservés pour signaler
	les problèmes de compatibilité de formats&nbsp;; un lecteur devrait
	simplement ignorer les bits inattendus dans cet ensemble. Actuellement,
	seul un bit est défini, le reste doit être à zéro&nbsp;:
        <variablelist>
         <varlistentry>
          <term>Bit 16</term>
          <listitem>
           <para>
            si 1, les OID sont inclus dans la donnée&nbsp;; si 0, non
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Longueur de l'aire d'extension de l'en-tête</term>
      <listitem>
       <para>
	entier sur 32 bits, longueur en octets du reste de l'en-tête, octets de 
	stockage de la longueur non-compris. À l'heure actuelle ce champ vaut zéro. La première ligne
	suit immédiatement. De futures modifications du format pourraient
	permettre la présence de données supplémentaires dans l'en-tête. Tout
	lecteur devrait ignorer silencieusement toute donnée de l'extension de
	l'en-tête qu'il ne sait pas traitée.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    </para>

    <para>
     L'aire d'extension de l'en-tête est prévue pour contenir une séquence de morceaux
     s'auto-identifiant. Le champ de commutateurs n'a pas pour but
     d'indiquer aux lecteurs ce qui se trouve dans l'aire d'extension. La
     conception spécifique du contenu de l'extension de l'en-tête est pour
     une prochaine version.
    </para>

    <para>
     Cette conception permet l'ajout d'en-têtes compatible (ajout de
     morceaux d'extension d'en-tête, ou initialisation des octets commutateurs de poids faible)
     et les modifications non compatibles (initialisation des octets commutateurs de
     poids fort pour signaler de telles modifications, et ajout des données de support dans
     l'aire d'extension si nécessaire).
    </para>
   </refsect3>

   <refsect3>
    <title>Tuples</title>
    <para>
     Chaque tuple débute par un compteur, entier codé sur 16 bits, représentant le nombre de champs 
     du tuple. (Actuellement, tous les tuples d'une table ont le même compteur,
     mais il est probable que cela ne soit pas toujours le cas.) On trouve ensuite, 
     répété pour chaque champ du tuple, un mot de 32 bits annonçant le nombre
     d'octets de stockage de la donnée qui suivent. (Ce mot n'inclut pas
     sa longueur propre et peut donc être nul.) -1, cas spécial, indique une
     valeur de champ NULL. Dans ce cas, aucun octet de valeur ne suit.
    </para>

    <para>
     Il n'y a ni complètement d'alignement ni toute autre donnée supplémentaire
     entre les champs.
    </para>

    <para>
     Actuellement, toutes les valeurs d'un fichier <command>COPY BINARY</command> sont supposées être dans un format binaire
     (code de format).
     Il est probable qu'une extension future ajoute un champ d'en-tête
     autorisant la spécification de codes de format par colonne.
    </para>

    <para>
     La consulation du code source de <productname>PostgreSQL</productname>, et en
     particulier les fonctions <function>*send</function> et <function>*recv</function>
     associées à chaque type de données de la colonne, 
     permet de déterminer le format binaire approprié à la donnée réelle.
     Ces fonctions se situent dans le répertoire <filename>src/backend/utils/adt/</filename> des
     sources.
    </para>

    <para>
     Lorsque les OID sont inclus dans le fichier, le champ OID suit immédiatement
     le compteur de champ. C'est un champ normal, à ceci près qu'il n'est pas
     inclus dans le compteur. En fait, il contient un mot de stockage de la longueur
     &mdash; ceci permet de faciliter le passage d'OID sur quatre octets 
     aux OID sur huit octets et permet d'afficher les OID comme étant NULL en cas de besoin.
    </para>
   </refsect3>

   <refsect3>
    <title>Queue du fichier</title>

    <para>
     La fin du fichier consiste en un entier sur 16 bits contenant -1. Cela permet
     de le
     distinguer aisément du compteur de champs d'un tuple.
    </para>

    <para>
     Il est souhaitable que le lecteur rapporte une erreur si le mot compteur de champ ne vaut
     ni -1 ni le nombre attendu de colonnes. Cela assure une vérification
     supplémentaire d'une éventuelle désynchronisation d'avec les
     données.
    </para>
   </refsect3>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Copier une table vers le client en utilisant la barre
   verticale (<literal>|</literal>) comme délimiteur de champ&nbsp;:
<programlisting>COPY pays TO STDOUT WITH DELIMITER '|';
</programlisting>
  </para>

  <para>
   Copier des données d'un fichier vers la table <literal>pays</literal>&nbsp;:
<programlisting>COPY pays FROM '/usr1/proj/bray/sql/pays_donnees';
</programlisting>
  </para>

  <para>
   Pour copier dans un fichier les pays dont le nom commence par 'A'&nbsp;:
<programlisting>
COPY (SELECT * FROM pays WHERE nom_pays LIKE 'A%') TO '/usr1/proj/bray/sql/une_liste_de_pays.copy';
</programlisting>
  </para>

  <para>
   Exemple de données convenables pour une copie vers une table depuis
   <literal>STDIN</literal>&nbsp;:
<programlisting>AF      AFGHANISTAN
AL      ALBANIE
DZ      ALGERIE
ZM      ZAMBIE
ZW      ZIMBABWE
</programlisting>
   L'espace sur chaque ligne est en fait un caractère de
   tabulation.
  </para>

  <para>
   Les même données, extraites au format binaire. Les données sont
   affichées après filtrage au travers de l'outil Unix <command>od -c</command>. La
   table a trois colonnes&nbsp;; la première est de type <type>char(2)</type>,
   la deuxième de type <type>text</type> et la troisième de type <type>integer</type>.
   Toutes les lignes ont une valeur NULL sur la troisième colonne.
<programlisting>0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   E 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   E 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   E 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas d'instruction <command>COPY</command> dans le standard SQL.
  </para>

  <para>
   La syntaxe suivante, utilisée avant <productname>PostgreSQL</productname>
   version 7.3, est toujours supportée&nbsp;:

<synopsis>COPY [ BINARY ] <replaceable class="parameter">nomtable</replaceable> [ WITH OIDS ]
    FROM { '<replaceable class="parameter">nomfichier</replaceable>' | STDIN }
    [ [USING] DELIMITERS '<replaceable class="parameter">délimiteur</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">chaîne NULL</replaceable>' ]

COPY [ BINARY ] <replaceable class="parameter">nomtable</replaceable> [ WITH OIDS ]
    TO { '<replaceable class="parameter">nomfichier</replaceable>' | STDOUT }
    [ [USING] DELIMITERS '<replaceable class="parameter">délimiteur</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">chaîne NULL</replaceable>' ]
</synopsis>
  </para>
 </refsect1>
</refentry>
