<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_aggregate.sgml,v 1.10 2005/09/15 07:03:26 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-CREATEAGGREGATE">
 <refmeta>
  <refentrytitle id="sql-createaggregate-title">CREATE AGGREGATE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE AGGREGATE</refname>
  <refpurpose>définit une nouvelle fonction d'agrégat</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createaggregate">
  <primary>CREATE AGGREGATE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE AGGREGATE <replaceable class="PARAMETER">nom</replaceable> (
    BASETYPE = <replaceable class="PARAMETER">type_donnée_entrée</replaceable>,
    SFUNC = <replaceable class="PARAMETER">sfonc</replaceable>,
    STYPE = <replaceable class="PARAMETER">type_donnée_état</replaceable>
    [ , FINALFUNC = <replaceable class="PARAMETER">ffonc</replaceable> ]
    [ , INITCOND = <replaceable class="PARAMETER">condition_initiale</replaceable> ]
    [ , SORTOP = <replaceable class="PARAMETER">operateur_tri</replaceable> ]
)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE AGGREGATE</command> définit une nouvelle fonction d'agrégat.
   Quelques fonctions d'agrégat basiques et largement utilisées sont fournies
   dans la distribution standard&nbsp;; elles sont documentées dans le <xref
   linkend="functions-aggregate"/>. Si une d'entre elles définit de nouveaux
   types ou a besoin d'une fonction d'agrégat non fournie, alors <command>CREATE
   AGGREGATE</command> peut être utilisé pour fournir les fonctionnalités
   désirées.
  </para>

  <para>
   Si un nom de schéma est donné (par exemple, <literal>CREATE AGGREGATE
   monschema.monagg ...</>), alors la fonction d'agrégat est créée dans le
   schéma spécifié. Sinon, elle est créée dans le schéma courant.
  </para>

  <para>
   Une fonction d'agrégat est identifiée par son nom et son type de données en
   entrée. Deux agrégats dans le même schéma peuvent avoir le même nom s'ils
   opèrent sur des types différents en entrée. Le nom et le type de données en
   entrée d'un agrégat doivent aussi être distincts du nom et du type de données
   de toutes les fonctions ordinaires du même schéma.
  </para>

  <para>
   Une fonction d'agrégat est réalisée à partir d'une ou deux fonctions
   ordinaires&nbsp;:
   une fonction de transition d'état
   <replaceable class="PARAMETER">sfonc</replaceable>,
   et une fonction de traitement final optionnelle
   <replaceable class="PARAMETER">ffonc</replaceable>.
   Elles sont utilisées ainsi&nbsp;:
<programlisting>
<replaceable class="PARAMETER">sfonc</replaceable>( état-interne,
nouvel-élément-données ) ---> prochain-état-interne
<replaceable class="PARAMETER">ffonc</replaceable>( état-interne ) --->
valeur-agrégat
</programlisting>
  </para>

  <para>
   <productname>PostgreSQL</productname> crée une variable temporaire de type
   <replaceable class="PARAMETER">stype</replaceable> pour contenir l'état
   interne courant de l'agrégat. À chaque élément de données en entrée, la
   fonction de transition d'état est appelée pour calculer une nouvelle valeur
   de l'état interne. Une fois que toutes les données sont traitées, la fonction
   finale est appelée une fois pour calculer la valeur de retour de l'agrégat.
   S'il n'existe pas de fonction finale, alors la valeur d'état final est
   retournée ainsi.
  </para>
  
  <para>
   Une fonction d'agrégat peut fournir une condition initiale, c'est-à-dire une
   valeur initiale pour la valeur de l'état interne. Ceci est spécifié et stocké
   dans la base de données comme une colonne de type <type>text</type> mais doit
   être une représentation externe valide d'une constante du type de donnée de
   la valeur de l'état. Si elle n'est pas fournie, la valeur de l'état commence
   avec NULL.
  </para>
  
  <para>
   Si la fonction de transition de l'état est déclarée <quote>strict</quote>,
   alors elle ne peut pas être appelée avec des entrées NULL. Avec une telle
   fonction de transition, l'exécution d'agrégat se comporte ainsi. Les valeurs
   des entrées NULL sont ignorées (la fonction n'est pas appelée et la valeur de
   l'état précédent est conservée). Si la valeur de l'état initial est NULL,
   alors la première valeur en entrée non NULL remplace la valeur de l'état et
   la fonction de transition est appelée en commençant avec la seconde valeur en
   entrée non NULL. Ceci est pratique pour implémenter les agrégats comme
   <function>max</function>. Notez que ce comportement est seulement disponible
   quand <replaceable class="PARAMETER">type_donnée_état</replaceable> est
   identique à <replaceable class="PARAMETER">type_donnée_entrée</replaceable>.
   Lorsque ces types sont différents, vous devez fournir une condition initiale
   non NULL ou utiliser une fonction de transition non stricte.
  </para>
  
  <para>
   Si la fonction de transition d'état n'est pas stricte, alors elle sera
   appelée sans condition à chaque valeur en entrée et devra gérer les
   entrées NULL et les valeurs de transition NULL. Ceci permet à l'auteur de
   l'agrégat d'avoir le contrôle complet sur la gestion des valeurs NULL par
   l'agrégat.
  </para>
  
  <para>
   Si la fonction finale est déclarée <quote>strict</quote>, alors elle ne sera
   pas appelée quand la valeur d'état finale est NULL&nbsp;; à la place, un
   résultat NULL sera retourné automatiquement. (Bien sûr, c'est simplement le
   comportement normal de fonctions strictes.) Dans tous les cas, la fonction
   finale a l'option de renvoyer une valeur NULL. Par exemple, la fonction
   finale pour <function>avg</function> renvoie NULL lorsqu'elle n'a aucune
   lignes en entrée.
  </para>
  
  <para>
   Les agrégats qui se comportent comme  <function>MIN</> ou <function>MAX</>
   peuvent parfois être optimisés en cherchant un index au lieu de parcourir
   toute ligne en entrée. Si cet agrégat peut être aussi optimisé, indiquez-le
   en spécifiant un <firstterm>opérateur de tri</>. Le prérequis basique est
   que l'agrégat doit  The basic requirement is that
   the aggregate must produire le premier élément dans l'ordre du tri induit par
   l'opérateur&nbsp;; en d'autres mots
<programlisting>
SELECT agg(col) FROM tab;
</programlisting>
   doit être équivalent à
<programlisting>
SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
</programlisting>
   D'autres prérequis sont que l'agrégat ignore les entrées NULL et qu'il
   fournit un résultat NULL si et seulement si il n'y a aucune entrée NULL.
   D'ordinaire, l'opérateur <literal>&lt;</> d'un type de données est le bon
   opérateur de tri pour <function>MIN</> et <literal>&gt;</> est le bon
   opérateur de tri pour <function>MAX</>. Notez que l'optimisation ne prendra
   jamais effet sauf si l'opérateur spécifié est le membre de la stratégie
   LessThan ou GreaterThan d'une classe d'opérateur pour un index btree.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="PARAMETER">nom</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction d'agrégat à créer (pouvant être qualifié avec le nom
      du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">type_donnée_entrée</replaceable></term>
    <listitem>
     <para>
      Le type de données en entrée sur lequel opère la fonction d'agrégat. Elle
      peut être spécifiée comme <literal>"ANY"</> pour un agrégat qui n'examine
      pas les valeurs en entrée (un exemple est <function>count(*)</function>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">sfonc</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction de transition de l'état à appeler pour chaque
      valeur en entrée. C'est normalement une fonction à deux arguments, le
      premier étant de type <replaceable
      class="PARAMETER">type_donnée_état</replaceable> et le second de type
      <replaceable class="PARAMETER">type_donnée_entrée</replaceable>.
      Autrement, pour un agrégat qui n'examine pas les valeurs en entrée, la
      fonction prend un seul argument de type <replaceable
      class="PARAMETER">type_donnée_état</replaceable>. Dans chaque cas, la
      fonction doit renvoyer une valeur de type <replaceable
      class="PARAMETER">type_donnée_état</replaceable>. Cette fonction prend la
      valeur de l'état en cours et l'élément de donnée en cours et renvoie la
      prochaine valeur d'état.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">type_donnée_état</replaceable></term>
    <listitem>
     <para>
      Le type de donnée pour la valeur d'état de l'agrégat.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">ffonc</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction finale à appeler pour traiter le résultat de
      l'agrégat une fois que toutes les données en entrée aient été parcourues.
      La fonction prend un seul argument de type <replaceable
      class="PARAMETER">type_donnée_état</replaceable>. Le type de retour de
      l'agrégat de la fonction est défini comme le type de retour de cette
      fonction. Si <replaceable class="PARAMETER">ffonc</replaceable> n'est pas
      spécifiée, alors la valeur d'état finale est utilisée comme résultat de
      l'agrégat et le type de retour est <replaceable
      class="PARAMETER">type_donnée_état</replaceable>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">condition_initiale</replaceable></term>
    <listitem>
     <para>
      La configuration initiale pour la valeur de l'état. Elle doit être une
      constante de type chaîne de caractères dans la forme acceptée par le type
      de données <replaceable class="PARAMETER">type_donnée_état</replaceable>.
      Si non spécifié, la valeur d'état commence à NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">sort_operator</replaceable></term>
    <listitem>
     <para>
      L'opérateur de tri associé pour un agrégat de type <function>MIN</> ou
      <function>MAX</>. C'est seulement le nom de l'opérateur (qualifié si
      nécessaire du nom du schéma). L'opérateur est supposé avoir les mêmes
      types de données en entrée que pour l'agrégat.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les paramètres de <command>CREATE AGGREGATE</command> peuvent être écrit
   dans n'importe quel ordre, pas uniquement dans l'ordre illustré ci-dessus.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Exemples</title>

  <para>
   Voir <xref linkend="xaggr">.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>CREATE AGGREGATE</command> est une extension du langage
   <productname>PostgreSQL</productname>. Le standard SQL ne fournit pas de
   fonctions d'agrégat définies par l'utilisateur.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alteraggregate" endterm="sql-alteraggregate-title"></member>
   <member><xref linkend="sql-dropaggregate" endterm="sql-dropaggregate-title"></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
