<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_cast.sgml,v 1.10 2005/09/15 07:03:26 guillaume Exp $ -->
<!-- SAS 20060327 : Correction tags -->

<refentry id="SQL-CREATECAST">
 <refmeta>
  <refentrytitle id="SQL-CREATECAST-TITLE">CREATE CAST</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE CAST</refname>
  <refpurpose>définit un transtypage</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createcast">
  <primary>CREATE CAST</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE CAST (<replaceable>typesource</replaceable> AS <replaceable>typecible</replaceable>)
    WITH FUNCTION <replaceable>nomfonction</replaceable> (<replaceable>argtype</replaceable>)
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<replaceable>typesource</replaceable> AS <replaceable>typecible</replaceable>)
    WITHOUT FUNCTION
    [ AS ASSIGNMENT | AS IMPLICIT ]
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createcast-description">
  <title>Description</title>

  <para>
   <command>CREATE CAST</command> définit un transtypage. Un transtypage
   spécifie l'opération de conversion entre deux types de
   données. Par exemple,
<programlisting>
SELECT CAST(42 AS text);
</programlisting>
   convertit la constante entière 42 en <type>text</type> en appelant
   une fonction précédemment définie, <literal>text(int4)</literal> dans le cas
   présent (si aucun transtypage convenable n'a été défini, la conversion échoue).
  </para>

  <para>
   Deux types peuvent être <firstterm>binairement compatibles</firstterm>,
   ce qui signifie que la conversion d'un type en l'autre est
   <quote>gratuite</quote> et ne nécessite pas d'appel de fonction. Les
   valeurs correspondantes doivent pour cela utiliser la même représentation interne.
   Les types <type>text</type> et <type>varchar</type>, par exemple, sont binairement compatibles.
  </para>

  <para>
   Un transtypage peut être appelé explicitement.
   Par exemple&nbsp;: <literal>CAST(<replaceable>x</replaceable> AS
   <replaceable>nomtype</replaceable>)</literal> ou
   <replaceable>x</replaceable><literal>::</literal><replaceable>nomtype</replaceable>.
  </para>

  <para>
   Si le transtypage est marqué <literal>AS ASSIGNMENT</literal> (NDT&nbsp;: à l'affectation),
   alors son appel peut être
   implicite lors de l'affectation d'une valeur à une colonne du
   type de donnée cible. Par exemple, en supposant que
   <literal>foo.f1</literal> soit une colonne de type <type>text</type>, 
<programlisting>
INSERT INTO foo (f1) VALUES (42);
</programlisting>
   est autorisé si la conversion du type <type>integer</type> vers le type
   <type>text</type> est indiquée <literal>AS ASSIGNMENT</literal>. Dans le cas contraire,
   c'est interdit. Le terme de <firstterm>transtypage d'affectation</firstterm>
   est utilisé pour décrire ce type de conversion.
  </para>

  <para>
   Si le transtypage est marqué <literal>AS IMPLICIT</literal>, alors 
   son appel peut être implicite, indépendemment du contexte, lors d'une
   affectation ou dans une expression. Par exemple, comme <literal>||</literal> prend deux
   opérandes <type>text</type>,
<programlisting>
SELECT 'L\'heure est ' || now();
</programlisting>
   n'est autorisé que si la conversion du type <type>timestamp</type> vers le
   type <type>text</type> est marquée <literal>AS IMPLICIT</literal>. Dans le cas contraire,
   il est nécessaire d'écrire explicitement la conversion, par exemple
<programlisting>
SELECT 'L\'heure est ' || CAST(now() AS text);
</programlisting>
   Le terme de <firstterm>transtypage implicite</firstterm> est habituellement utilisé pour décrire
   ce type de conversion.
  </para>

  <para>
   Il est conseillé d'être conservateur sur le marquage du caractère implicite 
   des transtypages. Une surabondance de transtypages implicites peut conduire
   <productname>PostgreSQL</productname> à interpréter étrangement des commandes,
   voire à se retrouver dans l'incapacité totale de les résoudre parce que plusieurs
   interprétations s'avèrent envisageables. Une bonne règle est de ne réaliser 
   des transtypages implicites que pour les transformations entre types de la
   même catégorie générale et qui préservent l'information. Par exemple,
   la conversion entre <type>int2</type> et <type>int4</type> peut être
   raisonnablement implicite mais celle entre <type>float8</type> et
   <type>int4</type> est probablement réservée à l'affectation. Les
   transtypages inter-catégories, tels que de <type>text</type> vers <type>int4</type>,
   sont préférablement exécutés dans le seul mode explicite.
  </para>

  <para>
   Pour créer un transtypage, il faut être propriétaire
   du type source ou destination. Seul le superutilisateur peut créer 
   un transtypage binairement compatible (une erreur sur un tel transtypage
   peut aisément engendrer un arrêt brutal du serveur).
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable>typesource</replaceable></term>

     <listitem>
      <para>
       Le nom du type de donnée source du transtypage.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>typecible</replaceable></term>

     <listitem>
      <para>
       Le nom du type de donnée cible du transtypage.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>    
     <term><replaceable>nomfonction</replaceable>
      (<replaceable>type_argument</replaceable>)</term>

     <listitem>
      <para>
       La fonction utilisée pour effectuer la conversion. Le nom de la fonction
       peut être qualifié du nom du schéma. Si ce n'est pas le cas, la
       fonction est recherchée dans le chemin des schémas. Le type de données
       résultant de la fonction doit correspondre au type cible du transtypage.
       Ses arguments sont explicités ci-dessous.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WITHOUT FUNCTION</literal></term>

     <listitem>
      <para>
       Indication d'une compatibilité binaire des types source et cible. 
       Aucune fonction n'est ainsi requise pour effectuer la conversion.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>AS ASSIGNMENT</literal></term>

     <listitem>
      <para>
       Lors d'une affectation, l'invocation du transtypage peut être implicite.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>AS IMPLICIT</literal></term>

     <listitem>
      <para>
       L'invocation du transtypage peut être implicite dans tout contexte.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  <para>
   Les fonctions de transtypage ont un à trois arguments. Le
   premier argument est du même type que le type source. Le deuxième argument, si fourni,
   doit être de type <type>integer</type>. Il stocke le modificateur de type associé au type de
   destination, ou <literal>-1</literal> en l'absence de modificateur. Le troisième
   argument, si fourni,  doit être de type <type>boolean</type>. Il vaut
   <literal>true</literal> si la conversion est explicite, <literal>false</literal> dans le
   cas contraire. Bizarrement, les spécifications SQL appellent des comportements
   différents pour les transtypages explicites et implicites dans certains
   cas. Ce paramètre est fourni pour les fonctions qui implémentent
   de tel transtypages. Il n'est pas recommandé de concevoir des types de
   données utilisateur entrant dans ce cas de figure.
  </para>

<!-- ICI -->
  <para>
   Généralement, un transtypage correspond à des type source et destination
   différents. Cependant, il est permis de déclarer une conversion d'un
   type source identique au type destination si la fonction de transtypage a
   plus d'un argument. C'est utilisé pour représenter des fonctions de
   restrictions sur une longueur d'un type spécifique. La fonction nommée
   est utilisée pour restreindre la valeur d'un type suivant la valeur du
   modificateur de type donnée par le second paramètre (depuis que la
   grammaire actuelle permet seulement a certains types d'avoir des
   modificateurs de type, cette fonctionnalité n'est d'aucun intérêt pour
   les types sources définis par l'utilisateur, néanmoins nous le signalons).
  </para>

  <para>
   Quand une conversion a un type source et un type destination différent
   et que la fonction a plus d'un argument,  alors la conversion d'un type
   vers un autre et la restriction sur la longeur du type destination sont
   faits en une seule etape. Quand aucune entrée n'est disponible, alors la
   restriction du type qui utilise un modificateur de type implique deux
   étapes, une pour la conversion entre les types de données et la seconde
   pour appliquer le modificateur.
  </para>
 
 </refsect1>

 <refsect1 id="sql-createcast-notes">
  <title>Notes</title>

  <para>
   Utilisez <xref linkend="sql-dropcast" endterm="sql-dropcast-title"> pour
   supprimer les conversions définies par l'utilisateur.
  </para>

  <para>
   Rappelez-vous que si vous souhaitez être capable de convertir les types dans
   les deux sens, vous devez déclarer explicitement les deux sens.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 7.3, chaque fonction qui avait le même nom
   qu'un type de données, envoyait ce type de données et prenait un argument
   d'un autre type était automatiquement détectée comme une fonction de
   conversion. Ceci a été abandonné lors de l'introduction des schémas et pour
   être capable de représenter des conversions compatibles binairement dans les
   catalogues système. Les fonctions de conversion intégrées suivent toujours
   le même schéma de nommage mais elle doivent maintenant être données comme
   conversion dans le catalogue système <structname>pg_cast</structname>.
  </para>

  <para>
   Bien que cela ne soit pas requis, il est recommandé que vous continuez à
   suivre l'ancienne convention de nommage des fonctions de conversion
   après le type de données de destination. Beaucoup d'utilisateurs sont
   habitués à convertir des types de données en utilisant un style de
   notation de fonction, c'est-à-dire
   <replaceable>nom_type</replaceable>(<replaceable>x</replaceable>). En fait, cette
   notation n'est ni plus ni moins un appel à une fonction de conversion.
   Ce n'est pas forcément géré comme une conversion. Si vos fonctions de
   conversions ne sont pas nommées de tel façon a supporter cette
   convention alors vous aurez des utilisateurs surpris. Depuis que
   <productname>PostgreSQL</productname> permet de surcharger le même nom de fonction avec
   différents types d'argument, il n'y a aucune difficulté pour avoir plusieurs
   fonctions de conversion avec des types différents qui utilise le même
   nom de type destination.
  </para>

  <note>
   <para>
   Il y a un petit mensonge dans le paragraphe précédent&nbsp;: il existe
   un cas dans lequel <structname>pg_cast</structname> sera utilisé pour résoudre le sens
   d'un appel de fonction évidente. Si un appel de fonction
   <replaceable>nom</replaceable>(<replaceable>x</replaceable>) coincide avec aucune fonction
   existante, alors <replaceable>nom</replaceable>(<replaceable>x</replaceable>) est le nom du type
   de donnée et <structname>pg_cast</structname> indique une conversion binairement
   compatible depuis le type de <replaceable>x</replaceable>, alors l'appel sera interprété
   comme une conversion explicite. Cette exception est faite de telle façon à
   ce que les conversions compatibles puissent etre invoquées en utilisant une
   syntaxe fonctionnel, même si elles n'ont aucune fonction (de conversion).
   </para>
  </note>
 </refsect1>


 <refsect1 id="sql-createcast-examples">
  <title>Exemples</title>

  <para>
   Pour créer une conversion du type <type>text</type> vers le type
   <type>int4</type> en utilisant la fonction
   <literal>int4(text)</literal>&nbsp;:
<programlisting>
CREATE CAST (text AS int4) WITH FUNCTION int4(text);
</programlisting>
   (Cette conversion est déjà prédéfinie dans le système.)
  </para>
 </refsect1>

 
 <refsect1 id="sql-createcast-compat">
  <title>Compatibilité</title>

  <para>
   La commande <command>CREATE CAST</command> est conforme à <acronym>SQL</acronym>
   sauf que SQL ne parle pas des types compatibles binairement ou d'arguments
   supplémentaires pour les fonctions d'implémentation. <literal>AS IMPLICIT</literal>
   est aussi une extension <productname>PostgreSQL</productname>.
  </para>
 </refsect1>


 <refsect1 id="sql-createcast-seealso">
  <title>Voir aussi</title>

  <para>
   <xref linkend="sql-createfunction" endterm="sql-createfunction-title">,
   <xref linkend="sql-createtype" endterm="sql-createtype-title">,
   <xref linkend="sql-dropcast" endterm="sql-dropcast-title">
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
