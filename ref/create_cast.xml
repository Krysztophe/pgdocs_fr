<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060616 -->

<refentry id="sql-createcast">
 <refmeta>
  <refentrytitle id="sql-createcast-title">CREATE CAST</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE CAST</refname>
  <refpurpose>Définir un transtypage</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE CAST (<replaceable>type_source</replaceable> AS <replaceable>type_cible</replaceable>)
    WITH FUNCTION <replaceable>nomfonction</replaceable> (<replaceable>argtype</replaceable>)
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<replaceable>type_source</replaceable> AS <replaceable>type_cible</replaceable>)
    WITHOUT FUNCTION
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<replaceable>type_source</replaceable> AS <replaceable>type_cible</replaceable>)
    WITH INOUT
    [ AS ASSIGNMENT | AS IMPLICIT ]
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createcast-description">
  <title>Description</title>
  <indexterm zone="sql-createcast">
   <primary>CREATE CAST</primary>
  </indexterm>

  <para>
   <command>CREATE CAST</command> définit un transtypage. Un transtypage
   spécifie l'opération de conversion entre deux types de
   données. Par exemple&nbsp;:
<programlisting>SELECT CAST(42 AS float8);
</programlisting>
   convertit la constante entière 42 en <type>float8</type> en appelant
   une fonction précédemment définie, <literal>float8(int4)</literal> dans le cas
   présent (si aucun transtypage convenable n'a été défini, la conversion échoue).
  </para>

  <para>
   Two types can be <firstterm>binary coercible</firstterm>, which
   means that the conversion can be performed <quote>for free</quote>
   without invoking any function.  This requires that corresponding
   values use the same internal representation.  For instance, the
   types <type>text</type> and <type>varchar</type> are binary
   coercible both ways.  Binary coercibility is not necessarily a
   symmetric relationship.  For example, the cast
   from <type>xml</type> to <type>text</type> can be performed for
   free in the present implementation, but the reverse direction
   requires a function that performs at least a syntax check.  (Two
   types that are binary coercible both ways are also referred to as
   binary compatible.)
  </para>

  <para>
   You can define a cast as an <firstterm>I/O conversion cast</firstterm> using
   the <literal>WITH INOUT</literal> syntax. An I/O conversion cast is
   performed by invoking the output function of the source data type, and
   passing the result to the input function of the target data type.
  </para>

  <para>
   Un transtypage peut être appelé explicitement.
   Par exemple&nbsp;: <literal>CAST(<replaceable>x</replaceable> AS
   <replaceable>nomtype</replaceable>)</literal> ou
   <replaceable>x</replaceable><literal>::</literal><replaceable>nomtype</replaceable>.
  </para>

  <para>
   Si le transtypage est marqué <literal>AS ASSIGNMENT</literal> (NDT&nbsp;: à l'affectation),
   alors son appel peut être
   implicite lors de l'affectation d'une valeur à une colonne du
   type de donnée cible. Par exemple, en supposant que
   <literal>foo.f1</literal> soit une colonne de type <type>text</type>&nbsp;:
<programlisting>INSERT INTO foo (f1) VALUES (42);
</programlisting>
   est autorisé si la conversion du type <type>integer</type> vers le type
   <type>text</type> est indiquée <literal>AS ASSIGNMENT</literal>. Dans le cas contraire,
   c'est interdit. Le terme de <firstterm>transtypage d'affectation</firstterm>
   est utilisé pour décrire ce type de conversion.
  </para>

  <para>
   Si la conversion est marquée <literal>AS IMPLICIT</literal>, alors elle
   peut être appelée implicitement dans tout contexte, soit par une affectation
   soit en interne dans une expression (nous utilisons généralement le terme
   <firstterm>conversion implicite</firstterm> pour décrire ce type de
   conversion.)
   Par exemple, voici une requête&nbsp;:
<programlisting>
SELECT 2 + 4.0;
</programlisting>
   L'analyseur marque au début les constantes comme étant de type
   <type>integer</type> et <type>numeric</type> respectivement. Il n'existe pas
   d'opérateur <type>integer</type> <literal>+</literal> <type>numeric</type>
   dans les catalogues systèmes mais il existe un opérateur
   <type>numeric</type> <literal>+</literal> <type>numeric</type>. La requête
   sera un succès si une conversion de <type>integer</type> vers
   <type>numeric</type> est disponible et marquée <literal>AS IMPLICIT</literal>
   &mdash; ce qui est le cas. L'analyseur appliquera la conversion implicite
   et résoudra la requête comme si elle avait été écrite de cette façon&nbsp;:
<programlisting>
SELECT CAST ( 2 AS numeric ) + 4.0;
</programlisting>
  </para>

  <para>
   Maintenant, les catalogues fournissent aussi une conversion de
   <type>numeric</type> vers <type>integer</type>. Si cette conversion était
   marquée <literal>AS IMPLICIT</literal> &mdash; mais ce n'est pas le cas
   &mdash; alors l'analyseur devra choisir entre l'interprétation ci-dessus et
   son alternative (la conversion de la constante <type>numeric</type> en un
   <type>integer</type>) et appliquer l'opérateur <type>integer</type>
   <literal>+</literal> <type>integer</type>. Comme il n'a aucune information
   qui lui permettrait de choisir le meilleur moyen, il abandonne et déclare la
   requête comme étant ambigüe. Le fait qu'une seule des conversions est
   indiquée comme implicite est le moyen par lequel nous apprenons à l'analyseur
   de préférer la première solution (c'est-à-dire de transformer une expression
   <type>numeric</type>-and-<type>integer</type> en
   <type>numeric</type>)&nbsp;; il n'y a pas d'autre moyen.
  </para>

  <para>
   Il est conseillé d'être conservateur sur le marquage du caractère implicite 
   des transtypages. Une surabondance de transtypages implicites peut conduire
   <productname>PostgreSQL</productname> à interpréter étrangement des commandes,
   voire à se retrouver dans l'incapacité totale de les résoudre parce que plusieurs
   interprétations s'avèrent envisageables. Une bonne règle est de ne réaliser 
   des transtypages implicites que pour les transformations entre types de la
   même catégorie générale et qui préservent l'information. Par exemple,
   la conversion entre <type>int2</type> et <type>int4</type> peut être
   raisonnablement implicite mais celle entre <type>float8</type> et
   <type>int4</type> est probablement réservée à l'affectation. Les
   transtypages inter-catégories, tels que de <type>text</type> vers <type>int4</type>,
   sont préférablement exécutés dans le seul mode explicite.
  </para>

  <note>
   <para>
    Sometimes it is necessary for usability or standards-compliance reasons
    to provide multiple implicit casts among a set of types, resulting in
    ambiguity that cannot be avoided as above.  The parser has a fallback
    heuristic based on <firstterm>type categories</firstterm> and <firstterm>preferred
    types</firstterm> that can help to provide desired behavior in such cases.  See
    <xref linkend="sql-createtype" endterm="sql-createtype-title"/> for
    more information.
   </para>
  </note>

  <para>
   Pour créer un transtypage, il faut être propriétaire
   du type source ou destination. Seul le superutilisateur peut créer 
   un transtypage binairement compatible (une erreur sur un tel transtypage
   peut aisément engendrer un arrêt brutal du serveur).
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable>typesource</replaceable></term>

     <listitem>
      <para>
       Le nom du type de donnée source du transtypage.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>typecible</replaceable></term>

     <listitem>
      <para>
       Le nom du type de donnée cible du transtypage.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>    
     <term><replaceable>nomfonction</replaceable>
      (<replaceable>type_argument</replaceable>)</term>

     <listitem>
      <para>
       La fonction utilisée pour effectuer la conversion. Le nom de la fonction
       peut être qualifié du nom du schéma. Si ce n'est pas le cas, la
       fonction est recherchée dans le chemin des schémas. Le type de données
       résultant de la fonction doit correspondre au type cible du transtypage.
       Ses arguments sont explicités ci-dessous.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WITHOUT FUNCTION</literal></term>

     <listitem>
      <para>
       Indication d'une compatibilité binaire entre le type source et le type
       cible pour qu'aucune fonction ne soit requise pour effectuer la
       conversion.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WITH INOUT</literal></term>

     <listitem>
      <para>
       Indicates that the cast is an I/O conversion cast, performed by
       invoking the output function of the source data type, and passing the
       result to the input function of the target data type.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>AS ASSIGNMENT</literal></term>

     <listitem>
      <para>
       Lors d'une affectation, l'invocation du transtypage peut être implicite.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>AS IMPLICIT</literal></term>

     <listitem>
      <para>
       L'invocation du transtypage peut être implicite dans tout contexte.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  <para>
   Les fonctions de transtypage ont un à trois arguments. Le
   premier argument est du même type que le type source ou doit être compatible
   avec ce type. Le deuxième argument, si fourni,
   doit être de type <type>integer</type>. Il stocke le modificateur de type associé au type de
   destination, ou <literal>-1</literal> en l'absence de modificateur. Le troisième
   argument, si fourni,  doit être de type <type>boolean</type>. Il vaut
   <literal>true</literal> si la conversion est explicite, <literal>false</literal> dans le
   cas contraire. Bizarrement, le standard SQL appelle des comportements
   différents pour les transtypages explicites et implicites dans certains
   cas. Ce paramètre est fourni pour les fonctions qui implémentent
   de tel transtypages. Il n'est pas recommandé de concevoir des types de
   données utilisateur entrant dans ce cas de figure.
  </para>

  <para>
   The return type of a cast function must be identical to or
   binary-coercible to the cast's target type.
  </para>

  <para>
   En général, un transtypage correspond à des type source et destination
   différents. Cependant, il est permis de déclarer un transtypage entre 
   types source et destination identiques si la fonction de transtypage a
   plus d'un argument. Cette possibilité est utilisée pour représenter dans le
   catalogue système des fonctions de transtypage agissant sur la longueur d'un type.
   La fonction nommée est utilisée pour convertir la valeur d'un type à la valeur du
   modificateur de type fournie par le second argument.
  </para>

  <para>
   Quand un transtypage concerne des types source et destination différents
   et que la fonction a plus d'un argument, le transtypage 
   et la conversion de longeur du type destination sont
   faites en une seule etape. Quand une telle entrée n'est pas disponible, le
   transtypage vers un type qui utilise un modificateur de type implique deux
   étapes, une pour convertir les types de données et la seconde
   pour appliquer le modificateur.
  </para>
 
 </refsect1>

 <refsect1 id="sql-createcast-notes">
  <title>Notes</title>

  <para>
   <xref linkend="sql-dropcast" endterm="sql-dropcast-title"/> est utilisé pour
   supprimer les transtypages utilisateur.
  </para>

  <para>
   Pour convertir les types dans les deux sens, il est obligatoire de déclarer explicitement les deux sens.
  </para>

 <indexterm zone="sql-createcast">
  <primary>cast</primary>
  <secondary>conversion I/O</secondary>
 </indexterm>

  <para>
   Il est habituellement nécessaire de créer des conversions entre des types
   définis par l'utilisateur et des types de chaîne standards (<type>text</type>,
   <type>varchar</type> et<type>char(<replaceable>n</replaceable>)</type>), as well as user-defined types that
   are defined to be in the string category). 
   <productname>PostgreSQL</productname> provides automatic I/O conversion casts for that. The automatic casts to
   string types are treated as assignment casts, while the automatic casts
   from string types are
   explicit-only. Vous
   pouvez changer ce comportement en déclarant votre propre conversion
   pour rempalcer une conversion automatique mais, habituellement, la seule
   raison de le faire est si vous voulez que la conversion soit plus facilement
   appelable que la forme standard de conversion par affectation ou le
   paramètre pour ue conversion explicite seulement. Une autre raison possible
   est que vous voulez que la conversion se comporte différement de la fonction
   I/O du type&nbsp;; mais c'est suffisamment surprenant pour que vous y pensiez
   à deux fois avant de le faire. (Un petit nombre de types internes ont
   en fait des comportements différents pour les conversions, principalement
   à cause des besoins du standard SQL.)
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 7.3, toute fonction qui portait le même nom
   qu'un type de données, retournait ce type de données et prenait un argument
   d'un autre type était automatiquement détectée comme une fonction de
   conversion. Cette convention a été abandonnée du fait de l'introduction des schémas et pour
   pouvoir représenter des conversions binairement compatibles dans les
   catalogues système. Les fonctions de conversion intégrées suivent toujours
   le même schéma de nommage mais elle doivent également être présentées comme
   fonctions de transtypage dans le catalogue système <structname>pg_cast</structname>.
  </para>

  <para>
   Bien que cela ne soit pas requis, il est recommandé de
   suivre l'ancienne convention de nommage des fonctions de transtypage
   en fonction du type de données de destination. Beaucoup d'utilisateurs sont
   habitués à convertir des types de données à l'aide d'une notation 
   de style fonction, c'est-à-dire
   <replaceable>nom_type</replaceable>(<replaceable>x</replaceable>). En fait, cette
   notation n'est ni plus ni moins qu'un appel à la fonction d'implantation du transtypage&nbsp;;
   sa gestion n'est pas spécifique à un transtypage. Le non-respect de cette convention peut
   surprendre certains utilisateurs. Puisque
   <productname>PostgreSQL</productname> permet de surcharger un même nom de fonction avec
   différents types d'argument, il n'y a aucune difficulté à avoir plusieurs
   fonctions de conversion vers des types différents qui utilisent toutes le même
   nom de type destination.
  </para>

  <note>
   <para>
    En fait, le paragraphe précédent est une sur-simplification&nbsp;: il existe
    deux cas pour lesquels une construction d'appel de fonction sera traitée
    comme une demande de conversion sans qu'il y ait correspondance avec une
    fonction réelle. Si un appel de fonction
    <replaceable>nom</replaceable>(<replaceable>x</replaceable>) ne correspond
    pas exactement à une fonction existante, mais que
    <replaceable>nom</replaceable> est le nom d'un type de données et que
    <structname>pg_cast</structname> fournit une conversion compatible
    binairement vers ce type à partir du type <replaceable>x</replaceable>,
    alors l'appel sera construit à partir de la conversion compatible
    binairement. Cette exception est faite pour que les conversions compatibles
    binairement puissent être appelées en utilisant la syntaxe fonctionnelle,
    même si la fonction manque. De ce fait, s'il n'y pas d'entrée dans
    <structname>pg_cast</structname> mais que la conversion serait à partir de
    ou vers un type chapîne, l'appel sera réalisé avec une conversion I/O.
    Cette exception autorise l'appel de conversion I/O en utilisant la syntaxe
    fonctionnelle.
   </para>
  </note>
 </refsect1>


 <refsect1 id="sql-createcast-examples">
  <title>Exemples</title>

  <para>
   Création d'un transtypage d'affectation du type <type>bigint</type> vers le type
   <type>int4</type> à l'aide de la fonction
   <literal>int4(bigint)</literal>&nbsp;:
<programlisting>CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;
</programlisting>
   (Ce transtypage est déjà prédéfini dans le système.)
  </para>
 </refsect1>

 
 <refsect1 id="sql-createcast-compat">
  <title>Compatibilité</title>

  <para>
   La commande <command>CREATE CAST</command> est conforme à <acronym>SQL</acronym>
   à ceci près que SQL ne mentionne pas les types binairement compatibles et les arguments
   supplémentaires pour les fonctions d'implantation. <literal>AS IMPLICIT</literal>
   est aussi une extension <productname>PostgreSQL</productname>.
  </para>
 </refsect1>


 <refsect1 id="sql-createcast-seealso">
  <title>Voir aussi</title>

  <para>
   <xref linkend="sql-createfunction" endterm="sql-createfunction-title"/>,
   <xref linkend="sql-createtype" endterm="sql-createtype-title"/>,
   <xref linkend="sql-dropcast" endterm="sql-dropcast-title"/>
  </para>
 </refsect1>

</refentry>
