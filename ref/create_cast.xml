<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_cast.sgml,v 1.10 2005/09/15 07:03:26 guillaume Exp $ -->
<!-- SAS 20060616 -->

<refentry id="sql-createcast">
 <refmeta>
  <refentrytitle id="sql-createcast-title">CREATE CAST</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE CAST</refname>
  <refpurpose>Définir un transtypage</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE CAST (<replaceable>typesource</replaceable> AS <replaceable>typecible</replaceable>)
    WITH FUNCTION <replaceable>nomfonction</replaceable> (<replaceable>argtype</replaceable>)
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<replaceable>typesource</replaceable> AS <replaceable>typecible</replaceable>)
    WITHOUT FUNCTION
    [ AS ASSIGNMENT | AS IMPLICIT ]
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createcast-description">
  <title>Description</title>
  <indexterm zone="sql-createcast">
   <primary>CREATE CAST</primary>
  </indexterm>

  <para>
   <command>CREATE CAST</command> définit un transtypage. Un transtypage
   spécifie l'opération de conversion entre deux types de
   données. Par exemple&nbsp;:
<programlisting>SELECT CAST(42 AS float8);
</programlisting>
   convertit la constante entière 42 en <type>float8</type> en appelant
   une fonction précédemment définie, <literal>float8(int4)</literal> dans le cas
   présent (si aucun transtypage convenable n'a été défini, la conversion échoue).
  </para>

  <para>
   Deux types peuvent être <firstterm>binairement compatibles</firstterm>,
   ce qui signifie que la conversion d'un type en l'autre est
   <quote>gratuite</quote> et ne nécessite pas d'appel de fonction. Les
   valeurs correspondantes doivent pour cela utiliser la même représentation interne.
   Les types <type>text</type> et <type>varchar</type>, par exemple, sont binairement compatibles.
  </para>

  <para>
   Un transtypage peut être appelé explicitement.
   Par exemple&nbsp;: <literal>CAST(<replaceable>x</replaceable> AS
   <replaceable>nomtype</replaceable>)</literal> ou
   <replaceable>x</replaceable><literal>::</literal><replaceable>nomtype</replaceable>.
  </para>

  <para>
   Si le transtypage est marqué <literal>AS ASSIGNMENT</literal> (NDT&nbsp;: à l'affectation),
   alors son appel peut être
   implicite lors de l'affectation d'une valeur à une colonne du
   type de donnée cible. Par exemple, en supposant que
   <literal>foo.f1</literal> soit une colonne de type <type>text</type>&nbsp;:
<programlisting>INSERT INTO foo (f1) VALUES (42);
</programlisting>
   est autorisé si la conversion du type <type>integer</type> vers le type
   <type>text</type> est indiquée <literal>AS ASSIGNMENT</literal>. Dans le cas contraire,
   c'est interdit. Le terme de <firstterm>transtypage d'affectation</firstterm>
   est utilisé pour décrire ce type de conversion.
  </para>

  <para>
   If the cast is marked <literal>AS IMPLICIT</literal> then it can be invoked
   implicitly in any context, whether assignment or internally in an
   expression.  (We generally use the term <firstterm>implicit
   cast</firstterm> to describe this kind of cast.)
   For example, consider this query:
<programlisting>
SELECT 2 + 4.0;
</programlisting>
   The parser initially marks the constants as being of type <type>integer</type>
   and <type>numeric</type> respectively.  There is no <type>integer</type>
   <literal>+</literal> <type>numeric</type> operator in the system catalogs,
   but there is a <type>numeric</type> <literal>+</literal> <type>numeric</type> operator.
   The query will therefore succeed if a cast from <type>integer</type> to
   <type>numeric</type> is available and is marked <literal>AS IMPLICIT</literal> &mdash;
   which in fact it is.  The parser will apply the implicit cast and resolve
   the query as if it had been written
<programlisting>
SELECT CAST ( 2 AS numeric ) + 4.0;
</programlisting>
  </para>

  <para>
   Now, the catalogs also provide a cast from <type>numeric</type> to
   <type>integer</type>.  If that cast were marked <literal>AS IMPLICIT</literal> &mdash;
   which it is not &mdash; then the parser would be faced with choosing
   between the above interpretation and the alternative of casting the
   <type>numeric</type> constant to <type>integer</type> and applying the
   <type>integer</type> <literal>+</literal> <type>integer</type> operator.  Lacking any
   knowledge of which choice to prefer, it would give up and declare the
   query ambiguous.  The fact that only one of the two casts is
   implicit is the way in which we teach the parser to prefer resolution
   of a mixed <type>numeric</type>-and-<type>integer</type> expression as
   <type>numeric</type>; there is no built-in knowledge about that.
  </para>

  <para>
   Il est conseillé d'être conservateur sur le marquage du caractère implicite 
   des transtypages. Une surabondance de transtypages implicites peut conduire
   <productname>PostgreSQL</productname> à interpréter étrangement des commandes,
   voire à se retrouver dans l'incapacité totale de les résoudre parce que plusieurs
   interprétations s'avèrent envisageables. Une bonne règle est de ne réaliser 
   des transtypages implicites que pour les transformations entre types de la
   même catégorie générale et qui préservent l'information. Par exemple,
   la conversion entre <type>int2</type> et <type>int4</type> peut être
   raisonnablement implicite mais celle entre <type>float8</type> et
   <type>int4</type> est probablement réservée à l'affectation. Les
   transtypages inter-catégories, tels que de <type>text</type> vers <type>int4</type>,
   sont préférablement exécutés dans le seul mode explicite.
  </para>

  <para>
   Pour créer un transtypage, il faut être propriétaire
   du type source ou destination. Seul le superutilisateur peut créer 
   un transtypage binairement compatible (une erreur sur un tel transtypage
   peut aisément engendrer un arrêt brutal du serveur).
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><replaceable>typesource</replaceable></term>

     <listitem>
      <para>
       Le nom du type de donnée source du transtypage.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>typecible</replaceable></term>

     <listitem>
      <para>
       Le nom du type de donnée cible du transtypage.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>    
     <term><replaceable>nomfonction</replaceable>
      (<replaceable>type_argument</replaceable>)</term>

     <listitem>
      <para>
       La fonction utilisée pour effectuer la conversion. Le nom de la fonction
       peut être qualifié du nom du schéma. Si ce n'est pas le cas, la
       fonction est recherchée dans le chemin des schémas. Le type de données
       résultant de la fonction doit correspondre au type cible du transtypage.
       Ses arguments sont explicités ci-dessous.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WITHOUT FUNCTION</literal></term>

     <listitem>
      <para>
       Indication d'une compatibilité binaire des types source et cible. 
       Aucune fonction n'est ainsi requise pour effectuer la conversion.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>AS ASSIGNMENT</literal></term>

     <listitem>
      <para>
       Lors d'une affectation, l'invocation du transtypage peut être implicite.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>AS IMPLICIT</literal></term>

     <listitem>
      <para>
       L'invocation du transtypage peut être implicite dans tout contexte.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  <para>
   Les fonctions de transtypage ont un à trois arguments. Le
   premier argument est du même type que le type source. Le deuxième argument, si fourni,
   doit être de type <type>integer</type>. Il stocke le modificateur de type associé au type de
   destination, ou <literal>-1</literal> en l'absence de modificateur. Le troisième
   argument, si fourni,  doit être de type <type>boolean</type>. Il vaut
   <literal>true</literal> si la conversion est explicite, <literal>false</literal> dans le
   cas contraire. Bizarrement, les spécifications SQL appellent des comportements
   différents pour les transtypages explicites et implicites dans certains
   cas. Ce paramètre est fourni pour les fonctions qui implémentent
   de tel transtypages. Il n'est pas recommandé de concevoir des types de
   données utilisateur entrant dans ce cas de figure.
  </para>

  <para>
   En général, un transtypage correspond à des type source et destination
   différents. Cependant, il est permis de déclarer un transtypage entre 
   types source et destination identiques si la fonction de transtypage a
   plus d'un argument. Cette possibilité est utilisée pour représenter dans le
   catalogue système des fonctions de transtypage agissant sur la longueur d'un type.
   La fonction nommée est utilisée pour convertir la valeur d'un type à la valeur du
   modificateur de type fournie par le second argument.
  </para>

  <para>
   Quand un transtypage concerne des types source et destination différents
   et que la fonction a plus d'un argument, le transtypage 
   et la conversion de longeur du type destination sont
   faites en une seule etape. Quand une telle entrée n'est pas disponible, le
   transtypage vers un type qui utilise un modificateur de type implique deux
   étapes, une pour convertir les types de données et la seconde
   pour appliquer le modificateur.
  </para>
 
 </refsect1>

 <refsect1 id="sql-createcast-notes">
  <title>Notes</title>

  <para>
   <xref linkend="sql-dropcast" endterm="sql-dropcast-title"/> est utilisé pour
   supprimer les transtypages utilisateur.
  </para>

  <para>
   Pour convertir les types dans les deux sens, il est obligatoire de déclarer explicitement les deux sens.
  </para>

 <indexterm zone="sql-createcast">
  <primary>cast</primary>
  <secondary>conversion I/O</secondary>
 </indexterm>

  <para>
   It is normally not necessary to create casts between user-defined types
   and the standard string types (<type>text</type>, <type>varchar</type>, and
   <type>char(<replaceable>n</replaceable>)</type>).  <productname>PostgreSQL</productname> will
   automatically handle a cast to a string type by invoking the other
   type's output function, or conversely handle a cast from a string type
   by invoking the other type's input function.  These
   automatically-provided casts are known as <firstterm>I/O conversion
   casts</firstterm>.  I/O conversion casts to string types are treated as
   assignment casts, while I/O conversion casts from string types are
   explicit-only.  You can override this behavior by declaring your own
   cast to replace an I/O conversion cast, but usually the only reason to
   do so is if you want the conversion to be more easily invokable than the
   standard assignment-only or explicit-only setting.  Another possible
   reason is that you want the conversion to behave differently from the
   type's I/O function; but that is sufficiently surprising that you
   should think twice about whether it's a good idea.  (A small number of
   the built-in types do indeed have different behaviors for conversions,
   mostly because of requirements of the SQL standard.)
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 7.3, toute fonction qui portait le même nom
   qu'un type de données, retournait ce type de données et prenait un argument
   d'un autre type était automatiquement détectée comme une fonction de
   conversion. Cette convention a été abandonnée du fait de l'introduction des schémas et pour
   pouvoir représenter des conversions binairement compatibles dans les
   catalogues système. Les fonctions de conversion intégrées suivent toujours
   le même schéma de nommage mais elle doivent également être présentées comme
   fonctions de transtypage dans le catalogue système <structname>pg_cast</structname>.
  </para>

  <para>
   Bien que cela ne soit pas requis, il est recommandé de
   suivre l'ancienne convention de nommage des fonctions de transtypage
   en fonction du type de données de destination. Beaucoup d'utilisateurs sont
   habitués à convertir des types de données à l'aide d'une notation 
   de style fonction, c'est-à-dire
   <replaceable>nom_type</replaceable>(<replaceable>x</replaceable>). En fait, cette
   notation n'est ni plus ni moins qu'un appel à la fonction d'implantation du transtypage&nbsp;;
   sa gestion n'est pas spécifique à un transtypage. Le non-respect de cette convention peut
   surprendre certains utilisateurs. Puisque
   <productname>PostgreSQL</productname> permet de surcharger un même nom de fonction avec
   différents types d'argument, il n'y a aucune difficulté à avoir plusieurs
   fonctions de conversion vers des types différents qui utilisent toutes le même
   nom de type destination.
  </para>

  <note>
   <para>
    Actually the preceding paragraph is an oversimplification: there are
    two cases in which a function-call construct will be treated as a cast
    request without having matched it to an actual function.
    If a function call <replaceable>name</replaceable>(<replaceable>x</replaceable>) does not
    exactly match any existing function, but <replaceable>name</replaceable> is the name
    of a data type and <structname>pg_cast</structname> provides a binary-compatible cast
    to this type from the type of <replaceable>x</replaceable>, then the call will be
    construed as a binary-compatible cast.  This exception is made so that
    binary-compatible casts can be invoked using functional syntax, even
    though they lack any function.  Likewise, if there is no
    <structname>pg_cast</structname> entry but the cast would be to or from a string
    type, the call will be construed as an I/O conversion cast.  This
    exception allows I/O conversion casts to be invoked using functional
    syntax.
   </para>
  </note>
 </refsect1>


 <refsect1 id="sql-createcast-examples">
  <title>Exemples</title>

  <para>
   Création d'un transtypage du type <type>bigint</type> vers le type
   <type>int4</type> à l'aide de la fonction
   <literal>int4(bigint)</literal>&nbsp;:
<programlisting>CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint);
</programlisting>
   (Ce transtypage est déjà prédéfini dans le système.)
  </para>
 </refsect1>

 
 <refsect1 id="sql-createcast-compat">
  <title>Compatibilité</title>

  <para>
   La commande <command>CREATE CAST</command> est conforme à <acronym>SQL</acronym>
   à ceci près que SQL ne mentionne pas les types binairement compatibles et les arguments
   supplémentaires pour les fonctions d'implantation. <literal>AS IMPLICIT</literal>
   est aussi une extension <productname>PostgreSQL</productname>.
  </para>
 </refsect1>


 <refsect1 id="sql-createcast-seealso">
  <title>Voir aussi</title>

  <para>
   <xref linkend="sql-createfunction" endterm="sql-createfunction-title"/>,
   <xref linkend="sql-createtype" endterm="sql-createtype-title"/>,
   <xref linkend="sql-dropcast" endterm="sql-dropcast-title"/>
  </para>
 </refsect1>

</refentry>
