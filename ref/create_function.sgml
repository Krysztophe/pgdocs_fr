<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_function.sgml,v 1.9 2005/09/15 07:03:26 guillaume Exp $
-->

<refentry id="SQL-CREATEFUNCTION">
 <refmeta>
  <refentrytitle id="SQL-CREATEFUNCTION-TITLE">CREATE FUNCTION</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE FUNCTION</refname>
  <refpurpose>définit une nouvelle fonction</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createfunction">
  <primary>CREATE FUNCTION</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE [ OR REPLACE ] FUNCTION
    <replaceable class="parameter">nom</replaceable> ( [ [ <replaceable class="parameter">modearg</replaceable> ] [ <replaceable class="parameter">nomarg</replaceable> ] <replaceable class="parameter">typearg</replaceable> [, ...] ] )
    [ RETURNS <replaceable class="parameter">type_ret</replaceable> ]
  { LANGUAGE <replaceable class="parameter">nomlang</replaceable>
    | IMMUTABLE | STABLE | VOLATILE
    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
    | [EXTERNAL] SECURITY INVOKER | [EXTERNAL] SECURITY DEFINER
    | AS '<replaceable class="parameter">definition</replaceable>'
    | AS '<replaceable class="parameter">fichier_obj</replaceable>',
'<replaceable class="parameter">symbole_lien</replaceable>'
  } ...
    [ WITH ( <replaceable class="parameter">attribut</replaceable> [, ...] ) ]
</synopsis>
 </refsynopsisdiv>
  
 <refsect1 id="sql-createfunction-description">
  <title>Description</title>

  <para>
   <command>CREATE FUNCTION</command> définit une nouvelle fonction.
   <command>CREATE OR REPLACE FUNCTION</command> créera une nouvelle fonction
   ou remplacera une fonction existante.
  </para>

  <para>
   Si un nom de schéma est inclus, alors la fonction est créée dans le schéma
   spécifié. Sinon, elle est créée dans le schéma courant. Le nom de la nouvelle
   fonction ne doit pas correspondre à une autre fonction existante avec les
   mêmes types d'argument dans le même schéma. Néanmoins, les fonctions de types
   d'arguments différents pourraient partager un nom (ceci est appelé le
   <firstterm>surchargement</>).
  </para>

  <para>
   Pour mettre à jour la définition d'une fonction existante, utilisez
   <command>CREATE OR REPLACE FUNCTION</command>. Il n'est pas possible de
   changer le nom ou les types d'argument d'une fonction de cette façon (si vous
   avez essayé, vous devrez seulement créer une nouvelle fonction distincte). De
   même, <command>CREATE OR REPLACE FUNCTION</command> ne vous laissera pas
   modifier le type en retour d'une fonction existante. Pour cela, vous devez
   supprimer et recréer la fonction. (Lors de l'utilisation de paramètres
   <literal>OUT</>, cela signifie que vous ne pouvez pas changer le nom ou le
   type de tout paramètre <literal>OUT</> sauf en cas de suppression de la
   fonction.)
  </para>

  <para>
   Si vous supprimez, puis recréez une fonction, la nouvelle fonction n'est pas
   la même entité que l'ancienne&nbsp;; vous devrez supprimer les règles, vues,
   déclencheurs, etc. qui référençaient l'ancienne fonction. Utilisez
   <command>CREATE OR REPLACE FUNCTION</command> pour modifier la définition
   d'une fonction sans casser d'objets qui se réfèrent à la fonction.
  </para>

  <para>
   L'utilisateur qui crée la fonction devient le propriétaire de la fonction.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

   <variablelist>

    <varlistentry>
     <term><replaceable class="parameter">nom</replaceable></term>

     <listitem>
      <para>
       Le nom de la fonction à créer (pouvant être qualifié du nom du schéma).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">modearg</replaceable></term>

     <listitem>
      <para>
       Le mode d'un argument&nbsp;: soit <literal>IN</>, soit <literal>OUT</>,
       soit <literal>INOUT</>. En cas d'omission, la valeur par défaut est
       <literal>IN</>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nomarg</replaceable></term>

     <listitem>
      <para>
       Le nom d'un argument. Quelques langages (actuellement seulement
       PL/pgSQL) vous laissent utiliser le nom dans le corps de la fonction.
       Pour les autres langages, le nom d'un argument en entrée est une
       documentation supplémentaire car il définit le nom de la colonne dans
       le type de ligne résultat. (Si vous omettez le nom d'un argument en
       sortie, le système choisira un nom de colonne par défaut.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argtype</replaceable></term>

     <listitem>
      <para>
       Le(s) type(s) de données des arguments de la fonction (pouvant être
       qualifié par le nom du schéma), s'il y en a. Les types des arguments
       peuvent être de base, composite ou de domaines, ou pourraient aussi
       référencer le type d'une colonne.
      </para>
      <para>
       Suivant le langage d'implémentation, il pourrait aussi être autorisé de
       spécifier des <quote>pseudotypes</> plutôt que des <type>cstring</>. Les
       pseudotypes indiquent que le type d'argument réel est soit non
       complètement spécifié, soit en dehors de l'ensemble des types de données
       ordinaires SQL.
      </para>
      <para>
       Le type d'une colonne est utilisé en écrivant <literal><replaceable
       class="parameter">nomtable</replaceable>.<replaceable
       class="parameter">nomcolonne</replaceable>%TYPE</literal>. Utiliser
       cette fonctionnalité peut quelque fois aider à rendre une fonction
       dépendante des modifications de la définition d'une table.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">type_ret</replaceable></term>

     <listitem>
      <para>
       Le type de données en retour (pouvant être qualifié du nom du schéma).
       Le type de retour pourrait être un type de base, complexe ou un domaine,
       ou pourrait être spécifié pour référencer le type d'une colonne
       existante. Suivant le langage d'implémentation, il pourrait aussi être
       autorisé de spécifier un <quote>pseudotype</> tel que <type>cstring</>.
      </para>
      <para>
       Quand il y a des paramètres <literal>OUT</> ou <literal>INOUT</>, la
       clause <literal>RETURNS</> peut être omise. Si elle est présente, elle
       doit correspondre au type de résultat fourni par les paramètres en
       sortie&nbsp;: <literal>RECORD</> s'il y a plusieurs paramètres en sortie,
       ou le type du seul paramètre en sortie.
      </para>
      <para>
       Le modificateur <literal>SETOF</literal> indique que la fonction renverra
       un ensemble d'éléments plutôt qu'un seul élément.
      </para>
      <para>
       Le type d'une colonne est référencé en écrivant <literal><replaceable
       class="parameter">nomtable</replaceable>.<replaceable
       class="parameter">nomcolonne</replaceable>%TYPE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nomlang</replaceable></term>

     <listitem>
      <para>
       Le nom du langage dans laquelle la fonction est implémentée. Pourrait
       être <literal>SQL</literal>, <literal>C</literal>,
       <literal>internal</literal> ou le nom d'un langage de procédures défini
       par l'utilisateur. Pour une compatibilité descendante, le
       nom peut être englobé avec des guillemets simples.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>IMMUTABLE</literal></term>
     <term><literal>STABLE</literal></term>
     <term><literal>VOLATILE</literal></term>

     <listitem>
      <para>
       Ces attributs informent le système s'il est sain de remplacer plusieurs
       évaluations de la fonction avec une seule évaluation pour une
       optimisation en exécution. Au plus un choix devra être donné. Si aucun
       n'apparaît, <literal>VOLATILE</literal> est la valeur par défaut.
      </para>

      <para>
       <literal>IMMUTABLE</literal> indique que la fonction renvoie toujours le
       même résultat si elle reçoit les mêmes valeurs en argument&nbsp;;
       c'est-à-dire qu'elle n'effectue pas de recherches dans la base de données
       ou, autrement, qu'elle utilise l'information non présente directement
       dans la liste d'arguments. Si cette option est donnée, tout appel de la
       fonction avec des arguments constants peut être immédiatement remplacé
       par la valeur de la fonction.
      </para>

      <para>
       <literal>STABLE</literal> indique qu'à l'intérieur d'un seul parcours de
       la table, la fonction renverra le même résultat pour les mêmes valeurs
       d'argument, mais son résultat pourrait varier au travers des
       instructions SQL. Ceci est la sélection appropriée pour les fonctions
       dont les résultats dépendent des recherches en base de données, des
       variables paramètres (tel que la zone horaire en cours), etc. Notez aussi
       que la famille de fonctions <function>current_timestamp</> est qualifiée
       de stable car leur valeur ne change pas à l'intérieur d'une transaction.
      </para>

      <para>
       <literal>VOLATILE</literal> indique que la valeur de la fonction peut
       changer même avec un seul parcours de table, donc aucune optimisation ne
       peut être réalisée. Relativement peu de fonctions de bases de données
       sont volatiles dans ce sens&nbsp;; quelques exemples sont
       <literal>random()</>, <literal>currval()</>, <literal>timeofday()</>.
       Notez que toute fonction qui a des effets de bord doit être classée
       comme volatile, même si son résultat est assez prévisible pour empêcher
       l'optimisation des appels&nbsp;; un exemple est <literal>setval()</>.
      </para>

      <para>
       Pour des détails supplémenaires, voir <xref linkend="xfunc-volatility">.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CALLED ON NULL INPUT</literal></term>
     <term><literal>RETURNS NULL ON NULL INPUT</literal></term>
     <term><literal>STRICT</literal></term>

     <listitem>
      <para>
       <literal>CALLED ON NULL INPUT</literal> (la valeur par défaut) indique
       que la fonction sera appelée normalement quand certains de ses arguments
       sont NULL. C'est alors de la responsabilité de l'auteur de la fonction de
       vérifier les valeurs NULL si nécessaire et de répondre en conséquence.
      </para>

      <para>
       <literal>RETURNS NULL ON NULL INPUT</literal> ou
       <literal>STRICT</literal> indiquent que la fonction renvoie toujours
       NULL si un de ces arguments est NULL. Si ce paramètre est spécifié, la
       fonction n'est pas exécutée quand il y a des arguments NULL&nbsp;; à la
       place, un résultat NULL est automatiquement renvoyé.
      </para>
     </listitem>
    </varlistentry>

   <varlistentry>
    <term><literal><optional>EXTERNAL</optional> SECURITY INVOKER</literal></term>
    <term><literal><optional>EXTERNAL</optional> SECURITY DEFINER</literal></term>

    <listitem>
     <para>
      <literal>SECURITY INVOKER</literal> indique que la fonction doit être
      exécutée avec les droits de l'utilisateur qui l'appelle. C'est la valeur
      par défaut. <literal>SECURITY DEFINER</literal> spécifie que la fonction
      doit être exécutée avec les droits de l'utilisateur qui l'a créé.
     </para>

     <para>
      Le mot clé <literal>EXTERNAL</literal> est autorisé pour la conformité SQL
      mais il est optionnel car, contrairement à SQL, cette fonctionnalité
      s'applique à toutes les fonctions, pas seulement les externes.
     </para>
    </listitem>
   </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">definition</replaceable></term>

     <listitem>
      <para>
       Une constante de type chaîne définissant la fonction&nbsp;; la
       signification dépend du
       langage. Cela pourrait être un nom de fonction interne, le chemin vers un
       fichier objet, une commande SQL ou un texte dans un langage de
       procédures.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><replaceable
	class="parameter">fichier_obj</replaceable>, <replaceable
	class="parameter">symbole_lien</replaceable></literal></term>

     <listitem>
      <para>
       Cette forme de clause <literal>AS</literal> est utilisée pour les
       fonctions en langage C chargeables dynamiquement quand le nom de la
       fonction dans le code source C n'est pas le même que celui de la fonction
       C. La chaîne <replaceable class="parameter">fichier_obj</replaceable> est
       le nom du fichier contenant l'objet chargeable dynamiquement et
       <replaceable class="parameter">symbole_lien</replaceable> est le symbole
       de lien de la fonction, c'est-à-dire le nom de la fonction dans le code
       source C. Si ce lien est omis, il est supposé être le même que le nom de
       la fonction en cours de définition.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">attribut</replaceable></term>

     <listitem>
      <para>
       La façon historique de spécifier les morceaux optionnels d'informations
       sur la fonction. Les attributs suivants pourraient apparaître ici&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>isStrict</></term>
        <listitem>
         <para>
          Équivalent à <literal>STRICT</literal> ou <literal>RETURNS NULL ON
          NULL INPUT</literal>
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>isCachable</></term>
        <listitem>
         <para>
          <literal>isCachable</literal> est un équivalent obsolète de
          <literal>IMMUTABLE</literal>&nbsp;; il est toujours accepté pour des
          raisons de compatibilité ascendante.
         </para>
        </listitem>
       </varlistentry>

      </variablelist>

      Les noms d'attribut ne sont pas sensibles à la casse.
     </para>
    </listitem>
   </varlistentry>

   </variablelist>

 </refsect1>

 <refsect1 id="sql-createfunction-notes">
  <title>Notes</title>

   <para>
    Référez-vous à <xref linkend="xfunc"> pour plus d'informations sur
    l'écriture de fonctions.
   </para>

   <para>
    La syntaxe complète de type <acronym>SQL</acronym> est autorisée pour les
    arguments en entrée et pour la valeur de sortie. Néanmoins, quelques détails
    de spécification de type (c'est-à-dire le champ précision pour le type
    <type>numeric</type>) sont de la responsabilité de l'implémentation de la
    fonction sous-jacente et sont silencieusement avalés (c'est-à-dire non
    reconnus ou forcés) par la commande <command>CREATE FUNCTION</command>.
   </para>

   <para>
    <productname>PostgreSQL</productname> autorise le
    <firstterm>surchargement</firstterm> de fonctions&nbsp;; c'est-à-dire que
    le même nom peut être utilisé pour plusieurs fonctions différentes si tant
    est qu'elles ont des types d'arguments distincts. Néanmoins, les noms C de
    toutes les fonctions doivent être différents, donc vous devez donner des
    noms différentes aux fonctions C suchargées (par exemple, utilisez les
    types d'argument comme morceaux des noms des fonctions C).
   </para>

   <para>
    Deux fonctions sont considérées identiques si elles partagent le même nom
    et les mêmes types d'argument en <emphasis>input</>, ignorant tous les
    paramètres <literal>OUT</>. Du coup, ces déclarations sont en conflit&nbsp;:
<programlisting>
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, out text) ...
</programlisting>
   </para>

   <para>
    Lors d'appels répétés à <command>CREATE FUNCTION</command> et se référant
    au même fichier objet, le fichier est chargé une seule fois. Pour décharger
    et recharger le fichier (peut-être pendant le développement), utilisez la
    commande <xref linkend="sql-load" endterm="sql-load-title">.
   </para>

   <para>
    Utilisez <xref linkend="sql-dropfunction" endterm="sql-dropfunction-title">
    pour supprimer les fonctions définies par l'utilisateur.
   </para>

  <para>
    Il est souvent utile d'utiliser les guillemets dollar (voir <xref
    linkend="sql-syntax-dollar-quoting">) pour écrire la chaîne de définition
    d'une fonction, plutôt que la syntaxe habituelle à guillemets simples. Sans
    guillemets dollar, tout guillemet simple et tout antislash devrait être
    échappé en les doublant dans la définition de la fonction.
  </para>

   <para>
    Pour être capable de définir une fonction, l'utilisateur doit avoir le droit
    <literal>USAGE</literal> sur le langage.
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-examples">
  <title>Exemples</title>

  <para>
   Voici quelques exemples triviaux pour vous aider à commencer. Pour plus
   d'informations et d'exemples, voir <xref linkend="xfunc">.
<programlisting>
CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
</programlisting>
  </para>
 
   <para>
   Incrémenter un entier, en utilisant le nom de l'argument, dans
   <application>PL/pgSQL</application>&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
</programlisting>
  </para>

  <para>
   Renvoyer un enregistrement contenant plusieurs paramètres en sortie&nbsp;:
<programlisting>
CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   Vous pouvez faire la même chose en plus verbeux avec un type composite
   nommé explicitement&nbsp;:
<programlisting>
CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
  </para>
</refsect1>

 
 <refsect1 id="sql-createfunction-compat">
  <title>Compatibilité</title>

  <para>
   Une commande <command>CREATE FUNCTION</command> est définie en SQL:1999 et
   ultérieur. La version <productname>PostgreSQL</productname> est similaire
   mais pas entièrement compatible. Les attributs ne sont pas portables, pas
   plus que les différents langages disponibles.
  </para>

  <para>
   Pour la compatibilité avec les autres systèmes de bases de données, 
   <replaceable class="parameter">modearg</replaceable> peut être écrit soit
   avant soit après <replaceable class="parameter">nomarg</replaceable>. Mais
   seule la première façon est compatible avec le standard.
  </para>
 </refsect1>


 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterfunction"
    endterm="sql-alterfunction-title"></member>
   <member><xref linkend="sql-dropfunction"
    endterm="sql-dropfunction-title"></member>
   <member><xref linkend="sql-grant" endterm="sql-grant-title"></member>
   <member><xref linkend="sql-load" endterm="sql-load-title"></member>
   <member><xref linkend="sql-revoke" endterm="sql-revoke-title"></member>
   <member><xref linkend="app-createlang"
    endterm="app-createlang-title"></member>
  </simplelist>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->