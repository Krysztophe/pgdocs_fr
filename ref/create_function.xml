<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20070906 : PG823 -->

<refentry id="sql-createfunction">
 <refmeta>
  <refentrytitle id="sql-createfunction-title">CREATE FUNCTION</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE FUNCTION</refname>
  <refpurpose>Définir une nouvelle fonction</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ OR REPLACE ] FUNCTION
    <replaceable class="parameter">nom</replaceable> ( [ [ <replaceable class="parameter">modearg</replaceable> ] [ <replaceable class="parameter">nomarg</replaceable> ] <replaceable class="parameter">typearg</replaceable>  [ { DEFAULT | = } <replaceable class="parameter">defexpr</replaceable> ] [, ...] ] ) ] )
    [ RETURNS <replaceable class="parameter">type_ret</replaceable>
      | RETURNS TABLE ( <replaceable class="parameter">nom_colonne</replaceable> <replaceable class="parameter">type_colonne</replaceable> [, ...] ) ]
  { LANGUAGE <replaceable class="parameter">nomlang</replaceable>
    | WINDOW
    | IMMUTABLE | STABLE | VOLATILE
    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
    | [EXTERNAL] SECURITY INVOKER | [EXTERNAL] SECURITY DEFINER
    | COST <replaceable class="parameter">cout_execution</replaceable>
    | ROWS <replaceable class="parameter">nb_lignes_resultat</replaceable>
    | SET <replaceable class="parameter">parametre</replaceable> { TO <replaceable class="parameter">value</replaceable> | = <replaceable class="parameter">value</replaceable> | FROM CURRENT }
    | AS '<replaceable class="parameter">definition</replaceable>'
    | AS '<replaceable class="parameter">fichier_obj</replaceable>', '<replaceable class="parameter">symbole_lien</replaceable>'
  } ...
    [ WITH ( <replaceable class="parameter">attribut</replaceable> [, ...] ) ]
</synopsis>
 </refsynopsisdiv>
  
 <refsect1 id="sql-createfunction-description">
  <title>Description</title>
  <indexterm zone="sql-createfunction">
   <primary>CREATE FUNCTION</primary>
  </indexterm>

  <para>
   <command>CREATE FUNCTION</command> définit une nouvelle fonction.
   <command>CREATE OR REPLACE FUNCTION</command> crée une nouvelle fonction
   ou la remplace si elle existe déjà.
  </para>

  <para>
   Si un nom de schéma est précisé, la fonction est créée dans le schéma
   indiqué. Sinon, elle est créée dans le schéma courant. Le nom de la nouvelle
   fonction ne peut pas correspondre à celui d'une fonction existant avec les
   mêmes types d'arguments en entrée dans le même schéma. Toutefois, les fonctions de types
   d'arguments différents peuvent partager le même nom (ceci est appelé
   <firstterm>surcharge</firstterm>).
  </para>

  <para>
   Pour remplacer la définition actuelle d'une fonction existante, 
   <command>CREATE OR REPLACE FUNCTION</command> est utilisé. Il n'est pas possible de
   changer le nom ou les types d'argument d'une fonction de cette façon 
   (cela crée une nouvelle fonction distincte). De
   même, <command>CREATE OR REPLACE FUNCTION</command> ne permet pas
   de modifier le type retour d'une fonction existante. Pour cela, il est nécessaire
   de supprimer et de recréer la fonction. (Lors de l'utilisation de paramètres
   <literal>OUT</literal>, cela signifie que le nom ou le
   type d'un paramètre <literal>OUT</literal> ne peut être modifié que par 
   la suppression de la fonction.)
  </para>

  <para>
   En cas de suppression et de recréaction d'une fonction, la nouvelle fonction n'est pas
   la même entité que l'ancienne&nbsp;; il faut supprimer les règles, vues,
   déclencheurs, etc. qui référencent l'ancienne fonction. 
   <command>CREATE OR REPLACE FUNCTION</command> permet de modifier la définition
   d'une fonction sans casser les objets qui s'y réfèrent.
   De plus, <command>ALTER FUNCTION</command> peut être utilisé pour modifier la
   plupart des propriétés supplémentaires d'une fonction existante.
  </para>

  <para>
   L'utilisateur qui crée la fonction en devient le propriétaire.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

   <variablelist>

    <varlistentry>
     <term><replaceable class="parameter">nom</replaceable></term>

     <listitem>
      <para>
       Le nom de la fonction à créer (éventuellement qualifié du nom du schéma).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">modearg</replaceable></term>

     <listitem>
      <para>
       Le mode d'un argument&nbsp;: <literal>IN</literal>,
       <literal>OUT</literal>, <literal>INOUT</literal> ou
       <literal>VARIADIC</literal>. En cas d'omission, la valeur par défaut est
       <literal>IN</literal>.
       Seuls des arguments <literal>OUT</literal> peuvent suivre un argument
       <literal>VARIADIC</literal>.
       Par ailleurs, des arguments <literal>OUT</literal> et <literal>INOUT</literal> ne peuvent
       pas être utilisés en même temps que la notation <literal>RETURNS TABLE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nomarg</replaceable></term>

     <listitem>
      <para>
       Le nom d'un argument. Quelques langages (seul
       PL/pgSQL, en réalité) permettent d'utiliser ce nom dans le corps de la fonction.
       Pour les autres langages, le nom d'un argument en entrée est 
       purement documentaire. En revanche, le nom d'un argument en sortie
       a une utilité car il définit le nom de la colonne dans la ligne résultat.
       (En cas d'omission du nom d'un argument en
       sortie, le système choisit un nom de colonne par défaut.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argtype</replaceable></term>

     <listitem>
      <para>
       Le(s) type(s) de données des arguments de la fonction (éventuellement
       qualifié du nom du schéma), s'il y en a. Les types des arguments
       peuvent être basiques, composites ou de domaines, ou 
       faire référence au type d'une colonne.
      </para>
      <para>
       En fonction du langage, il est possible d'indiquer
       des <quote>pseudotypes</quote>, tel que <type>cstring</type>. Les
       pseudotypes indiquent que le type d'argument réel est soit non
       complètement spécifié, soit en dehors de l'ensemble des types de données
       ordinaires du SQL.
      </para>
      <para>
       Il est fait référence au type d'une colonne par
       <literal><replaceable class="parameter">nomtable</replaceable>.<replaceable class="parameter">nomcolonne</replaceable>%TYPE</literal>. 
       Cette fonctionnalité peut servir à rendre une fonction
       indépendante des modifications de la définition d'une table.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">defexpr</replaceable></term>

     <listitem>
      <para>
       Une expression à utiliser en tant que valeur par défaut si le
       paramètre n'est pas spécifié. L'expression doit pouvoir être coercible
       dans le type d'argument du paramètre.
       Seuls les paramètres d'entrée (dont les <literal>INOUT</literal>) peuvent
       avoir une valeur par défaut. Tous les paramètres d'entrée suivant un
       paramètre avec une valeur par défaut doivent aussi avoir une valeur par
       défaut.
   </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">type_ret</replaceable></term>

     <listitem>
      <para>
       Le type de données en retour (éventuellement qualifié du nom du schéma).
       Le type de retour peut être un type basique, composite ou de domaine,
       ou faire référence au type d'une colonne
       existante. En fonction du langage, il est possible d'indiquer
       un <quote>pseudotype</quote>, tel que <type>cstring</type>.
       Si la fonction ne doit pas renvoyer de valeur, on indique
       <type>void</type> comme type de retour.
      </para>
      <para>
       Quand il y a des paramètres <literal>OUT</literal> ou <literal>INOUT</literal>, la
       clause <literal>RETURNS</literal> peut être omise. Si elle est présente, elle
       doit correspondre au type de résultat imposé par les paramètres de
       sortie&nbsp;: <literal>RECORD</literal> s'il y en a plusieurs,
       ou le type du seul paramètre en sortie.
      </para>
      <para>
       Le modificateur <literal>SETOF</literal> indique que la fonction retourne
       un ensemble d'éléments plutôt qu'un seul.
      </para>
      <para>
       Il est fait référence au type d'une colonne par 
       <literal><replaceable class="parameter">nomtable</replaceable>.<replaceable class="parameter">nomcolonne</replaceable>%TYPE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nom_colonne</replaceable></term>

     <listitem>
      <para>
       Le nom d'une colonne de sortie dans la syntaxe <literal>RETURNS TABLE</literal>.
       C'est une autre façon de déclarer un paramètre OUT nommé, à la différence près
       que <literal>RETURNS TABLE</literal> implique aussi <literal>RETURNS SETOF</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">type_colonne</replaceable></term>

     <listitem>
      <para>
       Le type de données d'une colonne de sortie dans la syntaxe
       <literal>RETURNS TABLE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nomlang</replaceable></term>

     <listitem>
      <para>
       Le nom du langage d'écriture de la fonction. Peut
       être <literal>SQL</literal>, <literal>C</literal>,
       <literal>internal</literal> ou le nom d'un langage procédural
       utilisateur. Pour des raisons de compatibilité descendante, le
       nom peut être écrit entre guillemets simples.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WINDOW</literal></term>

     <listitem>
      <para>
       <literal>WINDOW</literal> indique que la fonction est une 
       <firstterm>fonction window</firstterm> plutôt qu'une fonction simple.
       Ceci n'est à l'heure actuelle utilisable que pour les fonctions écrites
       en C. L'attribut <literal>WINDOW</literal> ne peut pas être changé lors
       du remplacement d'une définition de fonction existante.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>IMMUTABLE</literal></term>
     <term><literal>STABLE</literal></term>
     <term><literal>VOLATILE</literal></term>

     <listitem>
      <para>
       Ces attributs informent l'optimiseur de requêtes sur le comportement
       de la fonction. Un seul choix est possible. En son absence,
       <literal>VOLATILE</literal> est utilisé.
      </para>

      <para>
       <literal>IMMUTABLE</literal> indique que la fonction ne peut pas modifier
       la base de données et qu'à arguments constants, la fonction renvoie
       toujours le même résultat&nbsp;;
       c'est-à-dire qu'elle n'effectue pas de recherches dans la base de données,
       ou alors qu'elle utilise des informations non directement présentes
       dans la liste d'arguments. Si cette option est précisée, tout appel de la
       fonction avec des arguments constants peut être immédiatement remplacé
       par la valeur de la fonction.
      </para>

      <para>
       <literal>STABLE</literal> indique que la fonction ne peut pas modifier
       la base de données et qu'à l'intérieur d'un seul parcours de
       la table, à arguments constants, la fonction retourne le même résultat,
       mais celui-ci varie en fonction des instructions SQL.
       Cette option est appropriée pour les fonctions
       dont les résultats dépendent des recherches en base, des
       variables de paramètres (tel que la zone horaire courante), etc. La 
       famille de fonctions <function>current_timestamp</function> est qualifiée
       de stable car les valeurs de ces fonctions ne changent pas à l'intérieur d'une transaction.
      </para>

      <para>
       <literal>VOLATILE</literal> indique que la valeur de la fonction peut
       changer même au cours d'un seul parcours de table. Aucune optimisation ne
       peut donc être réalisée. Relativement peu de fonctions de bases de données
       sont volatiles dans ce sens&nbsp;; quelques exemples sont
       <literal>random()</literal>, <literal>currval()</literal>, <literal>timeofday()</literal>.
       Toute fonction qui a des effets de bord doit être classée
       volatile, même si son résultat est assez prévisible. Cela afin d'éviter
       l'optimisation des appels&nbsp;; <literal>setval()</literal> en est un exemple.
      </para>

      <para>
       Pour des détails complémentaires, voir <xref linkend="xfunc-volatility"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CALLED ON NULL INPUT</literal></term>
     <term><literal>RETURNS NULL ON NULL INPUT</literal></term>
     <term><literal>STRICT</literal></term>

     <listitem>
      <para>
       <literal>CALLED ON NULL INPUT</literal> (la valeur par défaut) indique
       que la fonction est appelée normalement si certains de ses arguments
       sont NULL. C'est alors de la responsabilité de l'auteur de la fonction de
       gérer les valeurs NULL.
      </para>

      <para>
       <literal>RETURNS NULL ON NULL INPUT</literal> ou
       <literal>STRICT</literal> indiquent que la fonction renvoie toujours
       NULL si l'un de ses arguments est NULL. Lorsque ce paramètre est utilisé 
       et qu'un des arguments est NULL, la fonction n'est pas exécutée, mais un résultat NULL
       est automatiquement retourné.
      </para>
     </listitem>
    </varlistentry>

   <varlistentry>
    <term><literal><optional>EXTERNAL</optional> SECURITY INVOKER</literal></term>
    <term><literal><optional>EXTERNAL</optional> SECURITY DEFINER</literal></term>

    <listitem>
     <para>
      <literal>SECURITY INVOKER</literal> indique que la fonction est
      exécutée avec les droits de l'utilisateur qui l'appelle. C'est la valeur
      par défaut. <literal>SECURITY DEFINER</literal> spécifie que la fonction
      est exécutée avec les droits de l'utilisateur qui l'a créé.
     </para>

     <para>
      Le mot clé <literal>EXTERNAL</literal> est autorisé pour la conformité SQL
      mais il est optionnel car, contrairement à SQL, cette fonctionnalité
      s'applique à toutes les fonctions, pas seulement celles externes.
     </para>
    </listitem>
   </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">cout_execution</replaceable></term>

     <listitem>
      <para>
       Un nombre positif donnant le coût estimé pour l'exécution de la fonction
       en unité de <xref linkend="guc-cpu-operator-cost"/>. Si la fonction
       renvoie plusieurs lignes, il s'agit d'un coût par ligne renvoyée. Si le
       coût n'est pas spécifié, une unité est supposée pour les fonctions en
       langage C et les fonctions internes. Ce coût est de 100 unités pour les
       fonctions dans tout autre langage. Des valeurs plus importantes feront
       que le planificateur tentera d'éviter l'évaluation de la fonction
       aussi souvent que possible.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nb_lignes_resultat</replaceable></term>

     <listitem>
      <para>
       Un nombre positif donnant le nombre estimé de lignes que la fonction
       renvoie, information utile au planificateur. Ceci est seulement
       autorisé pour les fonctions qui renvoient plusieurs lignes (fonctions
       SRF). La valeur par défaut est de 1000 lignes.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>parametre</replaceable></term>
     <term><replaceable>valeur</replaceable></term>
     <listitem>
      <para>
       La clause <literal>SET</literal> fait que le paramètre de configuration
       indiquée est initialisée avec la valeur précisée au lancement de la
       fonction, puis restaurée à sa valeur d'origine lors de la sortie de la
       fonction. <literal>SET FROM CURRENT</literal> utilise la valeur actuelle
       de la session comme valeur à appliquer au lancement de la fonction.
      </para>

      <para>
       Voir <xref linkend="sql-set" endterm="sql-set-title"/> et
       <xref linkend="runtime-config"/> pour plus d'informations sur les
       paramètres et valeurs autorisés.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">definition</replaceable></term>

     <listitem>
      <para>
       Une constante de type chaîne définissant la fonction&nbsp;; la
       signification dépend du langage. Cela peut être un nom de fonction
       interne, le chemin vers un
       fichier objet, une commande SQL ou du texte en langage procédural.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><replaceable class="parameter">fichier_obj</replaceable>, <replaceable class="parameter">symbole_lien</replaceable></literal></term>

     <listitem>
      <para>
       Cette forme de clause <literal>AS</literal> est utilisée pour les
       fonctions en langage C chargeables dynamiquement lorsque le nom de la
       fonction dans le code source C n'est pas le même que celui de la fonction
       SQL. La chaîne <replaceable class="parameter">fichier_obj</replaceable> est
       le nom du fichier contenant l'objet chargeable dynamiquement et
       <replaceable class="parameter">symbole_lien</replaceable> est le symbole
       de lien de la fonction, c'est-à-dire le nom de la fonction dans le code
       source C. Si ce lien est omis, il est supposé être le même que le nom de
       la fonction SQL définie.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">attribut</replaceable></term>

     <listitem>
      <para>
       Façon historique d'indiquer des informations optionnelles
       concernant la fonction. Les attributs suivants peuvent apparaître ici&nbsp;:

      <variablelist>
       <varlistentry>
        <term><literal>isStrict</literal></term>
        <listitem>
         <para>
          Équivalent à <literal>STRICT</literal> ou <literal>RETURNS NULL ON
          NULL INPUT</literal>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>isCachable</literal></term>
        <listitem>
         <para>
          <literal>isCachable</literal> est un équivalent obsolète de
          <literal>IMMUTABLE</literal>&nbsp;; il est toujours accepté pour des
          raisons de compatibilité ascendante.
         </para>
        </listitem>
       </varlistentry>

      </variablelist>

      Les noms d'attribut sont insensibles à la casse.
     </para>
    </listitem>
   </varlistentry>

   </variablelist>

 </refsect1>

 <refsect1 id="sql-createfunction-notes">
  <title>Notes</title>

   <para>
    La lecture de <xref linkend="xfunc"/> fournit des informations 
    supplémentaires sur l'écriture de fonctions.
   </para>

   <para>
    Toute la syntaxe des types <acronym>SQL</acronym> est autorisée pour les
    arguments en entrée et la valeur de sortie. Néanmoins, quelques détails
    de spécification de type (le champ précision pour le type
    <type>numeric</type>, par exemple) sont de la responsabilité de l'implantation de la
    fonction sous-jacente et sont silencieusement acceptés (c'est-à-dire non
    reconnus ou vérifiés) par la commande <command>CREATE FUNCTION</command>.
   </para>

   <para>
    <productname>PostgreSQL</productname> autorise la
    <firstterm>surcharge</firstterm> des fonctions&nbsp;; c'est-à-dire que
    le même nom peut être utilisé pour des fonctions différentes si tant
    est qu'elles aient des types d'arguments en entrée distincts. Néanmoins, les noms C de
    toutes les fonctions doivent être différents. Il est donc nécessaire de donner des
    noms différents aux fonctions C suchargées (on peut, par exemple, utiliser le type
    des arguments dans le nom de la fonction).
   </para>

   <para>
    Deux fonctions sont considérées identiques si elles partagent le même nom
    et les mêmes types d'argument en <emphasis>entrée</emphasis>, sans considération des
    paramètres <literal>OUT</literal>. Les déclarations suivantes sont, de fait, en conflit&nbsp;:
<programlisting>CREATE FUNCTION truc(int) ...
CREATE FUNCTION truc(int, out text) ...
</programlisting>
   </para>

   <para>
    Des fonctions ayant des listes de types d'arguments différents ne seront
    pas considérées comme en conflit au moment de leur création, mais si des
    valeurs par défauts sont fournies, elles peuvent se retrouver en conflit
    au moment de l'invocation. Considérez par exemple&nbsp;:
<programlisting>
CREATE FUNCTION truc(int) ...
CREATE FUNCTION truc(int, int default 42) ...
</programlisting>
    Un appel <literal>truc(10)</literal> échouera à cause de l'ambiguïté sur la
    fonction à appeler.
   </para>

   <para>
    Lors d'appels répétés à <command>CREATE FUNCTION</command> faisant référence
    au même fichier objet, le fichier est chargé une seule fois par session.
    Pour décharger et recharger le fichier (en phase de développement, par
    exemple), démarrez une nouvelle session.
   </para>

   <para>
    <xref linkend="sql-dropfunction" endterm="sql-dropfunction-title"/> est utilisé
    pour supprimer les fonctions utilisateur.
   </para>

  <para>
    Les guillemets dollar (voir <xref linkend="sql-syntax-dollar-quoting"/>) peuvent
    s'avérer plus utiles que la syntaxe habituelle à guillemets simples pour écrire
    la chaîne de définition d'une fonction. En l'absence de
    guillemets dollar, tout guillemet simple et tout antislash dans la définition de
    la fonction doit être échappé en le doublant.
  </para>

   <para>
    Si une <literal>SET</literal> est attachée à une fonction, alors les effets
    d'une commande <command>SET LOCAL</command> exécutée dans la fonction pour
    la même variable seront restreints à la fonction&nbsp;: la valeur précedente
    du paramètre sera toujours restaurée à la sortie de la fonction. Néanmoins,
    une commande <command>SET</command> standard (sans <literal>LOCAL</literal>)
    surcharge la clause <literal>SET</literal>, comme il le ferait avec une
    <command>SET LOCAL</command> précédente&nbsp;: les effets d'une telle
    commande subisteront à la sortie de la fonction sauf si la transaction en
    cours est annulée.
   </para>

   <para>
    Pour pouvoir définir une fonction, l'utilisateur doit posséder le droit
    <literal>USAGE</literal> sur le langage.
   </para>

   <para>
    Lorsque <command>CREATE OR REPLACE FUNCTION</command> est utilisé pour
    remplacer une fonction existante, le propriétaire et les droits de la
    fonction ne sont pas changés. Toutes les autres propriétés de la fonction
    sont affectées par les valeurs indiquées ou par les valeurs imploquées par
    la commande. Vous devez être le propriétaire de la fonction pour la
    remplacer (cela inclut aussi les membres du rôle propriétaire).
   </para>

   <para>
    Si une fonction est déclarée <literal>STRICT</> avec un argument
    <literal>VARIADIC</>, la vérification du côté strict d'une fonction teste
    si le tableau variadic <emphasis>lui-même</> est non NULL. La fonction sera
    quand même appelée si le tableau contient des éléments NULL.
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-examples">
  <title>Exemples</title>

  <para>
   Quelques exemples triviaux pour bien débuter sont présentés ci-après. Pour plus
   d'informations et d'exemples, voir <xref linkend="xfunc"/>.
<programlisting>CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
</programlisting>
  </para>
 
   <para>
   Incrémenter un entier, en utilisant le nom de l'argument, dans
   <application>PL/pgSQL</application>&nbsp;:

<programlisting>CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
</programlisting>
  </para>

  <para>
   Renvoyer un enregistrement contenant plusieurs paramètres en sortie&nbsp;:
<programlisting>CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   La même chose, en plus verbeux, avec un type composite
   nommé explicitement&nbsp;:
<programlisting>CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   Une autre façon de renvoyer plusieurs colonnes est d'utiliser une fonction
   <literal>TABLE</literal>&nbsp;:
<programlisting>
CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   Toutefois, une fonction <literal>TABLE</literal> est différente des
   exemples précédents parce qu'elle retourne en fait un <emphasis>ensemble</emphasis>
   d'enregistrements, pas juste un enregistrement.
  </para>
</refsect1>

 <refsect1 id="sql-createfunction-security">
  <title>Écrire des fonctions <literal>SECURITY DEFINER</literal> en toute
    sécurité</title>

   <para>
    Parce qu'une fonction <literal>SECURITY DEFINER</literal> est exécutée
    avec les droits de l'utilisateur qui l'a créé, une certaine attention
    est nécessaire pour s'assurer que la fonction ne peut pas être
    utilisée de façon maline. Pour des raisons de sécurité,
    <xref linkend="guc-search-path"/> doit être configuré pour exclure les
    schémas modifiables par des utilisateurs indignes de confiance.
    Cela empêche des utilisateurs malveillants de créer des
    objets qui masquent les objets utilisés par la fonction. Dans
    ce sens, le schéma des tables temporaires est particulièrement
    important car il est le premier schéma parcouru et qu'il est normalement
    modifiable par tous les utilisateurs. Une solution consiste à forcer
    le parcours de ce schéma en dernier lieu.
    Pour cela, on écrit <literal>pg_temp</literal> comme dernière entrée de
    <varname>search_path</varname>. La fonction suivante illustre une
    utilisation sûre&nbsp;:
   </para>

<programlisting>
CREATE FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT)
RETURNS BOOLEAN AS $$
DECLARE ok BOOLEAN;
BEGIN
        -- Effectuer le travail sécurisé de la fonction.
        SELECT  (motdepasse = $2) INTO ok
        FROM    motsdepasse
        WHERE   nomutilisateur = $1;

        RETURN ok;
END;
$$  LANGUAGE plpgsql
    SECURITY DEFINER
    -- Configure un search_path sécurisée : les schémas de confiance, puis 'pg_temp'.
    SET search_path = admin, pg_temp;
</programlisting>

   <para>
    Avant <productname>PostgreSQL</productname> 8.3, l'option
    <literal>SET</literal> n'était pas disponible, donc les anciennes fonctions
    pouvaient contenir un code assez complexe pour sauvegarder, initialiser
    puis restaurer un paramètre comme <varname>search_path</varname>. L'option <literal>SET</literal> est plus simple à utiliser dans ce but.
   </para>

   <para>
    Un autre point à garder en mémoire est que, par défaut, le droit d'exécution
    est donné à <literal>PUBLIC</literal> pour les fonctions nouvellement
    créées (voir <xref linkend="sql-grant" endterm="sql-grant-title"/> pour plus
    d'informations). Fréquemment, vous souhaiterez restreindre l'utilisation
    d'une fonction « security definer » à seulement quelques utilisateurs. Pour
    cela, vous devez révoquer les droits <literal>PUBLIC</literal> puis donner
    le droit d'exécution aux utilisateurs sélectionnés. Pour éviter que la
    nouvelle fonction soit accessible à tous pendant un court moment, créez-la
    et initialisez les droits dans une même transaction. Par exemple&nbsp;:
   </para>

<programlisting>
BEGIN;
CREATE FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION verifie_motdepasse(unom TEXT, motpasse TEXT) TO admins;
COMMIT;
</programlisting>

 </refsect1>

 <refsect1 id="sql-createfunction-compat">
  <title>Compatibilité</title>

  <para>
   Une commande <command>CREATE FUNCTION</command> est définie en SQL:1999 et
   ultérieur. La version <productname>PostgreSQL</productname> est similaire
   mais pas entièrement compatible. Les attributs ne sont pas portables, pas
   plus que les différents langages disponibles.
  </para>

  <para>
   Pour des raisons de compatibilité avec d'autres systèmes de bases de données, 
   <replaceable class="parameter">modearg</replaceable> peut être écrit 
   avant ou après <replaceable class="parameter">nomarg</replaceable>. Mais
   seule la première façon est compatible avec le standard.
  </para>

  <para>
   Le standard SQL ne définit pas de paramètres par défaut. La syntaxe
   avec le mot clé <literal>DEFAULT</literal> provient d'Oracle, et elle
   est assez proche de l'esprit du standard&nbsp;: SQL/PSQL l'utilise pour les
   valeurs par défaut de variables. La syntaxe avec <literal>=</literal>
   est utilisée dans T-SQL et Firebird.
  </para>
 </refsect1>
 
 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterfunction" endterm="sql-alterfunction-title"/></member>
   <member><xref linkend="sql-dropfunction" endterm="sql-dropfunction-title"/></member>
   <member><xref linkend="sql-grant" endterm="sql-grant-title"/></member>
   <member><xref linkend="sql-load" endterm="sql-load-title"/></member>
   <member><xref linkend="sql-revoke" endterm="sql-revoke-title"/></member>
   <member><xref linkend="app-createlang" endterm="app-createlang-title"/></member>
  </simplelist>
 </refsect1>

</refentry>
