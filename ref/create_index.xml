<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_index.sgml,v 1.8 2005/03/14 06:03:51 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060618 -->

<refentry id="sql-createindex">
 <refmeta>
  <refentrytitle id="sql-createindex-title">CREATE INDEX</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE INDEX</refname>
  <refpurpose>Définir un nouvel index</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] <replaceable class="parameter">nom</replaceable> ON <replaceable class="parameter">table</replaceable> [ USING <replaceable class="parameter">méthode</replaceable> ]
    ( { <replaceable class="parameter">colonne</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">classeop</replaceable> ] [, ...] )
    [ WITH ( <replaceable class="parameter">parametre_stockage</replaceable> = <replaceable class="parameter">valeur</replaceable> [, ... ] ) ]
    [ TABLESPACE <replaceable class="parameter">espacelogique</replaceable> ]
    [ WHERE <replaceable class="parameter">prédicat</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createindex">
   <primary>CREATE INDEX</primary>
  </indexterm>


  <para>
   <command>CREATE INDEX</command> construit un index
   <replaceable class="parameter">nom_index</replaceable> sur la table spécifiée. Les index
   sont principalement utilisés pour améliorer les performances de la base de
   données (bien qu'une utilisation inappropriée puisse produire l'effet inverse).
  </para>

  <para>
   Les champs clé pour l'index sont spécifiés à l'aide de noms des colonnes ou
   par des expressions écrites entre parenthèses. Plusieurs champs peuvent
   être spécifiés si la méthode d'indexation supporte les index multi-colonnes.
  </para>

  <para>
   Un champ d'index peut être une expression calculée à partir des valeurs d'une
   ou plusieurs colonnes de la ligne de table. Cette fonctionnalité peut être
   utilisée pour obtenir un accès rapide à des données obtenues par 
   transformation des données basiques. Par exemple, un index calculé sur
   <literal>upper(col)</literal> autorise la clause 
   <literal>WHERE upper(col) = 'JIM'</literal> à utiliser un index.
  </para>

  <para>
   <productname>PostgreSQL</productname> fournit les méthodes d'indexation
   B-tree (NDT&nbsp;: arbres balancés), hash (NDT&nbsp;: hachage),
   GiST (NDT&nbsp;: arbres de recherche généralisés) et GIN.
   Il est possible, bien que compliqué,
   de définir des méthodes d'indexation utilisateur.
  </para>

  <para>
    Lorsque la clause <literal>WHERE</literal> est présente, un
    <firstterm>index partiel</firstterm> est créé. Un index partiel est un index
    ne contenant des entrées que pour une portion d'une table, habituellement
    la portion sur laquelle l'indexation est la plus utile. Par
    exemple, si une table contient des ordres facturés et d'autres qui ne le sont pas,
    et que les ordres non facturés n'occupent qu'une petite fraction du total de
    la table, qui plus est fréquemment utilisée, les performances sont
    améliorées par la création d'un index sur cette portion. Une
    autre application possible est l'utilisation de la clause <literal>WHERE</literal> 
    en combinaison avec <literal>UNIQUE</literal> pour assurer l'unicité sur un sous-ensemble
    d'une table. Voir <xref linkend="indexes-partial"/> pour plus de renseignements.
  </para>

  <para>
    L'expression utilisée dans la clause <literal>WHERE</literal> peut ne
    faire référence qu'à des colonnes de la table sous-jacente, mais elle peut
    utiliser toutes les colonnes, pas uniquement celles indexées.
    Actuellement, les sous-requêtes et les expressions d'agrégats sont aussi
    interdites dans la clause <literal>WHERE</literal>. Les mêmes restrictions
    s'appliquent aux champs d'index qui sont des expressions.
  </para>

  <para>
   Toutes les fonctions et opérateurs utilisés dans la définition d'index
   doivent être <quote>immutable</quote> (NDT&nbsp;: immuable), c'est-à-dire que leur résultat ne doit
   dépendre que de leurs arguments et jamais d'une influence externe
   (telle que le contenu d'une autre table ou l'heure). Cette
   restriction permet de s'assurer que le comportement de l'index est strictement
   défini. Pour utiliser une fonction utilisateur dans une
   expression d'index ou dans une clause <literal>WHERE</literal>, cette fonction
   doit être marquée immutable lors de sa création.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

    <variablelist>
     <varlistentry>
      <term><literal>UNIQUE</literal></term>
      <listitem>
       <para>
		Le système vérifie la présence de valeurs dupliquées dans la table à la
	création de l'index (si des données existent déjà) et à chaque fois
	qu'une donnée est ajoutée. Les tentatives d'insertion ou de mises à jour
	qui résultent en des entrées dupliquées engendrent une erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CONCURRENTLY</literal></term>
      <listitem>
       <para>
        Quand cette option est utilisée, <productname>PostgreSQL</productname>
        construira l'index sans prendre de verrous qui bloquent les insertions,
        mises à jour, suppression en parallèle sur cette table&nbsp;;
        la construction d'un index standard verrouille les écritures (mais pas
        les lectures) sur la table jusqu'à la fin de la construction. Il
        est nécessaire d'avoir quelques connaissances avant d'utiliser
        cette option &mdash; voir <xref linkend="sql-createindex-concurrently"
        endterm="sql-createindex-concurrently-title"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom</replaceable></term>
      <listitem>
       <para>
        Le nom de l'index à créer. Aucun nom de schéma ne peut être inclus
	ici&nbsp;; l'index est toujours créé dans le même schéma que sa table
	parent.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">table</replaceable></term>
      <listitem>
       <para>
	Le nom de la table à indexer (éventuellement qualifié du nom du schéma).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">méthode</replaceable></term>
      <listitem>
       <para>
        Le nom de la méthode à utiliser pour l'index. Les choix sont
        <literal>btree</literal>, <literal>hash</literal>,
	<literal>gist</literal> et <literal>gin</literal>. La méthode par
	défaut est <literal>btree</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">colonne</replaceable></term>
      <listitem>
       <para>
	Le nom d'une colonne de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">expression</replaceable></term>
      <listitem>
       <para>
	Une expression basée sur une ou plusieurs colonnes de la table.
	L'expression doit habituellement être écrite entre
	parenthèses, comme la syntaxe le précise. Néanmoins, les parenthèses
	peuvent être omises si l'expression a la forme d'un appel de
	fonction.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">classeop</replaceable></term>
      <listitem>
       <para>
	Le nom d'une classe d'opérateur. Voir plus bas pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">paramètre_stockage</replaceable></term>
      <listitem>
       <para>
        Le nom d'un paramètre de stockage spécifique à la méthode d'indexage.
        Voir ci-dessous pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">espacelogique</replaceable></term>
      <listitem>
       <para>
        Le tablespace dans lequel créer l'index. S'il n'est pas précisé,
        <xref linkend="guc-default-tablespace"/> est utilisé ou le tablespace
	par défaut de la base de données si <varname>default_tablespace</varname> est
	une chaîne vide.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">prédicat</replaceable></term>
      <listitem>
       <para>
	L'expression de la contrainte pour un index partiel.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
 
  <refsect2 id="sql-createindex-storage-parameters">
   <title id="sql-createindex-storage-parameters-title">Paramètres de stockage des index</title>

   <para>
    La clause <literal>WITH</literal> peut spécifier des <firstterm>paramètres
    de stockage</firstterm> pour les index. Chaque méthode d'indexage peut avoir
    son propre ensemble de paramètres de stockage. Les méthodes d'indexage
    intégrées acceptent toutes un seul paramètre&nbsp;:
   </para>

   <variablelist>

   <varlistentry>
    <term><literal>FILLFACTOR</literal></term>
    <listitem>
     <para>
      Le facteur de remplissage pour un index est un pourcentage qui détermine
      à quel point les pages d'index seront remplies par la méthode
      d'indexage. Pour les B-tree, les pages enfants sont remplies jusqu'à ce
      pourcentage lors de la construction initiale de l'index, et aussi lors
      de l'extension de l'index sur la droite (valeurs de clé les plus
      importantes). Si les pages deviennent ensuite totalement remplies,
      elles seront partagées, amenant une dégradation graduelle de l'efficacité
      de l'index. Les arbres B-tree utilisent un facteur de remplissage de 90%
      par défaut mais toute valeur entre 10 et 100 peut être choisie. Si la
      table est statique, alors un facteur de 100 est meilleur pour minimiser
      la taille physique de l'index. Pour les tables mises à jour régulièrement,
      un facteur de remplissage plus petit est meilleur pour minimiser le besoin
      de pages divisées. Les autres méthodes d'indexage utilisent un facteur de
      remplissage de façon différente mais en gros analogue&nbsp;; le facteur de
      remplissage varie suivant les méthodes.
     </para>
    </listitem>
   </varlistentry>

   </variablelist>

  </refsect2>

  <refsect2 id="sql-createindex-concurrently">
   <title id="sql-createindex-concurrently-title">Construire des index en parallèle</title>

   <indexterm zone="sql-createindex-concurrently">
   <primary>index</primary>
   <secondary>construction en parallèle</secondary>
   </indexterm>

   <para>
    Créer un index peut interférer avec les opérations normales d'une base de
    données. Habituellement, <productname>PostgreSQL</productname> verrouille
    la table à indexer pour la protéger des écritures et construit l'index
    complet avec un seul parcours de la table. Les autres transactions peuvent
    toujours lire la table mais s'ils essaient d'insérer, mettre à jour,
    supprimer des lignes dans la table, elles seront bloquées jusqu'à la fin
    de la construction de l'index. Ceci peut avoir un effet sérieux si le
    système est une base en production. Les grosses tables peuvent demander
    plusieurs heures pour être indexées. Même pour les petites tables, une
    construction d'index peut bloquer les processus qui voudraient écrire
    dans la table pendant des périodes longues sur un système de production.
   </para>

   <para>
    <productname>PostgreSQL</productname> supporte la construction des index
    sans verrouillage des écritures. Cette méthode est appelée en précisant
    l'option <literal>CONCURRENTLY</literal> de <command>CREATE INDEX</command>.
    Quand cette option est utilisée, <productname>PostgreSQL</productname>
    doit réaliser deux parcours de table et, en plus, il doit attendre que toutes
    les transactions existantes se terminent. Du coup, cette méthode requiert
    plus de temps qu'une construction standard de l'index et est bien plus
    longue à se terminer. Néanmoins, comme cela autorise la poursuite des
    opérations pendant la construction de l'index, cette méthode est utile
    pour ajouter de nouveaux index dans un environnement en production. Bien
    sûr, la charge CPU et I/O supplémentaire imposée par la création de l'index
    peut ralentir les autres opérations.
   </para>

   <para>
    Si un problème survient lors du deuxième parcours de la table, comme une
    violation d'unicité dans un index unique, la commande <command>CREATE
    INDEX</command> échouera mais laissera derrière un index
    <quote>invalide</quote>. Cet index sera ignoré pour les requêtes exécutées
    après car il pourrait être incomplet&nbsp;; néanmoins, il consommera
    toujours du temps machine pendant les mises à jour. La méthode de récupération
    recommandée dans de tels cas est de supprimer l'index et de tenter de
    nouveau un <command>CREATE INDEX CONCURRENTLY</command>. (Une autre
    possibilité est de reconstruire l'index avec <command>REINDEX</command>.
    Néanmoins, comme <command>REINDEX</command> ne supporte pas la construction
    d'index en parallèle, cette option ne semble pas très attirante.)
   </para>

   <para>
    Lors de la construction d'un index unique en parallèle, la contrainte d'unicité
    est déjà placée pour les autres transactions quand le deuxième parcours de
    table commence. Cela signifie que des violations de contraintes pourraient
    être rapportées dans les autres requêtes avant que l'index ne soit disponible,
    voire même dans des cas où la construction de l'index va échouer. De plus,
    si un échec survient dans le deuxième parcours, l'index
    <quote>invalide</quote> continue à forcer la contrainte d'unicité.
   </para>

   <para>
    Les constructions en parallèle d'index avec expression et d'index partiels
    sont supportées. Les erreurs survenant pendant l'évaluation de ces expressions
    pourraient causer un comportement similaire à celui décrit ci-dessus pour
    les violations de contraintes d'unicité.
   </para>

   <para>
    Les constructions d'index standards permettent d'autres construction d'index
    en parallèle sur la même table mais seul une construction d'index en parallèle
    peut survenir sur une table à un même moment. Dans les deux cas, aucun autre
    type de modification de schéma n'est autorisé sur la table. Une autre
    différence est qu'une commande <command>CREATE INDEX</command> normale peut
    être réalisée à l'intérieur d'un bloc de transactions mais <command>CREATE INDEX
    CONCURRENTLY</command> ne le peut pas.
   </para>
  </refsect2>
</refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   <xref linkend="indexes"/> présente des informations sur le moment où les
   index peuvent être utilisés, quand ils ne le sont pas et dans quelles situations
   particulières ils peuvent être utiles.
  </para>

  <para>
   Actuellement, seules les méthodes d'indexation B-tree et GiST supportent les
   index multi-colonnes. Jusqu'à 32 champs peuvent être spécifiés par défaut.
   (Cette limite peut être modifiée à la compilation de
   <productname>PostgreSQL</productname>.) Seul B-tree supporte actuellement les
   index uniques.
  </para>

  <para>
   Une <firstterm>classe d'opérateur</firstterm> peut être spécifiée pour
   chaque colonne d'un index. La classe d'opérateur identifie les opérateurs à
   utiliser par l'index pour cette colonne. Par exemple, un index B-tree sur des
   entiers codés sur quatre octets utilise la classe
   <literal>int4_ops</literal>, qui contient des
   fonctions de comparaison pour les entiers sur quatre octets. En pratique, la
   classe d'opérateur par défaut pour le type de données de la colonne est
   généralement suffisant. Les classes d'opérateur trouvent leur intérêt principal 
   dans l'existence, pour certains types de données, de plusieurs
   ordonnancements significatifs. 
  </para>
  <para>
   Soit l'exemple d'un type de données
   <quote>nombre complexe</quote> qui doit être classé par sa valeur absolue
   ou par sa partie réelle. Cela peut être réalisé par la définition de deux
   classes d'opérateur pour le type de données, puis par la sélection de la
   classe appropriée lors de la création d'un index.
  </para>
  <para>
   De plus amples informations sur les classes d'opérateurs sont disponibles
   dans <xref linkend="indexes-opclass"/> et dans <xref linkend="xindex"/>.
  </para>

  <para>
   <xref linkend="sql-dropindex" endterm="sql-dropindex-title"/> est utilisé
   pour supprimer un index.
  </para>

  <para>
   Par défaut, les index ne sont pas utilisés pour les clauses <literal>IS NULL</literal>.
   La meilleure façon d'utiliser des index dans de tels cas est de
   créer un index partiel qui utilise un prédicat <literal>IS NULL</literal>.
  </para>

  <para>
   Les versions précédentes de <productname>PostgreSQL</productname> ont aussi
   une méthode d'index R-tree. Cette méthode a été supprimée car elle n'a pas
   d'avantages par rapport à la méthode GiST.
   Si <literal>USING rtree</literal> est indiqué, <command>CREATE INDEX</command>
   l'interprétera comme <literal>USING gist</literal> pour simplifier la
   conversions des anciennes bases à GiST.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer un index B-tree sur la colonne <literal>titre</literal> dans la
   table <literal>films</literal>&nbsp;:
<programlisting>CREATE UNIQUE INDEX title_idx ON films (title);
</programlisting>
  </para>

  <para>
   Pour créer un index sur l'expression <literal>lower(titre)</literal>,
   permettant une recherche efficace quelque soit la casse&nbsp;:
<programlisting>CREATE INDEX idx_titre_minuscule ON films ((lower(titre)));
</programlisting>
  </para>

  <para>
   Pour créer un index avec un facteur de remplissage différent&nbsp;:
<programlisting>CREATE UNIQUE INDEX idx_titre ON films (titre) WITH (fillfactor = 70);
</programlisting>
  </para>

  <para>
   Créer un index sur la colonne <literal>code</literal> de la table
   <literal>films</literal> et donner à l'index l'emplacement du tablespace
   <literal>espaceindex</literal>&nbsp;:
<programlisting>CREATE INDEX code_idx ON films(code) TABLESPACE espaceindex;
</programlisting>
  </para>

<!--
<comment>
Is this example correct?
</comment>
  <para>
   To create a GiST index on a point attribute so that we
   can efficiently use box operators on the result of the
   conversion function:
  <programlisting>
CREATE INDEX pointloc
    ON points USING GIST (point2box(location) box_ops);
SELECT * FROM points
    WHERE point2box(points.pointloc) = boxes.box;
  </programlisting>
  </para>
-->

  <para>
   Pour créer un index sans verrouiller les écritures dans la table&nbsp;:
<programlisting>CREATE INDEX CONCURRENTLY index_quentite_ventes ON table_ventes (quantité);
</programlisting>
  </para>

 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>CREATE INDEX</command> est une extension du langage
   <productname>PostgreSQL</productname>. Les index n'existent pas dans le
   standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterindex"
    endterm="sql-alterindex-title"/></member>
   <member><xref linkend="sql-dropindex" endterm="sql-dropindex-title"/></member>
  </simplelist>
 </refsect1>
</refentry>
