<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_index.sgml,v 1.8 2005/03/14 06:03:51 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060618 -->

<refentry id="sql-createindex">
 <refmeta>
  <refentrytitle id="sql-createindex-title">CREATE INDEX</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE INDEX</refname>
  <refpurpose>Définir un nouvel index</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] <replaceable class="parameter">nom</replaceable> ON <replaceable class="parameter">table</replaceable> [ USING <replaceable class="parameter">méthode</replaceable> ]
    ( { <replaceable class="parameter">colonne</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">classeop</replaceable> ] [, ...] )
    [ WITH ( <replaceable class="PARAMETER">parametre_stockage</replaceable> = <replaceable class="PARAMETER">valeur</replaceable> [, ... ] ) ]
    [ TABLESPACE <replaceable class="parameter">espacelogique</replaceable> ]
    [ WHERE <replaceable class="parameter">prédicat</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createindex">
   <primary>CREATE INDEX</primary>
  </indexterm>


  <para>
   <command>CREATE INDEX</command> construit un index
   <replaceable class="parameter">nom_index</replaceable> sur la table spécifiée. Les index
   sont principalement utilisés pour améliorer les performances de la base de
   données (bien qu'une utilisation inappropriée puisse produire l'effet inverse).
  </para>

  <para>
   Les champs clé pour l'index sont spécifiés à l'aide de noms des colonnes ou
   par des expressions écrites entre parenthèses. Plusieurs champs peuvent
   être spécifiés si la méthode d'indexation supporte les index multi-colonnes.
  </para>

  <para>
   Un champ d'index peut être une expression calculée à partir des valeurs d'une
   ou plusieurs colonnes de la ligne de table. Cette fonctionnalité peut être
   utilisée pour obtenir un accès rapide à des données obtenues par 
   transformation des données basiques. Par exemple, un index calculé sur
   <literal>upper(col)</literal> autorise la clause 
   <literal>WHERE upper(col) = 'JIM'</literal> à utiliser un index.
  </para>

  <para>
   <productname>PostgreSQL</productname> fournit les méthodes d'indexation
   B-tree (NDT&nbsp;: arbres balancés), hash (NDT&nbsp;: hachage),
   GiST (NDT&nbsp;: arbres de recherche généralisés) et GIN.
   Il est possible, bien que compliqué,
   de définir des méthodes d'indexation utilisateur.
  </para>

  <para>
    Lorsque la clause <literal>WHERE</literal> est présente, un
    <firstterm>index partiel</firstterm> est créé. Un index partiel est un index
    ne contenant des entrées que pour une portion d'une table, habituellement
    la portion sur laquelle l'indexation est la plus utile. Par
    exemple, si une table contient des ordres facturés et d'autres qui ne le sont pas,
    et que les ordres non facturés n'occupent qu'une petite fraction du total de
    la table, qui plus est fréquemment utilisée, les performances sont
    améliorées par la création d'un index sur cette portion. Une
    autre application possible est l'utilisation de la clause <literal>WHERE</literal> 
    en combinaison avec <literal>UNIQUE</literal> pour assurer l'unicité sur un sous-ensemble
    d'une table. Voir <xref linkend="indexes-partial"/> pour plus de renseignements.
  </para>

  <para>
    L'expression utilisée dans la clause <literal>WHERE</literal> peut ne
    faire référence qu'à des colonnes de la table sous-jacente, mais elle peut
    utiliser toutes les colonnes, pas uniquement celles indexées.
    Actuellement, les sous-requêtes et les expressions d'agrégats sont aussi
    interdites dans la clause <literal>WHERE</literal>. Les mêmes restrictions
    s'appliquent aux champs d'index qui sont des expressions.
  </para>

  <para>
   Toutes les fonctions et opérateurs utilisés dans la définition d'index
   doivent être <quote>immutable</quote> (NDT&nbsp;: immuable), c'est-à-dire que leur résultat ne doit
   dépendre que de leurs arguments et jamais d'une influence externe
   (telle que le contenu d'une autre table ou l'heure). Cette
   restriction permet de s'assurer que le comportement de l'index est strictement
   défini. Pour utiliser une fonction utilisateur dans une
   expression d'index ou dans une clause <literal>WHERE</literal>, cette fonction
   doit être marquée immutable lors de sa création.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

    <variablelist>
     <varlistentry>
      <term><literal>UNIQUE</literal></term>
      <listitem>
       <para>
		Le système vérifie la présence de valeurs dupliquées dans la table à la
	création de l'index (si des données existent déjà) et à chaque fois
	qu'une donnée est ajoutée. Les tentatives d'insertion ou de mises à jour
	qui résultent en des entrées dupliquées engendrent une erreur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CONCURRENTLY</literal></term>
      <listitem>
       <para>
        When this option is used, <productname>PostgreSQL</productname> will build the
        index without taking any locks that prevent concurrent inserts,
        updates, or deletes on the table; whereas a standard index build
        locks out writes (but not reads) on the table until it's done.
        There are several caveats to be aware of when using this option
        &mdash; see <xref linkend="SQL-CREATEINDEX-CONCURRENTLY"
        endterm="SQL-CREATEINDEX-CONCURRENTLY-title"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom</replaceable></term>
      <listitem>
       <para>
        Le nom de l'index à créer. Aucun nom de schéma ne peut être inclus
	ici&nbsp;; l'index est toujours créé dans le même schéma que sa table
	parent.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">table</replaceable></term>
      <listitem>
       <para>
	Le nom de la table à indexer (éventuellement qualifié du nom du schéma).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">méthode</replaceable></term>
      <listitem>
       <para>
        Le nom de la méthode à utiliser pour l'index. Les choix sont
        <literal>btree</literal>, <literal>hash</literal>,
	<literal>gist</literal> et <literal>gin</literal>. La méthode par
	défaut est <literal>btree</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">colonne</replaceable></term>
      <listitem>
       <para>
	Le nom d'une colonne de la table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">expression</replaceable></term>
      <listitem>
       <para>
	Une expression basée sur une ou plusieurs colonnes de la table.
	L'expression doit habituellement être écrite entre
	parenthèses, comme la syntaxe le précise. Néanmoins, les parenthèses
	peuvent être omises si l'expression a la forme d'un appel de
	fonction.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">classeop</replaceable></term>
      <listitem>
       <para>
	Le nom d'une classe d'opérateur. Voir plus bas pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">storage_parameter</replaceable></term>
      <listitem>
       <para>
        The name of an index-method-specific storage parameter.  See
        below for details.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">espacelogique</replaceable></term>
      <listitem>
       <para>
        L'espace logique dans lequel créer l'index. S'il n'est pas précisé,
        <xref linkend="guc-default-tablespace"/> est utilisé ou l'espace logique
	par défaut de la base de données si <varname>default_tablespace</varname> est
	une chaîne vide.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">prédicat</replaceable></term>
      <listitem>
       <para>
	L'expression de la contrainte pour un index partiel.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
 
  <refsect2 id="SQL-CREATEINDEX-storage-parameters">
   <title id="SQL-CREATEINDEX-storage-parameters-title">Index Storage Parameters</title>

   <para>
    The <literal>WITH</literal> clause can specify <firstterm>storage parameters</firstterm>
    for indexes.  Each index method can have its own set of allowed storage
    parameters.  The built-in index methods all accept a single parameter:
   </para>

   <variablelist>

   <varlistentry>
    <term><literal>FILLFACTOR</literal></term>
    <listitem>
     <para>
      The fillfactor for an index is a percentage that determines how full
      the index method will try to pack index pages.  For B-trees, leaf pages
      are filled to this percentage during initial index build, and also
      when extending the index at the right (largest key values).  If pages
      subsequently become completely full, they will be split, leading to
      gradual degradation in the index's efficiency.  B-trees use a default
      fillfactor of 90, but any value from 10 to 100 can be selected.
      If the table is static then fillfactor 100 is best to minimize the
      index's physical size, but for heavily updated tables a smaller
      fillfactor is better to minimize the need for page splits.  The
      other index methods use fillfactor in different but roughly analogous
      ways; the default fillfactor varies between methods.
     </para>
    </listitem>
   </varlistentry>

   </variablelist>

  </refsect2>

  <refsect2 id="SQL-CREATEINDEX-CONCURRENTLY">
   <title id="SQL-CREATEINDEX-CONCURRENTLY-title">Building Indexes Concurrently</title>

   <indexterm zone="SQL-CREATEINDEX-CONCURRENTLY">
   <primary>index</primary>
   <secondary>building concurrently</secondary>
   </indexterm>

   <para>
    Creating an index can interfere with regular operation of a database.
    Normally <productname>PostgreSQL</productname> locks the table to be indexed against
    writes and performs the entire index build with a single scan of the
    table. Other transactions can still read the table, but if they try to
    insert, update, or delete rows in the table they will block until the
    index build is finished. This could have a severe effect if the system is
    a live production database. Large tables can take many hours to be
    indexed, and even for smaller tables, an index build can lock out writers
    for periods that are unacceptably long for a production system.
   </para>

   <para>
    <productname>PostgreSQL</productname> supports building indexes without locking
    out writes.  This method is invoked by specifying the
    <literal>CONCURRENTLY</literal> option of <command>CREATE INDEX</command>.
    When this option is used,
    <productname>PostgreSQL</productname> must perform two scans of the table, and in
    addition it must wait for all existing transactions to terminate.  Thus
    this method requires more total work than a standard index build and takes
    significantly longer to complete.  However, since it allows normal
    operations to continue while the index is built, this method is useful for
    adding new indexes in a production environment.  Of course, the extra CPU
    and I/O load imposed by the index creation may slow other operations.
   </para>

   <para>
    If a problem arises during the second scan of the table, such as a
    uniqueness violation in a unique index, the <command>CREATE INDEX</command>
    command will fail but leave behind an <quote>invalid</quote> index. This index
    will be ignored for querying purposes because it may be incomplete;
    however it will still consume update overhead.  The recommended recovery
    method in such cases is to drop the index and try again to perform
    <command>CREATE INDEX CONCURRENTLY</command>.  (Another possibility is to rebuild
    the index with <command>REINDEX</command>.  However, since <command>REINDEX</command>
    does not support concurrent builds, this option is unlikely to seem
    attractive.)
   </para>

   <para>
    Another caveat when building a unique index concurrently is that the
    uniqueness constraint is already being enforced against other transactions
    when the second table scan begins.  This means that constraint violations
    could be reported in other queries prior to the index becoming available
    for use, or even in cases where the index build eventually fails.  Also,
    if a failure does occur in the second scan, the <quote>invalid</quote> index
    continues to enforce its uniqueness constraint afterwards.
   </para>

   <para>
    Concurrent builds of expression indexes and partial indexes are supported.
    Errors occurring in the evaluation of these expressions could cause
    behavior similar to that described above for unique constraint violations.
   </para>

   <para>
    Regular index builds permit other regular index builds on the
    same table to occur in parallel, but only one concurrent index build
    can occur on a table at a time.  In both cases, no other types of schema
    modification on the table are allowed meanwhile.  Another difference
    is that a regular <command>CREATE INDEX</command> command can be performed within
    a transaction block, but <command>CREATE INDEX CONCURRENTLY</command> cannot.
   </para>
  </refsect2>
</refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   <xref linkend="indexes"/> présente des informations sur le moment où les
   index peuvent être utilisés, quand ils ne le sont pas et dans quelles situations
   particulières ils peuvent être utiles.
  </para>

  <para>
   Actuellement, seules les méthodes d'indexation B-tree et GiST supportent les
   index multi-colonnes. Jusqu'à 32 champs peuvent être spécifiés par défaut.
   (Cette limite peut être modifiée à la compilation de
   <productname>PostgreSQL</productname>.) Seul B-tree supporte actuellement les
   index uniques.
  </para>

  <para>
   Une <firstterm>classe d'opérateur</firstterm> peut être spécifiée pour
   chaque colonne d'un index. La classe d'opérateur identifie les opérateurs à
   utiliser par l'index pour cette colonne. Par exemple, un index B-tree sur des
   entiers codés sur quatre octets utilise la classe
   <literal>int4_ops</literal>, qui contient des
   fonctions de comparaison pour les entiers sur quatre octets. En pratique, la
   classe d'opérateur par défaut pour le type de données de la colonne est
   généralement suffisant. Les classes d'opérateur trouvent leur intérêt principal 
   dans l'existence, pour certains types de données, de plusieurs
   ordonnancements significatifs. 
  </para>
  <para>
   Soit l'exemple d'un type de données
   <quote>nombre complexe</quote> qui doit être classé par sa valeur absolue
   ou par sa partie réelle. Cela peut être réalisé par la définition de deux
   classes d'opérateur pour le type de données, puis par la sélection de la
   classe appropriée lors de la création d'un index.
  </para>
  <para>
   De plus amples informations sur les classes d'opérateurs sont disponibles
   dans <xref linkend="indexes-opclass"/> et dans <xref linkend="xindex"/>.
  </para>

  <para>
   <xref linkend="sql-dropindex" endterm="sql-dropindex-title"/> est utilisé
   pour supprimer un index.
  </para>

  <para>
   Par défaut, les index ne sont pas utilisés pour les clauses <literal>IS NULL</literal>.
   La meilleure façon d'utiliser des index dans de tels cas est de
   créer un index partiel qui utilise un prédicat <literal>IS NULL</literal>.
  </para>

  <para>
   Prior releases of <productname>PostgreSQL</productname> also had an
   R-tree index method.  This method has been removed because
   it had no significant advantages over the GiST method.
   If <literal>USING rtree</literal> is specified, <command>CREATE INDEX</command>
   will interpret it as <literal>USING gist</literal>, to simplify conversion
   of old databases to GiST.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer un index B-tree sur la colonne <literal>titre</literal> dans la
   table <literal>films</literal>&nbsp;:
<programlisting>CREATE UNIQUE INDEX title_idx ON films (title);
</programlisting>
  </para>

  <para>
   To create an index on the expression <literal>lower(title)</literal>,
   allowing efficient case-insensitive searches:
<programlisting>
CREATE INDEX lower_title_idx ON films ((lower(title)));
</programlisting>
  </para>

  <para>
   To create an index with non-default fill factor:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);
</programlisting>
  </para>

  <para>
   Créer un index sur la colonne <literal>code</literal> de la table
   <literal>films</literal> et donner à l'index l'emplacement de l'espace logique
   <literal>espaceindex</literal>&nbsp;:
<programlisting>CREATE INDEX code_idx ON films(code) TABLESPACE espaceindex;
</programlisting>
  </para>

<!--
<comment>
Is this example correct?
</comment>
  <para>
   To create a GiST index on a point attribute so that we
   can efficiently use box operators on the result of the
   conversion function:
  <programlisting>
CREATE INDEX pointloc
    ON points USING GIST (point2box(location) box_ops);
SELECT * FROM points
    WHERE point2box(points.pointloc) = boxes.box;
  </programlisting>
  </para>
-->

  <para>
   To create an index without locking out writes to the table:
<programlisting>
CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);
</programlisting>
  </para>

 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>CREATE INDEX</command> est une extension du langage
   <productname>PostgreSQL</productname>. Les index n'existent pas dans le
   standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterindex"
    endterm="sql-alterindex-title"/></member>
   <member><xref linkend="sql-dropindex" endterm="sql-dropindex-title"/></member>
  </simplelist>
 </refsect1>
</refentry>
