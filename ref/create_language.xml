<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_language.sgml,v 1.10 2005/09/22 18:34:45 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060517 -->

<refentry id="sql-createlanguage">
 <refmeta>
  <refentrytitle id="sql-createlanguage-title">CREATE LANGUAGE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE LANGUAGE</refname>
  <refpurpose>définir un nouveau langage procédural</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ PROCEDURAL ] LANGUAGE <replaceable class="parameter">nom</replaceable>
CREATE [ TRUSTED ] [ PROCEDURAL ] LANGUAGE <replaceable class="parameter">nom</replaceable>
    HANDLER <replaceable class="parameter">gestionnaire_appel</replaceable> [ VALIDATOR <replaceable>fonction_validation</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createlanguage-description">
  <title>Description</title>
  <indexterm zone="sql-createlanguage">
   <primary>CREATE LANGUAGE</primary>
  </indexterm>

  <para>
   Par l'utilisation de <command>CREATE LANGUAGE</command>, un utilisateur
   de <productname>PostgreSQL</productname> peut associer un nouveau langage
   procédural à une base de données <productname>PostgreSQL</productname>. En
   conséquence, les fonctions et les procédures de déclencheurs peuvent être
   définies dans ce nouveau langage. L'utilisateur doit avoir les droits de
   superutilisateur pour enregistrer un nouveau langage.
  </para>

  <para>
   <command>CREATE LANGUAGE</command> associe en fait le nom du langage à
   un gestionnaire d'appels responsable de l'exécution des fonctions
   écrites dans le langage. <xref linkend="xplang"/> offre de plus amples
   informations sur les gestionnaires d'appels.
  </para>

  <para>
   La commande <command>CREATE LANGUAGE</command> existe sous deux formes. Dans
   la première, l'utilisateur ne fournit que le nom du langage désiré et
   le serveur <productname>PostgreSQL</productname> consulte le catalogue
   système <link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link>
   pour déterminer les paramètres adéquats. Dans la seconde, l'utilisateur
   fournit les paramètres du langage avec son nom. Cette
   forme peut être utilisée pour créer un langage non défini dans
   <structname>pg_pltemplate</structname>. Cette approche est cependant obsolète.
  </para>

  <para>
   Si le serveur trouve une entrée dans le catalogue
   <structname>pg_pltemplate</structname> pour le nom donné, il utilise les données du
   catalogue quand bien même la commande incluerait les paramètres du langage. Ce
   comportement simplifie le chargement des anciens fichiers de sauvegarde&nbsp;; ceux-ci
   présentent le risque de contenir des informations caduques sur les fonctions de
   support du langage.
  </para>
 </refsect1>

 <refsect1 id="sql-createlanguage-parameters">
  <title>Paramètres</title>

   <variablelist>
    <varlistentry>
     <term><literal>TRUSTED</literal></term>

     <listitem>
      <para>
       Précise que le gestionnaire d'appels du
       langage est sûr, c'est-à-dire qu'il n'offre pas à un utilisateur sans
       privilège la possibilité d'outrepasser les restrictions d'accès.
       Si ce mot clé est omis à
       l'enregistrement du langage, seuls les superutilisateurs peuvent
       utiliser ce langage pour créer de nouvelles fonctions.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>PROCEDURAL</literal></term>

     <listitem>
      <para>
       Sans objet.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">nom</replaceable></term>

     <listitem>
      <para>
       Le nom du nouveau langage procédural, insensible à la casse.
       Il ne peut y avoir deux langages portant le même nom au sein
       de la base de données.
      </para>

      <para>
       Pour des raisons de compatibilité descendante, le nom doit être entouré de
       guillemets simples.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>HANDLER</literal> <replaceable class="parameter">gestionnaire_appel</replaceable></term>

     <listitem>
      <para>
       <replaceable class="parameter">gestionnaire_appel</replaceable> est le
       nom d'une fonction précédemment enregistrée. C'est elle qui est appelée pour
       exécuter les fonctions du langage procédural. Le gestionnaire d'appels
       d'un langage procédural doit être écrit dans un langage compilé,
       tel que le C, avec la convention d'appel version 1 et enregistré dans 
       <productname>PostgreSQL</productname> comme une fonction ne prenant aucun
       argument et retournant le type <type>language_handler</type>, type
       servant essentiellement à identifier la fonction comme gestionnaire
       d'appels.
      </para>
     </listitem>
    </varlistentry>

<!-- ICI -->
    <varlistentry>
     <term><literal>VALIDATOR</literal> <replaceable class="parameter">fonction_validation</replaceable></term>

     <listitem>
      <para>
       <replaceable class="parameter">fonction_validation</replaceable> est le
       nom d'une fonction précédemment enregistrée. C'est elle qui est appelée lorsqu'une
       nouvelle fonction est créée dans ce langage, pour valider toute nouvelle
       fonction écrite dans ce langage. Si aucune fonction de validation n'est spécifiée, alors une
       nouvelle fonction ne sera pas vérifiée à sa création. La fonction de
       validation prend un argument de type <type>oid</type>, qui sera l'OID de
       la fonction à créer, et renverra typiquement <type>void</type>.
      </para>

      <para>
       Une fonction de validation inspecterait typiquement le corps de la
       fonction pour s'assurer de la justesse syntaxique mais il regarderait
       aussi d'autres propriétés de la fonction, par exemple si le langage ne
       peut pas gérer certains types d'argument. Pour signaler une erreur, la
       fonction de validation devrait utiliser la fonction
       <function>ereport()</function>. La valeur de retour de la fonction est
       ignorée.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  <para>
   L'option <literal>TRUSTED</literal> et le(s) nom(s) de la fonction de support
   sont ignorés si le serveur a une entrée pour le nom du langage spécifié
   dans <structname>pg_pltemplate</structname>.
  </para>
 </refsect1>

 <refsect1 id="sql-createlanguage-notes">
  <title>Notes</title>

  <para>
   Le programme <xref linkend="app-createlang"/> est un simple emballage autour
   de la commande <command>CREATE LANGUAGE</command>. Il facilite l'installation des
   langages de procédures à partir de la ligne de commande du shell.
  </para>

  <para>
   Utilisez <xref linkend="sql-droplanguage" endterm="sql-droplanguage-title"/>,
   ou encore mieux le programme <xref linkend="app-droplang"/> pour supprimer
   des langages de procédures.
  </para>

  <para>
   Le catalogue système <classname>pg_language</classname> (voir <xref
   linkend="catalog-pg-language"/>) enregistre des informations sur les langages
   actuellement installés. De plus, <command>createlang</command> dispose d'une
   option pour lister les langages installés.
  </para>

  <para>
   Pour créer des fonctions dans un langage de procédures, un utilisateur doit
   avoir le droit <literal>USAGE</literal> pour ce langage. Par défaut,
   <literal>USAGE</literal> est donné à <literal>PUBLIC</literal> (c'est-à-dire tout le monde)
   pour les langages de confiance. Ce droit peut être révoqué si nécessaire.
  </para>

  <para>
   Les langages de procédures sont installées base par base. Néanmoins, un
   langage peut être installé dans la base de données
   <literal>template1</literal>, ce qui la rendra automatiquement disponible
   dans toutes les bases de données créées ensuite.
  </para>

  <para>
   Le gestionnaire d'appels et le validateur (s'il y en a un) doivent déjà
   exister si le serveur n'a pas une entrée pour le langage dans
   <structname>pg_pltemplate</structname>. Mais quand il y a une entrée, les fonctions
   n'ont pas besoin de pré-exister&nbsp;; elles seront automatiquement définies
   si elles ne sont pas présentes dans la base de données. (Ceci pourrait
   résulter en un échec de <command>CREATE LANGUAGE</command> si la bibliothèque
   partagée implémentant le langage n'est pas disponible dans l'installation.)
  </para>

  <para>
   Dans les versions de <productname>PostgreSQL</productname> antérieures à la
   7.3, il était nécessaire de déclarer les fonctions de gestion comme renvoyant
   le type <type>opaque</type>, plutôt que <type>language_handler</type>. Pour supporter
   le chargement des anciens fichiers de sauvegarde, <command>CREATE LANGUAGE</command>
   acceptera une fonction déclarant renvoyé le type <type>opaque</type> mais elle
   affichera un message d'avertissement et modifiera le type de retour de la
   fonction par <type>language_handler</type>.
  </para>
 </refsect1>

 <refsect1 id="sql-createlanguage-examples">
  <title>Exemples</title>

  <para>
   La façon préférée de créer tout langage standard de procédures est la
   suivante&nbsp;:
<programlisting>CREATE LANGUAGE plpgsql;
</programlisting>
  </para>

  <para>
   Pour un langage inconnu du catalogue <structname>pg_pltemplate</structname>, une
   séquence comme celle-ci est nécessaire&nbsp;:
<programlisting>CREATE FUNCTION plsample_call_handler() RETURNS language_handler
    AS '$libdir/plsample'
    LANGUAGE C;
CREATE LANGUAGE plsample
    HANDLER plsample_call_handler;
</programlisting>
  </para>
 </refsect1>

 <refsect1 id="sql-createlanguage-compat">
  <title>Compatibilité</title>

  <para>
   <command>CREATE LANGUAGE</command> est un extension de
   <productname>PostgreSQL</productname>.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterlanguage"
    endterm="sql-alterlanguage-title"/></member>
   <member><xref linkend="sql-createfunction"
    endterm="sql-createfunction-title"/></member>
   <member><xref linkend="sql-droplanguage"
    endterm="sql-droplanguage-title"/></member>
   <member><xref linkend="sql-grant" endterm="sql-grant-title"/></member>
   <member><xref linkend="sql-revoke" endterm="sql-revoke-title"/></member>
   <member><xref linkend="app-createlang"
    endterm="app-createlang-title"/></member>
   <member><xref linkend="app-droplang" endterm="app-droplang-title"/></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
