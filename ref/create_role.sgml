<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$PostgreSQL: pgsql/doc/src/sgml/ref/create_role.sgml,v 1.3 2005/08/14 23:35:38 tgl Exp $
PostgreSQL documentation
-->
<!-- SAS 20060410 -->

<refentry id="SQL-CREATEROLE">
 <refmeta>
  <refentrytitle id="sql-createrole-title">CREATE ROLE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE ROLE</refname>
  <refpurpose>définir un nouveau rôle dans la base de données</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createrole">
  <primary>CREATE ROLE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE ROLE <replaceable class="PARAMETER">nom</replaceable> [ [ WITH ] <replaceable class="PARAMETER">option</replaceable> [ ... ] ]

où <replaceable class="PARAMETER">option</replaceable> peut être&nbsp;:
    
      SUPERUSER | NOSUPERUSER
    | CREATEDB | NOCREATEDB
    | CREATEROLE | NOCREATEROLE
    | CREATEUSER | NOCREATEUSER
    | INHERIT | NOINHERIT
    | LOGIN | NOLOGIN
    | CONNECTION LIMIT <replaceable class="PARAMETER">limite_connexion</replaceable>
    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD '<replaceable class="PARAMETER">motdepasse</replaceable>'
    | VALID UNTIL '<replaceable class="PARAMETER">heuredate</replaceable>' 
    | IN ROLE <replaceable class="PARAMETER">nomrole</replaceable> [, ...]
    | IN GROUP <replaceable class="PARAMETER">nomrole</replaceable> [, ...]
    | ROLE <replaceable class="PARAMETER">nomrole</replaceable> [, ...]
    | ADMIN <replaceable class="PARAMETER">nomrole</replaceable> [, ...]
    | USER <replaceable class="PARAMETER">nomrole</replaceable> [, ...]
    | SYSID <replaceable class="PARAMETER">uid</replaceable> 
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE ROLE</command> ajoute un nouveau rôle dans une grappe (cluster) de
   bases de données <productname>PostgreSQL</productname>. Un rôle est une
   entité qui peut posséder des objets de la base de données et avoir des droits
   sur la base. Il peut être considéré comme un
   <quote>utilisateur</quote>, un <quote>groupe</quote> ou les deux suivant la façon dont
   il est utilisé. <xref linkend="user-manag"/> et <xref linkend="client-authentication"/>
   donnent de plus amples informations sur la gestion des
   utilisateurs et l'authentification. Il est nécessaire de posséder le droit 
   <literal>CREATEROLE</literal> ou d'être superutilisateur pour
   utiliser cette commande.
  </para>

  <para>
   Les rôles sont définis au niveau de la grappe de bases de données,
   et sont donc valides dans toutes les bases de la grappe.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">nom</replaceable></term>
      <listitem>
       <para>
        Le nom du nouveau rôle.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SUPERUSER</literal></term>
      <term><literal>NOSUPERUSER</literal></term>
      <listitem>
       <para>
        Ces clauses déterminent si le nouveau rôle est 
        <quote>superutilisateur</quote>, et peut ainsi surpasser tous les droits d'accès
        à la base de données. Le statut de superutilisateur est
        dangereux et ne doit être utilisé que lorsque cela est réellement
        nécessaire. Seul un superutilisateur peut créer un
        nouveau superutilisateur. Lorsqu'aucune clause n'est spécifiée,
        <literal>NOSUPERUSER</literal> est la valeur par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATEDB</literal></term>
      <term><literal>NOCREATEDB</literal></term>
      <listitem>
       <para>
        Ces clauses définissent la capacité d'un rôle à créer des bases de
        données. Si <literal>CREATEDB</literal> est spécifié, le rôle 
        défini est autorisé à créer de nouvelles bases de données.
        <literal>NOCREATEDB</literal> produit l'effet inverse.
        En l'absence de précision, <literal>NOCREATEDB</literal> est
        la valeur par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATEROLE</literal></term>
      <term><literal>NOCREATEROLE</literal></term>
      <listitem>
       <para>
        Ces clauses déterminent si un rôle a le droit de créer de nouveaux rôles
        (c'est-à-dire d'exécuter <command>CREATE ROLE</command>). Un rôle qui
        possède le droit <literal>CREATEROLE</literal> peut aussi modifier ou supprimer
        d'autres rôles. En l'absence de précision, <literal>NOCREATEROLE</literal> est la
        valeur par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATEUSER</literal></term>
      <term><literal>NOCREATEUSER</literal></term>
      <listitem>
       <para>
        Ces clauses sont obsolètes, bien que toujours acceptées. Elles
        ne sont pas équivalentes à <literal>CREATEROLE</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INHERIT</literal></term>
      <term><literal>NOINHERIT</literal></term>
      <listitem>
       <para>
        Ces clauses déterminent si un rôle <quote>hérite</quote> des droits d'un rôle
        dont il est membre. Un rôle qui possède l'attribut
        <literal>INHERIT</literal> peut automatiquement utiliser tout privilège détenu
        par un rôle dont il est membre direct ou indirect. Sans 
        <literal>INHERIT</literal>, l'appartenance à un autre rôle lui confère
        uniquement la possibilité d'utiliser <command>SET ROLE</command> sur cet autre
        rôle. Les droits de l'autre rôle ne sont disponibles qu'après cela.
	En l'absence de précision, <literal>INHERIT</literal> est la valeur par défaut.
       </para>
      </listitem>
     </varlistentry>

<!-- ICI -->
     <varlistentry>
      <term><literal>LOGIN</literal></term>
      <term><literal>NOLOGIN</literal></term>
      <listitem>
       <para>
        Ces clauses déterminent si un rôle est autorisé à se connecter,
        c'est-à-dire que le rôle peut être donnée comme nom d'autorisation
        initiale de session durant la connexion du client. Un rôle ayant
        l'attribut <literal>LOGIN</literal> peut être pensé comme un
        utilisateur. Les rôles ne disposant pas de cet attribut sont utiles pour
        gérer les droits de la base de données mais ne sont pas des utilisateurs
        au sens habituel du mot. Si non spécifié, <literal>NOLOGIN</literal>
        est la valeur par défaut, sauf lorsque <command>CREATE ROLE</command> est
        appelé via sa commande synonyme <command>CREATE USER</command>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CONNECTION LIMIT</literal> <replaceable class="parameter">limiteconnexion</replaceable></term>
      <listitem>
       <para>
        Si un rôle peut se connecter, ceci spécifie le nombre maximum de
        connexions concurrentes possibles par ce rôle. -1 (la valeur par
        défaut) signifie sans limite.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PASSWORD</literal> <replaceable class="parameter">motdepasse</replaceable></term>
      <listitem>
       <para>
        Configure le mot de passe du rôle. (Un mot de passe est seulement utile
        pour les rôles ayant l'attribut <literal>LOGIN</literal> mais vous
        pouvez néanmoins en définir un sur les rôles n'en disposant pas.) Si
        vous ne pensez pas utiliser l'authentification par mot de passe, vous
        pouvez oublier cette option.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ENCRYPTED</literal></term>
      <term><literal>UNENCRYPTED</literal></term>
      <listitem>
       <para>
        Ces mots clés contrôlent si le mot de passe est stocké crypté dans les
        catalogues système. (Si rien n'est spécifié, le comportement par
        défaut est déterminé par le paramètre de configuration <xref
        linkend="guc-password-encryption"/>.) Si le mot de passe présenté est
        déjà une chaîne crypté avec MD5, alors il est stocké directement, que
        <literal>ENCRYPTED</literal> ou <literal>UNENCRYPTED</literal> soit spécifié
        (car le système ne peut pas décrypter la chaîne déjà cryptée). Ceci
        permet de recharger des mots de passe cryptés lors de la
        sauvegarde/restauration.
       </para>

       <para>
        Notez que les anciens clients pourraient ne pas disposer du support
        pour le mécanisme d'authentification MD5, nécessaire pour travailler
        avec les mots de passe stockés cryptés.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>VALID UNTIL</literal> '<replaceable class="parameter">dateheure</replaceable>'</term>
      <listitem>
       <para>
        La clause <literal>VALID UNTIL</literal> configure une date et une
        heure après lesquelles le mot de passe du rôle n'est plus valide. Si
        cette clause est omise, le mot de passe est valide en permanence.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>IN ROLE</literal> <replaceable class="parameter">nomrole</replaceable></term>
      <listitem>
       <para>
        La clause <literal>IN ROLE</literal> liste un ou plusieurs rôles
        existants auxquels le nouveau rôle sera immédiatement ajouté en tant que
        nouveau membre. (Notez qu'il n'existe pas d'option pour ajouter le
        nouveau rôle en tant qu'administrateur, utilisez une commande
        <command>GRANT</command> séparée pour cela.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>IN GROUP</literal> <replaceable class="parameter">nomrole</replaceable></term>
      <listitem>
       <para>
        <literal>IN GROUP</literal> est une façon obsolète pour dire <literal>IN
        ROLE</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ROLE</literal> <replaceable class="parameter">nomrole</replaceable></term>
      <listitem>
       <para>
        La clause <literal>ROLE</literal> liste un ou plusieurs rôles existants
        qui sont automatiquement ajoutés comme membre du nouveau rôle. (En
        conséquence, ceci transforme le nouveau rôle en un <quote>groupe</quote>.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ADMIN</literal> <replaceable class="parameter">nomrole</replaceable></term>
      <listitem>
       <para>
        La clause <literal>ADMIN</literal> est identique à
        <literal>ROLE</literal>, mais les rôles nommés sont ajoutés au nouveau
        rôle avec l'option <literal>WITH ADMIN OPTION</literal>, leur donnant le droit
        de donner ce rôle à d'autres.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USER</literal> <replaceable class="parameter">nomrole</replaceable></term>
      <listitem>
       <para>
        La clause <literal>USER</literal> est une façon osbolète de donner la
        clause <literal>ROLE</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SYSID</literal> <replaceable class="parameter">uid</replaceable></term>
      <listitem>
       <para>
        La clause <literal>SYSID</literal> est ignorée bien qu'elle soit
        toujours acceptée pour des raisons de compatibilité.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
 </refsect1> 

 <refsect1>
  <title>Notes</title>

  <para>
   Utilisez <xref linkend="SQL-ALTERROLE" endterm="SQL-ALTERROLE-title"/> pour
   modifier les attributs d'un rôle, et <xref linkend="SQL-DROPROLE"
   endterm="SQL-DROPROLE-title"/> pour supprimer un rôle. Tous les attributs
   spécifiés par <command>CREATE ROLE</command> peuvent être modifiés par la suite
   avec des commandes <command>ALTER ROLE</command>.
  </para>

  <para>
   La façon préférée d'ajouter et de supprimer des membres de rôles utilisés
   comme des groupes est d'utiliser<xref linkend="SQL-GRANT"
   endterm="SQL-GRANT-title"/> et <xref linkend="SQL-REVOKE"
   endterm="SQL-REVOKE-title"/>.
  </para>

  <para>
   La clause <literal>VALID UNTIL</literal> définit une date et heure d'expiration
   pour le mot de passe seulement, pas pour le rôle en lui-même. En particulier,
   l'heure d'expiration n'est pas vérifiée lors de la connexion en utilisant
   une méthode d'authentification sans mot de passe.
  </para>

  <para>
   L'attribut <literal>INHERIT</literal> gouverne l'héritage des droits qu'il est
   possible de donner (c'est-à-dire les droits d'accès pour les objets de la
   base de données et les appartenances à des rôles). Cela ne s'applique pas
   aux attributs spéciaux de rôle configurés par <command>CREATE ROLE</command> et
   <command>ALTER ROLE</command>. Par exemple, être un membre d'un rôle disposant du
   droit <literal>CREATEDB</literal> ne donne pas immédiatement le droit de créer des
   bases de données, même si <literal>INHERIT</literal> est configuré, il
   deviendrait nécessaire de devenir ce rôle via <xref linkend="SQL-SET-ROLE"
   endterm="SQL-SET-ROLE-title"/> avant de créer une base de données.
  </para>

  <para>
   L'attribut <literal>INHERIT</literal> est la valeur par défaut pour des raisons de
   compatibilité descendante: dans les précédentes versions de
   <productname>PostgreSQL</productname>, les utilisateurs avaient toujours
   accès à tous les droits des groupes dont ils étaient membres. Néanmoins,
   <literal>NOINHERIT</literal> fournit une correspondance plus proche de la sémantique
   spécifiée dans le standard SQL.
  </para>

  <para>
   <productname>PostgreSQL</productname> inclut un programme <xref
   linkend="APP-CREATEUSER" endterm="APP-CREATEUSER-title"/> qui a la même
   fonctionnalité que <command>CREATE ROLE</command> (en fait, il appelle cette
   commande) mais peut être lancé à partir du shell.
  </para>

  <para>
   L'option <literal>CONNECTION LIMIT</literal> est vérifiée seulement
   approximativement, si deux nouvelles sessions sont lancées à peu près
   au même moment alors que seul un <quote>emplacement</quote> de connexion reste
   vacant pour le rôle, il est possible que les deux échouent. De plus, la
   limite n'est jamais vérifiée pour les superutilisateurs.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer un rôle qui peut se connecter mais sans lui donner de mot de
   passe:
<programlisting>
CREATE ROLE jonathan LOGIN;
</programlisting>
  </para>

  <para>
   Créer un rôle avec un mot de passe :
<programlisting>
CREATE USER davide WITH PASSWORD 'jw8s0F4';
</programlisting>
   (<command>CREATE USER</command> est identique à <command>CREATE ROLE</command> sauf que
   cela implique <literal>LOGIN</literal>.)
  </para>

  <para>
   Créer un rôle avec un mot de passe valide jusqu'à fin 2004. Une seconde après
   le passage à 2005, le mot de passe n'est plus valide.

<programlisting>
CREATE ROLE miriam WITH LOGIN PASSWORD 'jw8s0F4' VALID UNTIL '2005-01-01';
</programlisting>
  </para>

  <para> 
   Créer un rôle qui peut créer des bases de données et gérer des rôles :
<programlisting>
CREATE ROLE admin WITH CREATEDB CREATEROLE;
</programlisting>
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   L'instruction <command>CREATE ROLE</command> est dans le standard SQL mais ce
   standard ne requiert que la syntaxe
<synopsis>
CREATE ROLE <replaceable class="PARAMETER">nom</replaceable> [ WITH ADMIN <replaceable class="PARAMETER">nomrole</replaceable> ]
</synopsis>
   La possibilité d'avoir plusieurs administrateurs initialement et toutes les
   autres options de <command>CREATE ROLE</command> sont des extensions de
   <productname>PostgreSQL</productname>.
  </para>
  
  <para>
   Le standard SQL définit les concepts des utilisateurs et des rôles mais
   il les considère comme des concepts distincts et laisse la spécification des
   commandes définissant les utilisateurs à l'implémentation de chaque base de
   données. Dans <productname>PostgreSQL</productname>, nous avons choisi
   d'unifier les utilisateurs et les rôles en un seul type d'entité. Du coup,
   les rôles ont de nombreux attributs optionnels par rapport au standard.
  </para>

  <para>
   Le comportement spécifié par le standard SQL est une approximation très
   proche en donnant aux utilisateurs l'attribut <literal>NOINHERIT</literal> alors
   que les rôles se voient donnés l'attribut <literal>INHERIT</literal>.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-set-role" endterm="sql-set-role-title"/></member>
   <member><xref linkend="sql-alterrole" endterm="sql-alterrole-title"/></member>
   <member><xref linkend="sql-droprole" endterm="sql-droprole-title"/></member>
   <member><xref linkend="sql-grant" endterm="sql-grant-title"/></member>
   <member><xref linkend="sql-revoke" endterm="sql-revoke-title"/></member>
   <member><xref linkend="app-createuser"/></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
