<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$PostgreSQL: pgsql/doc/src/sgml/ref/create_role.sgml,v 1.3 2005/08/14 23:35:38 tgl Exp $
PostgreSQL documentation
-->
<!-- SAS 20060410 -->

<refentry id="sql-createrole">
 <refmeta>
  <refentrytitle id="sql-createrole-title">CREATE ROLE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE ROLE</refname>
  <refpurpose>définir un nouveau rôle dans la base de données</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createrole">
  <primary>CREATE ROLE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE ROLE <replaceable class="parameter">nom</replaceable> [ [ WITH ] <replaceable class="parameter">option</replaceable> [ ... ] ]

où <replaceable class="parameter">option</replaceable> peut être&nbsp;:
    
      SUPERUSER | NOSUPERUSER
    | CREATEDB | NOCREATEDB
    | CREATEROLE | NOCREATEROLE
    | CREATEUSER | NOCREATEUSER
    | INHERIT | NOINHERIT
    | LOGIN | NOLOGIN
    | CONNECTION LIMIT <replaceable class="parameter">limite_connexion</replaceable>
    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD '<replaceable class="parameter">motdepasse</replaceable>'
    | VALID UNTIL '<replaceable class="parameter">heuredate</replaceable>' 
    | IN ROLE <replaceable class="parameter">nomrole</replaceable> [, ...]
    | IN GROUP <replaceable class="parameter">nomrole</replaceable> [, ...]
    | ROLE <replaceable class="parameter">nomrole</replaceable> [, ...]
    | ADMIN <replaceable class="parameter">nomrole</replaceable> [, ...]
    | USER <replaceable class="parameter">nomrole</replaceable> [, ...]
    | SYSID <replaceable class="parameter">uid</replaceable> 
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE ROLE</command> ajoute un nouveau rôle dans une grappe (cluster) de
   bases de données <productname>PostgreSQL</productname>. Un rôle est une
   entité qui peut posséder des objets de la base de données et avoir des droits
   sur la base. Il peut être considéré comme un
   <quote>utilisateur</quote>, un <quote>groupe</quote> ou les deux suivant la façon dont
   il est utilisé. <xref linkend="user-manag"/> et <xref linkend="client-authentication"/>
   donnent de plus amples informations sur la gestion des
   utilisateurs et l'authentification. Il est nécessaire de posséder le droit 
   <literal>CREATEROLE</literal> ou d'être superutilisateur pour
   utiliser cette commande.
  </para>

  <para>
   Les rôles sont définis au niveau de la grappe de bases de données,
   et sont donc valides dans toutes les bases de la grappe.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">nom</replaceable></term>
      <listitem>
       <para>
        Le nom du nouveau rôle.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SUPERUSER</literal></term>
      <term><literal>NOSUPERUSER</literal></term>
      <listitem>
       <para>
        Ces clauses précisent si le nouveau rôle est 
        <quote>superutilisateur</quote>, et peut ainsi surpasser tous les droits d'accès
        à la base de données. Le statut de superutilisateur est
        dangereux et ne doit être utilisé que lorsque cela est réellement
        nécessaire. Seul un superutilisateur peut en créer un
        nouveau. Lorsqu'aucune clause n'est spécifiée,
        <literal>NOSUPERUSER</literal> est la valeur par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATEDB</literal></term>
      <term><literal>NOCREATEDB</literal></term>
      <listitem>
       <para>
        Ces clauses précisent si le rôle a le droit de création de bases de
        données. Si <literal>CREATEDB</literal> est spécifié, l'autorisation
	est donnée au rôle, <literal>NOCREATEDB</literal> produit l'effet inverse.
        En l'absence de précision, <literal>NOCREATEDB</literal> est
        la valeur par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATEROLE</literal></term>
      <term><literal>NOCREATEROLE</literal></term>
      <listitem>
       <para>
        Ces clauses déterminent si le rôle a le droit de création de nouveaux rôles
        (c'est-à-dire d'exécuter <command>CREATE ROLE</command>). Un rôle qui
        possède le droit <literal>CREATEROLE</literal> peut aussi modifier ou supprimer
        d'autres rôles. En l'absence de précision, <literal>NOCREATEROLE</literal> est la
        valeur par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATEUSER</literal></term>
      <term><literal>NOCREATEUSER</literal></term>
      <listitem>
       <para>
        Ces clauses, obsolètes mais toujours acceptées, sont équivalentes à <literal>SUPERUSER</literal>
	et <literal>NOSUPERUSER</literal>. Elles
        <emphasis>ne</emphasis> sont <emphasis>pas</emphasis> équivalentes à <literal>CREATEROLE</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INHERIT</literal></term>
      <term><literal>NOINHERIT</literal></term>
      <listitem>
       <para>
        Ces clauses précisent si un rôle <quote>hérite</quote> des droits d'un rôle
        dont il est membre. Un rôle qui possède l'attribut
        <literal>INHERIT</literal> peut automatiquement utiliser tout privilège détenu
        par un rôle dont il est membre direct ou indirect. Sans 
        <literal>INHERIT</literal>, l'appartenance à un autre rôle lui confère
        uniquement la possibilité d'utiliser <command>SET ROLE</command> pour acquérir
        les droits de l'autre rôle&nbsp; ils ne sont disponibles qu'après cela.
	En l'absence de précision, <literal>INHERIT</literal> est la valeur par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LOGIN</literal></term>
      <term><literal>NOLOGIN</literal></term>
      <listitem>
       <para>
        Ces clauses précisent si un rôle est autorisé à se connecter,
        c'est-à-dire si le rôle peut être donné comme nom pour l'autorisation
        initiale de session à la connexion du client. Un rôle ayant
        l'attribut <literal>LOGIN</literal> peut être vu comme un
        utilisateur. Les rôles qui ne disposent pas de cet attribut sont utiles pour
        gérer les privilèges de la base de données mais ne sont pas des utilisateurs
        au sens habituel du mot. En l'absence de précision, <literal>NOLOGIN</literal>
        est la valeur par défaut, sauf si <command>CREATE ROLE</command> est
        appelé à travers la commande <command>CREATE USER</command>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CONNECTION LIMIT</literal> <replaceable class="parameter">limiteconnexion</replaceable></term>
      <listitem>
       <para>
        Le nombre maximum de connexions concurrentes possibles pour rôle qui possède
	le droit de connexion. -1 (valeur par défaut) signifie qu'il n'y a pas de limite.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PASSWORD</literal> <replaceable class="parameter">motdepasse</replaceable></term>
      <listitem>
       <para>
        Le mot de passe du rôle. (Un mot de passe n'est utile que
        pour les rôles ayant l'attribut <literal>LOGIN</literal> mais il est possible
        d'en définir un pour les rôles qui n'ont pas cet attribut.) Cette option
	peut être omise si l'authentification par mot de passe n'est pas envisagée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ENCRYPTED</literal></term>
      <term><literal>UNENCRYPTED</literal></term>
      <listitem>
       <para>
        Ces mots clés contrôlent le chiffrement du mot de passe stocké dans les
        catalogues système. (En l'absence de précision, le comportement par
        défaut est déterminé par le paramètre de configuration
	<xref linkend="guc-password-encryption"/>.) Si le mot de passe présenté est
        déjà une chaîne chiffrée avec MD5, il est stocké tel-quel, quelque soit le
	mot-clé spécifié, <literal>ENCRYPTED</literal> ou <literal>UNENCRYPTED</literal>
        (le système ne peut pas déchiffrer la chaîne déjà chiffrée). Cela
        permet de recharger des mots de passe chiffrés lors d'opérations de 
        sauvegarde/restauration.
       </para>

       <para>
        D'anciens clients peuvent ne pas disposer du support
        pour le mécanisme d'authentification MD5, nécessaire pour travailler
        avec les mots de passe stockés chiffrés.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>VALID UNTIL</literal> '<replaceable class="parameter">dateheure</replaceable>'</term>
      <listitem>
       <para>
        La clause <literal>VALID UNTIL</literal> configure une date et une
        heure de fin de validité du mot de passe. En l'absence de
        cette clause, le mot de passe est indéfiniment valide.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>IN ROLE</literal> <replaceable class="parameter">nomrole</replaceable></term>
      <listitem>
       <para>
        La clause <literal>IN ROLE</literal> liste les rôles dont le nouveau
        rôle sera immédiatement membre. (Il n'existe pas d'option pour ajouter le
        nouveau rôle en tant qu'administrateur&nbsp;; cela se fait à l'aide d'une commande
        <command>GRANT</command> séparée.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>IN GROUP</literal> <replaceable class="parameter">nomrole</replaceable></term>
      <listitem>
       <para>
        <literal>IN GROUP</literal> est un équivalent obsolète de <literal>IN ROLE</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ROLE</literal> <replaceable class="parameter">nomrole</replaceable></term>
      <listitem>
       <para>
        La clause <literal>ROLE</literal> liste les rôles membres du nouveau rôle.
        (Le nouveau rôle devient ainsi un <quote>groupe</quote>.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ADMIN</literal> <replaceable class="parameter">nomrole</replaceable></term>
      <listitem>
       <para>
        La clause <literal>ADMIN</literal> est équivalente à la clause
        <literal>ROLE</literal>, à la différence que les rôles nommés sont ajoutés au nouveau
        rôle avec l'option <literal>WITH ADMIN OPTION</literal>, leur conférant le droit
        de donner l'appartenance à ce rôle à d'autres.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USER</literal> <replaceable class="parameter">nomrole</replaceable></term>
      <listitem>
       <para>
        <literal>USER</literal> est un équivalent osbolète de <literal>ROLE</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SYSID</literal> <replaceable class="parameter">uid</replaceable></term>
      <listitem>
       <para>
        La clause <literal>SYSID</literal> est ignorée, mais
        toujours acceptée pour des raisons de compatibilité.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
 </refsect1> 

 <refsect1>
  <title>Notes</title>

  <para>
   <xref linkend="sql-alterrole" endterm="sql-alterrole-title"/> est utilisé pour
   modifier les attributs d'un rôle, et
   <xref linkend="sql-droprole" endterm="sql-droprole-title"/> pour supprimer un rôle.
   Tous les attributs
   spécifiés par <command>CREATE ROLE</command> peuvent être modifiés ensuite
   par des commandes <command>ALTER ROLE</command>.
  </para>

  <para>
   Il est préférable d'utiliser <xref linkend="sql-grant" endterm="sql-grant-title"/>
   et <xref linkend="sql-revoke" endterm="sql-revoke-title"/> pour ajouter et supprimer
   des membres de rôles utilisés comme des groupes.
  </para>

  <para>
   La clause <literal>VALID UNTIL</literal> définit une date et heure d'expiration
   pour le mot de passe uniquement, pas pour le rôle en lui-même. En particulier,
   l'heure d'expiration n'est pas vérifiée lors des connexions à l'aide de
   méthodes d'authentification qui n'utilisent pas les mots de passe.
  </para>

  <para>
   L'attribut <literal>INHERIT</literal> gouverne l'héritage des droits conférables
   (c'est-à-dire les droits d'accès aux objets de la
   base de données et les appartenances aux rôles). Il ne s'applique pas
   aux attributs de rôle spéciaux configurés par <command>CREATE ROLE</command> et
   <command>ALTER ROLE</command>. Par exemple, être membre d'un rôle disposant du
   droit <literal>CREATEDB</literal> ne confère pas automatiquement le droit de création de
   bases de données, même si <literal>INHERIT</literal> est positionné, il
   est nécessaire de devenir ce rôle via
   <xref linkend="sql-set-role" endterm="sql-set-role-title"/> avant de créer une base de données.
  </para>

  <para>
   L'attribut <literal>INHERIT</literal> est la valeur par défaut pour des raisons de
   compatibilité descendante&nbsp;: dans les précédentes versions de
   <productname>PostgreSQL</productname>, les utilisateurs avaient toujours
   accès à tous les droits des groupes dont ils étaient membres. Toutefois,
   <literal>NOINHERIT</literal> est plus respectueux de la sémantique
   spécifiée dans le standard SQL.
  </para>

  <para>
   <productname>PostgreSQL</productname> inclut un programme,
   <xref linkend="app-createuser" endterm="app-createuser-title"/>, avec les mêmes
   fonctionnalités que <command>CREATE ROLE</command> (en fait, il appelle cette
   commande) qui peut être lancé à partir du shell.
  </para>

  <para>
   L'option <literal>CONNECTION LIMIT</literal> n'est vérifiée 
   qu'approximativement. Si deux nouvelles sessions sont lancées à peu près
   simultanément alors qu'il ne reste qu'un seul <quote>emplacement</quote> de connexion
   disponible pour le rôle, il est possible que les deux échouent. De plus, la
   limite n'est jamais vérifiée pour les superutilisateurs.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer un rôle qui peut se connecter mais sans lui donner de mot de
   passe&nbsp;:
<programlisting>
CREATE ROLE jonathan LOGIN;
</programlisting>
  </para>

  <para>
   Créer un rôle avec un mot de passe&nbsp;:
<programlisting>
CREATE USER davide WITH PASSWORD 'jw8s0F4';
</programlisting>
   (<command>CREATE USER</command> est identique à <command>CREATE ROLE</command> mais
   implique <literal>LOGIN</literal>.)
  </para>

  <para>
   Créer un rôle avec un mot de passe valide jusqu'à fin 2004. Une seconde après
   le passage à 2005, le mot de passe n'est plus valide.

<programlisting>
CREATE ROLE miriam WITH LOGIN PASSWORD 'jw8s0F4' VALID UNTIL '2005-01-01';
</programlisting>
  </para>

  <para> 
   Créer un rôle qui peut créer des bases de données et gérer des rôles&nbsp;:
<programlisting>
CREATE ROLE admin WITH CREATEDB CREATEROLE;
</programlisting>
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   L'instruction <command>CREATE ROLE</command> est définie dans le standard SQL mais 
   il n'impose que la syntaxe
<synopsis>
CREATE ROLE <replaceable class="parameter">nom</replaceable> [ WITH ADMIN <replaceable class="parameter">nomrole</replaceable> ]
</synopsis>
   La possibilité d'avoir plusieurs administrateurs initiaux et toutes les
   autres options de <command>CREATE ROLE</command> sont des extensions de
   <productname>PostgreSQL</productname>.
  </para>
  
  <para>
   Le standard SQL définit les concepts d'utilisateurs et de rôles mais
   les considère comme des concepts distincts et laisse la spécification des
   commandes de définition des utilisateurs à l'implantation de chaque base de
   données. <productname>PostgreSQL</productname> a pris le parti
   d'unifier les utilisateurs et les rôles au sein d'une même entité. Ainsi,
   les rôles ont plus d'attributs optionnels que dans le standard.
  </para>

  <para>
   Le comportement spécifié par le standard SQL peut être approché 
   en donnant aux utilisateurs l'attribut <literal>NOINHERIT</literal> et
   aux rôles l'attribut <literal>INHERIT</literal>.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-set-role" endterm="sql-set-role-title"/></member>
   <member><xref linkend="sql-alterrole" endterm="sql-alterrole-title"/></member>
   <member><xref linkend="sql-droprole" endterm="sql-droprole-title"/></member>
   <member><xref linkend="sql-grant" endterm="sql-grant-title"/></member>
   <member><xref linkend="sql-revoke" endterm="sql-revoke-title"/></member>
   <member><xref linkend="app-createuser"/></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
