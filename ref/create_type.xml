<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_type.sgml,v 1.11 2005/09/15 07:03:26 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060618 -->

<refentry id="sql-createtype">
 <refmeta>
  <refentrytitle id="sql-createtype-title">CREATE TYPE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TYPE</refname>
  <refpurpose>Définir un nouveau type de données</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE TYPE <replaceable class="parameter">nom</replaceable> AS
    ( <replaceable class="parameter">nom_attribut</replaceable> <replaceable class="parameter">type_donnée</replaceable> [, ... ] )

CREATE TYPE <replaceable class="parameter">nom</replaceable> AS ENUM
    ( '<replaceable class="parameter">label</replaceable>' [, ... ] )

CREATE TYPE <replaceable class="parameter">nom</replaceable> (
    INPUT = <replaceable class="parameter">fonction_entrée</replaceable>,
    OUTPUT = <replaceable class="parameter">fonction_sortie</replaceable>
    [ , RECEIVE = <replaceable class="parameter">fonction_réception</replaceable> ]
    [ , SEND = <replaceable class="parameter">fonction_envoi</replaceable> ]
    [ , TYPMOD_IN = <replaceable class="parameter">type_modifier_input_function</replaceable> ]
    [ , TYPMOD_OUT = <replaceable class="parameter">type_modifier_output_function</replaceable> ]
    [ , ANALYZE = <replaceable class="parameter">fonction_analyse</replaceable> ]
    [ , INTERNALLENGTH = { <replaceable class="parameter">longueurinterne</replaceable> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <replaceable class="parameter">alignement</replaceable> ]
    [ , STORAGE = <replaceable class="parameter">stockage</replaceable> ]
    [ , DEFAULT = <replaceable class="parameter">défaut</replaceable> ]
    [ , ELEMENT = <replaceable class="parameter">élément</replaceable> ]
    [ , DELIMITER = <replaceable class="parameter">délimiteur</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">nom</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createtype">
   <primary>CREATE TYPE</primary>
  </indexterm>

  <para>
   <command>CREATE TYPE</command> enregistre un nouveau type de données 
   utilisable dans la base courante. L'utilisateur qui définit un type
   en devient le propriétaire.
  </para>

  <para>
   Si un nom de schéma est précisé, le type est créé dans ce schéma.
   Sinon, il est créé dans le schéma courant. Le nom du type doit être
   distinct du nom de tout type ou domaine existant dans le même schéma. 
   Les tables possèdent des types de données associés. Il est donc nécessaire
   que le nom du type soit également distinct du nom de toute table existant dans le même schéma.
  </para>

  <refsect2>
   <title>Types composites</title>

  <para>
   La première forme de <command>CREATE TYPE</command> crée un type composite. Le
   type composite est défini par une liste de noms d'attributs et de types de
   données. Pour l'essentiel, il est équivalent au type ligne
   (NDT&nbsp;: <foreignphrase>row type</foreignphrase> en anglais) d'une table,
   mais l'utilisation de <command>CREATE TYPE</command>
   permet d'éviter la création d'une table réelle quand seule la définition d'un type
   est voulue. Un type composite autonome est utile comme type d'argument ou de retour d'une
   fonction.
  </para>
  </refsect2>

  <refsect2>
   <title>Enumerated Types</title>

   <para>
    The second form of <command>CREATE TYPE</command> creates an enumerated
    (enum) type, as described in <xref linkend="datatype-enum"/>.
    Enum types take a list of one or more quoted labels, each of which
    must be less than <symbol>NAMEDATALEN</symbol> bytes long (64 in a standard
    <productname>PostgreSQL</productname> build).
   </para>
  </refsect2>

  <refsect2>
   <title>Types de base</title>

  <para>
   La troisième forme de <command>CREATE TYPE</command> crée un nouveau type de base
   (type scalaire). L'ordre des paramètres, dont la plupart sont optionnels, n'a aucune
   d'importance. Avant de définir le type, il est nécessaire de définir au moins
   deux fonctions (à l'aide de la commande <command>CREATE FUNCTION</command>).
   Les fonctions de support <replaceable class="parameter">fonction_entrée</replaceable>
   et <replaceable class="parameter">fonction_sortie</replaceable> sont obligatoires. Les
   fonctions <replaceable class="parameter">fonction_réception</replaceable>,
   <replaceable class="parameter">fonction_envoi</replaceable>,
   <replaceable class="parameter">type_modifier_input_function</replaceable>,
   <replaceable class="parameter">type_modifier_output_function</replaceable>
   et
   <replaceable class="parameter">fonction_analyse</replaceable> sont
   optionnelles. Généralement, ces fonctions sont codées en C ou dans un
   autre langage de bas niveau.
  </para>

  <para>
   La <replaceable class="parameter">fonction_entrée</replaceable> convertit la
   représentation textuelle externe du type en représentation interne
   utilisée par les opérateurs et fonctions définis pour le type.
   La <replaceable class="parameter">fonction_sortie</replaceable> réalise la transformation
   inverse. La fonction entrée peut être déclarée avec un
   argument de type <type>cstring</type> ou trois arguments de
   types <type>cstring</type>, <type>oid</type>, <type>integer</type>. Le
   premier argument est le texte en entrée sous la forme d'une chaîne C, le second
   argument est l'OID du type (sauf dans le cas des types tableau où il
   s'agit de l'OID du type de l'élément) et le troisième est le <literal>typmod</literal>
   de la colonne destination, s'il est connu (-1 sinon). La fonction entrée
   doit renvoyer une valeur du nouveau type de données.
   Habituellement, une fonction d'entrée devrait être déclarée comme STRICT&nbsp;
   si ce n'est pas le cas, elle sera appelée avec un premier paramètre NULL à
   la lecture d'une valeur NULL en entrée. La fonction doit toujours envoyer
   NULL dans ce cas, sauf si une erreur est rapportée.
   (Ce cas a pour but de supporter les fonctions d'entrée des domaines qui ont
   besoin de rejeter les entrées NULL.)
   La fonction sortie doit prendre un argument du nouveau type de données, et
   retourner le type <type>cstring</type>. Les fonctions sortie ne sont pas
   appelées pour des valeurs NULL.
  </para>

  <para>
   La <replaceable class="parameter">fonction_réception</replaceable>,
   optionnelle, convertit la représentation binaire externe du type en
   représentation interne.
   <!-- participate in binary input -->
   Si cette fonction n'est pas fournie, le type n'accepte pas
   d'entrée binaire. La représentation binaire est choisie de telle sorte
   que sa conversion en forme interne soit peu coûteuse, tout en restant
   portable. (Par exemple, les types de données
   standard entiers utilisent l'ordre réseau des octets comme représentation
   binaire externe alors que la représentation interne est dans l'ordre natif
   des octets de la machine.) La fonction de réception réalise les
   vérifications adéquates pour s'assurer que la valeur est valide. Elle
   peut être déclarée avec un argument de type
   <type>internal</type> ou trois arguments de types
   <type>internal</type>, <type>integer</type> et <type>oid</type>. Le premier
   argument est un pointeur vers un tampon <type>StringInfo</type>
   qui contient la chaîne d'octets reçue&nbsp;; les arguments optionnels sont les
   mêmes que pour la fonction entrée de type texte. La fonction de réception
   retourne une valeur du type de données.
   Habituellement, une fonction de réception devrait être déclarée comme STRICT&nbsp;
   si ce n'est pas le cas, elle sera appelée avec un premier paramètre NULL à
   la lecture d'une valeur NULL en entrée. La fonction doit toujours envoyer
   NULL dans ce cas, sauf si une erreur est rapportée.
   (Ce cas a pour but de supporter les fonctions de réception des domaines qui ont
   besoin de rejeter les entrées NULL.)
   De façon similaire, la
   <replaceable class="parameter">fonction_envoi</replaceable>, optionnelle,
   convertit la représentation interne en représentation
   binaire externe. Si cette fonction n'est pas fournie, le type
   <!-- participate in binary output -->
   n'accepte pas de sortie binaire. La fonction d'envoi doit être déclarée
   avec un argument du nouveau type de données et retourner le type <type>bytea</type>.
   Les fonctions réception ne sont pas appelées pour des valeurs NULL.
  </para>

  <para>
   À ce moment-là, vous pouvez vous demander comment les fonctions d'entrée et
   de sortie peuvent être déclarées avoir un résultat ou un argument du nouveau
   type alors qu'elles sont à créer avant que le nouveau type ne soit créé. La
   réponse est que le type sera tout d'abord défini en tant que
   <firstterm>type squelette</firstterm> (<foreignphrase>shell type</foreignphrase>),
   une ébauche de type sans propriété à part un nom et un propriétaire. Ceci se
   fait en exécutant la commande <literal>CREATE TYPE <replaceable>nom</replaceable></literal>
   sans paramètres supplémentaires. Ensuite, les fonctions d'entrée/sortie
   peuvent être définies en référençant le squelette. Enfin, le
   <command>CREATE TYPE</command> avec une définition complète remplace le
   squelette avec une définition complète et valide du type, après quoi le
   nouveau type peut être utilisé normalement.
  </para>

  <para>
   The optional
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   and <replaceable class="parameter">type_modifier_output_function</replaceable>
   are needed if the type supports modifiers, that is optional constraints
   attached to a type declaration, such as <literal>char(5)</literal> or
   <literal>numeric(30,2)</literal>.  <productname>PostgreSQL</productname> allows
   user-defined types to take one or more simple constants or identifiers as
   modifiers; however, this information must be capable of being packed into a
   single non-negative integer value for storage in the system catalogs.  The
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   is passed the declared modifier(s) in the form of a <type>cstring</type>
   array.  It must check the values for validity (throwing an error if they
   are wrong), and if they are correct, return a single non-negative
   <type>integer</type> value that will be stored as the column <quote>typmod</quote>.
   Type modifiers will be rejected if the type does not have a
   <replaceable class="parameter">type_modifier_input_function</replaceable>.
   The <replaceable class="parameter">type_modifier_output_function</replaceable>
   converts the internal integer typmod value back to the correct form for
   user display.  It must return a <type>cstring</type> value that is the exact
   string to append to the type name; for example <type>numeric</type>'s
   function might return <literal>(30,2)</literal>.
   It is allowed to omit the
   <replaceable class="parameter">type_modifier_output_function</replaceable>,
   in which case the default display format is just the stored typmod value
   enclosed in parentheses.
  </para>

  <para>
   La <replaceable class="parameter">fonction_analyse</replaceable>, optionnelle,
   calcule des statistiques spécifiques au type de données pour les
   colonnes de ce type. Par défaut, <command>ANALYZE</command> tente de
   récupérer des statistiques à l'aide des opérateurs d'<quote>égalité</quote> et
   d'<quote>infériorité</quote> du type, s'il existe une classe d'opérateur B-tree
   par défaut pour le type. Ce comportement est inadapté aux types non-scalaires&nbsp;;
   il peut être surchargé à l'aide d'une fonction
   d'analyse personnalisée. La fonction d'analyse doit être déclarée avec
   un seul argument de type <type>internal</type> et un résultat de type
   <type>boolean</type>. L'API détaillée des fonctions d'analyses est présentée dans
   <filename>src/include/commands/vacuum.h</filename>.
  </para>

  <para>
   Alors que les détails de la représentation interne du nouveau type ne sont
   connus que des fonctions d'entrées/sorties et des fonctions utilisateurs
   d'interaction avec le type, plusieurs propriétés de
   la représentation interne doivent être déclarées à
   <productname>PostgreSQL</productname>. La première est
   <replaceable class="parameter">longueurinterne</replaceable>. Les types de
   données basiques peuvent être de longueur fixe (dans ce cas, 
   <replaceable class="parameter">longueurinterne</replaceable> est un entier positif)
   ou de longueur variable (indiquée par le positionnement de 
   <replaceable class="parameter">longueurinterne</replaceable> à
   <literal>VARIABLE</literal>&nbsp;; en interne, cela est représenté en initialisant
   <literal>typlen</literal> à -1). La représentation interne de tous les types de
   longueur variable doit commencer par un entier de quatre octets indiquant la
   longueur totale de cette valeur.
  </para>

  <para>
   Le drapeau optionnel <literal>PASSEDBYVALUE</literal> indique que les
   valeurs de ce type de données sont passées par valeur plutôt que par
   référence. Les types dont la
   représentation interne est plus grande que la taille du type
   <type>Datum</type> (quatre octets sur la plupart des machines, huit sur
   quelques-unes) ne doivent pas être passés par valeur.
  </para>

  <para>
   Le paramètre <replaceable class="parameter">alignement</replaceable>
   spécifie l'alignement de stockage requis pour le type de données. Les
   valeurs permises sont des alignements sur 1, 2, 4 ou 8 octets.
   Les types de longueurs variables ont un alignement d'au
   moins quatre octets car leur premier composant est nécessairement un <type>int4</type>.
  </para>

  <para>
   Le paramètre <replaceable class="parameter">stockage</replaceable> permet de
   choisir une stratégie de stockage pour les types de données de longueur
   variable. (Seul <literal>plain</literal> est autorisé pour les types de
   longueur fixe.) <literal>plain</literal> indique des données
   stockées en ligne et non compressées.
   Dans le cas d'<literal>extended</literal> le système essaie tout d'abord de
   compresser une valeur longue et déplace la valeur hors de
   la ligne de la table principale si elle est toujours trop longue.
   <literal>external</literal> permet à la valeur d'être déplacée hors de la
   table principale mais le système ne tente pas de la compresser.
   <literal>main</literal> autorise la compression mais ne déplace
   la valeur hors de la table principale qu'en dernier recours.
   (Ils seront déplacés s'il n'est pas possible de placer la ligne 
   dans la table principale, mais
   sont préférentiellement conservés dans la table principale, contrairement aux éléments
   <literal>extended</literal> et <literal>external</literal>.)
  </para>

  <para>
   Une valeur par défaut peut être spécifiée dans le cas où l'utilisateur
   souhaite que cette valeur soit différente de NULL pour les colonnes de ce type.
   La valeur par défaut est précisée à l'aide du mot clé
   <literal>DEFAULT</literal>. (Une telle valeur par défaut peut être surchargée
   par une clause <literal>DEFAULT</literal> explicite attachée à une colonne
   particulière.)
  </para>

  <para>
   Pour indiquer qu'un type est un tableau, le type des éléments du
   tableau est précisé par le mot clé <literal>ELEMENT</literal>. Par exemple, pour
   définir un tableau d'entiers de quatre octets (<type>int4</type>),
   <literal>ELEMENT = int4</literal> est utilisé. Plus de détails sur les types
   tableau apparaissent ci-dessous.
  </para>

  <para>
   Pour préciser le délimiteur de valeurs utilisé dans la
   représentation externe des tableaux de ce type,
   <replaceable class="parameter">délimiteur</replaceable> peut être positionné à un
   caractère particulier. Le délimiteur par défaut est la virgule
   (<literal>,</literal>). Le délimiteur est associé avec le type
   élément de tableau, pas avec le type tableau.
  </para>

  </refsect2>

  <refsect2>
   <title>Types tableau</title>

   <para>
    Whenever a user-defined type is created,
    <productname>PostgreSQL</productname> automatically creates an
    associated array type, whose name consists of the base type's
    name prepended with an underscore, and truncated if necessary to keep
    it less than <symbol>NAMEDATALEN</symbol> bytes long.  (If the name
    so generated collides with an existing type name, the process is
    repeated until a non-colliding name is found.)
    This implicitly-created array type is variable length and uses the
    built-in input and output functions <literal>array_in</literal> and
    <literal>array_out</literal>.  The array type tracks any changes in its
    element type's owner or schema, and is dropped if the element type is.
   </para>

   <para>
    Pourquoi existe-t-il une option
    <option>ELEMENT</option> si le système fabrique automatiquement le bon type
    tableau ? 
    La seule utilité d'<option>ELEMENT</option> est la création d'un type de longueur
    fixe représenté en interne par un tableau d'éléments identiques auxquels on souhaite 
    accéder directement par leurs indices (en plus de toute autre opération 
    effectuée sur le type dans sa globalité). For example, type <type>point</type>
    is represented as just two floating-point numbers, which it allows to be
    accessed as <literal>point[0]</literal> and <literal>point[1]</literal>. Cette
    fonctionnalité n'est possible qu'avec les types de longueur fixe dont la
    forme interne est strictement une séquence de champs de longueur fixée.
    Un type de longueur variable est accessible par ses indices
    si sa représentation interne 
    généralisée est celle utilisée par <literal>array_in</literal> et <literal>array_out</literal>.
    Pour des raisons historiques (c'est-à-dire pour de mauvaises raisons, mais
    il est trop tard pour changer) les indices des tableaux de types de longueur
    fixe commencent à zéro et non à un comme c'est le cas pour les tableaux de
    longueur variable.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
     Le nom (éventuellement qualifié du nom du schéma) du type à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom_attribut</replaceable></term>
    <listitem>
     <para>
      Le nom d'un attribut (colonne) du type composite.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_données</replaceable></term>
    <listitem>
     <para>
      Le nom d'un type de données existant utilisé comme colonne du type
      composite.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">label</replaceable></term>
    <listitem>
     <para>
      A string literal representing the textual label associated with
      one value of an enum type.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_entrée</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      textuelle externe du type en forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_sortie</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      interne du type en forme textuelle externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_réception</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme binaire externe du type en
      forme interne.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">fonction_envoi</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction de conversion des données de la forme
      interne du type en forme binaire externe.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_modifier_input_function</replaceable></term>
    <listitem>
     <para>
      The name of a function that converts numeric modifier(s) for the type
      into internal form.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_modifier_output_function</replaceable></term>
    <listitem>
     <para>
      The name of a function that converts the internal form of the type's
      modifier(s) to external textual form.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">analyze_function</replaceable></term>
    <listitem>
     <para>
      Le nom d'une fonction d'analyses statistiques pour le type
      de données.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">longueurinterne</replaceable></term>
    <listitem>
     <para>
      Une constante numérique qui précise la longueur en octets de la
      représentation interne du nouveau type. Supposée variable par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alignement</replaceable></term>
    <listitem>
     <para>
      La spécification d'alignement du stockage du type de données. Peut être
      <literal>char</literal>, <literal>int2</literal>,
      <literal>int4</literal> ou <literal>double</literal>&nbsp;;
      <literal>int4</literal> par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">stockage</replaceable></term>
    <listitem>
     <para>
      La stratégie de stockage du type de données. Peut être <literal>plain</literal>,
      <literal>external</literal>,
      <literal>extended</literal> ou <literal>main</literal>&nbsp;;
      <literal>plain</literal> par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">défaut</replaceable></term>
    <listitem>
     <para>
      La valeur par défaut du type de données. Omise, elle est NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">élément</replaceable></term>
    <listitem>
     <para>
      Type des éléments du type tableau créé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">délimiteur</replaceable></term>
    <listitem>
     <para>
      Le caractère délimiteur des valeurs des tableaux de ce type.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="sql-createtype-notes">
  <title>Notes</title>

  <para>
   Comme il n'y a pas de restrictions à l'utilisation d'un type de données
   une fois qu'il a été créé, créer un type de base est équivalent à donner les
   droits d'exécution ssur les fonctions mentionnées dans la définition du
   type. (Le créateur du type a donc besoin de posséder ces fonctions.) Ce
   n'est pas un problème habituellement pour le genre de fonctions utiles
   dans la définition d'un type mais réfléchissez bien avant de concevoir
   un type d'une façon qui nécessiterait que des informations
   <quote>secrètes</quote> soient utilisées lors de sa convertion vers ou à
   partir d'une forme externe.
  </para>

  <para>
   Before <productname>PostgreSQL</productname> version 8.3, the name of
   a generated array type was always exactly the element type's name with one
   underscore character (<literal>_</literal>) prepended.  (Type names were
   therefore restricted in length to one less character than other names.)
   While this is still usually the case, the array type name may vary from
   this in case of maximum-length names or collisions with user type names
   that begin with underscore.  Writing code that depends on this convention
   is therefore deprecated.  Instead, use
   <structname>pg_type</structname>.<structfield>typarray</structfield> to locate the array type
   associated with a given type.
  </para>

  <para>
   It may be advisable to avoid using type and table names that begin with
   underscore.  While the server will change generated array type names to
   avoid collisions with user-given names, there is still risk of confusion,
   particularly with old client software that may assume that type names
   beginning with underscores always represent arrays.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> version 8.2, la syntaxe
   <literal>CREATE TYPE <replaceable>nom</replaceable></literal> n'existait pas.
   La façon de créer un nouveau type de base était de créer en premier les
   fonctions paramètres. Dans cette optique,
   <productname>PostgreSQL</productname> verra tout d'abord le nom d'un nouveau
   type de données comme type de retour de la fonction en entrée. Le type shell
   est créé implicitement dans ce cas et il est ensuite référencé dans le reste
   des fonctions d'entrée/sortie. Cette approche fonctionne toujours mais
   est obsolète et pourrait être interdite dans une version future. De plus,
   pour éviter de faire grossir les catalogues de façon accidentelle avec des
   squelettes de type erronés, un squelette sera seulement créé quand la fonction
   en entrée est écrit en C.
  </para>

  <para>
   Dans les versions de <productname>PostgreSQL</productname> antérieures à la
   7.3, la création d'un type coquille était habituellement évitée en remplaçant
   les références des fonctions au nom du type par le pseudotype <type>opaque</type>.
   Les arguments <type>cstring</type> et les résultats étaient également déclarés
   <type>opaque</type>. Pour supporter le chargement d'anciens
   fichiers de sauvegarde, <command>CREATE TYPE</command> accepte les fonctions
   d'entrées/sorties déclarées avec le pseudotype <type>opaque</type> mais un
   message d'avertissement est affiché. La déclaration de la fonction est
   également modifiée pour utiliser les bons types.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer un type composite utilisé dans la définition d'une
   fonction&nbsp;:
<programlisting>CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;
</programlisting>
  </para>

  <para>
   This example creates an enumerated type and uses it in
   a table definition:
<programlisting>
CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');

CREATE TABLE bug (
    serial id,
    description text,
    status bug_status
);
</programlisting>
  </para>

  <para>
   Créer le type de données basique <type>box</type> utilisé dans
   la définition d'une table&nbsp;:
<programlisting>CREATE TYPE box;

CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = ma_fonction_entree_box,
    OUTPUT = ma_fonction_sortie_box
);

CREATE TABLE myboxes (
    id integer,
    description box
);
</programlisting>
  </para>

  <para>
   Si la structure interne de <type>box</type> est un tableau de quatre
   éléments <type>float4</type>, on peut écrire&nbsp;:
<programlisting>CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = ma_fonction_entree_box,
    OUTPUT = ma_fonction_sortie_box,
    ELEMENT = float4
);
</programlisting>
   ce qui permet d'accéder aux nombres composant la valeur d'une boîte par
   les indices. Le comportement du type n'est pas modifié.
  </para>

  <para>
   Créer un objet large utilisé dans la définition d'une table&nbsp;:
<programlisting>CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);
</programlisting>
  </para>

  <para>
   D'autres exemples, intégrant des fonctions utiles 
   d'entrée et de sortie, peuvent être consultés dans <xref linkend="xtypes"/>.
  </para>
 </refsect1>

 <refsect1 id="sql-createtype-compatibility">
  <title>Compatibilité</title>

  <para>
   La commande <command>CREATE TYPE</command> présentée ici est une extension
   <productname>PostgreSQL</productname>. L'instruction
   <command>CREATE TYPE</command> du standard <acronym>SQL</acronym>
   est, dans le détail, assez différente.
  </para>
 </refsect1>

 <refsect1 id="sql-createtype-see-also">
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createfunction" endterm="sql-createfunction-title"/></member>
   <member><xref linkend="sql-droptype" endterm="sql-droptype-title"/></member>
   <member><xref linkend="sql-altertype" endterm="sql-altertype-title"/></member>
   <member><xref linkend="sql-createdomain" endterm="sql-createdomain-title"/></member>
  </simplelist>
 </refsect1>

</refentry>
