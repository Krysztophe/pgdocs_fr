<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_view.sgml,v 1.10 2005/09/15 07:03:26 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060612 : Relecture initiale -->

<refentry id="sql-createview">
 <refmeta>
  <refentrytitle id="sql-createview-title">CREATE VIEW</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE VIEW</refname>
  <refpurpose>définir une vue</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] VIEW <replaceable class="parameter">nom</replaceable> [ ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) ]
    AS <replaceable class="parameter">requête</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createview">
   <primary>CREATE VIEW</primary>
  </indexterm>

  <para>
   <command>CREATE VIEW</command> définit une vue d'après une requête. La
   vue n'est pas matérialisée physiquement. Au lieu de cela, la requête
   est lancée chaque fois qu'une vue est utilisée dans une requête.
  </para>

  <para>
   <command>CREATE OR REPLACE VIEW</command> a la même finalité, mais
   si une vue du même nom existe déjà, elle est remplacée. Une vue ne
   peut être remplacée que par une requête engendrant le même
   ensemble de colonnes (c'est-à-dire avec les mêmes noms de colonnes 
   et les même types de données).
  </para>

  <para>
   Si un nom de schéma est donné (par exemple
   <literal>CREATE VIEW monschema.mavue ...</literal>),
   alors la vue est créée dans ce schéma.
   Dans le cas contraire, elle est créée dans le schéma courant. Les vues
   temporaires existent dans un schéma spécial. Il n'est donc pas nécessaire
   de fournir de schéma pour les vues temporaires. Le
   nom de la vue doit être différent du nom de toute autre vue, table, séquence
   ou index du même schéma.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><literal>TEMPORARY</literal> ou <literal>TEMP</literal></term>
    <listitem>
     <para>
      La vue est temporaire. Celles-ci sont automatiquement supprimées
	  en fin de session. Les relations permanentes qui portent le même nom ne sont plus
      visibles pour la session tant que la vue temporaire existe, sauf
      s'il y est fait référence avec le nom du schéma.
     </para>

     <para>
      Si l'une des tables référencées par la vue est temporaire, la vue est alors elle-aussi
      temporaire (que <literal>TEMPORARY</literal> soit spécifié ou non).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
       Le nom de la vue à créer (éventuellement qualifié du nom du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">nom de colonne</replaceable></term>
    <listitem>
     <para>
      Une liste optionnelle de noms à utiliser pour les colonnes de la vue.
      Si elle n'est pas donnée, le nom des colonnes est déduit de la requête.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">requête</replaceable></term>
    <listitem>
     <para>
      Une requête (c'est-à-dire une instruction <command>SELECT</command>)
      qui fournit les colonnes et les lignes de la vue.
     </para>

     <para>
      On peut se référer à l'instruction <xref linkend="sql-select" endterm="sql-select-title"/>
	  pour obtenir de plus amples informations sur les requêtes valides.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    Actuellement, les vues sont en lecture seule&nbsp;: le système n'autorise
    pas une insertion, une mise à jour ou une suppression sur une vue.
	Les effets d'une vue actualisable peuvent être reproduits par la création
    de règles de réécriture des insertions, suppressions, mises à jour, etc. sur la vue en actions
    appropriées sur les autres tables. 
	<xref linkend="sql-createrule" endterm="sql-createrule-title"/>
	présente des informations utiles à ce propos.
   </para>

   <para>
    L'instruction <xref linkend="sql-dropview" endterm="sql-dropview-title"/>
	est utilisée pour supprimer les vues.
   </para>

   <para>
	Il est important de s'assurer que le nom et le type des colonnes de la vue
	correspondent à ce qui est souhaité. Ainsi,
<programlisting>CREATE VIEW vista AS SELECT 'Hello World';
</programlisting>
    présente deux défauts majeurs&nbsp;: le nom de la colonne prend la valeur implicite
	<literal>?column?</literal> et son type de données le type implicite <type>unknown</type>.
	Pour obtenir une chaîne de caractères dans le résultat de la vue, on peut écrire
<programlisting>CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
</programlisting>
   </para>

   <para>
    L'accès aux tables référencées dans la vue est déterminé par les droits
    du propriétaire de la vue.  Cependant, les fonctions appelées dans la vue
    sont traitées comme si elles étaient appelées directement
    par la requête utilisant la vue.  Par conséquent, l'utilisateur de la vue
    doit avoir le droit d'appeler toutes les fonctions utilisées par la vue.
   </para>

 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Créer une vue composée des comédies&nbsp;:

<programlisting>CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE genre = 'Comédie';
</programlisting>
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   Le standard SQL spécifie quelques possibilités supplémentaires pour
   l'instruction <command>CREATE VIEW</command>&nbsp;:
<synopsis>CREATE VIEW <replaceable class="parameter">nom</replaceable> [ ( <replaceable class="parameter">nom_colonne</replaceable> [, ...] ) ]
    AS <replaceable class="parameter">requête</replaceable>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
</synopsis>
  </para>

  <para>
   Les clauses optionnelles de la commande SQL complète sont&nbsp;:

   <variablelist>
     <varlistentry>
      <term><literal>CHECK OPTION</literal></term>
      <listitem>
       <para>
        Cette option concerne les vues actalisables.
        Toutes les commandes <command>INSERT</command> et <command>UPDATE</command>
        appliquées à la vue sont contrôlées pour s'assurer que les données
        satisfont les conditions de définition de la vue
        (les nouvelles données sont visibles au travers de la vue). 
		Si ce n'est pas le cas, la mise à jour est rejetée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LOCAL</literal></term>
      <listitem>
       <para>
        Contrôle d'intégrité de la vue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CASCADED</literal></term>
      <listitem>
       <para>
        Contrôle d'intégrité de la vue et de toutes les
        vues dépendantes. <literal>CASCADED</literal> est implicite si
        ni <literal>CASCADED</literal> ni <literal>LOCAL</literal> ne sont
        précisés.
       </para>
      </listitem>
     </varlistentry>
   </variablelist>
  </para>

  <para>
   <command>CREATE OR REPLACE VIEW</command> est une extension
   <productname>PostgreSQL</productname>, tout comme le concept de vue temporaire.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-dropview" endterm="sql-dropview-title"/></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
