<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/declare.sgml,v 1.10 2005/07/15 06:14:32 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060619 -->

<refentry id="sql-declare">
 <refmeta>
  <refentrytitle id="sql-declare-title">DECLARE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>DECLARE</refname>
  <refpurpose>Définir un curseur</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>DECLARE <replaceable class="parameter">nom</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ]
    CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">requête</replaceable>
    [ FOR { READ ONLY | UPDATE [ OF <replaceable class="parameter">colonnes</replaceable> [, ...] ] } ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-declare">
   <primary>DECLARE</primary>
  </indexterm>

  <indexterm zone="sql-declare">
   <primary>curseur</primary>
   <secondary>DECLARE</secondary>
  </indexterm>

  <para>
   <command>DECLARE</command> permet à un utilisateur de créer des curseurs.
   Ils peuvent être utilisés pour récupérer un petit nombre de lignes à la
   fois à partir d'une requête plus importante. Les curseurs peuvent renvoyer
   des données au format texte ou au format binaire par l'utilisation de 
   <xref linkend="sql-fetch" endterm="sql-fetch-title"/>.
  </para>

  <para>
   Les curseurs normaux renvoient des données au format texte, identique à
   celui produit par un <command>SELECT</command>. 
   Les données sont stockées nativement au format binaire, le système doit donc
   effectuer une conversion pour produire
   le format texte. Une fois l'information arrivée au format texte,
   le client peut être amené à la convertir au format binaire pour la manipuler. 
   De plus, les données au format texte sont souvent
   plus volumineuses qu'au format binaire. Les curseurs binaires renvoient
   les données dans une représentation binaire plus facilement
   manipulable. Néanmoins, pour afficher les données au format texte, 
   les récupérer au format texte peut faciliter le travail du client.
  </para>

  <para>
   Par exemple, dans le cas d'une requête renvoyant la valeur un
   extraite d'une colonne de type entier (integer), un curseur par
   défaut rend une chaîne <literal>1</literal> alors qu'un curseur binaire
   rend un champ de quatre octets qui contient la représentation
   interne de la valeur (dans l'ordre d'octets big-endian).
  </para>

  <para>
   Les curseurs binaires doivent être utilisés avec précaution. Beaucoup
   d'applications, dont <application>psql</application>, ne sont pas
   préparées pour gérer des curseurs binaires et attendent le
   retour des données au format texte.
  </para>

  <note>
   <para>
    Lorsque le client utilise le protocole de <quote>requête étendue</quote>
    pour exécuter une commande <command>FETCH</command>, le message du 
    protocole Bind indique le format de récupération de la donnée.
    Ce choix surcharge la définition du curseur. Le concept de curseur
    binaire est alors rendu obsolète &mdash; tout curseur peut être traité 
    comme textuel ou binaire.
   </para>
  </note>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom du curseur à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BINARY</literal></term>
    <listitem>
     <para>
      Le curseur retourne les données au format binaire.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INSENSITIVE</literal></term>
    <listitem>
     <para>
      Les données récupérées à partir du curseur ne doivent pas
      être affectées par les mises à jour des tables concernées par le curseur
      tant que celui-ci existe. Dans <productname>PostgreSQL</productname>, tous
      les curseurs sont inaltérables&nbsp;; ce mot-clé n'a actuellement aucun
      effet. Il est présent pour des raisons de compatibilité avec le standard SQL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SCROLL</literal></term>
    <term><literal>NO SCROLL</literal></term>
    <listitem>
     <para>
      <literal>SCROLL</literal> indique une utilisation possible du curseur
      pour récupérer des lignes de façon non séquentielle (c'est-à-dire en remontant
      la liste). En fonction de la complexité du plan d'exécution de la requête,
      <literal>SCROLL</literal> peut induire des pertes de
      performance sur le temps d'exécution de la requête.
	  <literal>NO SCROLL</literal> indique que le curseur ne peut pas être utilisé pour
      récupérer des lignes de façon non séquentielle. La valeur par
      défaut autorise la non-séquentialité du curseur dans certains cas&nbsp;; ce n'est pas la
      même chose que de spécifier <literal>SCROLL</literal>.
	  Voir <xref linkend="sql-declare-notes" endterm="sql-declare-notes-title"/> pour les
      détails.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH HOLD</literal></term>
    <term><literal>WITHOUT HOLD</literal></term>
    <listitem>
     <para>
      <literal>WITH HOLD</literal> (NDT&nbsp;: persistant) indique une utilisation possible
	  du curseur après la validation de la transaction qui l'a créé. 
      <literal>WITHOUT HOLD</literal> (NDT&nbsp;: volatil) interdit l'utilisation du curseur
      en dehors de la transaction qui l'a créé. 
      <literal>WITHOUT HOLD</literal> est la valeur par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">requête</replaceable></term>
    <listitem>
     <para>
      A <xref linkend="sql-select" endterm="sql-select-title"/> or
      <xref linkend="sql-values" endterm="sql-values-title"/> command
      which will provide the rows to be returned by the cursor.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FOR READ ONLY</literal></term>
    <term><literal>FOR UPDATE</literal></term>
    <listitem>
     <para>
      <literal>FOR READ ONLY</literal> indique une utilisation du curseur en
      mode lecture seule. <literal>FOR UPDATE</literal> indique que le curseur
      est utilisé pour actualiser des tables. Comme les mises à jour de
      curseur ne sont pas supportées actuellement dans
      <productname>PostgreSQL</productname>, <literal>FOR UPDATE</literal>
	  provoque un message d'erreur, <literal>FOR READ ONLY</literal> est sans effet.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">colonnes</replaceable></term>
    <listitem>
     <para>
      La (les) colonne(s) à mettre à jour par le curseur. Comme les mises à jour de
      curseur ne sont actuellement pas supportées dans
      <productname>PostgreSQL</productname>, la clause <literal>FOR UPDATE</literal>
	  provoque un message d'erreur.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les mots clés <literal>BINARY</literal>, <literal>INSENSITIVE</literal> et
   <literal>SCROLL</literal> peuvent apparaître dans n'importe quel ordre.
  </para>
 </refsect1>

 <refsect1 id="sql-declare-notes">
  <title id="sql-declare-notes-title">Notes</title>

   <para>
    Si la clause <literal>WITH HOLD</literal> n'est pas précisée, le curseur créé par
    cette commande ne peut être utilisé qu'à l'intérieur d'une transaction.
    Ainsi, <command>DECLARE</command> sans <literal>WITH HOLD</literal> est inutile à
    l'extérieur d'un bloc de transaction&nbsp;: le curseur survivrait seulement
    jusqu'à la fin de l'instruction. <productname>PostgreSQL</productname> 
    rapporte donc une erreur si cette commande 
    est utilisée en dehors d'un bloc de transactions.
	On utilise <xref linkend="sql-begin" endterm="sql-begin-title"/>,
	<xref linkend="sql-commit" endterm="sql-commit-title"/> et
	<xref linkend="sql-rollback" endterm="sql-rollback-title"/> pour définir un bloc de transaction.
   </para>
   <para>
    Si la clause <literal>WITH HOLD</literal> est précisée, et que la 
    transaction qui a créé le curseur est validée, ce dernier reste
    accessible par les transactions ultérieures de la session. 
    Au contraire, si la transaction initiale est annulée, le curseur est supprimé.
    Un curseur créé avec la clause <literal>WITH HOLD</literal> est fermé
    soit par un appel explicite à la commande <command>CLOSE</command>, soit
    par la fin de la session.
    Dans l'implantation actuelle, les lignes représentées par un
    curseur persistant (<literal>WITH HOLD</literal>) sont copiées dans un fichier 
    temporaire ou en mémoire afin de garantir leur disponibilité pour les transactions
    suivantes.
   </para>

   <para>
    L'option <literal>SCROLL</literal> est nécessaire à la définition de 
    curseurs utilisés en récupération remontante (retour dans la 
    liste des résultats, backward fetch), comme précisé par le
    standard SQL. Néanmoins, pour des raisons de compatibilité 
    avec les versions antérieures, <productname>PostgreSQL</productname> 
    autorise les récupérations remontantes sans que l'option
    <literal>SCROLL</literal> ne soit précisé, sous réserve que le plan
    d'exécution du curseur soit suffisamment simple pour être géré
    sans surcharge. Toutefois, il est fortement conseillé aux développeurs
    d'application ne pas utiliser les récupérations remontantes avec
    des curseurs qui n'ont pas été créés avec l'option <literal>SCROLL</literal>.
    Si <literal>NO SCROLL</literal> est spécifié, les récupérations remontantes
    sont toujours dévalidées.
   </para>

   <para>
    Le standard SQL ne mentionne les curseurs que pour le
    <acronym>SQL</acronym> embarqué. <productname>PostgreSQL</productname>
    n'implante pas l'instruction
    <command>OPEN</command> pour les curseurs&nbsp;; un curseur est considéré
    ouvert à sa déclaration. Néanmoins, <application>ECPG</application>, le
    préprocesseur de SQL embarqué pour <productname>PostgreSQL</productname>,
    supporte les conventions du standard SQL relatives aux curseurs, dont celles
    utilisant les instructions <command>DECLARE</command> et
    <command>OPEN</command>.
   </para>

   <para>
    Vous pouvez voir tous les curseurs disponibles en exécutant une requête sur
    la vue système <link
    linkend="view-pg-cursors"><structname>pg_cursors</structname></link>.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Déclarer un curseur&nbsp;:
<programlisting>DECLARE liahona CURSOR FOR SELECT * FROM films;
</programlisting>
   Voir <xref linkend="sql-fetch" endterm="sql-fetch-title"/> pour plus
   d'exemples sur l'utilisation des curseurs.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Le standard SQL n'autorise les curseurs que dans le
   <acronym>SQL</acronym> embarqué et dans les modules.
   <productname>PostgreSQL</productname> permet une utilisation 
   interactive des curseurs.
  </para>

  <para>
   Le standard SQL autorise les curseurs à mettre à jour les données d'une
   table. Tous les curseurs <productname>PostgreSQL</productname> sont en lecture seule.
  </para>

  <para>
   Les curseurs binaires sont une extension
   <productname>PostgreSQL</productname>.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-close" endterm="sql-close-title"/></member>
   <member><xref linkend="sql-fetch" endterm="sql-fetch-title"/></member>
   <member><xref linkend="sql-move" endterm="sql-move-title"/></member>
  </simplelist>
 </refsect1>
</refentry>
