<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060619 -->

<refentry id="sql-declare">
 <refmeta>
  <refentrytitle id="sql-declare-title">DECLARE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>DECLARE</refname>
  <refpurpose>Définir un curseur</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>DECLARE <replaceable class="parameter">nom</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ]
    CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">requête</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-declare">
   <primary>DECLARE</primary>
  </indexterm>

  <indexterm zone="sql-declare">
   <primary>curseur</primary>
   <secondary>DECLARE</secondary>
  </indexterm>

  <para>
   <command>DECLARE</command> permet à un utilisateur de créer des curseurs.
   Ils peuvent être utilisés pour récupérer un petit nombre de lignes à la
   fois à partir d'une requête plus importante.
   Après la création du curseur, les lignes sont récupérées en utilisant
   <xref linkend="sql-fetch" endterm="sql-fetch-title"/>.
  </para>

 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom du curseur à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BINARY</literal></term>
    <listitem>
     <para>
      Le curseur retourne les données au format binaire.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INSENSITIVE</literal></term>
    <listitem>
     <para>
      Les données récupérées à partir du curseur ne doivent pas
      être affectées par les mises à jour des tables concernées par le curseur
      qui surviennent une fois que ce dernier est créé. Dans
      <productname>PostgreSQL</productname>, c'est le comportement par
      défaut&nbsp;; ce mot-clé n'a aucun effet. Il est seulement accepté pour
      des raisons de compatibilité avec le standard SQL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SCROLL</literal></term>
    <term><literal>NO SCROLL</literal></term>
    <listitem>
     <para>
      <literal>SCROLL</literal> indique une utilisation possible du curseur
      pour récupérer des lignes de façon non séquentielle (c'est-à-dire en remontant
      la liste). En fonction de la complexité du plan d'exécution de la requête,
      <literal>SCROLL</literal> peut induire des pertes de
      performance sur le temps d'exécution de la requête.
	  <literal>NO SCROLL</literal> indique que le curseur ne peut pas être utilisé pour
      récupérer des lignes de façon non séquentielle. La valeur par
      défaut autorise la non-séquentialité du curseur dans certains cas&nbsp;; ce n'est pas la
      même chose que de spécifier <literal>SCROLL</literal>.
	  Voir <xref linkend="sql-declare-notes" endterm="sql-declare-notes-title"/> pour les
      détails.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH HOLD</literal></term>
    <term><literal>WITHOUT HOLD</literal></term>
    <listitem>
     <para>
      <literal>WITH HOLD</literal> (NDT&nbsp;: persistant) indique une utilisation possible
	  du curseur après la validation de la transaction qui l'a créé. 
      <literal>WITHOUT HOLD</literal> (NDT&nbsp;: volatil) interdit l'utilisation du curseur
      en dehors de la transaction qui l'a créé. 
      <literal>WITHOUT HOLD</literal> est la valeur par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">requête</replaceable></term>
    <listitem>
     <para>
      A <xref linkend="sql-select" endterm="sql-select-title"/> or
      <xref linkend="sql-values" endterm="sql-values-title"/> command
      which will provide the rows to be returned by the cursor.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les mots clés <literal>BINARY</literal>, <literal>INSENSITIVE</literal> et
   <literal>SCROLL</literal> peuvent apparaître dans n'importe quel ordre.
  </para>
 </refsect1>

 <refsect1 id="sql-declare-notes">
  <title id="sql-declare-notes-title">Notes</title>

  <para>
   Les curseurs normaux renvoient les données au format texte, le même que
   produirait un <command>SELECT</command>. L'option <literal>BINARY</literal>
   spécifie que le curseur doit renvoyer les données au format binaire. Ceci
   réduit les efforts de conversion pour le serveur et le client, au coût d'un
   effort particulier de développement pour la gestion des formats de données
   binaires dépendants des plateformes. Comme exemple, si une requête
   renvoie une valeur de un dans une colonne de type integer, vous obtiendrez
   une chaîne <literal>1</literal> avec un curseur par défaut. Avec un curseur
   binaire, vous obtiendrez un champ sur quatre octet contenant la
   représentation interne de la valeur (dans l'ordre big-endian).
  </para>

  <para>
   Les curseurs binaires doivent être utilisés en faisant très attention.
   Beaucoup d'applications, incluant <application>psql</application>, ne sont
   pas préparées à gérer des curseurs binaires et s'attendent à ce que les
   données reviennent dans le format texte.
  </para>

  <note>
   <para>
    Quand l'application cliente utilise le protocole des <quote>requêtes
    étendues</quote> pour exécuter la commande <command>FETCH</command>, le
    message Bind du protocole spécifie si les données sont à récupérer au
    format texte ou binaire. Ce choix surcharge la façon dont le curseur est
    défini. Le concept de curseur binaire est donc obsolète lors de l'utilisation
    du protocole des requêtes étendues &mdash; tout curseur peut être traité soit
    en texte soit en binaire.
   </para>
  </note>

   <para>
    Si la clause <literal>WITH HOLD</literal> n'est pas précisée, le curseur créé par
    cette commande ne peut être utilisé qu'à l'intérieur d'une transaction.
    Ainsi, <command>DECLARE</command> sans <literal>WITH HOLD</literal> est inutile à
    l'extérieur d'un bloc de transaction&nbsp;: le curseur survivrait seulement
    jusqu'à la fin de l'instruction. <productname>PostgreSQL</productname> 
    rapporte donc une erreur si cette commande 
    est utilisée en dehors d'un bloc de transactions.
	On utilise <xref linkend="sql-begin" endterm="sql-begin-title"/>,
	<xref linkend="sql-commit" endterm="sql-commit-title"/> et
	<xref linkend="sql-rollback" endterm="sql-rollback-title"/> pour définir un bloc de transaction.
   </para>
   <para>
    Si la clause <literal>WITH HOLD</literal> est précisée, et que la 
    transaction qui a créé le curseur est validée, ce dernier reste
    accessible par les transactions ultérieures de la session. 
    Au contraire, si la transaction initiale est annulée, le curseur est supprimé.
    Un curseur créé avec la clause <literal>WITH HOLD</literal> est fermé
    soit par un appel explicite à la commande <command>CLOSE</command>, soit
    par la fin de la session.
    Dans l'implantation actuelle, les lignes représentées par un
    curseur persistant (<literal>WITH HOLD</literal>) sont copiées dans un fichier 
    temporaire ou en mémoire afin de garantir leur disponibilité pour les transactions
    suivantes.
   </para>

   <para>
    <literal>WITH HOLD</literal> n'est pas utilisable quand la requête contient
    déjà <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal>.
   </para>

   <para>
    L'option <literal>SCROLL</literal> est nécessaire à la définition de 
    curseurs utilisés en récupération remontante (retour dans la 
    liste des résultats, backward fetch), comme précisé par le
    standard SQL. Néanmoins, pour des raisons de compatibilité 
    avec les versions antérieures, <productname>PostgreSQL</productname> 
    autorise les récupérations remontantes sans que l'option
    <literal>SCROLL</literal> ne soit précisé, sous réserve que le plan
    d'exécution du curseur soit suffisamment simple pour être géré
    sans surcharge. Toutefois, il est fortement conseillé aux développeurs
    d'application ne pas utiliser les récupérations remontantes avec
    des curseurs qui n'ont pas été créés avec l'option <literal>SCROLL</literal>.
    Si <literal>NO SCROLL</literal> est spécifié, les récupérations remontantes
    sont toujours dévalidées.
   </para>

   <para>
    Si la requête du curseur inclut les clauses <literal>FOR UPDATE</literal>
    ou <literal>FOR SHARE</literal>, alors les lignes renvoyées sont verrouillées
    au moment où elles sont récupérées, de la même façon qu'une commande
    <xref linkend="sql-select" endterm="sql-select-title"/> standard avec ces
    options.
    De plus, les lignes renvoyées seront les versions les plus à jour&nbsp;; du
    coup, ces options fournissent l'équivalent de ce que le standard SQL appelle
    un <quote>curseur sensible</quote>. Il est souvent conseillé d'utiliser
    <literal>FOR UPDATE</literal> si le cuseur doit être utilisé avec
    <command>UPDATE ... WHERE CURRENT OF</command> ou <command>DELETE ... WHERE
    CURRENT OF</command>, car cela empêchera les autres sessions de modifier
    les lignes entre le moment où elles ont été récupérées et le moment où elles
    ont été mises à jour. Sans <literal>FOR UPDATE</literal>, une commande
    <literal>WHERE CURRENT OF</literal> n'aura aucun effet si la ligne a été
    modifiée entre temps.
   </para>

   <para>
    <literal>SCROLL</literal> peut ne pas être indiqué quand la requête inclut
    <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal>.
   </para>

   <para>
    Le standard SQL ne mentionne les curseurs que pour le
    <acronym>SQL</acronym> embarqué. <productname>PostgreSQL</productname>
    n'implante pas l'instruction
    <command>OPEN</command> pour les curseurs&nbsp;; un curseur est considéré
    ouvert à sa déclaration. Néanmoins, <application>ECPG</application>, le
    préprocesseur de SQL embarqué pour <productname>PostgreSQL</productname>,
    supporte les conventions du standard SQL relatives aux curseurs, dont celles
    utilisant les instructions <command>DECLARE</command> et
    <command>OPEN</command>.
   </para>

   <para>
    Vous pouvez voir tous les curseurs disponibles en exécutant une requête sur
    la vue système <link
    linkend="view-pg-cursors"><structname>pg_cursors</structname></link>.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Déclarer un curseur&nbsp;:
<programlisting>DECLARE liahona CURSOR FOR SELECT * FROM films;
</programlisting>
   Voir <xref linkend="sql-fetch" endterm="sql-fetch-title"/> pour plus
   d'exemples sur l'utilisation des curseurs.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Le standard SQL indique que la sensibilité des curseurs aux mises à jour en
   parallèle des données récupérées est dépendante de l'implantation par défaut.
   Dans <productname>PostgreSQL</productname>, les curseurs n'ont pas ce
   comportement par défaut, mais peuvent le devenir en ajoutant <literal>FOR
   UPDATE</literal>. D'autres produits peuvent gérer cela différement.
  </para>

  <para>
   Le standard SQL n'autorise les curseurs que dans le
   <acronym>SQL</acronym> embarqué et dans les modules.
   <productname>PostgreSQL</productname> permet une utilisation 
   interactive des curseurs.
  </para>

  <para>
   Le standard SQL autorise les curseurs à mettre à jour les données d'une
   table. Tous les curseurs <productname>PostgreSQL</productname> sont en lecture seule.
  </para>

  <para>
   Les curseurs binaires sont une extension
   <productname>PostgreSQL</productname>.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-close" endterm="sql-close-title"/></member>
   <member><xref linkend="sql-fetch" endterm="sql-fetch-title"/></member>
   <member><xref linkend="sql-move" endterm="sql-move-title"/></member>
  </simplelist>
 </refsect1>
</refentry>
