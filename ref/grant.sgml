<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/grant.sgml,v 1.12 2005/09/15 07:03:27 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-GRANT">
 <refmeta>
  <refentrytitle id="sql-grant-title">GRANT</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>GRANT</refname>
  <refpurpose>définit les droits d'accès</refpurpose>
 </refnamediv>

 <indexterm zone="sql-grant">
  <primary>GRANT</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
GRANT { { SELECT | INSERT | UPDATE | DELETE | RULE | REFERENCES | TRIGGER }
    [,...] | ALL [ PRIVILEGES ] }
    ON [ TABLE ] <replaceable class="PARAMETER">nomtable</replaceable> [, ...]
    TO { <replaceable class="PARAMETER">nomutilisateur</replaceable> | GROUP <replaceable class="PARAMETER">nomgroupe</replaceable> | PUBLIC } [, ...] [ WITH
GRANT OPTION ]

GRANT { { CREATE | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] }
    ON DATABASE <replaceable>nombase</replaceable> [, ...]
    TO { <replaceable class="PARAMETER">nomutilisateur</replaceable> | GROUP <replaceable class="PARAMETER">nomgroupe</replaceable> | PUBLIC } [, ...] [ WITH
GRANT OPTION ]

GRANT { EXECUTE | ALL [ PRIVILEGES ] }
    ON FUNCTION <replaceable>nomfonction</replaceable> ( [ [ <replaceable class="parameter">modearg</replaceable> ] [ <replaceable class="parameter">nomarg</replaceable> ] <replaceable class="parameter">typearg</replaceable> [, ...] ] ) [, ...]
    TO { <replaceable class="PARAMETER">nomutilisateur</replaceable> | GROUP <replaceable class="PARAMETER">nomgroupe</replaceable> | PUBLIC } [, ...] [ WITH
GRANT OPTION ]

GRANT { USAGE | ALL [ PRIVILEGES ] }
    ON LANGUAGE <replaceable>nomlangage</replaceable> [, ...]
    TO { <replaceable class="PARAMETER">nomutilisateur</replaceable> | GROUP <replaceable class="PARAMETER">nomgroupe</replaceable> | PUBLIC } [, ...] [ WITH
GRANT OPTION ]

GRANT { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] }
    ON SCHEMA <replaceable>nomschéma</replaceable> [, ...]
    TO { <replaceable class="PARAMETER">nomutilisateur</replaceable> | GROUP <replaceable class="PARAMETER">nomgroupe</replaceable> | PUBLIC } [, ...] [ WITH
GRANT OPTION ]

GRANT { CREATE | ALL [ PRIVILEGES ] }
    ON TABLESPACE <replaceable>nomespacelogique</> [, ...]
    TO { <replaceable class="PARAMETER">nomutilisateur</replaceable> | GROUP <replaceable class="PARAMETER">nomgroupe</replaceable> | PUBLIC } [, ...] [ WITH
GRANT OPTION ]

GRANT <replaceable class="PARAMETER">role</replaceable> [, ...]
    TO { <replaceable class="PARAMETER">nomutilisateur</replaceable> | GROUP <replaceable class="PARAMETER">nomgroupe</replaceable> | PUBLIC } [, ...] [ WITH ADMIN OPTION ]
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-grant-description">
  <title>Description</title>

  <para>
   La commande <command>GRANT</command> a deux variantes basiques&nbsp;: une
   qui donne des droits sur un objet de la base de données (table, vue,
   séquence, base de données, fonction, langage de procédure, schéma ou espace
   logique), et une qui rend le rôle membre d'un autre rôle. Ces variantes sont
   similaires de plusieurs façons mais elles sont assez différentes pour être
   décrites séparément.
  </para>

  <para>
   A partir de <productname>PostgreSQL</productname> 8.1, les concepts
   d'utilisateurs et de groupes ont été unifiés en un seul type d'entité appelé
   un rôle. Du coup, il n'est plus nécessaire d'utiliser le mot clé 
   <literal>GROUP</> pour identifier si celui à qui s'applique le droit est un
   utilisateur ou un groupe. <literal>GROUP</> est toujours accepté dans la
   commande mais est inutile.
  </para>

 <refsect2 id="sql-grant-description-objects">
  <title>GRANT sur les objets de la base de données</title>

  <para>
   Cette variante de la commande <command>GRANT</command> donne des droits
   spécifiques sur un objet de la base de données pour un ou plusieurs rôles.
   Ces droits sont ajoutés à ceux déjà possédés.
  </para>

  <para>
   Le mot clé <literal>PUBLIC</literal> indique que les droits sont donnés à
   tous les rôles, y compris ceux qui seront créés ultérieurement.
   <literal>PUBLIC</literal> pourrait être vu comme un groupe implicitement
   défini qui inclut en permanence tous les rôles. Un rôle
   particulier dispose de la somme des droits qui lui sont acquis, des droits
   de tout rôle dont il est membre et des droits donnés à
   <literal>PUBLIC</literal>.
  </para>

  <para>
   Si <literal>WITH GRANT OPTION</literal> est spécifié, celui qui reçoit ce
   droit peut le donner à d'autres. Sans option GRANT, l'utilisateur ne peut
   pas le faire. Les options de droits ne peuvent pas être données à
   <literal>PUBLIC</literal>.
  </para>

  <para>
   Il n'y a pas besoin d'accorder des droits au propriétaire d'un objet
   (habituellement l'utilisateur qui l'a créé) car le propriétaire a tous les
   droits par défaut. (Le propriétaire pourrait, néanmoins, choisir de révoquer
   certains de ses propres droits.) Le droit de supprimer un objet ou de
   modifier sa définition n'est pas décrit par un droit
   donnable&nbsp;; il est inhérent au propriétaire et ne peut être ni donné ni
   enlevé. Le propriétaire a aussi toutes les options GRANT sur cet objet.
  </para>

  <para>
   Suivant le type de l'objet, <literal>PUBLIC</literal> peut avoir certains 
   droits initiaux par défaut. La valeur par
   défaut est aucun accès public aux tables, schémas et espaces logiques&nbsp;;
   droit de création de table <literal>TEMP</> pour les bases de données&nbsp;;
   droit <literal>EXECUTE</> pour les fonctions&nbsp;; et droit
   <literal>USAGE</> pour les langages. Le propriétaire de l'objet peut bien
   sûr choisir de révoquer ces droits. (Pour un maximum de sécurité, lancez
   <command>REVOKE</> dans la même transaction que la création de l'objet&nbsp;;
   ainsi, il n'y aura pas de laps temps pendant lequel un autre utilisateur 
   pourrait utiliser l'objet.)
  </para>

  <para>
   Les droits possibles sont&nbsp;:

   <variablelist>
    <varlistentry>
     <term>SELECT</term>
     <listitem>
      <para>
       Autorise <xref linkend="sql-select" endterm="sql-select-title"> parmi
       toutes les colonnes de la table, vue ou séquence spécifiée. Autorise
       aussi l'utilisation de <xref linkend="sql-copy" endterm="sql-copy-title">
       TO. Pour les séquences, ce droit permet aussi l'utilisation de la
       fonction <function>currval</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>INSERT</term>
     <listitem>
      <para>
       Autorise <xref linkend="sql-insert" endterm="sql-insert-title"> d'une
       nouvelle ligne dans la table spécifiée. Autorise aussi <xref
       linkend="sql-copy" endterm="sql-copy-title"> FROM.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>UPDATE</term>
     <listitem>
      <para>
       Autorise <xref linkend="sql-update" endterm="sql-update-title"> de toute
       colonne de la table spécifiée. <literal>SELECT ... FOR UPDATE</literal>
       et <literal>SELECT ... FOR SHARE</literal>
       requièrent aussi ce droit (en plus du droit <literal>SELECT</literal>).
       Pour les séquences, ce droit autorise l'utilisation des fonctions
       <function>nextval</function> et <function>setval</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>DELETE</term>
     <listitem>
      <para>
       Autorise <xref linkend="sql-delete" endterm="sql-delete-title"> d'une
       ligne pour la table spécifiée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>RULE</term>
     <listitem>
      <para>
       Autorise la création d'une règle sur la table/vue. (Voir l'instruction
       <xref linkend="sql-createrule" endterm="sql-createrule-title">.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>REFERENCES</term>
     <listitem>
      <para>
       Pour créer une contrainte de clé étrangère, il est nécessaire d'avoir ce
       droit sur la table de référence et sur celle référencée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>TRIGGER</term>
     <listitem>
      <para>
       Autorise la création d'un déclencheur sur la table spécifiée. (Voir
       l'instruction <xref linkend="sql-createtrigger"
       endterm="sql-createtrigger-title">.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>CREATE</term>
     <listitem>
      <para>
       Pour les bases de données, autorise la création de nouveaux schémas à
       l'intérieur de la base de données.
      </para>
      <para>
       Pour les schémas, autorise la création de nouveaux objets dans le schéma.
       Pour renommer un objet existant, vous devez être le propriétaire de
       l'objet <emphasis>et</> avoir ce droit pour le schéma qui le contient.
      </para>
      <para>
       Pour les espaces logiques (tablespaces), autorise la création 
       de tables et d'index à
       l'intérieur de l'espace logique et autorise la création de bases de
       données ayant cet espace logique par défaut. (Notez que révoquer ce
       privilège ne modifie pas l'emplacement des objets existants.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>TEMPORARY</term>
     <term>TEMP</term>
     <listitem>
      <para>
       Autorise la création de tables temporaires lors de l'utilisation
       de la base de données.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>EXECUTE</term>
     <listitem>
      <para>
       Autorise l'utilisation de la fonction spécifiée et l'utilisation de tout
       opérateur qui est implémenté avec cette fonction. C'est le seul type de
       droit qui est applicable aux fonctions. (Cette syntaxe fonctionne aussi
       pour les fonctions d'agrégat.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>USAGE</term>
     <listitem>
      <para>
       Pour les langages de procédures, autorise l'utilisation du langage
       spécifié pour la création de fonctions dans ce langage. Ceci est le seul
       type de droit applicable aux langages de procédures.
      </para>
      <para>
       Pour les schémas, autorise l'accès aux objets contenus dans le schéma
       spécifié (en supposant que les besoins de droits des objets propres sont
       aussi respectés). Essentiellement, ceci permet à celui ayant reçu le 
       droit de <quote>rechercher</> les objets contenus dans ce schéma.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>ALL PRIVILEGES</term>
     <listitem>
      <para>
       Donne tous les droits disponibles en une fois.
       Le mot clé <literal>PRIVILEGES</literal> est optionnel dans
       <productname>PostgreSQL</productname> bien qu'il soit requis par le SQL
       strict.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Les droits requis par d'autres commandes sont listés sur la page référencée
   de la commande respective.
  </para>
 </refsect2>


 <refsect2 id="sql-grant-description-roles">
  <title>GRANT sur les rôles</title>

  <para>
   Cette variante de la commande <command>GRANT</command> rend un ou plusieurs
   rôles membre(s) d'un autre rôle. L'appartenance à un rôle est significatif
   car il apporte tous les droits accordés à ce rôle à tous ses membres.
  </para>

  <para>
   Si <literal>WITH ADMIN OPTION</literal> est spécifié, le membre peut
   autoriser d'autres rôles à faire partie de ce rôle, and revoke membership
   in the role as well. Sans cette option, les utilisateurs standards ne peuvent
   pas le faire. Néanmoins, les superutilisateurs de la base de données peuvent
   donner ou supprimer l'appartenance à un rôle pour tout le monde. Les rôles
   ayant le droit <literal>CREATEROLE</> peuvent donner ou enlever une 
   appartenance à tout rôle qui n'est pas superutilisateur.
  </para>
 </refsect2>
 </refsect1>


 <refsect1 id="SQL-GRANT-notes">
  <title>Notes</title>

   <para>
    La commande <xref linkend="sql-revoke" endterm="sql-revoke-title"> est
    utilisée pour retirer les droits d'accès.
   </para>

   <para>
    Quand un utilisateur, non propriétaire d'un objet, essaie de donner les
    droits <command>GRANT</> de cet objet, la commande échoue si l'utilisateur
    n'a aucun droit sur l'objet. Si l'utilisateur dispose de droits, la
    commande continue mais ne donne que les droits pour lesquels l'utilisateur
    dispose de l'option GRANT. Les formes <command>GRANT ALL
    PRIVILEGES</> affichent un message d'avertissement si aucune option GRANT
    n'est détenue. (En principe, ces instructions s'appliquent aussi au
    propriétaire de l'objet mais, comme ce dernier est toujours traité comme
    détenant les options GRANT, le cas n'arrive jamais.)
   </para>

   <para>
    Il faut noter que les superutilisateurs de la base de données
    peuvent accéder à tous les objets sans paramétrage de droits sur les
    objets. Ceci est comparable aux droits de <literal>root</> sur un système
    Unix. Comme avec <literal>root</>, il est déconseillé d'opérer en tant que
    superutilisateur sauf lorsque cela est absolument nécessaire.
   </para>

   <para>
    Si un superutilisateur choisit de lancer une commande <command>GRANT</> ou
    <command>REVOKE</>, la commande est exécutée comme si elle avait été lancée
    par le propriétaire de l'objet affecté. En particulier, les droits donnés
    via une telle commande semblent avoir été donnés par le propriétaire de
    l'objet.
    (Pour l'appartenance à rôle, cela apparaît comme ayant été donné par le
    rôle fournisseur lui-même.)
   </para>

   <para>
    <command>GRANT</> et <command>REVOKE</> peuvent aussi se faire par un
    rôle qui n'est pas le propriétaire de l'objet affecté mais qui est un membre
    du rôle qui possède l'objet ou est un membre du rôle qui détient les droits
    <literal>WITH GRANT OPTION</literal> sur l'objet. Dans ce cas, les droits
    seront enregistrés comme ayant été donnés par le rôle qui possède
    actuellement l'objet ou détient les droits <literal>WITH GRANT
    OPTION</literal>. Par exemple, si la table <literal>t1</> appartient au
    rôle <literal>g1</>, dont le rôle <literal>u1</> est un membre, alors
    <literal>u1</> peut donner les droits sur <literal>t1</> à <literal>u2</>,
    mais ces droits apparaîtront comme étant donnés directement par
    <literal>g1</>. Tout autre membre du rôle <literal>g1</> pourrait les
    supprimer plus tard.
   </para>

   <para>
    Si le rôle exécutant <command>GRANT</> détient les droits requis
    indirectement via plus d'un chemin d'appartenance, le rôle enregistré n'est
    pas déterminable à l'avance. Dans de tels cas, le meilleur moyen d'utiliser
    <command>SET ROLE</> est de devenir le rôle spécifique que vous voulez
    trouver.
   </para>

   <para>
    Actuellement, <productname>PostgreSQL</productname> ne permet pas
    d'attribuer ou de révoquer des droits sur des colonnes individuelles d'une
    table. Un contournement possible est de créer une vue ayant les
    colonnes désirées et donner les droits GRANT sur cette vue.
   </para>

   <para>
    Utilisez la commande <command>\z</command> de <xref linkend="app-psql"> pour
    obtenir des informations sur les droits existants, par exemple&nbsp;:
<programlisting>
=&gt; \z matable

                        Access privileges for database "lusitania"
 Schema |  Name   | Type  |                     Access privileges
--------+---------+-------+-----------------------------------------------------
-------
 public | matable | table | {miriam=arwdRxt/miriam,=r/miriam,"group
todos=arw/miriam"}
(1 row)
</programlisting>
    Les entrées affichées par <command>\z</command> sont interprétées
    ainsi&nbsp;:
<programlisting>
              =xxxx -- droits donnés à PUBLIC
         uname=xxxx -- droits donnés à un utilisateur
   group gname=xxxx -- droits donnés à un groupe

                  r -- SELECT ("lecture")
                  w -- UPDATE ("écriture")
                  a -- INSERT ("ajout")
                  d -- DELETE
                  R -- RULE
                  x -- REFERENCES
                  t -- TRIGGER
                  X -- EXECUTE
                  U -- USAGE
                  C -- CREATE
                  T -- TEMPORARY
            arwdRxt -- ALL PRIVILEGES (pour les tables)
                  * -- option de droit pour le droit précédant

              /yyyy -- utilisateur qui a donné ce droit
</programlisting>

    L'affichage de l'exemple ci-dessus pourrait être vue par l'utilisatrice
    <literal>miriam</> après la création de la table <literal>matable</> et le
    lancement de

<programlisting>
GRANT SELECT ON matable TO PUBLIC;
GRANT SELECT, UPDATE, INSERT ON matable TO GROUP todos;
</programlisting>
   </para>

   <para>
   Si la colonne <quote>Access privileges</> est vide pour un objet donné, cela
   signifie que l'objet a les droits par défaut (c'est-à-dire que la
   colonne des droits est NULL). Les droits par défaut incluent toujours les
   droits pour le propriétaire et peuvent inclure quelques droits pour
   <literal>PUBLIC</> suivant le type d'objet comme expliqué ci-dessus. Le
   premier <command>GRANT</> ou <command>REVOKE</> sur un objet instancie les
   droits par défaut (produisant, par exemple,
   <literal>{=,miriam=arwdRxt/miriam}</>) puis les modifie par la requête
   spécifiée.
   </para>

   <para>
    Notez que les options GRANT implicites du propriétaire ne sont pas indiquées
    dans l'affichage des droits d'accès. Une <literal>*</> apparaît seulement
    lorsque des options GRANT ont été explicitement données à quelqu'un.
   </para>
 </refsect1>

 <refsect1 id="sql-grant-examples">
  <title>Exemples</title>

  <para>
   Donner le droit d'insertion à tous les utilisateurs sur la table
   <literal>films</literal>&nbsp;:

<programlisting>
GRANT INSERT ON films TO PUBLIC;
</programlisting>
  </para>

  <para>
   Donner tous les droits à l'utilisateur <literal>manuel</literal> pour la vue
   <literal>genres</literal>&nbsp;:

<programlisting>
GRANT ALL PRIVILEGES ON genres TO manuel;
</programlisting>

   Notez que, bien que la commande ci-dessus donne bien tous les droits si
   elle est exécutée par un superutilisateur ou par le propriétaire de
   <literal>genres</literal>, si elle est exécutée par quelqu'un d'autre, elle
   ne donne les droits qu'en accord avec ce que possède cet utilisateur.
  </para>

  <para>
   Faire que <literal>joe</> devienne un membre de <literal>admins</>&nbsp;:

<programlisting>
GRANT admins TO joe;
</programlisting>
  </para>
 </refsect1>

 <refsect1 id="sql-grant-compatibility">
  <title>Compatibilité</title>
    
   <para>
    Suivant le standard SQL, le mot clé <literal>PRIVILEGES</literal>
    dans <literal>ALL PRIVILEGES</literal> est requis. Le standard SQL ne
    supporte pas l'initialisation des droits de plus d'un objet par commande.
   </para>

   <para>
    <productname>PostgreSQL</productname> autorise un propriétaire d'objet
    à révoquer ses propres droits ordinaires&nbsp;: par exemple, le
    propriétaire d'un objet peut le placer en lecture seule pour lui-même en
    révoquant ses propres droits INSERT, UPDATE et DELETE. Ceci n'est pas
    possible d'après le standard SQL. La raison en est que 
    <productname>PostgreSQL</productname> traite les droits du propriétaire
    comme ayant été donnés par le propriétaire&nbsp;; du coup, il peut aussi les
    révoquer. Dans le standard SQL, les droits du propriétaires sont donnés par
    une entité <quote>_SYSTEM</>. Sans être <quote>_SYSTEM</>, le propriétaire
    ne peut pas révoquer ces droits.
   </para>

   <para>
    Le standard SQL autorise l'initialisation de droits pour des colonnes
spécifiques à l'intérieur d'une table&nbsp;:

<synopsis>
GRANT <replaceable class="PARAMETER">droits</replaceable>
    ON <replaceable class="PARAMETER">table</replaceable> [ ( <replaceable
class="PARAMETER">colonne</replaceable> [, ...] ) ] [, ...]
    TO { PUBLIC | <replaceable class="PARAMETER">nomutilisateur</replaceable> [,
...] } [ WITH GRANT OPTION ]
</synopsis>
   </para>

   <para>
    Le standard SQL fournit un droit <literal>USAGE</literal> sur d'autres
    types d'objets&nbsp;: ensembles de caractères, collations, traductions,
    domaines.
   </para>

   <para>
    Le droit <literal>RULE</literal> et les droits sur les bases de données,
    les espaces logiques, langages, schémas et séquences sont des extensions
    de <productname>PostgreSQL</productname>.
   </para>
 </refsect1>


 <refsect1>
  <title>Voir aussi</title>

  <simpara>
   <xref linkend="sql-revoke" endterm="sql-revoke-title">
  </simpara>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
