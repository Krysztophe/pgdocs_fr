<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/lock.sgml,v 1.10 2005/09/15 07:03:27 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-LOCK">
 <refmeta>
  <refentrytitle id="sql-lock-title">LOCK</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>LOCK</refname>
  <refpurpose>verrouille une table</refpurpose>
 </refnamediv>

 <indexterm zone="sql-lock">
  <primary>LOCK</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
LOCK [ TABLE ] <replaceable class="PARAMETER">nom</replaceable> [, ...] [ IN
<replaceable class="PARAMETER">mode_verrou</replaceable> MODE ] [ NOWAIT ]

où <replaceable class="PARAMETER">mode_verrou</replaceable> fait partie
de&nbsp;:

    ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE
    | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>LOCK TABLE</command> obtient un verrou de niveau table, attendant
   si nécessaire que tous les verrous en conflit soient lâchés. Si 
   <literal>NOWAIT</literal> est spécifié, <command>LOCK TABLE</command>
   n'attend pas l'acquisition du verrou désiré&nbsp;: s'il ne peut pas être
   obtenu immédiatement, la commande est annulée et une erreur est émise. Une
   fois obtenu, le verrou est gardé jusqu'à la fin de la transaction en cours.
   (Il n'y a pas de commande <command>UNLOCK TABLE</command>&nbsp;; les verrous
   sont toujours abandonnés à la fin de la transaction.)
  </para>

  <para>
   Lors de l'acquisition automatique de verrous pour les commandes qui
   référencent des tables, <productname>PostgreSQL</productname> utilise
   toujours le mode de verrou le moins restrictif possible. <command>LOCK
   TABLE</command> est fourni pour les cas où vous pourriez avoir besoin de
   verrous plus restrictifs. Par exemple, supposez qu'une application exécute
   une transaction au niveau d'isolation de lecture validé (Read Committed)
   pour s'assurer que
   les données de la table restent stables pendant la durée de la transaction.
   Pour réaliser ceci, vous pouvez obtenir un mode de verrou <literal>SHARE</>
   sur la table avant d'envoyer la requête. Ceci empêche toute modification
   concurrente des données et assure que les lectures de la table voient une
   vue stable des données validées parce que le mode de verrou <literal>SHARE</>
   est en conflit avec le verrou <literal>ROW EXCLUSIVE</> acquis par les
   modificateurs et votre instruction <command>LOCK TABLE <replaceable
   class="PARAMETER">nom</replaceable> IN SHARE MODE</command> attend jusqu'à
   ce que tous déteneurs concurrents de verrous en mode <literal>ROW
   EXCLUSIVE</literal> valident ou annulent. Du coup, une fois le verrou obtenu,
   il ne reste aucune écriture en attente&nbsp;; de plus, aucune ne peut
   commencer tant que vous n'avez pas supprimé le verrou.
  </para>

  <para>
   Pour obtenir un effet similaire lors de l'exécution d'une transaction au
   niveau d'isolation sérialisable, vous devez exécuter l'instruction
   <command>LOCK TABLE</> avant d'exécuter toute instruction
   <command>SELECT</command> ou toute instruction de modification de données. La
   vue des données par une transaction sérialisable des données est gelée à la
   première instruction <command>SELECT</command> ou à la première instruction
   de modification des données. Un <command>LOCK TABLE</> plus tard empêche
   toujours les écritures concurrentes &mdash; mais il n'assure pas que ce que
   la transaction lit correspond aux dernières données validées.
  </para>
  
  <para>
   Si une transaction de cette sorte va modifier les données de la table, alors
   elle doit utiliser le mode de verrou <literal>SHARE ROW EXCLUSIVE</> au
   lieu du mode <literal>SHARE</>. Ceci nous assure que seule une transaction de
   ce type est en exécution à la fois. Sans cela, un verrou mortel est
   possible&nbsp;: deux transactions pourraient acquérir à la fois le mode
   <literal>SHARE</> et être ensuite incapable d'acquérir aussi le mode
   <literal>ROW EXCLUSIVE</> pour réellement effectuer leur mises à jour. (Notez
   que les propres verrous d'une transaction ne sont jamais en conflit, donc une
   transaction peut acquérir le mode <literal>ROW EXCLUSIVE</> lorsqu'il tient
   le mode <literal>SHARE</> &mdash; mais pas si quelqu'un d'autre détient le
   mode <literal>SHARE</>.) Pour éviter les verrous bloquants, assurez-vous que
   toutes les transactions acquièrent des verrous sur les mêmes objets dans le
   même ordre, et si des modes multiples de verrous sont impliqués pour un seul
   objet, alors les transactions doivent toujours acquérir en premier le mode
   le plus restrictif.
  </para>

  <para>
   Plus d'informations sur les modes de verrou et les stratégies de verrouillage
   sont disponibles dans <xref linkend="explicit-locking">.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="PARAMETER">nom</replaceable></term>
    <listitem>
     <para>
      Le nom d'une table existante à verrouiller (pouvant être qualifié du nom
      du schéma).
     </para>

     <para>
      La commande <literal>LOCK a, b;</> est équivalente à <literal>LOCK a; LOCK
      b;</>. Les tables sont verrouillées une par une dans l'ordre spécifié dans
      la commande <command>LOCK TABLE</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">modeverrou</replaceable></term>
    <listitem>
     <para>
      Le mode verrou spécifie avec quels verrous ce verrou entre en conflit.
      Les modes de verrous sont décrits dans <xref linkend="explicit-locking">.
     </para>

     <para>
      Si aucun mode de verrou n'est spécifié, alors <literal>ACCESS
      EXCLUSIVE</literal>, le mode le plus restrictif, est utilisé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOWAIT</literal></term>
    <listitem>
     <para>
      Spécifie que <command>LOCK TABLE</command> n'attend pas que les verrous
      conflictuels soient annulés&nbsp;: si le verrou spécifié ne peut être
      acquis immédiatement, sans attendre, la transaction est annulée.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    <literal>LOCK TABLE ... IN ACCESS SHARE MODE</> requiert les droits
    <literal>SELECT</> sur la table cible. Tous les autres formats de
    <command>LOCK</> requièrent les droits <literal>UPDATE</> et/ou
    <literal>DELETE</>.
   </para>

   <para>
    <command>LOCK TABLE</command> est utile seulement dans un bloc de
    transaction (paire <command>BEGIN</>/<command>COMMIT</>), car le verrou est
    supprimé aussitôt que la transaction se termine. Une commande
    <command>LOCK</> apparaissant à l'extérieur de tout bloc de transaction
    forme une transaction contenue dans elle-même, donc le verrou est supprimé
    dès qu'il est obtenu.
   </para>

  <para>
   <command>LOCK TABLE</> s'occupe seulement des verrous au niveau table et du
   coup, les noms de mode impliquant <literal>ROW</> sont tous mal nommés. Ces
   noms de modes doivent généralement être compris comme indiquant l'intention de
   l'utilisateur d'acquérir des verrous de niveau ligne à l'intérieur de la
   table verrouillée. De plus, le mode <literal>ROW EXCLUSIVE</> est un verrou
   de table partageable. Gardez en tête que tous les modes de verrou ont des
   sémantiques identiques en ce qui concerne <command>LOCK TABLE</>,
   différant seulement dans les règles de conflit entre les modes. Pour des
   informations sur la façon d'acquérir un réel verrou au niveau ligne, voir
   <xref linkend="locking-rows"> et <xref linkend="sql-for-update-share"
   endterm="sql-for-update-share-title"> dans la documentation de référence de
   <command>SELECT</command>.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Exemples</title>

  <para>
   Obtenir un verrou <literal>SHARE</> sur une table avec clé primaire avant
   de réaliser des insertions dans une table disposant de la clé
   étrangère&nbsp;:

<programlisting>
BEGIN WORK;
LOCK TABLE films IN SHARE MODE;
SELECT id FROM films 
    WHERE nom = 'Star Wars: Episode I - The Phantom Menace';
-- Effectuer un ROLLBACK si aucun enregistrement n'est retourné
INSERT INTO commentaires_films VALUES 
    (_id_, 'SUPER ! Je l''attendais depuis si longtemps !');
COMMIT WORK;
</programlisting>
  </para>

  <para>
   Prendre un verrou <literal>SHARE ROW EXCLUSIVE</> sur une table avec clé
   primaire lors du début des opérations de suppression&nbsp;:

<programlisting>
BEGIN WORK;
LOCK TABLE films IN SHARE ROW EXCLUSIVE MODE;
DELETE FROM commentaires_films WHERE id IN
    (SELECT id FROM films WHERE score &lt; 5);
DELETE FROM films WHERE score &lt; 5;
COMMIT WORK;
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>
	  
  <para>
   <command>LOCK TABLE</command> n'existe pas dans le standard SQL, qui utilise
   à la place <command>SET TRANSACTION</command> pour spécifier des niveaux
   de concurrence sur les transactions. <productname>PostgreSQL</productname> a
   aussi cela&nbsp;; voir <xref linkend="SQL-SET-TRANSACTION"
   endterm="SQL-SET-TRANSACTION-TITLE"> pour les détails.
  </para>

  <para>
   Sauf pour les modes de verrous <literal>ACCESS SHARE</>, <literal>ACCESS
   EXCLUSIVE</> et <literal>SHARE UPDATE EXCLUSIVE</>, les modes de verrou
   <productname>PostgreSQL</productname> et la syntaxe
   <command>LOCK TABLE</command> sont compatibles avec ceux présents dans
   <productname>Oracle</productname>.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
