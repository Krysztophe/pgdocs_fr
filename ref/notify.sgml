<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/notify.sgml,v 1.10 2005/07/15 06:14:32 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="sql-notify">
 <refmeta>
  <refentrytitle id="sql-notify-title">NOTIFY</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>NOTIFY</refname>
  <refpurpose>génère une notification</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>NOTIFY <replaceable class="parameter">nom</replaceable>        
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-notify">
   <primary>NOTIFY</primary>
  </indexterm>

  <para>
   La commande <command>NOTIFY</command> envoie un événement de notification
   à chaque application cliente qui a exécuté précédemment la commande
   <command>LISTEN <replaceable class="parameter">nom</replaceable></command>
   pour le nom de notification spécifié dans la base de données courante.
  </para>

  <para>
   <command>NOTIFY</command> fournit une simple forme de signal ou un mécanisme
   de communication interprocessus pour une collection de processus accédant à
   la même base de données <productname>PostgreSQL</productname>. Des mécanismes
   de haut niveau peuvent être construit en utilisant les tables dans la base
   de données pour passer des données supplémentaires (en plus d'un simple nom de
   notification) du notifieur aux écouteurs.
  </para>

  <para>
   L'information passée au client pour un événement de notification inclut le
   nom de notification et le <acronym>PID</acronym> du processus serveur de la session
   le notifiant. C'est au concepteur de la base de données de définir les noms
   de notification qui sont utilisés dans une base de données donnée et ce
   que chacun signifie.
  </para>

  <para>
   Habituellement, le nom de notification est le même que le nom d'une table
   dans la base de données. L'événement notify signifie
   essentiellement <quote>J'ai modifié cette table, jetez-y un &oelig;il pour
   vérifier ce qu'il y a de nouveau</quote>. Mais cette signification n'est 
   pas imposée par les commandes <command>NOTIFY</command> et
   <command>LISTEN</command>. Par exemple, un concepteur de bases de données
   pourrait utiliser plusieurs noms de notification différentes pour signaler
   différentes sortes de modifications vers une seule table.
  </para>

  <para>
   Lorsque <command>NOTIFY</command> est utilisé pour signaler l'occurrence des
   modifications pour une table particulière, une technique de programmation
   utile est de placer le <command>NOTIFY</command> dans une règle qui est
   déclenchée par les mises à jour de table. De cette façon, la notification
   arrive automatiquement quand la table est modifiée et le programmeur
   d'application ne peut oublier accidentellement de le faire.
  </para>

  <para>
   <command>NOTIFY</command> interagit fortement avec les transactions SQL.
   Tout d'abord, si un <command>NOTIFY</command> est exécuté
   à l'intérieur d'une transaction, les événements notify ne sont pas délivrés
   jusqu'à ce que et à condition que la transaction soit validée. Ceci est
   approprié car, si la transaction est annulée, toutes les commandes qu'elle 
   contenait sont annulées, y compris <command>NOTIFY</command>. Mais, cela peut
   être déconcertant si on s'attend à ce que les événements de
   notification soient délivrés immédiatement. Ensuite, si une session
   en écoute reçoit un signal de notification alors qu'il est à l'intérieur
   d'une transaction, l'événement de notification n'est pas délivré au client
   connecté tant que la transaction n'est pas terminée (soit validée soit
   annulée). Encore une fois, le raisonnement est que si une notification a été
   délivrée à l'intérieur d'une transaction qui a été finalement annulée, 
   on voudrait que la notification soit annulée &mdash; 
   mais le serveur ne peut pas <quote>récupérer</quote> une notification une fois
   qu'elle a été envoyée au client. Donc, les événements de notification sont
   seulement délivrés entre les transactions. Ce qui en découle est que les
   applications utilisant <command>NOTIFY</command> pour des signaux en temps
   réel doivent essayer d'avoir des transactions courtes.
  </para>

  <para>
   <command>NOTIFY</command> se comporte comme les signaux Unix sur un seul
   point&nbsp;: si le même nom de notification est signalé plusieurs fois en
   des successions rapides, il est possible que les récepteurs ne reçoivent 
   qu'un seul événement de notification pour plusieurs exécutions de
   <command>NOTIFY</command>. Donc, c'est une mauvaise idée de dépendre du
   nombre de notifications reçues. À la place, utilisez <command>NOTIFY</command>
   pour réveiller vos applications qui ont besoin de faire attention à quelque
   chose et utilisez un objet de bases de données (tel qu'une séquence) pour
   garder trace de ce qui s'est passé ou du nombre de fois où cela s'est passé.
  </para>

  <para>
   Il est courant pour un client qui exécute <command>NOTIFY</command>
   d'écouter le même nom de notification lui-même. Dans ce cas, il récupère un
   événement de notification, comme toutes les autres sessions en écoute.
   Suivant la logique de l'application, ceci pourrait résulter en un travail
   inutile, par exemple lire une table de la base de données pour trouver les
   mêmes mises à jour que cette session a écrit. Il est possible d'éviter un
   travail supplémentaire verifiant si le <acronym>PID</acronym> du processus
   serveur de la session notifiante (fourni dans le message d'événement de la
   notification) est le même que le <acronym>PID</acronym> sur process serveur 
   de sa propre session
   (disponible à partir de <application>libpq</application>). Quand ils sont identiques,
   l'événement de notification est le retour de son propre travail et peut être
   ignoré. (En dépit de ce qui est dit dans le précédent paragraphe, c'est une
   technique sûre. <productname>PostgreSQL</productname> distingue les
   notifications propres des notifications arrivant des autres sessions, de
   façon à ne pas oublier une notification externe en ignorant vos propres
   notifications.)
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Nom de la notification à signaler (un identifiant).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Configure et exécute une séquence listen/notify à partir de
   <application>psql</application>&nbsp;:

<programlisting>LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448.
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'y a pas d'instruction <command>NOTIFY</command> dans le standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-listen" endterm="sql-listen-title"/></member>
   <member><xref linkend="sql-unlisten" endterm="sql-unlisten-title"/></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
