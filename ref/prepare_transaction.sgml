<!--
$PostgreSQL: pgsql/doc/src/sgml/ref/prepare_transaction.sgml,v 1.2 2005/08/01 19:38:03 momjian Exp $
PostgreSQL documentation
-->

<refentry id="SQL-PREPARE-TRANSACTION">
 <refmeta>
  <refentrytitle id="sql-prepare-transaction-title">PREPARE TRANSACTION</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>PREPARE TRANSACTION</refname>
  <refpurpose>prépare la transaction en cours pour une validation en deux
    phases</refpurpose>
 </refnamediv>

 <indexterm zone="sql-prepare-transaction">
  <primary>PREPARE TRANSACTION</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
PREPARE TRANSACTION <replaceable class="PARAMETER">id_transaction</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>PREPARE TRANSACTION</command> prépare la transaction en cours pour
   une validation en deux phases. Après cette commande, la transaction n'est
   plus associée avec la session courante&nbsp;; à la place, son état est
   complètement stockée sur disque et il y a une forte probabilité pour qu'elle
   puisse être validée avec succès, y compris si un arrêt brutal de la base de
   données survient avant la demande de validation.
  </para>

  <para>
   Une fois préparée, une transaction peut être validée ou annulée plus tard
   avec, respectivement, <command>COMMIT PREPARED</command> ou
   <command>ROLLBACK PREPARED</command>. Ces commandes peuvent être exécutées
   à partir d'une autre session, pas seulement celle qui a exécuté la
   transaction initiale.
  </para>

  <para>
   Du point de vue de la session initiale, <command>PREPARE
   TRANSACTION</command> n'est pas différente de la commande
   <command>ROLLBACK</>&nbsp;: après son exécution, il n'y a plus de transaction
   active et les effets de la transaction préparée ne sont plus visibles. (Les
   effets deviendront de nouveau visibles si la transaction est validée.)
  </para>

  <para>
   Si la commande <command>PREPARE TRANSACTION</command> échoue quelqu'en soit
   la raison, elle devient une commande <command>ROLLBACK</>&nbsp;: la
   transaction en cours est annulée.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="PARAMETER">id_transaction</replaceable></term>
    <listitem>
     <para>
      Un identifiant arbitraire qui identifiera après cette transaction pour les
      commandes <command>COMMIT PREPARED</> et <command>ROLLBACK PREPARED</>.
      L'identifiant doit être écrit comme une chaîne littérale et doit avoir
      une longueur inférieur à 200 octets. Il doit être différent de tout autre
      identifiant utilisé pour une autre transaction préparée.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Cette commande doit être utilisée dans un bloc de transaction. Utilisez
   <command>BEGIN</command> puor en commencer une.
  </para>

  <para>
   Il n'est actuellement pas autorisé de préparer (<command>PREPARE</>) une
   transaction qui a exécuté des opérations impliquant des tables temporaires ou
   qui a créé des curseurs <literal>WITH HOLD</>. Ces fonctionnalités sont trop
   intégrées à la session en cours pour être utiles dans une transaction
   préparée.
  </para>

  <para>
   Si la transaction a modifié des paramètres en exécution avec <command>SET</>,
   leurs effets persistent après <command>PREPARE TRANSACTION</> et ne seront
   pas affectés ensuite par les commandes <command>COMMIT PREPARED</command> et
   <command>ROLLBACK PREPARED</command>. Du coup, dans ce cas,
   <command>PREPARE TRANSACTION</> agit plus comme <command>COMMIT</> que comme
   <command>ROLLBACK</>.
  </para>

  <para>
   Toutes les transactions préparées actuellement disponibles sont listées dans
   la vue système <structname>pg_prepared_xacts</>.
  </para>

  <para>
   D'un point de vue des performances, il est déconseillé de laisser des 
   transactions trop longtemps dans l'état préparé&nbsp;: cela interfèrera avec
   la capacité de <command>VACUUM</> de réclamer de l'espace. Gardez aussi en
   tête que la transaction continue à contenir tout verrou qu'elle détient.
   L'usage visé de cette fonctionnalité est qu'une transaction préparée sera
   soit validée soit annulée aussitôt qu'un gestionnaire de transaction externe
   aura vérifié que les autres bases de données sont aussi préparées pour
   valider.
  </para>

  <para>
   Si vous avez une utilisation importante des transactions préparées, vous
   voudrez probablement augmenter la valeur de <xref
   linkend="guc-max-prepared-transactions"> car la valeur par défaut est assez
   petite (pour éviter de perdre des ressources pour ceux qui ne l'utilisent
   pas). Il est recommandé de mettre une valeur au moins identique à
   <xref linkend="guc-max-connections">, de façon à ce que chaque session puisse
   avoir une transaction préparée dans la queue.
  </para>
 </refsect1>

 <refsect1 id="sql-prepare-transaction-examples">
  <title id="sql-prepare-transaction-examples-title">Exemples</title>
  <para>
   Préparer la transaction en cours pour une validation en deux phases en
   utilisant <literal>foobar</> comme identifiant de transaction&nbsp;:
   
<programlisting>
PREPARE TRANSACTION 'foobar';
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-commit-prepared" endterm="sql-commit-prepared-title"></member>
   <member><xref linkend="sql-rollback-prepared" endterm="sql-rollback-prepared-title"></member>
  </simplelist>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
