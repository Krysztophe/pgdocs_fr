<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/reindex.sgml,v 1.12 2005/09/22 18:34:45 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-REINDEX">
 <refmeta>
  <refentrytitle id="SQL-REINDEX-TITLE">REINDEX</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>REINDEX</refname>
  <refpurpose>reconstruit les index</refpurpose>
 </refnamediv>

 <indexterm zone="sql-reindex">
  <primary>REINDEX</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
REINDEX { INDEX | TABLE | DATABASE | SYSTEM } <replaceable class="PARAMETER">nom</replaceable> [ FORCE ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>REINDEX</command> reconstruit un index en utilisant les données
   stockées dans la table, remplaçant l'ancienne copie de l'index. Il y a deux
   raisons principales pour utiliser <command>REINDEX</command>&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Un index a été corrompu et ne contient plus de données valides. Bien 
      qu'en théorie, ceci ne devrait jamais arriver, en pratique, les index
      peuvent se corrompre à cause de bogues dans le logiciel ou d'échecs
      matériels. <command>REINDEX</command> fournit une méthode de récupération.
     </para>
    </listitem>

    <listitem>
     <para>
      L'index en question contient beaucoup de pages d'index mortes qui ne sont
      pas réclamés. Ceci peut arriver avec des index B-tree dans
      <productname>PostgreSQL</productname> sous certains modèles d'accès.
      <command>REINDEX</command> fournit un moyen de réduire la consommation
      d'espace de l'index en écrivant une nouvelle version de l'index sans les
      pages mortes. Voir <xref linkend="routine-reindex"> pour plus
      d'informations.
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </refsect1>
  
 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><literal>INDEX</literal></term>
    <listitem>
     <para>
      Recrée l'index spécifié.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TABLE</literal></term>
    <listitem>
     <para>
      Recrée tous les index de la table spécifiée. Si la table a une seconde
      table <quote>TOAST</>, elle est aussi réindexée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DATABASE</literal></term>
    <listitem>
     <para>
      Recrée tous les index de la base de données en cours. Les index sur
      les catalogues système partagés ne sont pas pris en compte sauf dans le
      mode autonome (voir ci-dessous).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SYSTEM</literal></term>
    <listitem>
     <para>
      Recrée tous les index des catalogues système à l'intérieur de la base de
      données en cours. Les index des tables utilisateur ne sont pas traités.
      De plus, les index sur les catalogues système partagés ne sont pas pris
      compte sauf dans le mode autonome (voir ci-dessous).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">nom</replaceable></term>
    <listitem>
     <para>
      Le nom de l'index, de la table ou de la base de données spécifique à
      réindexer. Les noms de table et d'index peuvent être qualifiés du nom du
      schéma. Actuellement, <command>REINDEX DATABASE</command> et
      <command>REINDEX SYSTEM</command> ne peuvent réindexer que la base de
      données en cours, donc ce paramètre doit correspondre au nom de la
      base de données en cours.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE</literal></term>
    <listitem>
     <para>
      Ceci est une option obsolète&nbsp;; elle est ignorée si elle est
      spécifiée.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Si vous suspectez une corruption d'un index sur une table utilisateur, vous
   pouvez simplement reconstruire cet index, ou tous les index de la table, en
   utilisant <command>REINDEX INDEX</command> ou <command>REINDEX
   TABLE</command>.
  </para>

  <para>
   Les choses sont plus difficiles si vous avez besoin de récupérer de la
   corruption d'un index sur une table système. Dans ce cas, il est important
   pour le système de ne pas avoir utilisé lui-même un des index suspects. (En
   fait, dans ce type de scénario, vous pourriez trouver que les processus
   serveur s'arrêtent brutalement immédiatement au lancement, à cause du besoin
   des index corrompus.) Pour récupérer proprement, le serveur doit être lancé
   avec l'option <option>-P</option>, qui l'empêche d'utiliser les indexes pour
   les recherches dans les catalogues système.
  </para>

  <para>
   Une façon de faire ceci est d'arrêter le postmaster et de lancer le serveur
   <productname>PostgreSQL</productname> en mode autonome avec l'option
   <option>-P</option> placée sur la ligne de commande. Ensuite,
   <command>REINDEX DATABASE</>, <command>REINDEX SYSTEM</command>,
   <command>REINDEX TABLE</> ou <command>REINDEX INDEX</> peuvent être lancés
   suivant ce que vous souhaitez reconstruire. En
   cas de doute, utilisez <command>REINDEX SYSTEM</> pour sélectionner la
   reconstruction de tous les index système dans la base de données. Enfin,
   quittez la session autonome du serveur et relancez le serveur habituel. Voir
   la page de référence de <xref linkend="app-postgres"> pour plus
   d'informations sur l'interaction avec l'interface du serveur autonome.
  </para>

  <para>
   Une session standard du serveur peut aussi être lancée avec
   <option>-P</option> dans les options de la ligne de commande. La
   méthode pour ce faire varie entre les clients mais dans tous les clients
   basés sur <application>libpq</>, il est possible de configurer la variable
   d'environnement <envar>PGOPTIONS</envar> à <literal>-P</> avant de lancer le
   client. Notez que, bien que cette méthode ne verrouille 
   pas les autres clients, il est conseillé d'empêcher les autres
   utilisateurs de se connecter à la base de données endommagée jusqu'à la fin
   des réparations.
  </para>

  <para>
   Si une corruption est suspectée dans les index d'un des catalogues système
   partagés (qui sont <structname>pg_authid</structname>,
   <structname>pg_auth_members</structname>,
   <structname>pg_database</structname>,
   <structname>pg_pltemplate</structname>,
   <structname>pg_shdepend</structname> et
   <structname>pg_tablespace</structname>), alors un serveur autonome doit être
   utilisé pour le réparer. <command>REINDEX</> ne traite pas les catalogues
   partagées dans le mode multiutilisateur.
  </para>

  <para>
   Pour tous les index sauf les catalogues système partagés,
   <command>REINDEX</> est protégé contre les arrêts brutaux et utilise les
   transactions. <command>REINDEX</> n'est pas protégé pour les index partagés,
   ce qui explique pourquoi ce cas est désactivé pendant les opérations
   normales. Si un échec survient lors de la réindexation d'un de ces catalogues
   dans le mode autonome, il n'est pas possible de relancer le serveur
   en mode normal jusqu'à ce que le problème soit rectifié. (Le symptome
   typique d'un index partagé reconstruit partiellement est une erreur
   <quote>index n'est pas un btree</>.)
  </para>

  <para>
   <command>REINDEX</command> est similaire à une suppression et à une nouvelle
   création de l'index dans le fait que le contenu de l'index est complètement
   recréé. Néanmoins, les considérations de verrouillage sont assez
   différentes. <command>REINDEX</> verrouille les écritures mais pas les
   lectures de la table mère de l'index. Il prend aussi un verrou exclusif sur
   l'index en cours de traitement, ce qui bloque les lectures qui tentent
   d'utiliser l'index. Au contraire, <command>DROP INDEX</> crée temporairement
   un verrou exclusif sur la table parent, bloquant ainsi écritures et lectures.
   Le <command>CREATE INDEX</> qui suit verrouille les écritures mais pas les
   lectures&nbsp;; comme l'index n'existe pas, aucune lecture ne peut être
   tentée, signifiant qu'il n'y a aucun blocage et que les lectures sont
   probablement forcées de réaliser des parcours séquentiels complets. Un autre
   point important est que l'approche suppression/création invalide tous plans
   de requête en cache utilisant cet index, problème que <command>REINDEX</> ne
   connaît pas.
  </para>

  <para>
   Ré-indexer un seul index ou une seule table requiert d'être le propriétaire
   de cet index ou de cette table. Ré-indexer une base de données requiert
   d'être le propriétaire de la base de donénes (notez du coup que le
   propriétaire peut reconstruire les index de tables possédées par d'autres
   utilisateurs). Bien sûr, les superutilisateurs peuvent toujours tout
   ré-indexer.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 8.1, <command>REINDEX
   DATABASE</> traitait seulement les index systèmes, pas tous les index comme
   on pourrait le supposer d'après le nom. Ceci a été modifié pour réduire le
   facteur de surprise. L'ancien comportement est disponible en tant que
   <command>REINDEX SYSTEM</>.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 7.4, <command>REINDEX
   TABLE</> ne traitait pas automatiquement les tables TOAST et, du coup, elles
   devaient être réindexées par des commandes séparées. C'est toujours possible
   mais redondant.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Recrée les index sur la table <literal>ma_table</literal>&nbsp;:

<programlisting>
REINDEX TABLE ma_table;
</programlisting>
  </para>

  <para>
   Reconstruit un index simple&nbsp;:

<programlisting>
REINDEX INDEX my_index;
</programlisting>
  </para>

  <para>
   Reconstruit tous les index d'une base de données particulière sans
   faire confiance à la validité des index système&nbsp;:

<programlisting>
$ <userinput>export PGOPTIONS="-P"</userinput>
$ <userinput>psql broken_db</userinput>
...
broken_db=&gt; REINDEX DATABASE broken_db;
broken_db=&gt; \q
</programlisting>
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas de commande <command>REINDEX</command> dans le standard SQL.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->