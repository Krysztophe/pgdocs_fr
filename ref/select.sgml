<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/select.sgml,v 1.15 2005/09/15 07:03:28 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-SELECT">
 <refmeta>
  <refentrytitle id="sql-select-title">SELECT</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>SELECT</refname>
  <refpurpose>récupère des lignes d'une table ou d'une vue</refpurpose>
 </refnamediv>

 <indexterm zone="sql-select">
  <primary>SELECT</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="parameter">expression</replaceable> [, ...] ) ] ]
    * | <replaceable class="parameter">expression</replaceable> [ AS <replaceable class="parameter">nom_d_affichage</replaceable> ] [, ...]
    [ FROM <replaceable class="parameter">éléments_from</replaceable> [, ...] ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]
    [ GROUP BY <replaceable class="parameter">expression</replaceable> [, ...] ]
    [ HAVING <replaceable class="parameter">condition</replaceable> [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class="parameter">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC |
DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [, ...] ]
    [ LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL } ]
    [ OFFSET <replaceable class="parameter">début</replaceable> ]
    [ FOR { UPDATE | SHARE } [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ] ]

où <replaceable class="parameter">éléments_from</replaceable> fait partie de:

    [ ONLY ] <replaceable class="parameter">nom_table</replaceable> [ * ] [ [
AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable
class="parameter">alias_colonne</replaceable> [, ...] ) ] ]
    ( <replaceable class="parameter">select</replaceable> ) [ AS ] <replaceable
class="parameter">alias</replaceable> [ ( <replaceable
class="parameter">alias_colonne</replaceable> [, ...] ) ]
    <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable
class="parameter">argument</replaceable> [, ...] ] ) [ AS ] <replaceable
class="parameter">alias</replaceable> [ ( <replaceable
class="parameter">alias_colonne</replaceable> [, ...] | <replaceable
class="parameter">définition_colonne</replaceable> [, ...] ) ]
    <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable
class="parameter">argument</replaceable> [, ...] ] ) AS ( <replaceable
class="parameter">définition_colonne</replaceable> [, ...] )
    <replaceable class="parameter">éléments_from</replaceable> [ NATURAL ]
<replaceable class="parameter">type_jointure</replaceable> <replaceable
class="parameter">éléments_from</replaceable> [ ON <replaceable
class="parameter">condition_jointure</replaceable> | USING ( <replaceable
class="parameter">colonne_jointure</replaceable> [, ...] ) ]
</synopsis>

 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>SELECT</command> récupère des lignes à partir de zéro ou plusieurs
   tables. Le traitement général de <command>SELECT</command> est le
   suivant&nbsp;:

   <orderedlist>
    <listitem>
     <para>
      Tous les éléments de la liste <literal>FROM</literal> sont calculés.
      (Chaque élément dans la liste <literal>FROM</literal> est une table 
      réelle ou virtuelle.) Si plus d'un élément est spécifié dans la liste
      <literal>FROM</literal>, ils sont joints ensemble. (Voir <xref
      linkend="sql-from" endterm="sql-from-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>WHERE</literal> est spécifiée, toutes les lignes
      qui ne satisfont pas les conditions sont éliminées de l'affichage. (Voir
      <xref linkend="sql-where" endterm="sql-where-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>GROUP BY</literal> est spécifiée, l'affichage est
      divisé en groupes de lignes qui correspondent à une ou plusieurs valeurs.
      Si la clause <literal>HAVING</literal> est présente, elle élimine les
      groupes qui ne satisfont pas la condition donnée. (Voir <xref
      linkend="sql-groupby" endterm="sql-groupby-title"> et <xref
      linkend="sql-having" endterm="sql-having-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Les lignes en sortie sont traitées en utilisant les expressions de sortie
      de <command>SELECT</command> pour chaque ligne sélectionnée. (Voir <xref
      linkend="sql-select-list" endterm="sql-select-list-title"> ci-dessous.)
    </para>
    </listitem>

    <listitem>
     <para>
      En utilisant les opérateurs <literal>UNION</literal>,
      <literal>INTERSECT</literal> et <literal>EXCEPT</literal>, l'affichage de
      plus d'une instruction <command>SELECT</command> peut être combiné pour
      former un ensemble de résultats. L'opérateur <literal>UNION</literal>
      renvoie toutes les lignes qui sont dans un ou plusieurs ensembles de
      résultats. L'opérateur <literal>INTERSECT</literal> renvoie toutes les
      lignes qui sont dans les deux ensembles de résultats.
      L'opérateur <literal>EXCEPT</literal> renvoie les lignes qui sont
      présentes dans le premier ensemble de résultats mais pas dans le 
      deuxième. Dans les trois cas, les lignes dupliquées sont éliminées sauf
      si <literal>ALL</literal> est spécifié. (Voir <xref linkend="sql-union"
      endterm="sql-union-title">, <xref linkend="sql-intersect"
      endterm="sql-intersect-title"> et <xref linkend="sql-except"
      endterm="sql-except-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>ORDER BY</literal> est spécifiée, les lignes
      renvoyées sont triées dans l'ordre spécifié. Si <literal>ORDER
      BY</literal> n'est pas indiqué, les lignes sont renvoyées dans l'ordre 
      que le système trouve le plus rapide à fournir. (Voir <xref
      linkend="sql-orderby" endterm="sql-orderby-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      <literal>DISTINCT</literal> élimine les lignes dupliquées du résultat.
      <literal>DISTINCT ON</literal> élimine les lignes qui correspondent à
      toutes les expressions données. <literal>ALL</literal> (la valeur par
      défaut) renvoie toutes les lignes candidates, y compris les lignes
      dupliquées. (Voir <xref linkend="sql-distinct"
      endterm="sql-distinct-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si les clauses <literal>LIMIT</literal> ou <literal>OFFSET</literal> sont
      spécifiées, l'instruction <command>SELECT</command> ne renvoie qu'un
      sous-ensemble de lignes de résultats. (Voir <xref linkend="sql-limit"
      endterm="sql-limit-title"> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>FOR UPDATE</literal> ou <literal>FOR
      SHARE</literal> est spécifiée, l'instruction <command>SELECT</command>
      verrouille les lignes sélectionnées contre les mises à jour concurrentes.
      (Voir <xref linkend="sql-for-update-share"
      endterm="sql-for-update-share-title"> ci-dessous.)
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Vous devez avoir le droit <literal>SELECT</literal> sur une table pour lire
   ses valeurs. L'utilisation de <literal>FOR UPDATE</literal> ou de
   <literal>FOR SHARE</literal> requiert de plus le droit 
   <literal>UPDATE</literal>.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <refsect2 id="SQL-FROM">
   <title id="sql-from-title">Clause <literal>FROM</literal></title>

   <para>
    La clause <literal>FROM</literal> spécifie une ou plusieurs tables source
    pour <command>SELECT</command>. Si plusieurs sources sont spécifiées, le
    résultat est un produit cartésien (jointure croisée) de toutes les sources.
    Mais habituellement, des conditions de qualification sont ajoutées pour
    restreindre les lignes renvoyées à un petit sous-ensemble de produit
    cartésien.
   </para>

   <para>
    La clause <literal>FROM</literal> peut contenir les éléments
    suivants&nbsp;:

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">nom_table</replaceable></term>
      <listitem>
       <para>
        Le nom (pouvant être qualifié du nom du schéma) d'une table existante
	ou d'une vue. Si <literal>ONLY</> est spécifié, seule cette table est
	parcourue. Si <literal>ONLY</> n'est pas spécifié, la table et toutes ses
	descendantes (si elles existent) sont parcourues. <literal>*</> peut
	être ajouté au nom de la table pour indiquer que les tables descendantes
	doivent être parcourues mais, dans la version actuelle, c'est le
	comportement par défaut. (Dans les versions précédant la 7.1,
	<literal>ONLY</> était le comportement par défaut.) Le comportement par
	défaut peut être modifié en changeant l'option de configuration
	<xref linkend="guc-sql-inheritance">.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">alias</replaceable></term>
      <listitem>
       <para>
        Un nom de substitution pour l'élément <literal>FROM</> contenant
	l'alias. Un alias est utilisé par brièveté ou pour éliminer toute
	ambiguïté pour les jointures où la même table est parcourue plusieurs
	fois. Quand un alias est fourni, il cache complètement le nom réel de
	la table ou fonction&nbsp; ; par exemple, avec <literal>FROM foo AS
	f</>, le reste du <command>SELECT</command> doit faire référence à cet
	élément de <literal>FROM</> par <literal>f</> et non pas par
	<literal>foo</>. Si un alias est donné, une liste d'alias de colonnes
	peut aussi être saisi pour fournir des noms de substitution pour une ou
	plusieurs colonnes de la table.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">select</replaceable></term>
      <listitem>
       <para>
        Un sous-<command>SELECT</command> peut apparaître dans la clause
        <literal>FROM</literal>. Ceci agit comme si sa sortie était 
        transformée en
        une table temporaire pour la durée de cette seule commande
        <command>SELECT</command>. Notez que le sous-<command>SELECT</command>
        doit être entouré par des parenthèses et qu'un alias
        <emphasis>doit</emphasis> être fourni pour le 
        sous-<command>SELECT</command>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_fonction</replaceable></term>
      <listitem>
       <para>
        Des appels de fonctions peuvent apparaître dans la clause
	<literal>FROM</literal>. (Ceci est particulièrement utile pour les
	fonctions renvoyant des ensembles de résultats mais toute fonction peut
	être utilisée.) Ceci agit comme si la sortie était transformée en une table
	temporaire pour la durée de cette seule commande
	<command>SELECT</command>. Un alias peut aussi être utilisé. Si un
	alias est donné, une liste d'alias de colonnes peut être ajoutée pour
	fournir des noms de substitution pour un ou plusieurs attributs du type
	composé de retour de la fonction. Si la fonction a été définie comme
	renvoyant le type de données <type>record</>, alors un alias ou un mot
	clé <literal>AS</> doit être présent, suivi par une liste de définitions
	de colonnes de la forme <literal>( <replaceable
	class="parameter">nom_colonne</replaceable> <replaceable
	class="parameter">type_données</replaceable> <optional>, ... </>
	)</literal>. La liste de définitions de colonnes doit correspondre au
	nombre réel et aux types réels des colonnes renvoyées par la fonction.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">type_jointure</replaceable></term>
      <listitem>
       <para>
        Fait partie de
        <itemizedlist>
         <listitem>
          <para><literal>[ INNER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>LEFT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>RIGHT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>FULL [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>CROSS JOIN</literal></para>
         </listitem>
        </itemizedlist>

        Pour les types de jointures <literal>INNER</> et <literal>OUTER</>, une
	condition de jointure doit être spécifiée, parmi
        <literal>NATURAL</>, <literal>ON <replaceable
        class="parameter">condition_jointure</replaceable></literal> ou
        <literal>USING (<replaceable
        class="parameter">colonne_jointure</replaceable> [, ...])</literal>.
        Voir ci-dessous pour la signification. Pour <literal>CROSS
	JOIN</literal>, aucune de ces clauses ne doit apparaître.
       </para>

       <para>
        Une clause <literal>JOIN</literal> combine deux éléments
        <literal>FROM</>. Utilisez les parenthèses si nécessaire pour
	déterminer l'ordre d'imbrication. En l'absence de parenthèses,
	les <literal>JOIN</literal> sont imbriqués de gauche à droite. Dans
	tous les cas, <literal>JOIN</literal> est plus prioritaire que les
	virgules séparant les éléments <literal>FROM</>.
       </para>

       <para>
        <literal>CROSS JOIN</> et <literal>INNER JOIN</literal> produisent un
	simple produit cartésien, le même résultat que vous obtenez à partir de
	la liste de deux éléments au niveau haut du <literal>FROM</>, mais
	restreint par la condition de jointure (si elle existe). <literal>CROSS
	JOIN</> est équivalent à <literal>INNER JOIN ON (TRUE)</>, c'est-à-dire
	qu'aucune ligne n'est supprimée par qualification. Ces types de
	jointure sont juste une aide à la notation car ils ne font rien de
	plus qu'un simple <literal>FROM</> et <literal>WHERE</>.
       </para>

       <para>
        <literal>LEFT OUTER JOIN</> renvoie toutes les lignes dans le produit
	cartésien qualifié (c'est-à-dire toutes les lignes combinées qui
	réussissent la condition de jointure), plus une copie de chaque ligne
	dans le côté gauche de la table pour laquelle il n'y a pas de côté droit
	qui a réussi la condition de jointure. Cette ligne côté gauche est
	étendue à la largeur complète de la table jointe par insertion de
	valeurs NULL pour les colonnes côté droit. Notez que seule la
	condition de la clause <literal>JOIN</> est utilisée pour décider des
	lignes qui correspondent. Les conditions externes sont appliquées après
	coup.
       </para>

       <para>
        Au contraire, <literal>RIGHT OUTER JOIN</> renvoie toutes les lignes
	jointes plus une ligne pour chaque ligne côté droit sans correspondance
	(complétée par des NULL pour le côté gauche). Ceci est une simple aide à
	la notation car vous pourriez la convertir en <literal>LEFT</> en
	inversant les entrées gauche et droite.
       </para>

       <para>
        <literal>FULL OUTER JOIN</> renvoie toutes les lignes jointes, plus
	chaque ligne gauche sans correspondance (étendue par des NULL à droite),
	plus chaque ligne droite sans correspondance (étendue par des NULL à
	gauche).
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>ON <replaceable
class="parameter">condition_jointure</replaceable></literal></term>
      <listitem>
       <para>
        <replaceable class="parameter">condition_jointure</replaceable> est une
        expression qui renvoie une valeur de type <type>boolean</type>
	(similaire à une clause <literal>WHERE</literal>) qui spécifie quelles
	lignes d'une jointure doivent correspondre.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>USING (<replaceable
	class="parameter">colonne_jointure</replaceable> [,
	...])</literal></term>
      <listitem>
       <para>
        Une clause de la forme <literal>USING ( a, b, ... )</literal> est un
	raccourci pour <literal>ON left_table.a = right_table.a AND left_table.b
	= right_table.b ...</literal>. De plus, <literal>USING</> implique que
	seule une des paires de colonnes équivalentes est inclue dans la sortie
	de la jointure, pas les deux.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NATURAL</literal></term>
      <listitem>
       <para>
        <literal>NATURAL</literal> est un raccourci pour une liste
        <literal>USING</> qui mentionne toutes les colonnes dans les deux 
        tables qui ont le même nom.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
   
  <refsect2 id="SQL-WHERE">
   <title id="sql-where-title">Clause <literal>WHERE</literal></title>

   <para>
    La clause <literal>WHERE</literal> optionnelle a la forme générale
<synopsis>
WHERE <replaceable class="parameter">condition</replaceable>
</synopsis>
    où <replaceable class="parameter">condition</replaceable> est une 
    expression
    qui s'évalue en un résultat de type <type>boolean</type>. Toute ligne ne
    satisfaisant pas cette condition est éliminée de la sortie. Une ligne
    satisfait la condition si elle renvoie vrai quand les valeurs réelles
    de la ligne sont substituées à toute référence de variable.
   </para>
  </refsect2>
  
  <refsect2 id="SQL-GROUPBY">
   <title id="sql-groupby-title">Clause <literal>GROUP BY</literal></title>

   <para>
    La clause <literal>GROUP BY</literal> optionnelle a la forme générale
<synopsis>
GROUP BY <replaceable class="parameter">expression</replaceable> [, ...]
</synopsis>
   </para>

   <para>
    <literal>GROUP BY</literal> condense en une seule ligne toutes les lignes
    sélectionnées qui partagent les mêmes valeurs pour les expressions
    groupées. <replaceable class="parameter">expression</replaceable> peut être
    un nom de colonne en entrée, ou le nom ou le nombre ordinal d'une colonne
    en sortie (élément de la liste <command>SELECT</command>), ou une 
    expression
    arbitraire formée par des valeurs de colonnes en entrée. Dans le cas d'une
    ambiguïté, un nom <literal>GROUP BY</literal> est interprété comme un nom
    de colonne en entrée plutôt qu'un nom de colonne en sortie.
   </para>

   <para>
    Les fonctions d'agrégat, si elles sont utilisées, sont calculées pour
    toutes les lignes composant chaque groupe, produisant une valeur séparée
    pour chaque groupe (alors que sans <literal>GROUP BY</literal>, un agrégat
    produit une valeur unique calculée avec toutes les lignes
    sélectionnées). Quand <literal>GROUP BY</literal> est présent, il n'est pas
    valide que les expressions de liste <command>SELECT</command> fassent
    référence aux colonnes non groupées sauf à l'intérieur de fonctions
    d'agrégat car il y aurait plus d'une valeur possible à renvoyer pour une
    colonne non groupée.
   </para>
  </refsect2>

  <refsect2 id="SQL-HAVING">
   <title id="sql-having-title">Clause <literal>HAVING</literal></title>

   <para>
    La clause <literal>HAVING</literal> optionnelle a la forme générale
<synopsis>
HAVING <replaceable class="parameter">condition</replaceable>
</synopsis>
    où <replaceable class="parameter">condition</replaceable> est identique à
    celle spécifiée pour la clause <literal>WHERE</literal>.
   </para>
    
   <para>
    <literal>HAVING</literal> élimine les lignes groupées qui ne satisfont
    pas à la condition. <literal>HAVING</literal> est différent de
    <literal>WHERE</literal>&nbsp;: <literal>WHERE</literal> filtre les lignes
    individuelles avant l'application de <literal>GROUP BY</literal> alors que
    <literal>HAVING</literal> filtre les lignes groupées créées par
    <literal>GROUP BY</literal>. Chaque colonne référencée dans <replaceable
    class="parameter">condition</replaceable> doit référencer sans ambiguïté 
    une colonne groupée, sauf si la référence apparaît dans une fonction
    d'agrégat.
   </para>
    
   <para>
    La présence de <literal>HAVING</literal> transforme une requête en une
    requête groupée même s'il n'y a pas de clause <literal>GROUP BY</>. C'est
    identique à ce qui arrive quand la requête contient des fonctions
    d'agrégats mais pas de clause <literal>GROUP BY</>. Toutes les lignes
    sélectionnées sont considérées ne former qu'un seul groupe, et la liste
    <command>SELECT</command> et la clause <literal>HAVING</literal> peuvent
    seulement référencer les colonnes de table comprises dans les fonctions
    d'agrégat. De tels requêtes émettront une seule ligne si la condition
    <literal>HAVING</literal> est vraie, aucune ligne dans le cas contraire.
   </para>
  </refsect2>

  <refsect2 id="sql-select-list">
   <title id="sql-select-list-title">Liste <command>SELECT</command></title>

   <para>
    La liste <command>SELECT</command> (entre les mots clés
    <literal>SELECT</> et <literal>FROM</>) spécifie les expressions qui
    forment les lignes en sortie de l'instruction <command>SELECT</command>.
    Les expressions peuvent faire (et en général font) référence aux colonnes
    traitées dans la clause <literal>FROM</>. En utilisant la clause
    <literal>AS <replaceable 
    class="parameter">nom_sortie</replaceable></literal>,
    un autre nom peut être indiqué pour une colonne en sortie. Ce nom est
    principalement utilisé pour nommer la colonne à l'affichage. Il
    peut aussi être utilisé pour référencer la valeur de la colonne dans les
    clauses <literal>ORDER BY</> et <literal>GROUP BY</>, mais pas dans les
    clauses <literal>WHERE</> ou <literal>HAVING</>&nbsp;; là, vous devez
    écrire les expressions à la place.
   </para>

   <para>
    Au lieu d'une expression, on peut utiliser <literal>*</literal> dans la
    liste de sortie comme raccourci pour toutes les colonnes des lignes
    sélectionnées. De plus, vous pouvez écrire <literal><replaceable
    class="parameter">nom_table</replaceable>.*</literal> comme raccourci pour
    toutes les colonnes provenant de cette table.
   </para>
  </refsect2>

  <refsect2 id="SQL-UNION">
   <title id="sql-union-title">Clause <literal>UNION</literal></title>

   <para>
    La clause <literal>UNION</literal> a la forme générale&nbsp;:
<synopsis>
<replaceable class="parameter">instruction_select</replaceable> UNION [ ALL ]
<replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est toute
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</>,
    <literal>LIMIT</>, <literal>FOR SHARE</literal> ou <literal>FOR
    UPDATE</literal>. (<literal>ORDER BY</> et
    <literal>LIMIT</> peuvent être attachés à une sous-expression si elle est
    englobée
    dans des parenthèses. Sans parenthèses, ces clauses s'appliquent
    au résultat de l'<literal>UNION</literal>, et non pas à son
    expression côté droit.)
   </para>
    
   <para>
    L'opérateur <literal>UNION</literal> calcule l'union ensembliste des
    lignes renvoyées par les instructions <command>SELECT</command> impliquées.
    Une ligne est dans l'union de deux ensembles de résultats si elle apparaît
    dans au moins un des ensembles de résultats. Les deux instructions
    <command>SELECT</command> qui représentent les opérandes directs de
    l'<literal>UNION</literal> doivent produire le même nombre de colonnes et
    les colonnes correspondantes doivent être d'un type de données compatible.
   </para>
    
   <para>
    Le résultat de <literal>UNION</> ne doit pas contenir de lignes
    dupliquées sauf si l'option <literal>ALL</> est spécifiée. <literal>ALL</>
    empêche l'élimination des lignes dupliquées.  (Du coup, <literal>UNION
    ALL</> est significativement plus rapide qu'<literal>UNION</>&nbsp;;
    utilisez <literal>ALL</> quand vous le pouvez.)
   </para>
    
   <para>
    Plusieurs opérateurs <literal>UNION</> dans la même instruction
    <command>SELECT</command> sont évalués de gauche à droite sauf si c'est
    indiqué autrement par des parenthèses.
   </para>
    
   <para>
    Actuellement, <literal>FOR UPDATE</> et <literal>FOR SHARE</> ne peuvent
    pas être spécifié pour un résultat <literal>UNION</> ou pour toute entrée
    d'un <literal>UNION</>.
   </para>
  </refsect2>

  <refsect2 id="SQL-INTERSECT">
   <title id="sql-intersect-title">Clause <literal>INTERSECT</literal></title>

   <para>
    La clause <literal>INTERSECT</literal> a cette forme générale&nbsp;:
<synopsis>
<replaceable class="parameter">instruction_select</replaceable> INTERSECT [ ALL
] <replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est toute
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</>,
    <literal>LIMIT</>, <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</>.
   </para>

   <para>
    L'opérateur <literal>INTERSECT</literal> calcule l'intersection des lignes
    renvoyées par les instructions <command>SELECT</command> impliquées. Une
    ligne est dans l'intersection des deux ensembles de résultats si elle
    apparaît dans chacun des deux ensembles.
   </para>
    
   <para>
    Le résultat d'<literal>INTERSECT</literal> ne contient pas de lignes
    dupliquées sauf si l'option <literal>ALL</> est spécifiée. Avec
    <literal>ALL</>, une ligne qui a <replaceable>m</> lignes dupliquées dans
    la table gauche et <replaceable>n</> lignes dupliquées dans la table droite
    apparaît min(<replaceable>m</>,<replaceable>n</>) fois dans
    l'ensemble de résultats.
   </para>
    
   <para>
    Plusieurs <literal>INTERSECT</literal> dans la même instruction
    <command>SELECT</command> sont évalués de gauche à droite sauf si des
    parenthèses dictent le contraire. <literal>INTERSECT</literal> est plus 
    prioritaire que <literal>UNION</literal>. C'est-à-dire que <literal>A 
    UNION B INTERSECT C</literal> est lu comme <literal>A UNION (B INTERSECT
    C)</literal>.
   </para>

   <para>
    Actuellement, <literal>FOR UPDATE</> et <literal>FOR SHARE</> ne peuvent 
    pas être spécifiés pour un résultat d'<literal>INTERSECT</> ou pour une
    entrée d'<literal>INTERSECT</>.
   </para>
  </refsect2>

  <refsect2 id="SQL-EXCEPT">
   <title id="sql-except-title">Clause <literal>EXCEPT</literal></title>

   <para>
    La clause <literal>EXCEPT</literal> a cette forme générale&nbsp;:
<synopsis>
<replaceable class="parameter">instruction_select</replaceable> EXCEPT [ ALL ]
<replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est toute
    instruction <command>SELECT</command> sans clause <literal>ORDER
    BY</>, <literal>LIMIT</>, <literal>FOR UPDATE</literal> ou
    <literal>FOR SHARE</>.
   </para>

   <para>
    L'opérateur <literal>EXCEPT</literal> calcule l'ensemble de lignes qui sont
    dans le résultat de l'instruction <command>SELECT</command> de gauche mais
    pas dans le résultat de celle de droite.
   </para>
    
   <para>
    Le résultat de <literal>EXCEPT</literal> ne contient aucune ligne dupliquée
    sauf si l'option <literal>ALL</> est spécifiée. Avec <literal>ALL</>, une
    ligne qui a <replaceable>m</> dupliquées dans la table gauche et
    <replaceable>n</> dupliquées dans la table droite apparaît
    max(<replaceable>m</>-<replaceable>n</>,0) fois dans l'ensemble de 
    résultat.
   </para>
    
   <para>
    Plusieurs opérateurs <literal>EXCEPT</literal> dans la même instruction
    <command>SELECT</command> sont évalués de gauche à droite sauf si des
    parenthèses dictent le contraire. <literal>EXCEPT</> a la même priorité
    qu'<literal>UNION</>.
   </para>

   <para>
    Actuellement, <literal>FOR UPDATE</> et <literal>FOR SHARE</> ne peuvent 
    pas être spécifiés dans un résultat <literal>EXCEPT</> ou pour une entrée
    d'un <literal>EXCEPT</>.
   </para>
  </refsect2>

  <refsect2 id="SQL-ORDERBY">
   <title id="sql-orderby-title">Clause <literal>ORDER BY</literal></title>

   <para>
    La clause optionnelle <literal>ORDER BY</literal> a cette forme
    générale&nbsp;:
<synopsis>
ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC |
USING <replaceable class="parameter">opérateur</replaceable> ] [, ...]
</synopsis>
    <replaceable class="parameter">expression</replaceable> peut être le nom ou
    le numéro ordinal d'une colonne en sortie (élément de la liste
    <command>SELECT</command>) ou il peut être une expression quelconque formée
    à partir des valeurs des colonnes en entrée.
   </para>

   <para>
    La clause <literal>ORDER BY</literal> fait que les lignes de résultat 
    sont triées suivant les expressions données. Si deux lignes sont
    identiques suivant l'expression la plus à gauche, elles sont comparées avec
    l'expression suivante et ainsi de suite. Si elles sont identiques pour
    toutes les expressions de tri, elles sont renvoyées dans un ordre
    dépendant de l'implémentation.
   </para>

   <para>
    Le numéro ordinal fait référence à la position ordinale (de gauche à 
    droite) de la
    colonne de résultat. Cette fonctionnalité rend possible de définir un ordre
    sur la base d'une colonne qui n'a pas un nom unique. Ceci n'est jamais
    absolument nécessaire parce qu'il est toujours possible d'affecter un nom à
    une colonne résultat en utilisant la clause <literal>AS</>.
   </para>
    
   <para>
    Il est aussi possible d'utiliser des expressions quelconques dans la clause
    <literal>ORDER BY</literal>, incluant des colonnes qui n'apparaissent pas
    dans la liste de résultat du <command>SELECT</command>. Du coup,
    l'instruction suivante est valide&nbsp;:
<programlisting>
SELECT nom FROM distributeurs ORDER BY code;
</programlisting>
    Une limitation de cette fonctionnalité est que la clause <literal>ORDER
    BY</> s'appliquant au résultat d'une clause <literal>UNION</>,
    <literal>INTERSECT</> ou <literal>EXCEPT</> peut seulement spécifier
    un nom ou numéro de colonne en sortie, pas une expression.
   </para>
    
   <para>
    Si une expression <literal>ORDER BY</> est un simple nom qui correspond à
    la fois à un nom de colonne résultat et à un nom de colonne en entrée,
    <literal>ORDER BY</> l'interprète comme le nom de la colonne résultat.
    Ceci est le contraire du choix que <literal>GROUP BY</> fait dans la même
    situation. Cette incohérence est nécessaire pour être compatible avec le
    standard SQL.
   </para>
    
   <para>
    Optionnellement, vous pourriez ajouter le mot clé <literal>ASC</>
    (ascendant) ou <literal>DESC</> (descendant) après toute expression de la
    clause <literal>ORDER BY</>. Sans indication, <literal>ASC</> est la valeur
    supposée par défaut. Autrement, un nom d'opérateur d'ordre spécifique
    peut être fourni dans la clause <literal>USING</>. <literal>ASC</> est
    habituellement équivalent à <literal>USING &lt;</> et <literal>DESC</> est
    habituellement équivalent à <literal>USING &gt;</>. (Mais le créateur d'un
    type de données défini par l'utilisateur peut définir à sa guise le tri par
    défaut et il pourrait correspondre à des opérateurs de nom différent.)
   </para>

   <para>
    La valeur NULL est triée plus haut que toute autre valeur. En d'autres 
    termes,
    avec un ordre de tri ascendant, les valeurs NULL sont triées à la fin et
    avec un ordre de tri descendant, elles sont triées au début.
   </para>

   <para>
    Les données de chaînes de caractères sont triées suivant
    l'ordre spécifique à la locale, ordre établi au moment de la création du
    groupe de bases de données.
   </para>
  </refsect2>

  <refsect2 id="sql-distinct">
  <title id="sql-distinct-title">Clause <literal>DISTINCT</literal></title>

  <para>
   Si <literal>DISTINCT</> est spécifié, toutes les lignes dupliquées sont
   supprimées de l'ensemble de résultat (une ligne est conservée pour chaque
   groupe de lignes dupliquées). <literal>ALL</> spécifie le contraire&nbsp;:
   toutes les lignes sont conservées&nbsp;; ceci est la valeur par défaut.
  </para>

  <para>
   <literal>DISTINCT ON ( <replaceable
   class="parameter">expression</replaceable> [, ...] )</literal>
   conserve seulement la première ligne de chaque ensemble de lignes où les
   expressions sont évaluées comme identiques. Les expressions 
   <literal>DISTINCT
   ON</literal> sont interprétées en utilisant les mêmes règles que pour
   <literal>ORDER BY</> (voir ci-dessus). Notez que la <quote>première
   ligne</quote> de chaque ensemble n'est pas prévisible sauf si <literal>ORDER
   BY</> est utilisé pour s'assurer que la ligne désirée apparaît en premier. 
   Par exemple,
<programlisting>
  SELECT DISTINCT ON (emplacement) emplacement, heure, rapport
  FROM rapports_meteo
  ORDER BY emplacement, heure DESC;
</programlisting>
   récupère le rapport météo le plus récent pour chaque emplacement. Mais si
   nous n'avions pas utilisé <literal>ORDER BY</> pour forcer l'ordre
   descendant des valeurs heure pour chaque emplacement, nous aurions obtenu un
   rapport à partir d'une heure non prévisible pour chaque emplacement.
  </para>

  <para>
   Le(s) expression(s) <literal>DISTINCT ON</> doi(ven)t correspondre à
   l'ordre des expression <literal>ORDER BY</>. La clause <literal>ORDER
   BY</> contient normalement des expressions supplémentaires qui déterminent
   la précédence désirée des lignes à l'intérieur de chaque groupe
   <literal>DISTINCT ON</>.
  </para>
  </refsect2>

 <refsect2 id="SQL-LIMIT">
   <title id="sql-limit-title">Clause <literal>LIMIT</literal></title>

   <para>
    La clause <literal>LIMIT</literal> est constituée de deux sous-clauses
    indépendantes&nbsp;:
<synopsis>
LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL }
OFFSET <replaceable class="parameter">début</replaceable>
</synopsis>
    <replaceable class="parameter">nombre</replaceable> spécifie le nombre
    maximum de lignes à renvoyer alors que <replaceable
    class="parameter">début</replaceable> spécifie le nombre de lignes à passer
    avant de commencer à renvoyer des lignes. Quand les deux sont spécifiés,
    <replaceable class="parameter">début</replaceable> lignes sont passées 
    avant de commencer à compter les <replaceable
    class="parameter">nombre</replaceable> lignes à renvoyer.
   </para>

   <para>
    Lors de l'utilisation de <literal>LIMIT</>, utiliser la clause
    <literal>ORDER BY</> est une bonne idée pour contraindre les lignes de
    résultat en un ordre unique. Sinon, vous obtenez un sous-ensemble non
    prévisible de lignes de la requête &mdash; vous pouvez demander les 
    lignes 10 à 20 mais de la 10 à la 20 dans quel ordre&nbsp;? Vous ne savez
    pas l'ordre tant que vous ne le spécifiez pas avec <literal>ORDER BY</>.
   </para>

   <para>
    Le planificateur de requêtes prend <literal>LIMIT</> en compte lors de
    la génération d'un plan de requêtes, donc vous avez beaucoup de chances
    d'obtenir des plans différents (récupération d'ordre de lignes différents)
    suivant ce que vous utilisez pour <literal>LIMIT</> et <literal>OFFSET</>.
    Du coup, l'utilisation de valeurs différentes pour
    <literal>LIMIT</>/<literal>OFFSET</> pour sélectionner des sous-ensembles
    d'un résultat de requête <emphasis>donne éventuellement des résultats
    incohérents</emphasis> sauf si vous forcez un ordre de résultat prévisible
    avec <literal>ORDER BY</>. Ceci n'est pas un bogue&nbsp;; c'est une
    conséquence inhérente au fait que SQL ne promet pas de délivrer les
    résultats d'une requête dans un ordre particulier sauf si <literal>ORDER
    BY</> est utilisé pour forcer cet ordre.
   </para>
  </refsect2>

  <refsect2 id="SQL-FOR-UPDATE-share">
   <title id="sql-for-update-share-title">Clause <literal>FOR UPDATE</literal>/<literal>FOR SHARE</></title>

   <para>
    La clause <literal>FOR UPDATE</literal> a cette forme&nbsp;:
<synopsis>
FOR UPDATE [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ]
</synopsis>
   </para>

   <para>
    La clause très proche, <literal>FOR SHARE</literal>, a cette forme&nbsp;:
<synopsis>
FOR SHARE [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ]
</synopsis>
   </para>


   <para>
    <literal>FOR UPDATE</literal> fait que les lignes récupérées par
    l'instruction <command>SELECT</command> sont verrouillées pour
    modification.
    Ceci les empêche d'être modifiées ou supprimées par les autres transactions
    jusqu'à la fin de la transaction en cours. C'est-à-dire que les autres
    transactions tentant des <command>UPDATE</command>,
    <command>DELETE</command> ou <command>SELECT FOR UPDATE</command> de ces
    lignes sont bloquées jusqu'à ce que la transaction en cours se termine. De
    plus, si un <command>UPDATE</command>, <command>DELETE</command> ou
    <command>SELECT FOR UPDATE</command> à partir d'une autre transaction a
    déjà verrouillé une ligne ou un ensemble de lignes, <command>SELECT FOR
    UPDATE</command> attend la fin de l'autre transaction puis verrouille et
    renvoie la ligne modifiée (ou aucune ligne si elle a été supprimée). Pour
    plus d'informations, voir <xref linkend="mvcc">.
   </para>

   <para>
    Pour empêcher l'opération d'attendre la validation des autres transactions,
    utilisez l'option <literal>NOWAIT</>. <command>SELECT FOR UPDATE
    NOWAIT</command> rapporte une erreur plutôt que d'attendre si une ligne
    sélectionnée ne peut pas être verrouillée immédiatement. Notez que
    <literal>NOWAIT</> s'applique seulement au(x) verrou(x) niveau ligne
    &mdash; le verrou niveau table <literal>ROW SHARE</literal> est toujours
    pris de la façon ordinaire (voir <xref linkend="mvcc">). Vous pouvez
    utiliser l'option <literal>NOWAIT</> de <xref linkend="sql-lock"
    endterm="sql-lock-title"> si vous avez besoin d'acquérir le verrou niveau
    table sans attendre.
   </para>

   <para>
    <literal>FOR SHARE</literal> se comporte de façon similaire sauf qu'il
    acquiert un verrou partagé plutôt qu'exclusif sur chaque ligne récupérée.
    Un verrou partagée bloque les autres transactions lors de l'exécution
    des instructions <command>UPDATE</command>, <command>DELETE</command> ou
    <command>SELECT FOR UPDATE</command> sur ces lignes mais il ne les empêche
    pas de lancer des <command>SELECT FOR SHARE</command>.
   </para>

   <para>
    Il n'est actuellement pas autorisé pour une seule instruction
    <command>SELECT</command> d'inclure à la fois une clause <literal>FOR
    UPDATE</literal> et une clause <literal>FOR SHARE</literal>, pas plus que
    différentes parties de l'instruction ne pourraient utiliser à la fois le
    mode <literal>NOWAIT</> et le mode d'attente normal.
   </para>

   <para>
    Si des tables spécifiques sont nommées dans <literal>FOR UPDATE</literal>
    ou <literal>FOR SHARE</literal>,
    alors seules les lignes provenant de ces tables sont verrouillées&nbsp;
    toute autre table utilisée dans le <command>SELECT</command> est simplement
    lue comme d'habitude.
   </para>

   <para>
    <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> ne peuvent
    pas être utilisées dans les contextes où les lignes renvoyées ne peuvent
    pas être clairement identifiées avec des lignes d'une table
    individuelle&nbsp;; par exemple, ces options ne peuvent pas être utilisées
    avec des agrégats.
   </para>

   <para>
    Il est possible pour une commande <command>SELECT</> utilisant les deux
    clauses <literal>LIMIT</literal> et <literal>FOR UPDATE/SHARE</literal> de
    renvoyer moins de lignes que celles spécifiées par <literal>LIMIT</literal>.
    Ceci est dû au fait que <literal>LIMIT</> s'applique en premier. La
    commande sélectionne le nombre spécifié de lignes puis pourrait ensuite
    bloquée en essayant d'obtenir le verrou sur une ou plusieurs d'entre elles.
    Une fois que <literal>SELECT</> les a déverrouillé, la ligne pourrait avoir
    été supprimée ou mise à jour et ne plus correspondre du coup à la condition
    <literal>WHERE</>, auquel cas elle ne serait plus renvoyée.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Pour joindre la table <literal>films</literal> avec la table
   <literal>distributeurs</literal>&nbsp;:

<programlisting>
SELECT f.titre, f.did, d.nom, f.date_prod, f.genre
    FROM distributeurs d, films f
    WHERE f.did = d.did

       titre       | did |     nom      | date_prod  |   genre
-------------------+-----+--------------+------------+------------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drame
 The African Queen | 101 | British Lion | 1951-08-11 | Romantique
 ...
</programlisting>
  </para>

  <para>
   Pour additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal>&nbsp;:

<programlisting>
SELECT genre, sum(longueur) AS total FROM films GROUP BY genre;

   genre    | total
------------+-------
 Action     | 07:34
 Comédie    | 02:58
 Drame      | 14:28
 Musical    | 06:42
 Romantique | 04:38
</programlisting>
  </para>

  <para>
   Pour additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal> et afficher les groupes 
   dont les totaux font moins de cinq heures&nbsp;:

<programlisting>
SELECT genre, sum(longueur) AS total
    FROM films
    GROUP BY genre
    HAVING sum(longueur) &lt; interval '5 hours';

   genre    | total
------------+-------
 Comedie    | 02:58
 Romantique | 04:38
</programlisting>
  </para>

  <para>
   Les deux exemples suivants sont des façons identiques de trier les résultats
   individuels suivant le contenu de la deuxième colonne
   (<literal>nom</literal>)&nbsp;:

<programlisting>
SELECT * FROM distributeurs ORDER BY nom;
SELECT * FROM distributeurs ORDER BY 2;

 did |       nom
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
</programlisting>
  </para>

  <para>
   Le prochain exemple montre comment obtenir l'union des tables
   <literal>distributeurs</literal> et <literal>acteurs</literal>, restreignant
   les résultats à ceux commençant avec la lettre W dans chaque table. Seules
   les lignes distinctes sont voulues, du coup le mot clé
   <literal>ALL</literal> est omis.

<programlisting>
distributeurs:               acteurs:
 did |     nom               id |     nom
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributeurs.nom
    FROM distributeurs
    WHERE distributeurs.nom LIKE 'W%'
UNION
SELECT actors.nom
    FROM acteurs
    WHERE acteurs.nom LIKE 'W%';

      nom
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
</programlisting>
  </para>

  <para>
   Cet exemple montre comment utiliser une fonction dans la clause
   <literal>FROM</>, à la fois avec et sans une liste de définition de
   colonnes&nbsp;:

<programlisting>
CREATE FUNCTION distributeurs(int) RETURNS SETOF distributeurs AS $$
    SELECT * FROM distributeurs WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributeurs(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributeurs_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributeurs WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributeurs_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
</programlisting>
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   Bien sûr, l'instruction <command>SELECT</command> est compatible avec le
   standard SQL. Mais il y a des extensions et quelques fonctionnalités
   manquantes.
  </para>
  
  <refsect2>
   <title>Clauses <literal>FROM</literal> omises</title>

   <para>
    <productname>PostgreSQL</productname> vous permet d'omettre la clause
    <literal>FROM</literal>. Cela permet par exemple de calculer le
    résultat d'expressions simples&nbsp;:
<programlisting>
SELECT 2+2;

 ?column?
----------
        4
</programlisting>
    D'autres bases de données <acronym>SQL</acronym> ne le permettent pas,
    sauf en introduisant une table d'une seule ligne à partir de laquelle la
    commande <command>SELECT</command> s'exécute.
   </para>

   <para>
    Notez que s'il n'y a pas de clause <literal>FROM</literal>, la requête ne
    peut pas référencer les tables de la base de données. Par exemple, la
    requête suivant est invalide&nbsp;:
<programlisting>
SELECT distributors.* WHERE distributors.name = 'Westward';
</programlisting>
    Les versions précédant <productname>PostgreSQL</productname> 8.1 auraient
    acceptées des requêtes de cette forme et ajouter une entrée implicite à
    la clause <literal>FROM</literal> de cette requête pour chaque table
    référencée par la requête. Ce n'est plus le comportement par défaut
    parce qu'il n'est pas compatible avec le standard SQL et qu'il est
    considéré comme générateur d'erreurs par beaucoup trop de gens. Pour des
    raisons de compatibilité avec les applications qui se basent sur ce
    comportement, la variable de configuration <xref
    linkend="guc-add-missing-from"> peut toujours être activée.
   </para>
  </refsect2>

  <refsect2>
   <title>Mot clé <literal>AS</literal></title>

   <para>
    Dans le SQL standard, le mot clé optionnel <literal>AS</> est seulement du
    bruit et peut être omis sans affecter la signification. L'analyseur 
    <productname>PostgreSQL</productname> requiert ce mot clé lors du renommage
    des colonnes en sortie parce que les fonctionnalités d'extension du type
    créent des ambiguïtés en son absence. <literal>AS</literal>
    est néanmoins optionnel pour les éléments <literal>FROM</literal>.
   </para>
  </refsect2>

  <refsect2>
   <title>Espace logique disponible pour <literal>GROUP BY</literal> et
    <literal>ORDER BY</literal></title>

   <para>
    Dans le standard SQL-92, une clause <literal>ORDER BY</literal> peut
    seulement utiliser des noms ou des numéros de colonnes alors qu'une clause
    <literal>GROUP BY</literal> peut seulement utiliser des expressions
    basées sur les noms de colonne en entrée.
    <productname>PostgreSQL</productname> étend chacune de ces clauses pour   
    permettre aussi un autre choix (mais il utilise l'interprétation du
    standard s'il y a ambiguïté). <productname>PostgreSQL</productname>
    autorise aussi les deux clauses à spécifier des expressions quelconques.
    Notez que les noms apparaissant dans une expression sont toujours pris en
    tant que noms des colonnes en entrée, et non pas en tant que noms des
    colonnes du résultat.
   </para>

   <para>
    SQL:1999 et ultérieur utilisent une définition légèrement différente qui
    n'est pas totalement compatible avec SQL-92. Néanmoins, dans la plupart des
    cas, <productname>PostgreSQL</productname> interpréte une expression
    <literal>ORDER BY</literal> ou <literal>GROUP BY</literal> de la même façon
    que ce que fait SQL:1999.
   </para>
  </refsect2>

  <refsect2>
   <title>Clauses non standard</title>

   <para>
    Les clauses <literal>DISTINCT ON</literal>,
    <literal>LIMIT</literal> et <literal>OFFSET</literal> ne sont pas définies
    dans le standard SQL.
   </para>
  </refsect2>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
