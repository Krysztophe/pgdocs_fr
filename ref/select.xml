<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060313 pour la relecture -->

<refentry id="sql-select">
 <refmeta>
  <refentrytitle id="sql-select-title">SELECT</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>SELECT</refname>
  <refpurpose>récupère des lignes d'une table ou d'une vue</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>SELECT [ ALL | DISTINCT [ ON ( <replaceable class="parameter">expression</replaceable> [, ...] ) ] ]
    * | <replaceable class="parameter">expression</replaceable> [ AS <replaceable class="parameter">nom_d_affichage</replaceable> ] [, ...]
    [ FROM <replaceable class="parameter">éléments_from</replaceable> [, ...] ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]
    [ GROUP BY <replaceable class="parameter">expression</replaceable> [, ...] ]
    [ HAVING <replaceable class="parameter">condition</replaceable> [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class="parameter">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL } ]
    [ OFFSET <replaceable class="parameter">début</replaceable> ]
    [ FOR { UPDATE | SHARE } [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ] [...] ]

avec <replaceable class="parameter">éléments_from</replaceable> qui peut être&nbsp;:

    [ ONLY ] <replaceable class="parameter">nom_table</replaceable> [ * ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ] ]
    ( <replaceable class="parameter">select</replaceable> ) [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] ) ]
    <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">alias_colonne</replaceable> [, ...] | <replaceable class="parameter">définition_colonne</replaceable> [, ...] ) ]
    <replaceable class="parameter">nom_fonction</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) AS ( <replaceable class="parameter">définition_colonne</replaceable> [, ...] )
    <replaceable class="parameter">éléments_from</replaceable> [ NATURAL ] <replaceable class="parameter">type_jointure</replaceable> <replaceable class="parameter">éléments_from</replaceable> [ ON <replaceable class="parameter">condition_jointure</replaceable> | USING ( <replaceable class="parameter">colonne_jointure</replaceable> [, ...] ) ]
</synopsis>

 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-select">
   <primary>SELECT</primary>
  </indexterm>

  <para>
   <command>SELECT</command> récupère des lignes de zéro ou plusieurs
   tables. Le traitement général de <command>SELECT</command> est le
   suivant&nbsp;:

   <orderedlist>
    <listitem>
     <para>
      Tous les éléments de la liste <literal>FROM</literal> sont calculés.
      (Chaque élément dans la liste <literal>FROM</literal> est une table 
      réelle ou virtuelle.) Si plus d'un élément sont spécifiés dans la liste
      <literal>FROM</literal>, ils font l'objet d'une jointure croisée (cross-join). (Voir <xref
      linkend="sql-from" endterm="sql-from-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>WHERE</literal> est spécifiée, toutes les lignes
      qui ne satisfont pas les conditions sont éliminées de l'affichage. (Voir
      <xref linkend="sql-where" endterm="sql-where-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>GROUP BY</literal> est spécifiée, l'affichage est
      divisé en groupes de lignes qui correspondent à une ou plusieurs valeurs.
      Si la clause <literal>HAVING</literal> est présente, elle élimine les
      groupes qui ne satisfont pas la condition donnée. (Voir <xref
      linkend="sql-groupby" endterm="sql-groupby-title"/> et <xref
      linkend="sql-having" endterm="sql-having-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Les lignes retournées sont traitées en utilisant les expressions de sortie
      de <command>SELECT</command> pour chaque ligne sélectionnée. (Voir <xref
      linkend="sql-select-list" endterm="sql-select-list-title"/> ci-dessous.)
    </para>
    </listitem>

    <listitem>
     <para>
      En utilisant les opérateurs <literal>UNION</literal>,
      <literal>INTERSECT</literal> et <literal>EXCEPT</literal>, l'affichage de
      plusieurs instructions <command>SELECT</command> peut être combiné pour
      former un ensemble unique de résultats. L'opérateur <literal>UNION</literal>
      renvoie toutes les lignes qui appartiennent, au moins, à l'un des ensembles de
      résultats. L'opérateur <literal>INTERSECT</literal> renvoie toutes les
      lignes qui sont dans tous les ensembles de résultats.
      L'opérateur <literal>EXCEPT</literal> renvoie les lignes qui sont
      présentes dans le premier ensemble de résultats mais pas dans le 
      deuxième. Dans les trois cas, les lignes dupliquées sont éliminées sauf
      si <literal>ALL</literal> est spécifié. (Voir <xref linkend="sql-union"
      endterm="sql-union-title"/>, <xref linkend="sql-intersect"
      endterm="sql-intersect-title"/> et <xref linkend="sql-except"
      endterm="sql-except-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>ORDER BY</literal> est spécifiée, les lignes
      renvoyées sont triées dans l'ordre spécifié. Si <literal>ORDER
      BY</literal> n'est pas indiqué, les lignes sont retournées dans l'ordre 
      qui permet la réponse la plus rapide du système. (Voir <xref
      linkend="sql-orderby" endterm="sql-orderby-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      <literal>DISTINCT</literal> élimine les lignes dupliquées du résultat.
      <literal>DISTINCT ON</literal> élimine les lignes qui correspondent à
      toutes les expressions données. <literal>ALL</literal> (la valeur par
      défaut) renvoie toutes les lignes candidates, y compris les lignes
      dupliquées. (Voir <xref linkend="sql-distinct"
      endterm="sql-distinct-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si les clauses <literal>LIMIT</literal> ou <literal>OFFSET</literal> sont
      spécifiées, l'instruction <command>SELECT</command> ne renvoie qu'un
      sous-ensemble de lignes de résultats. (Voir <xref linkend="sql-limit"
      endterm="sql-limit-title"/> ci-dessous.)
     </para>
    </listitem>

    <listitem>
     <para>
      Si la clause <literal>FOR UPDATE</literal> ou <literal>FOR
      SHARE</literal> est spécifiée, l'instruction <command>SELECT</command>
      verrouille les lignes sélectionnées contre les mises à jour concurrentes.
      (Voir <xref linkend="sql-for-update-share"
      endterm="sql-for-update-share-title"/> ci-dessous.)
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Le droit <literal>SELECT</literal> sur une table est nécessaire pour lire
   ses valeurs. L'utilisation de <literal>FOR UPDATE</literal> ou de
   <literal>FOR SHARE</literal> requiert en plus le droit 
   <literal>UPDATE</literal>.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <refsect2 id="sql-from">
   <title id="sql-from-title">Clause <literal>FROM</literal></title>

   <para>
    La clause <literal>FROM</literal> spécifie une ou plusieurs tables source
    pour le <command>SELECT</command>. Si plusieurs sources sont spécifiées, le
    résultat est un produit cartésien (jointure croisée) de toutes les sources.
    Mais habituellement, des conditions de qualification sont ajoutées pour
    restreindre les lignes renvoyées à un petit sous-ensemble du produit
    cartésien.
   </para>

   <para>
    La clause <literal>FROM</literal> peut contenir les éléments
    suivants&nbsp;:

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">nom_table</replaceable></term>
      <listitem>
       <para>
        Le nom (éventuellement qualifié par le nom du schéma) d'une table existante
	ou d'une vue. Si <literal>ONLY</literal> est spécifié, seule cette table est
	parcourue. Dans le cas contraire, la table et toutes ses
	descendantes (s'il y en a) sont parcourues. <literal>*</literal> peut
	être ajouté au nom de la table pour indiquer que les tables descendantes
	doivent être parcourues mais, dans la version actuelle, c'est le
	comportement par défaut. Dans les versions précédant la 7.1,
	<literal>ONLY</literal> était le comportement par défaut.
	Ce dernier peut être modifié à l'aide de l'option de configuration
	<xref linkend="guc-sql-inheritance"/>.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">alias</replaceable></term>
      <listitem>
       <para>
        Un nom de substitution pour l'élément <literal>FROM</literal> contenant
	l'alias. Un alias est utilisé par brièveté ou pour lever toute
	ambiguïté lors d'auto-jointures (la même table est parcourue plusieurs
	fois). Quand un alias est fourni, il cache complètement le nom réel de
	la table ou fonction&nbsp;; par exemple, avec <literal>FROM foo AS</literal>,
	le reste du <command>SELECT</command> doit faire référence à cet
	élément de <literal>FROM</literal> par <literal>f</literal> et non pas par
	<literal>foo</literal>. Si un alias est donné, une liste d'alias de colonnes
	peut aussi être saisi comme noms de substitution pour différentes
	colonnes de la table.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">select</replaceable></term>
      <listitem>
       <para>
        Un sous-<command>SELECT</command> peut apparaître dans la clause
        <literal>FROM</literal>. Il agit comme si sa sortie était 
        transformée en table temporaire pour la durée de cette seule commande
        <command>SELECT</command>. Le sous-<command>SELECT</command>
        doit être entouré de parenthèses et un alias
	<emphasis>doit</emphasis> lui être fourni.
	Une commande <xref linkend="sql-values" endterm="sql-values-title"/>
        peut aussi être utilisée ici.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nom_fonction</replaceable></term>
      <listitem>
       <para>
        Des appels de fonctions peuvent apparaître dans la clause
	<literal>FROM</literal>. (Cela est particulièrement utile pour les
	fonctions renvoyant des ensembles de résultats, mais n'importe quelle fonction peut
	être utilisée.) Un appel de fonction agit comme si la sortie était
	transformée en table temporaire pour la durée de cette seule commande
	<command>SELECT</command>.
<!-- J'ai l'impression qu'il y a là une imprécision dans la documentation
officielle. Il ne s'agit pas ici de sous-select, mais d'un appel de fonction.
Ce qui diffère légèrement d'un sous-select. A moins qu'un raccourci ne soit pris
pour considérer un appel de fonction comme un sous-select. SAS -->
	Un alias peut aussi être utilisé. Si un
	alias est donné, une liste d'alias de colonnes peut être ajoutée pour
	fournir des noms de substitution pour un ou plusieurs attributs du type
	composé de retour de la fonction. Si la fonction a été définie comme
	renvoyant le type de données <type>record</type>, alors un alias ou un mot
	clé <literal>AS</literal> doit être présent, suivi par une liste de définitions
	de colonnes de la forme <literal>( <replaceable
	class="parameter">nom_colonne</replaceable> <replaceable
	class="parameter">type_données</replaceable> <optional>, ... </optional>
	)</literal>. La liste de définitions de colonnes doit correspondre au
	nombre réel et aux types réels des colonnes renvoyées par la fonction.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><replaceable class="parameter">type_jointure</replaceable></term>
      <listitem>
       <para>
        Un des éléments 
        <itemizedlist>
         <listitem>
          <para><literal>[ INNER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>LEFT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>RIGHT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>FULL [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>CROSS JOIN</literal></para>
         </listitem>
        </itemizedlist>

        Pour les types de jointures <literal>INNER</literal> et <literal>OUTER</literal>, une
	condition de jointure doit être spécifiée, à choisir parmi
        <literal>NATURAL</literal>, <literal>ON <replaceable
        class="parameter">condition_jointure</replaceable></literal> ou
        <literal>USING (<replaceable
        class="parameter">colonne_jointure</replaceable> [, ...])</literal>.
        Voir ci-dessous pour la signification. Pour <literal>CROSS
	JOIN</literal>, aucune de ces clauses ne doit apparaître.
       </para>

       <para>
        Une clause <literal>JOIN</literal> combine deux éléments
        <literal>FROM</literal>. Les parenthèses peuvent être utilisées pour
	déterminer l'ordre d'imbrication. En l'absence de parenthèses,
	les <literal>JOIN</literal> sont imbriqués de gauche à droite. Dans
	tous les cas, <literal>JOIN</literal> est plus prioritaire que les
	virgules séparant les éléments <literal>FROM</literal>.
       </para>

       <para>
        <literal>CROSS JOIN</literal> et <literal>INNER JOIN</literal> produisent un
	simple produit cartésien. Le résultat est identique à celui obtenu 
	lorsque les deux éléments sont listés au premier niveau du <literal>FROM</literal>, mais
	restreint par la condition de jointure (si elle existe). <literal>CROSS
	JOIN</literal> est équivalent à <literal>INNER JOIN ON (TRUE)</literal>, c'est-à-dire
	qu'aucune ligne n'est supprimée par qualification. Ces types de
	jointure sont essentiellement une aide à la notation car ils ne font rien de
	plus qu'un simple <literal>FROM</literal> et <literal>WHERE</literal>.
       </para>

       <para>
        <literal>LEFT OUTER JOIN</literal> renvoie toutes les lignes du produit
	cartésien qualifié (c'est-à-dire toutes les lignes combinées qui
	satisfont la condition de jointure), plus une copie de chaque ligne
	de la table de gauche pour laquelle il n'y a pas de ligne à droite
	qui satisfasse la condition de jointure. La ligne de gauche est
	étendue à la largeur complète de la table jointe par insertion de
	valeurs NULL pour les colonnes de droite. Seule la
	condition de la clause <literal>JOIN</literal> est utilisée pour décider des
	lignes qui correspondent. Les conditions externes sont appliquées après
	coup.
       </para>

       <para>
        À l'inverse, <literal>RIGHT OUTER JOIN</literal> renvoie toutes les lignes
	jointes plus une ligne pour chaque ligne de droite sans correspondance
	(complétée par des NULL pour le côté gauche). C'est une simple aide à
	la notation car il est aisément convertible en <literal>LEFT</literal> en
	inversant les entrées gauche et droite.
       </para>

       <para>
        <literal>FULL OUTER JOIN</literal> renvoie toutes les lignes jointes, plus
	chaque ligne gauche sans correspondance (étendue par des NULL à droite),
	plus chaque ligne droite sans correspondance (étendue par des NULL à
	gauche).
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>ON <replaceable class="parameter">condition_jointure</replaceable></literal></term>
      <listitem>
       <para>
        <replaceable class="parameter">condition_jointure</replaceable> 
	est une expression qui retourne une valeur de type <type>boolean</type>
	(comme une clause <literal>WHERE</literal>) qui spécifie les
	lignes d'une jointure devant correspondre.
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><literal>USING (<replaceable
	class="parameter">colonne_jointure</replaceable> [,
	...])</literal></term>
      <listitem>
       <para>
        Une clause de la forme <literal>USING ( a, b, ... )</literal> est un
	raccourci pour <literal>ON table_gauche.a = table_droite.a AND table_gauche.b
	= table_droite.b ...</literal>. De plus, <literal>USING</literal> implique 
	l'affichage d'une seule paire des colonnes correspondantes dans la sortie
	de la jointure.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NATURAL</literal></term>
      <listitem>
       <para>
        <literal>NATURAL</literal> est un raccourci pour une liste
        <literal>USING</literal> qui mentionne toutes les colonnes de même nom dans les deux 
        tables.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
   
  <refsect2 id="sql-where">
   <title id="sql-where-title">Clause <literal>WHERE</literal></title>

   <para>
    La clause <literal>WHERE</literal> optionnelle a la forme générale
<synopsis>WHERE <replaceable class="parameter">condition</replaceable>
</synopsis>
    où <replaceable class="parameter">condition</replaceable> est une 
    expression dont le résultat est de type <type>boolean</type>. Toute ligne qui ne
    satisfait pas cette condition est éliminée de la sortie. Une ligne
    satisfait la condition si elle retourne vrai quand les valeurs réelles
    de la ligne sont substituées à toute référence de variable.
   </para>
  </refsect2>
  
  <refsect2 id="sql-groupby">
   <title id="sql-groupby-title">Clause <literal>GROUP BY</literal></title>

   <para>
    La clause <literal>GROUP BY</literal> optionnelle a la forme générale
<synopsis>GROUP BY <replaceable class="parameter">expression</replaceable> [, ...]
</synopsis>
   </para>

   <para>
    <literal>GROUP BY</literal> condense en une seule ligne toutes les lignes
    sélectionnées qui partagent les mêmes valeurs pour les expressions
    regroupées. <replaceable class="parameter">expression</replaceable> peut être
    le nom d'une colonne en entrée, le nom ou le numéro d'une colonne
    en sortie (élément de la liste <command>SELECT</command>), ou une 
    expression
    quelconque formée de valeurs de colonnes en entrée. En cas
    d'ambiguïté, un nom de <literal>GROUP BY</literal> est interprété comme un nom
    de colonne en entrée, non en sortie.
   </para>

   <para>
    Les fonctions d'agrégat, si utilisées, sont calculées pour
    toutes les lignes composant un groupe, produisant une valeur séparée
    pour chaque groupe (alors que sans <literal>GROUP BY</literal>, un agrégat
    produit une valeur unique calculée pour toutes les lignes
    sélectionnées). Quand <literal>GROUP BY</literal> est présent, 
    les expressions du <command>SELECT</command> ne peuvent faire
    référence qu'à des colonnes groupées, sauf à l'intérieur de fonctions
    d'agrégat, la valeur de retour d'une colonne non-groupée n'étant
    pas unique.
   </para>
  </refsect2>

  <refsect2 id="sql-having">
   <title id="sql-having-title">Clause <literal>HAVING</literal></title>

   <para>
    La clause optionnelle <literal>HAVING</literal> a la forme générale
<synopsis>HAVING <replaceable class="parameter">condition</replaceable>
</synopsis>
    où <replaceable class="parameter">condition</replaceable> est identique à
    celle spécifiée pour la clause <literal>WHERE</literal>.
   </para>
    
   <para>
    <literal>HAVING</literal> élimine les lignes groupées qui ne satisfont
    pas à la condition. <literal>HAVING</literal> est différent de
    <literal>WHERE</literal>&nbsp;: <literal>WHERE</literal> filtre les lignes
    individuelles avant l'application de <literal>GROUP BY</literal> alors que
    <literal>HAVING</literal> filtre les lignes groupées créées par
    <literal>GROUP BY</literal>. Chaque colonne référencée dans <replaceable
    class="parameter">condition</replaceable> doit faire référence sans ambiguïté 
    à une colonne groupée, sauf si la référence apparaît dans une fonction
    d'agrégat.
   </para>
    
   <para>
    Même en l'absence de clause <literal>GROUP BY</literal>, la présence de
    <literal>HAVING</literal> transforme une requête en requête groupée.
    Cela correspond au comportement d'une requête contenant des fonctions
    d'agrégats mais pas de clause <literal>GROUP BY</literal>. Les lignes 
    sélectionnées ne forment qu'un groupe, la liste du <command>SELECT</command>
    et la clause <literal>HAVING</literal> ne peuvent donc faire référence
    qu'à des colonnes à l'intérieur de fonctions d'agrégats. Une telle
    requête ne produira qu'une seule ligne si la condition <literal>HAVING</literal>
    est réalisée, aucune dans le cas contraire.
   </para>
  </refsect2>

  <refsect2 id="sql-select-list">
   <title id="sql-select-list-title">Liste <command>SELECT</command></title>

   <para>
    La liste <command>SELECT</command> (entre les mots clés
    <literal>SELECT</literal> et <literal>FROM</literal>) spécifie les expressions qui
    forment les lignes en sortie de l'instruction <command>SELECT</command>.
    Il se peut que les expressions fassent (en général elles le font) référence aux colonnes
    traitées dans la clause <literal>FROM</literal>. L'utilisation de la clause
    <literal>AS <replaceable class="parameter">nom_sortie</replaceable></literal>
    permet de modifier le nom d'une colonne en sortie. Ce nom est
    principalement utilisé pour l'affichage. Il
    peut aussi l'être pour référencer la valeur de la colonne dans les
    clauses <literal>ORDER BY</literal> et <literal>GROUP BY</literal>. Il ne peut
    en revanche pas être utilisé dans les clauses <literal>WHERE</literal> ou
    <literal>HAVING</literal>&nbsp;; il faudra dans ce cas écrire les expressions.
   </para>

   <para>
    <literal>*</literal> peut être utilisé, à la place d'une expression, dans la
    liste de sortie comme raccourci pour toutes les colonnes des lignes
    sélectionnées. De plus, 
    <literal><replaceable class="parameter">nom_table</replaceable>.*</literal>
    peut être écrit comme raccourci pour toutes les colonnes de cette table.
   </para>
  </refsect2>

  <refsect2 id="sql-union">
   <title id="sql-union-title">Clause <literal>UNION</literal></title>

   <para>
    La clause <literal>UNION</literal> a la forme générale&nbsp;:
<synopsis><replaceable class="parameter">instruction_select</replaceable> UNION [ ALL ] <replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</literal>,
    <literal>LIMIT</literal>, <literal>FOR SHARE</literal> ou <literal>FOR
    UPDATE</literal>. (<literal>ORDER BY</literal> et
    <literal>LIMIT</literal> peuvent être attachés à une sous-expression si elle est
    entourée de parenthèses. Sans parenthèses, ces clauses s'appliquent
    au résultat de l'<literal>UNION</literal>, non à l'expression à sa droite.)
   </para>
    
   <para>
    L'opérateur <literal>UNION</literal> calcule l'union ensembliste des
    lignes renvoyées par les instructions <command>SELECT</command> impliquées.
    Une ligne est dans l'union de deux ensembles de résultats si elle apparaît
    dans au moins un des ensembles. Les deux instructions
    <command>SELECT</command> qui représentent les opérandes directes de
    l'<literal>UNION</literal> doivent produire le même nombre de colonnes et
    les colonnes correspondantes doivent être d'un type de données compatible.
   </para>
    
   <para>
    Sauf lorsque l'option <literal>ALL</literal> est spécifiée, il n'y a pas
    de doublons dans le résultat de <literal>UNION</literal>. <literal>ALL</literal>
    empêche l'élimination des lignes dupliquées. <literal>UNION
    ALL</literal> est donc significativement plus rapide qu'<literal>UNION</literal>, 
    et sera préféré.
   </para>
    
   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>UNION</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent.
   </para>
    
   <para>
    Actuellement, <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> ne peuvent
    pas être spécifiés pour un résultat d'<literal>UNION</literal> ou pour toute entrée
    d'un <literal>UNION</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-intersect">
   <title id="sql-intersect-title">Clause <literal>INTERSECT</literal></title>

   <para>
    La clause <literal>INTERSECT</literal> a la forme générale&nbsp;:
<synopsis><replaceable class="parameter">instruction_select</replaceable> INTERSECT [ ALL ] <replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER BY</literal>,
    <literal>LIMIT</literal>, <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal>.
   </para>

   <para>
    L'opérateur <literal>INTERSECT</literal> calcule l'intersection des lignes
    renvoyées par les instructions <command>SELECT</command> impliquées. Une
    ligne est dans l'intersection des deux ensembles de résultats si elle
    apparaît dans chacun des deux ensembles.
   </para>
    
   <para>
    Le résultat d'<literal>INTERSECT</literal> ne contient aucune ligne
    dupliquée sauf si l'option <literal>ALL</literal> est spécifiée. Dans ce cas,
    une ligne dupliquée <replaceable>m</replaceable> fois dans
    la table gauche et <replaceable>n</replaceable> fois dans la table droite
    apparaît min(<replaceable>m</replaceable>,<replaceable>n</replaceable>) fois dans
    l'ensemble de résultats.
   </para>
    
   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>INTERSECT</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent. <literal>INTERSECT</literal> a une 
    priorité supérieur à celle d'<literal>UNION</literal>. C'est-à-dire que <literal>A 
    UNION B INTERSECT C</literal> est lu comme <literal>A UNION (B INTERSECT
    C)</literal>.
   </para>

   <para>
    Actuellement, <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> ne peuvent 
    pas être spécifiés pour un résultat d'<literal>INTERSECT</literal> ou pour une
    entrée d'<literal>INTERSECT</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-except">
   <title id="sql-except-title">Clause <literal>EXCEPT</literal></title>

   <para>
    La clause <literal>EXCEPT</literal> a la forme générale&nbsp;:
<synopsis><replaceable class="parameter">instruction_select</replaceable> EXCEPT [ ALL ] <replaceable class="parameter">instruction_select</replaceable>
</synopsis>
    <replaceable class="parameter">instruction_select</replaceable> est une
    instruction <command>SELECT</command> sans clause <literal>ORDER
    BY</literal>, <literal>LIMIT</literal>, <literal>FOR UPDATE</literal> ou
    <literal>FOR SHARE</literal>.
   </para>

   <para>
    L'opérateur <literal>EXCEPT</literal> calcule l'ensemble de lignes qui appartiennent
    au résultat de l'instruction <command>SELECT</command> de gauche mais
    pas à celui de droite.
   </para>
    
   <para>
    Le résultat d'<literal>EXCEPT</literal> ne contient aucune ligne
    dupliquée sauf si l'option <literal>ALL</literal> est spécifiée. Dans ce cas,
    une ligne dupliquée <replaceable>m</replaceable> fois dans
    la table gauche et <replaceable>n</replaceable> fois dans la table droite
    apparaît max(<replaceable>m</replaceable>-<replaceable>n</replaceable>,0) fois dans
    l'ensemble de résultats.
   </para>
    
   <para>
    Si une instruction
    <command>SELECT</command> contient plusieurs opérateurs <literal>EXCEPT</literal>,
    ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses
    impose un comportement différent. <literal>EXCEPT</literal> a la même priorité
    qu'<literal>UNION</literal>.
   </para>

   <para>
    Actuellement, <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> ne peuvent 
    pas être spécifiés dans un résultat <literal>EXCEPT</literal> ou pour une entrée
    d'un <literal>EXCEPT</literal>.
   </para>
  </refsect2>

  <refsect2 id="sql-orderby">
   <title id="sql-orderby-title">Clause <literal>ORDER BY</literal></title>

   <para>
    La clause optionnelle <literal>ORDER BY</literal> a la forme
    générale&nbsp;:
 <synopsis>ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">opérateur</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...]
</synopsis>
    La clause <literal>ORDER BY</literal> impose le tri des lignes de résultat 
    suivant les expressions spécifiées. Si deux lignes sont
    identiques suivant l'expression la plus à gauche, elles sont comparées avec
    l'expression suivante et ainsi de suite. Si elles sont identiques pour
    toutes les expressions de tri, elles sont renvoyées dans un ordre
    dépendant de l'implantation.
   </para>

   <para>
    Chaque <replaceable class="parameter">expression</replaceable> peut être le
    nom ou le numéro ordinal d'une colonne en sortie (élément de la liste
    <command>SELECT</command>). Elle peut aussi être une expression arbitraire
    formée à partir de valeurs des colonnes.
   </para>

   <para>
    Le numéro ordinal fait référence à la position ordinale (de gauche à 
    droite) de la colonne de résultat. Cette fonctionnalité permet de définir un ordre
    sur la base d'une colonne dont le nom n'est pas unique. Ce n'est 
    pas particulièrement nécessaire parce qu'il est toujours possible d'affecter un nom à
    une colonne de résultat avec la clause <literal>AS</literal>.
   </para>
    
   <para>
    Il est aussi possible d'utiliser des expressions quelconques dans la clause
    <literal>ORDER BY</literal>, ce qui inclut des colonnes qui n'apparaissent pas
    dans la liste résultat du <command>SELECT</command>. Ainsi,
    l'instruction suivante est valide&nbsp;:
<programlisting>SELECT nom FROM distributeurs ORDER BY code;
</programlisting>
    Il y a toutefois une limitation à cette fonctionnalité. La clause
    <literal>ORDER BY</literal> qui s'applique au résultat d'une clause <literal>UNION</literal>,
    <literal>INTERSECT</literal> ou <literal>EXCEPT</literal> ne peut spécifier
    qu'un nom ou numéro de colonne en sortie, pas une expression.
   </para>
    
   <para>
    Si une expression <literal>ORDER BY</literal> est un nom qui correspond à
    la fois à celui d'une colonne résultat et à celui d'une colonne en entrée,
    <literal>ORDER BY</literal> l'interprète comme le nom de la colonne résultat.
    Ce comportement est à l'opposé de celui de <literal>GROUP BY</literal> dans la même
    situation. Cette incohérence est imposée par la compatibilité avec le
    standard SQL.
   </para>
    
   <para>
    Un mot clé <literal>ASC</literal> (ascendant) ou <literal>DESC</literal> (descendant) 
    peut être ajouté après toute expression de la
    clause <literal>ORDER BY</literal>. <literal>ASC</literal> est la valeur utilisée par défaut.
    Un nom d'opérateur d'ordre spécifique
    peut également être fourni dans la clause <literal>USING</literal>.
    Un opérateur de tri doit être un membre plus-petit-que ou plus-grand-que de
    certaines familles d'opérateur B-tree.
    <literal>ASC</literal> est
    habituellement équivalent à <literal>USING &lt;</literal> et <literal>DESC</literal>
    à <literal>USING &gt;</literal>. Le créateur d'un
    type de données utilisateur peut définir à sa guise le tri par
    défaut qui peut alors correspondre à des opérateurs de nom différent.
   </para>

   <para>
    Si <literal>NULLS LAST</literal> est indiqué, les valeurs NULL sont listées
    après toutes les valeurs non NULL&nbsp; si <literal>NULLS FIRST</literal>
    est indiqué, les valeurs NULL apparaissent avant toutes les valeurs non
    NULL. Si aucune des deux n'est présente, le comportement par défaut est
    <literal>NULLS LAST</literal> quand <literal>ASC</literal> est utilisé
    (de façon explicite ou non) et <literal>NULLS FIRST</literal> quand
    <literal>DESC</literal> est utilisé (donc la valeur par défaut est d'agir
    comme si les NULL étaient plus grands que les non NULL). Quand
    <literal>USING</literal> est indiqué, le tri des NULL par défaut dépend
    du fait que l'opérateur est un plus-petit-que ou un plus-grand-que.
   </para>

   <para>
    Notez que les options de tri s'appliquent seulement à l'expression qu'elles
    suivent. Par exemple, <literal>ORDER BY x, y DESC</literal> ne signifie pas
    la même chose que <literal>ORDER BY x DESC, y DESC</literal>.
   </para>

   <para>
    Les données de chaînes de caractères sont triées suivant
    l'ordre spécifique à la locale, ordre établi au moment de la création du
    groupe de bases de données.
   </para>
  </refsect2>

  <refsect2 id="sql-distinct">
  <title id="sql-distinct-title">Clause <literal>DISTINCT</literal></title>

  <para>
   Si <literal>DISTINCT</literal> est spécifié, toutes les lignes dupliquées sont
   supprimées de l'ensemble de résultats (une ligne est conservée pour chaque
   groupe de lignes dupliquées). <literal>ALL</literal> spécifie le contraire&nbsp;:
   toutes les lignes sont conservées&nbsp;; c'est la valeur par défaut.
  </para>

  <para>
   <literal>DISTINCT ON ( <replaceable class="parameter">expression</replaceable> [, ...] )</literal>
   ne conserve que la première ligne de chaque ensemble pour lesquels il y a 
   identité des expressions. Les expressions 
   <literal>DISTINCT ON</literal> sont interprétées en utilisant les mêmes règles que pour
   <literal>ORDER BY</literal> (voir ci-dessus). La <quote>première
   ligne</quote> de chaque ensemble n'est pas prévisible sauf si <literal>ORDER
   BY</literal> est utilisé. 
   Par exemple&nbsp;:
<programlisting>  SELECT DISTINCT ON (emplacement) emplacement, heure, rapport
  FROM rapports_meteo
  ORDER BY emplacement, heure DESC;
</programlisting>
   récupère le rapport météo le plus récent de chaque emplacement. 
   Si <literal>ORDER BY</literal> n'est pas utilisé pour forcer l'ordre
   descendant des valeurs heure de chaque emplacement, le
   rapport est ordonné suivant des temps aléatoires.
  </para>

  <para>
   Le(s) expression(s) <literal>DISTINCT ON</literal> doi(ven)t correspondre à
   l'ordre des expression <literal>ORDER BY</literal>. La clause <literal>ORDER
   BY</literal> contient des expressions supplémentaires qui déterminent
   la précédence désirée des lignes à l'intérieur de chaque groupe
   <literal>DISTINCT ON</literal>.
  </para>
  </refsect2>

 <refsect2 id="sql-limit">
   <title id="sql-limit-title">Clause <literal>LIMIT</literal></title>

   <para>
    La clause <literal>LIMIT</literal> est constituée de deux sous-clauses
    indépendantes&nbsp;:
<synopsis>LIMIT { <replaceable class="parameter">nombre</replaceable> | ALL }
OFFSET <replaceable class="parameter">début</replaceable>
</synopsis>
    <replaceable class="parameter">nombre</replaceable> spécifie le nombre
    maximum de lignes à renvoyer alors que <replaceable
    class="parameter">début</replaceable> spécifie le nombre de lignes à passer
    avant de commencer à renvoyer des lignes. Lorsque les deux clauses sont spécifiées,
    <replaceable class="parameter">début</replaceable> lignes sont passées 
    avant de commencer à compter les <replaceable
    class="parameter">nombre</replaceable> lignes à renvoyer.
   </para>

   <para>
    Avec <literal>LIMIT</literal>, utiliser la clause
    <literal>ORDER BY</literal> permet de contraindre l'ordre des lignes de
    résultat. Dans le cas contraire, le sous-ensemble obtenu n'est pas prévisible &mdash;
    rien ne permet de savoir à quel ordre correspondent les lignes retournées. 
    Celui-ci ne sera pas connu tant qu'<literal>ORDER BY</literal> n'aura pas été précisé.
   </para>

   <para>
    Lors de la génération d'un plan de requête, le planificateur tient compte
    de <literal>LIMIT</literal>. Le risque est donc grand d'obtenir des plans
    qui diffèrent (ordres des lignes différents) suivant les valeurs
    utilisées pour <literal>LIMIT</literal> et <literal>OFFSET</literal>. Ainsi, sélectionner
    des sous-ensembles différents d'un résultat à partir de valeurs différentes
    de <literal>LIMIT</literal>/<literal>OFFSET</literal> <emphasis>aboutit à des résultats
    incohérents</emphasis> à moins d'avoir figé l'ordre des lignes à l'aide
    de la clause <literal>ORDER BY</literal>. Ce n'est pas un bogue, mais une conséquence
    du fait que SQL n'assure pas l'ordre de présentation des résultats sans
    utilisation d'une clause <literal>ORDER BY</literal>.
   </para>

   <para>
    Il est même possible pour des exécutions répétées de la même requête
    <literal>LIMIT</literal> de renvoyer différents sous-ensembles des lignes
    d'une table s'il n'y a pas de clause <literal>ORDER BY</literal> pour forcer
    la sélection d'un sous-ensemble déterministe. Encore une fois, ce n'est pas
    un bogue&nbsp;; le déterminisme des résultats n'est tout simplement pas
    garanti dans un tel cas.
   </para>
  </refsect2>

  <refsect2 id="sql-for-update-share">
   <title id="sql-for-update-share-title">Clause <literal>FOR UPDATE</literal>/<literal>FOR SHARE</literal></title>

   <para>
    La clause <literal>FOR UPDATE</literal> a la forme&nbsp;:
<synopsis>FOR UPDATE [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ]
</synopsis>
   </para>

   <para>
    La clause liée, <literal>FOR SHARE</literal>, a la forme&nbsp;:
<synopsis>FOR SHARE [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ]
</synopsis>
   </para>


   <para>
    <literal>FOR UPDATE</literal> verrouille pour modification les lignes récupérées par
    l'instruction <command>SELECT</command>.
    Cela les empêche d'être modifiées ou supprimées par les autres transactions
    jusqu'à la fin de la transaction en cours. Les autres
    transactions qui tentent des <command>UPDATE</command>,
    <command>DELETE</command> ou <command>SELECT FOR UPDATE</command> sur ces
    lignes sont bloquées jusqu'à la fin de la transaction courante. De
    plus, si un <command>UPDATE</command>, <command>DELETE</command> ou
    <command>SELECT FOR UPDATE</command> a
    déjà verrouillé une ligne ou un ensemble de lignes à partir d'une autre transaction,
    <command>SELECT FOR UPDATE</command> attend la fin de l'autre transaction puis verrouille et
    renvoie la ligne modifiée (ou aucune ligne si elle a été supprimée). Pour
    plus d'informations, voir <xref linkend="mvcc"/>.
   </para>

   <para>
    Pour éviter à l'opération d'attendre la validation des autres transactions,
    on utilise l'option <literal>NOWAIT</literal>. <command>SELECT FOR UPDATE
    NOWAIT</command> rapporte une erreur si une ligne
    sélectionnée ne peut pas être verrouillée immédiatement. Il n'y a pas 
    d'attente.
    <literal>NOWAIT</literal> s'applique seulement au(x) verrou(x) niveau ligne
    &mdash; le verrou niveau table <literal>ROW SHARE</literal> est toujours
    pris de façon ordinaire (voir <xref linkend="mvcc"/>). 
    L'option <literal>NOWAIT</literal> de <xref linkend="sql-lock" endterm="sql-lock-title"/>
    peut toujours être utilisée pour acquérir le verrou niveau table sans attendre.
   </para>

   <para>
    <literal>FOR SHARE</literal> a un comportement similaire. La différence
    se situe dans le type de verrou acquis. Contrairement à 
    <literal>FOR UPDATE</literal> qui pose un verrou exclusif,
    <literal>FOR SHARE</literal> pose un verrou partagé sur chaque ligne récupérée.
    Un verrou partagée bloque les instructions <command>UPDATE</command>,
    <command>DELETE</command> ou <command>SELECT FOR UPDATE</command>
    des transaction concurrentes accédant à ces lignes, mais il n'interdit
    pas les <command>SELECT FOR SHARE</command>.
   </para>

   <para>
    Si des tables particulières sont nommées dans les clauses <literal>FOR UPDATE</literal>
    et <literal>FOR SHARE</literal>, alors seules les lignes provenant de ces
    tables sont verrouillées&nbsp;; toute autre table utilisée dans le
    <command>SELECT</command> est simplement lue. Une clause
    <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal> sans liste de
    tables affecte toute les tables utilisées dans la commande. Si
    <literal>FOR UPDATE</literal> ou <literal>FOR SHARE</literal> est appliquée
    à une vue ou à une sous-requête, cela affecte toutes les tables utilisées
    dans la vue ou la sous-requête.
   </para>

   <para>
    Plusieurs clauses <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal>
    peuvent être données si il est nécessaire de spécifier différents
    comportements de verrouillage pour différentes tables. Si la même table
    est mentionné (ou affectée implicitement) par les clauses
    <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal>, alors elle
    est traitée comme un simple <literal>FOR UPDATE</literal>. De façon similaire,
    une table est traitée avec <literal>NOWAIT</literal> si c'est spécifiée sur
    au moins une des clauses qui l'affectent.
   </para>

   <para>
    <literal>FOR UPDATE</literal> et <literal>FOR SHARE</literal> nécessitent
    que chaque ligne retournée soit clairement identifiable par une ligne
    individuelle d'une table&nbsp;; ces options ne peuvent, par exemple, pas être
    utilisées avec des fonctions d'aggrégats.
   </para>

  <caution>
   <para>
    Évitez de verrouiller une ligne puis de la modifier après un nouveau point
    de sauvegarde ou après un bloc d'exception <application>PL/pgSQL</application>.
    L'annulation suivante pourrait causer la perte du verrou. Par exemple&nbsp;:
<programlisting>
BEGIN;
SELECT * FROM ma_table WHERE cle = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE ma_table SET ... WHERE cle = 1;
ROLLBACK TO s;
</programlisting>
    Après le <command>ROLLBACK</command>, la ligne est réellement déverrouillée
    au lieu de retourner à son état avant le point de sauvegarde. Ceci peut
    arriver si une ligne verrouillée dans la transaction en cours est mise à
    jour ou supprimée, ou si un verrou partagé est passé en verrou exclusif&nbsp;:
    dans tous ces cas, l'état précédent du verrou est oublié. Si la transation
    est ensuite annulée à un état entre la commande de verrou initiale et la
    modification qui a suivi, la ligne n'apparaîtra plus verrouillée. Ceci est
    une déficience de l'implémentation qui sera corrigée dans une prochaine
    version de <productname>PostgreSQL</productname>.
   </para>
  </caution>

  <caution>
   <para>
    Il est possible qu'une commande <command>SELECT</command> qui utilise
    simultanément les clauses <literal>LIMIT</literal> et
    <literal>FOR UPDATE/SHARE</literal> retourne moins de lignes que
    le nombre spécifié par <literal>LIMIT</literal>. En effet, 
    <literal>LIMIT</literal> est appliqué le premier. La commande 
    sélectionne le nombre de lignes spécifiées, mais peut être bloquée
    en essayant d'obtenir un verrou sur l'une ou l'autre de ces lignes.
    Lorsque le <literal>SELECT</literal> est débloqué, la ligne peut avoir été 
    supprimée ou modifiée de telle sorte qu'elle ne remplisse plus les
    conditions imposées par la clause <literal>WHERE</literal>. Dans ce cas, 
    elle n'est pas retournée.
   </para>
  </caution>
  
  <caution>
   <para>
    De façon similaire, il est possible qu'une commande <command>SELECT</command>
    utilisant <literal>ORDER BY</literal> et <literal>FOR
    UPDATE/SHARE</literal> renvoient les lignes dans un ordre différent. Ceci
    est dû au fait que <literal>ORDER BY</literal> est d'abord appliqué. La commande
    trie le résultat mais pourrait ensuite bloquer en essayant d'obtenir un
    verrou sur une ou plusieurs lignes. Une fois que le <literal>SELECT</literal>
    est débloqué, une des colonnes ordonnées peut avoir été modifiée et être
    renvoyée dans un ordre différent. Un contournement de ce problème revient à
    réaliser un <command>SELECT ... FOR UPDATE/SHARE</command> et ensuite un
    <command>SELECT ... ORDER BY</command>.
   </para>
  </caution>

  </refsect2>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Joindre la table <literal>films</literal> avec la table
   <literal>distributeurs</literal>&nbsp;:

<programlisting>SELECT f.titre, f.did, d.nom, f.date_prod, f.genre
    FROM distributeurs d, films f
    WHERE f.did = d.did

       titre       | did |     nom      | date_prod  |   genre
-------------------+-----+--------------+------------+------------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drame
 The African Queen | 101 | British Lion | 1951-08-11 | Romantique
 ...
</programlisting>
  </para>

  <para>
   Additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal>&nbsp;:

<programlisting>SELECT genre, sum(longueur) AS total FROM films GROUP BY genre;

   genre    | total
------------+-------
 Action     | 07:34
 Comédie    | 02:58
 Drame      | 14:28
 Musical    | 06:42
 Romantique | 04:38
</programlisting>
  </para>

  <para>
   Additionner la colonne <literal>longueur</literal> de tous les films,
   grouper les résultats par <literal>genre</literal> et afficher les groupes 
   dont les totaux font moins de cinq heures&nbsp;:

<programlisting>SELECT genre, sum(longueur) AS total
    FROM films
    GROUP BY genre
    HAVING sum(longueur) &lt; interval '5 hours';

   genre    | total
------------+-------
 Comedie    | 02:58
 Romantique | 04:38
</programlisting>
  </para>

  <para>
   Les deux exemples suivants représentent des façons identiques de trier les résultats
   individuels en fonction du contenu de la deuxième colonne (<literal>nom</literal>)&nbsp;:

<programlisting>SELECT * FROM distributeurs ORDER BY nom;
SELECT * FROM distributeurs ORDER BY 2;

 did |       nom
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
</programlisting>
  </para>

  <para>
   L'exemple suivant présente l'union des tables
   <literal>distributeurs</literal> et <literal>acteurs</literal>, restreignant
   les résultats à ceux de chaque table dont la première lettre est un W.
   Le mot clé <literal>ALL</literal> est omis, ce qui permet de n'afficher que
   les lignes distinctes.

<programlisting>distributeurs:               acteurs:
 did |     nom               id |     nom
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributeurs.nom
    FROM distributeurs
    WHERE distributeurs.nom LIKE 'W%'
UNION
SELECT actors.nom
    FROM acteurs
    WHERE acteurs.nom LIKE 'W%';

      nom
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
</programlisting>
  </para>

  <para>
   L'exemple suivant présente l'utilisation d'une fonction dans la clause <literal>FROM</literal>,
   avec et sans liste de définition de colonnes&nbsp;:

<programlisting>CREATE FUNCTION distributeurs(int) RETURNS SETOF distributeurs AS $$
    SELECT * FROM distributeurs WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributeurs(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributeurs_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributeurs WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributeurs_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
</programlisting>
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   L'instruction <command>SELECT</command> est évidemment compatible avec le
   standard SQL. Mais il y a des extensions et quelques fonctionnalités
   manquantes.
  </para>
  
  <refsect2>
   <title>Clauses <literal>FROM</literal> omises</title>

   <para>
    <productname>PostgreSQL</productname> autorise l'omission de la clause
    <literal>FROM</literal>. Cela permet par exemple de calculer le
    résultat d'expressions simples&nbsp;:
<programlisting>SELECT 2+2;

 ?column?
----------
        4
</programlisting>
    D'autres bases de données <acronym>SQL</acronym> interdisent ce comportement,
    sauf à introduire une table virtuelle d'une seule ligne sur laquelle exécuter
    la commande <command>SELECT</command>.
   </para>

   <para>
    S'il n'y a pas de clause <literal>FROM</literal>, la requête ne
    peut pas référencer les tables de la base de données. La
    requête suivante est, ainsi, invalide&nbsp;:
<programlisting>SELECT distributors.* WHERE distributors.name = 'Westward';
</programlisting>
    Les versions antérieures à <productname>PostgreSQL</productname> 8.1 
    acceptaient les requêtes de cette forme en ajoutant une entrée implicite à
    la clause <literal>FROM</literal> pour chaque table référencée.
    Ce n'est plus le comportement par défaut, d'une part
    parce qu'il n'est pas compatible avec le standard SQL et, d'autre part,
    parce que considéré par beaucoup comme générateur d'erreurs. Pour des
    raisons de compatibilité avec les applications utilisant ce
    comportement, la variable de configuration <xref
    linkend="guc-add-missing-from"/> peut toujours être activée.
   </para>
  </refsect2>

  <refsect2>
   <title>Mot clé <literal>AS</literal></title>

   <para>
    Dans le SQL standard, le mot clé <literal>AS</literal> est optionnel et
    peut être omis sans affecter la signification. L'analyseur 
    <productname>PostgreSQL</productname> requiert ce mot clé lors du renommage
    des colonnes en sortie parce que les fonctionnalités d'extension de type
    créent des ambiguïtés d'analyse s'il est omis. <literal>AS</literal>
    est néanmoins optionnel pour les éléments <literal>FROM</literal>.
   </para>
  </refsect2>

  <refsect2>
   <title>Espace logique disponible pour <literal>GROUP BY</literal> et
    <literal>ORDER BY</literal></title>
   
   <para>
    Dans le standard SQL-92, une clause <literal>ORDER BY</literal>
    ne peut utiliser que les noms ou numéros des colonnes en sortie, une clause 
    <literal>GROUP BY</literal> que des expressions fondées sur les noms de
    colonnes en entrée. <productname>PostgreSQL</productname> va plus loin, puisqu'il 
    autorise chacune de ces clauses à utiliser également l'autre possibilité.
    En cas d'ambiguïté, c'est l'interprétation du standard qui prévaut.
    <productname>PostgreSQL</productname> autorise aussi l'utilisation d'expressions
    quelconques dans les deux clauses. 
    Les noms apparaissant dans ces expressions sont toujours considérés comme nom de
    colonne en entrée, pas en tant que nom de colonne du résultat.
   </para>

   <para>
    SQL:1999 et suivant utilisent une définition légèrement différente,
    pas totalement compatible avec le SQL-92. Néanmoins, dans la plupart des
    cas, <productname>PostgreSQL</productname> interprète une expression
    <literal>ORDER BY</literal> ou <literal>GROUP BY</literal> en suivant
    la norme SQL:1999.
   </para>
  </refsect2>

  <refsect2>
   <title>Clauses non standard</title>

   <para>
    Les clauses <literal>DISTINCT ON</literal>,
    <literal>LIMIT</literal> et <literal>OFFSET</literal> ne sont pas définies
    dans le standard SQL.
   </para>
  </refsect2>
 </refsect1>
</refentry>
