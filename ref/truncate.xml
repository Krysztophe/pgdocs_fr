<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->
<!-- SAS 20060301 pour la relecture -->

<refentry id="sql-truncate">
 <refmeta>
  <refentrytitle id="sql-truncate-title">TRUNCATE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>TRUNCATE</refname>
  <refpurpose>vide une table ou un ensemble de tables</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
TRUNCATE [ TABLE ] [ ONLY ] <replaceable class="PARAMETER">nom</replaceable> [, ... ]
    [ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-truncate">
   <primary>TRUNCATE</primary>
  </indexterm>

  <para>
   La commande <command>TRUNCATE</command> supprime rapidement toutes les
   lignes d'un ensemble de tables. Elle a le même effet qu'un
   <command>DELETE</command> non qualifié sur chaque table, mais comme elle ne
   parcourt par la table, elle est plus rapide. De plus, elle récupère
   immédiatement l'espace disque, évitant ainsi une opération
   <command>VACUUM</command>. Cette commande est particulièrement utile pour
   les tables volumineuses.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
     <para>
      Le nom d'une table à vider (peut être qualifié par le schéma).  If <literal>ONLY</> is specified, only that table is
      truncated.  If <literal>ONLY</> is not specified, the table and
      all its descendant tables (if any) are truncated.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESTART IDENTITY</literal></term>
    <listitem>
     <para>
      Automatically restart sequences owned by columns of
      the truncated table(s).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONTINUE IDENTITY</literal></term>
    <listitem>
     <para>
      Do not change the values of sequences.  This is the default.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CASCADE</literal></term>
    <listitem>
     <para>
      Vide toutes les tables qui ont des références de clés étrangères sur une
      des tables nommées et sur toute table ajoutée au groupe à cause du
      <literal>CASCADE</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESTRICT</literal></term>
    <listitem>
     <para>
      Refuse le vidage si une des tables a des références de clés étrangères
      sur une table qui ne sont pas listed in the command. Cette option est active par
      défaut.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   You must have the <literal>TRUNCATE</literal> privilege on a table
   to truncate it.
  </para>

  <para>
   <command>TRUNCATE</> acquires an access exclusive lock on the
   tables in operates on, which blocks all other concurrent operations
   on the table.  If concurrent access to a table is required, then
   the <command>DELETE</> command should be used instead.
  </para>

  <para>
   <command>TRUNCATE</command> ne peut pas être utilisé sur une table
   référencée par d'autres tables au travers de clés étrangères, sauf si ces
   tables sont aussi comprises dans la commande. Dans le cas contraire, la
   vérification nécessiterait des parcours complets de tables, ce qui n'est pas
   le but de la commande <command>TRUNCATE</command>. L'option
   <literal>CASCADE</literal> est utilisable pour inclure automatiquement
   toutes les tables dépendantes &mdash; faites attention lorsque vous utilisez
   cette option parce que vous pourriez perdre des données que vous auriez
   souhaitez conserver&nbsp;!
  </para>

  <para>
   <command>TRUNCATE</command> ne déclenchera aucun trigger <literal>ON
   DELETE</literal> qui pourrait exister sur les tables. But it will fire
   <literal>ON TRUNCATE</literal> triggers.
   If <literal>ON TRUNCATE</> triggers are defined for any of
   the tables, then all <literal>BEFORE TRUNCATE</literal> triggers are
   fired before any truncation happens, and all <literal>AFTER
   TRUNCATE</literal> triggers are fired after the last truncation is
   performed.  The triggers will fire in the order that the tables are
   to be processed (first those listed in the command, and then any
   that were added due to cascading).
  </para>

  <warning>
   <para>
    <command>TRUNCATE</command> n'est pas compatible avec MVCC (voir <xref
     linkend="mvcc"/> pour des informations générales sur MVCC). Après un
    vidage, la table apparaîtra vide pour toutes les transactions en cours
    même si elles utilisent une image prise avant le début du vidage. Ceci
    est un problème pour une transaction qui n'a pas eu un accès à la table
    avant le vidage &mdash; toute transaction qui y a accédé avant détient
    au moins un verrou <literal>ACCESS SHARE</literal> qui bloquera
    <command>TRUNCATE</command> jusqu'à la fin de la transaction. Donc le
    vidage ne causera aucune incohérence apparente dans le contenu de la
    table pour des requêtes successives sur la même table, mais il causera
    une incohérence visble entre la table tronquée et les autres tables de
    la base.
   </para>

   <para>
    Néanmoins, <command>TRUNCATE</command> est compatible avec le système des
    transactions&nbsp;: un tronquage pourrait être annulée si la transaction en
    cours n'est pas validée.
   </para>
  </warning>

  <para>
   <command>TRUNCATE</> is transaction-safe with respect to the data
   in the tables: the truncation will be safely rolled back if the surrounding
   transaction does not commit.
  </para>

  <warning>
   <para>
    Any <command>ALTER SEQUENCE RESTART</> operations performed as a
    consequence of using the <literal>RESTART IDENTITY</> option are
    nontransactional and will not be rolled back on failure.  To minimize
    the risk, these operations are performed only after all the rest of
    <command>TRUNCATE</>'s work is done.  However, there is still a risk
    if <command>TRUNCATE</> is performed inside a transaction block that is
    aborted afterwards.  For example, consider

<programlisting>
BEGIN;
TRUNCATE TABLE foo RESTART IDENTITY;
COPY foo FROM ...;
COMMIT;
</programlisting>

    If the <command>COPY</> fails partway through, the table data
    rolls back correctly, but the sequences will be left with values
    that are probably smaller than they had before, possibly leading
    to duplicate-key failures or other problems in later transactions.
    If this is likely to be a problem, it's best to avoid using
    <literal>RESTART IDENTITY</>, and accept that the new contents of
    the table will have higher serial numbers than the old.
   </para>
  </warning>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Vider les tables <literal>grossetable</literal> et
   <literal>grandetable</literal>&nbsp;:

<programlisting>TRUNCATE grossetable, grandetable;
</programlisting>
  </para>
  
  <para>
   The same, and also reset any associated sequence generators:

<programlisting>
TRUNCATE bigtable, fattable RESTART IDENTITY;
</programlisting>
  </para>

  <para>
   Vide la table <literal>uneautretable</literal>, et cascade cela à toutes
   les tables qui référencent <literal>uneautretable</literal> via des
   contraintes de clés étrangères&nbsp;:

<programlisting>
TRUNCATE uneautretable CASCADE;
</programlisting>
  </para>
 </refsect1>
 
 <refsect1>
  <title>Compatibilité</title>

  <para>
   The SQL:2008 standard includes a <command>TRUNCATE</command> command with the syntax
   <literal>TRUNCATE TABLE <replaceable>tablename</replaceable></literal>.
   The clauses <literal>CONTINUE IDENTITY</literal>/<literal>RESTART IDENTITY</literal>
   also appear in that standard but have slightly different but related meanings.
   Some of the concurrency behavior of this command is left implementation-defined
   by the standard, so the above notes should be considered and compared with
   other implementations if necessary.
  </para>
 </refsect1>
</refentry>
