<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/update.sgml,v 1.9 2005/04/22 06:38:58 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060228 pour la relecture -->
<!-- SAS 20060327 : tags -->

<refentry id="sql-update">
 <refmeta>
  <refentrytitle id="sql-update-title">UPDATE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>UPDATE</refname>
  <refpurpose>met à jour les lignes d'une table</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
UPDATE [ ONLY ] <replaceable class="parameter">table</replaceable> SET <replaceable class="parameter">colonne</replaceable> = { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...]
    [ FROM <replaceable class="parameter">liste_from</replaceable> ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-update">
   <primary>UPDATE</primary>
  </indexterm>


  <para>
   <command>UPDATE</command> modifie les valeurs des colonnes spécifiées pour
   toutes les lignes qui satisfont la condition. Seules les colonnes à
   modifier doivent être mentionnées dans la clause
   <literal>SET</literal>&nbsp;; Les autres colonnes conservent leur
   valeur précédente.
  </para>

  <para>
   Par défaut, <command>UPDATE</command> met à jour les lignes de la table
   spécifiée et toutes ses sous-tables. 
   Si seule la table mentionnée doit être mise à jour, la clause
   <literal>ONLY</literal> sera utilisée.
  </para>

  <para>
   Il existe deux façons de modifier une table en utilisant les informations
   contenues dans d'autres tables de la base de données&nbsp;: en utilisant des
   sous-requêtes ou en spécifiant des tables supplémentaires dans la clause
   <literal>FROM</literal>. La technique la plus appropriée dépend des
   circonstances.
  </para>

  <para>
   L'utilisateur doit avoir la permission <literal>UPDATE</literal> sur la table pour
   la mettre à jour, ainsi que le droit <literal>SELECT</literal> sur toutes les
   tables dont les valeurs sont lues dans 
   <replaceable class="parameter">expression</replaceable> ou 
   <replaceable class="parameter">condition</replaceable>.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">table</replaceable></term>
    <listitem>
     <para>
      Le nom de la table à mettre à jour (peut être qualifié par le nom du
      schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne dans <replaceable class="parameter">table</replaceable>.
      Le nom de la colonne peut être qualifié avec un nom de sous-champ ou un
      indice de tableau, si nécessaire.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">expression</replaceable></term>
    <listitem>
     <para>
      Une expression à affecter à la colonne. L'expression peut utiliser
      les anciennes valeurs de cette colonne ou d'autres colonnes de la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT</literal></term>
    <listitem>
     <para>
      Initialise la colonne à sa valeur par défaut (qui vaut NULL si aucune
      expression spécifique ne lui a été affectée par défaut).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">liste_from</replaceable></term>
    <listitem>
     <para>
      Une liste d'expressions de tables, permettant aux colonnes des autres
      tables d'apparaître dans la condition <literal>WHERE</literal> et les
      expressions de mise à jour. Cela est similaire à la liste de tables
      pouvant être spécifiée dans <xref linkend="sql-from" endterm="sql-from-title"/> 
      d'une instruction <command>SELECT</command>.
      La table cible ne doit pas apparaître dans
      <replaceable>liste_from</replaceable>, sauf en cas d'auto-jointure
      (auquel cas elle doit apparaître avec un alias dans
      <replaceable>liste_from</replaceable>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
     <para>
      Une expression qui renvoie une valeur de type <type>boolean</type>.
      Seules les lignes pour lesquelles cette expression renvoie
      <literal>true</literal> sont mises à jour.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Sorties</title>

  <para>
   En cas de succès, une commande <command>UPDATE</command> renvoie un message
   de la forme
<screen>
UPDATE <replaceable class="parameter">total</replaceable>
</screen>
   Le <replaceable class="parameter">total</replaceable> est le nombre de
   lignes mises à jour. Si <replaceable class="parameter">total</replaceable>
   vaut 0, aucune ligne ne correspond à <replaceable class="parameter">condition</replaceable> 
   (ceci n'est pas considéré comme une erreur).
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Quand une clause <literal>FROM</literal> est présente, la table cible est jointe
   aux tables mentionnées dans <replaceable>liste_from</replaceable>, et chaque
   ligne en sortie de la jointure représente une opération de mise à jour pour
   la table cible. Lors de l'utilisation de <literal>FROM</literal>, il faut s'assurer
   que la jointure produit au moins une ligne en sortie pour chaque
   ligne à modifier. En d'autres termes, une ligne cible ne doit pas être
   jointe plus d'une fois à une ligne d'une autre table. Si c'est le cas, alors
   seule une ligne de jointures est utilisée pour mettre à jour la
   ligne cible. Il n'est pas possible de prévoir cette ligne.
  </para>

  <para>
   À cause de ce manque de déterminisme, il est plus sûr de ne référencer 
   d'autres tables qu'à l'intérieur de sous-requêtes, même si c'est plus 
   difficile à lire et plus lent que l'utilisation d'une jointure.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Modifier le mot <literal>Drame</literal> en <literal>Dramatique</literal> dans la colonne
   <structfield>genre</structfield> de la table <structname>films</structname>&nbsp;:

<programlisting>
UPDATE films SET genre = 'Dramatique' WHERE genre = 'Drame';
</programlisting>
  </para>

  <para>
   Ajuster les entrées de température et réinitialiser la précipitation à sa
   valeur par défaut dans une ligne de la table
   <structname>temps</structname>&nbsp;:

<programlisting>
UPDATE temps SET temp_basse = temp_basse+1, temp_haute = temp_basse+15, prcp =
DEFAULT
  WHERE ville = 'San Francisco' AND date = '2003-07-03';
</programlisting>
  </para>

  <para>
   Incrémenter le total des ventes de la personne qui gère le compte d'Acme
   Corporation, en utilisant la syntaxe de la clause du
   <literal>FROM</literal>&nbsp;:
<programlisting>
UPDATE employes SET total_ventes = total_ventes + 1 FROM comptes
  WHERE compte.nom = 'Acme Corporation'
  AND employes.id = compte.vendeur;
</programlisting>
  </para>

  <para>
   Réaliser la même opération en utilisant une sous-requête dans la clause
   <literal>WHERE</literal>&nbsp;:
<programlisting>
UPDATE employes SET total_ventes = total_ventes + 1 WHERE id =
  (SELECT vendeur FROM comptes WHERE nom = 'Acme Corporation');
</programlisting>
  </para>

  <para>
   Maintenant que tous les papiers sont signés, on peut mettre à jour l'affaire
   la plus récemment terminée du vendeur qui a terminé l'affaire des
   <quote>Rocket Powered Skates</quote> avec la société Acme.
<programlisting>
UPDATE employes SET derniere_affaire_terminee = affaire.id
    FROM comptes JOIN affaires ON (compte.id = affaire.id_compte)
    WHERE affaire.id_employe = employes.id
    AND affaires.nom = 'Rocket Powered Skates'
    AND comptes.nom = 'Acme Corporation'
    ORDER BY affaire.date_signee DESC LIMIT 1;
</programlisting>
  </para>

  <para>
   Tenter d'insérer un nouvel élément dans le stock avec sa quantité. Si
   l'élément existe déjà, à la place, mettre à jour le total du stock de l'élément
   existant. Pour faire cela sans échec dans la transaction entière, utiliser les
   points de sauvegarde.
   <programlisting>
BEGIN;
-- autres opérations
SAVEPOINT sp1;
INSERT INTO vins VALUES('Chateau Lafite 2003', '24');
-- Suppose que l'instruction ci-dessus échoue à cause d'une violation de clé
-- unique, donc nous lançons maintenant ces commandes:
ROLLBACK TO sp1;
UPDATE vins SET stock = stock + 24 WHERE nomvin = 'Chateau Lafite 2003';
-- continue avec les autres opérations, et enfin
COMMIT;
 </programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Cette commande est conforme au standard <acronym>SQL</acronym>, à
   l'exception de la clause <literal>FROM</literal> qui est une extension
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   D'autres systèmes de bases de données offrent une option
   <literal>FROM</literal> dans laquelle la table cible est supposée être de nouveau
   indiquée dans le <literal>FROM</literal>. Ce n'est pas ainsi que
   <productname>PostgreSQL</productname> interprète <literal>FROM</literal>. 
   Il est important d'y faire attention pour le portage d'applications 
   utilisant cette extension.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
