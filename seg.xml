
<sect1 id="seg">
 <title>seg</title>
 
 <indexterm zone="seg">
  <primary>seg</primary>
 </indexterm>

 <para>
  Le module <literal>seg</literal> contient du code concernant le type
  utilisateur <literal>SEG</literal>, représentant des mesures de laboratoire
  sous la forme d'intervalle de nombres à virgule flottante.
 </para>
 
 <sect2>
  <title>Explications</title>
  <para>
   La géométrie des mesures est habituellement plus complexe qu'un point
   dans un continuum numérique. Une mesure est habituellement un segment
   de ce continuum avec des limites non définissables. Les mesures
   apparaissent comme des intervalles à cause de ce côté incertain et
   du hasard, ainsi qu'à cause du fait que la valeur mesurée peut
   naturellement être un intervalle indiquant certaines conditions comme
   une échelle de température pour la stabilité d'une protéine.
  </para>
  <para>
   En utilisant le bon sens, il apparaît plus agréable de stocker de telles
   données sous la forme d'intervalle, plutôt que sous la forme d'une paire
   de nombres. En pratique, c'est même plus efficace dans la plupart des
   applications.
  </para>
  <para>
   En allant plus loin, le côté souple des limites suggère que l'utilisation
   des types de données numériques traditionnels amène en fait une certaine
   perte d'informations. Pensez à ceci&nbsp;: votre instrument lit
   6.50, et vous saisissez cette valeur dans la base de données.
   Qu'obtenez-vous en la récupérant&nbsp;? Regardez&nbsp;:
  </para>
  <programlisting>
test=> select 6.50 as "pH";
 pH
---
6.5
(1 row)
  </programlisting>
  <para>
   Dans le monde des mesures, 6.50 n'est pas identique à 6.5. La différence
   pourrait même être critique. Les personnes ayant réalisé l'expérience
   écrivent habituellement (et publient) les chiffres qu'ils connaissent.
   6.50 est en fait un intervalle incertain compris dans un intervalle
   plus grand et encore plus incertain, 6.5, le point central étant
   (probablement) la seule fonctionnalité commune qu'ils partagent. Nous
   ne voulons pas que de telles différences de données apparaissent de
   façon identique.
  </para>
  <para>
   La conclusion&nbsp;? il est agréable d'avoir un type de données spécial
   qui peut enregistrer les limites d'un intervalle avec une précision
   variable arbitraire. Variable dans le sens où chaque élément de données
   enregistre sa propre précision.
  </para>
  <para>
   Vérifiez ceci&nbsp;:
  </para>
  <programlisting>
test=> select '6.25 .. 6.50'::seg as "pH";
          pH
------------
6.25 .. 6.50
(1 row)
  </programlisting>
 </sect2>

 <sect2>
  <title>Syntaxe</title>
  <para>
   La représentation externe d'un intervalle se forme en utilisant un ou deux
   nombres à virgule flottante joint par l'opérateur d'échelle ('..' ou '...').
   Des indicateurs optionel (&lt;, &gt; et ~) sont ignorés par la logique
   interne mais sont conservés dans les données.
  </para>
  
  <table>
   <title>Règles</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>règle 1</entry>
      <entry>seg -> limite PLUMIN déviation</entry>
     </row>
     <row>
      <entry>règle 2</entry>
      <entry>seg -> limite RANGE limite</entry>
     </row>
     <row>
      <entry>règle 3</entry>
      <entry>seg -> limite RANGE</entry>
     </row>
     <row>
      <entry>règle 4</entry>
      <entry>seg -> RANGE limite</entry>
     </row>
     <row>
      <entry>règle 5</entry>
      <entry>seg -> limite</entry>
     </row>
     <row>
      <entry>règle 6</entry>
      <entry>limite -> FLOAT</entry>
     </row>
     <row>
      <entry>règle 7</entry>
      <entry>limite -> EXTENSION FLOAT</entry>
     </row>
     <row>
      <entry>règle 8</entry>
      <entry>déviation -> FLOAT</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Jetons</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>RANGE</entry>
      <entry>(\.\.)(\.)?</entry>
     </row>
     <row>
      <entry>PLUMIN</entry>
      <entry>\'\+\-\'</entry>
     </row>
     <row>
      <entry>integer</entry>
      <entry>[+-]?[0-9]+</entry>
     </row>
     <row>
      <entry>real</entry>
      <entry>[+-]?[0-9]+\.[0-9]+</entry>
     </row>
     <row>
      <entry>FLOAT</entry>
      <entry>({integer}|{real})([eE]{integer})?</entry>
     </row>
     <row>
      <entry>EXTENSION</entry>
      <entry><![CDATA[[<>~]]]></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 
  <table>
   <title>Exemples de représentations <literal>SEG</literal> valides</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>Any number</entry>
      <entry>
       (règles 5,6) -- crée un segment de taille nulle (un point si vous
       préférez)
      </entry>
     </row>
     <row>
      <entry>~5.0</entry>
      <entry>
       (règles 5,7) -- crée un segment de taille nulle et enregistre
       '~' dans les données. Cette notation se lit <quote>approximativement
       5.0</quote>, mais sa signification n'est pas reconnue par le code.
       Elle est ignorée jusqu'à ce que vous récupériez la valeur. Vous
       pouvez comprendre cela comme un commentaire rapide.
      </entry>
     </row> 
     <row>
      <entry>&lt;5.0</entry>
      <entry>
       (règles 5,7) -- crée un point à 5.0&nbsp;; '&lt;' est ignoré mais
       est conservé comme commentaire
      </entry>
     </row>
     <row>
      <entry>>5.0</entry>
      <entry>
       (règles 5,7) -- crée un point à 5.0&nbsp;; '&gt;' est ignoré mais
       est conservé comme commentaire
      </entry>
     </row>
     <row>
      <entry><para>5(+-)0.3</para><para>5'+-'0.3</para></entry>
      <entry>
       <para>
        (règles 1,8) -- crée un intervalle '4.7..5.3'. Actuellement
        (02/09/2000), ce mécanisme n'est pas réellement précis pour
	déterminer le nombre de chiffres significatifs pour les limites.
	Par exemple, il ajoute un chiffre supplémentaire à la limite basse
	si l'intervalle résultat inclut une puissance de dix&nbsp;:
       </para>
       <programlisting>
postgres=> select '10(+-)1'::seg as seg;
      seg
---------
9.0 .. 11 -- should be: 9 .. 11
       </programlisting>
       <para>
        De plus, la notation (+-) n'est pas conservée&nbsp;: 'a(+-)b' sera
	toujours renvoyée comme '(a-b) .. (a+b)'. Le but de cette notation
        est d'autoriser la saisie de certaines données sans conversion.
       </para>
      </entry>
     </row>
     <row>
      <entry>50 .. </entry>
      <entry>(règle 3) -- tout ce qui est plus grand ou égale à 50</entry>
     </row>
     <row>
      <entry>.. 0</entry>
      <entry>(règle 4) -- tout ce qui est plus petit ou égale à 0</entry>
     </row>
     <row>
      <entry>1.5e-2 .. 2E-2 </entry>
      <entry>(règle 2) -- crée un intervalle (0.015 .. 0.02)</entry>
     </row>
     <row>
      <entry>1 ... 2</entry>
      <entry>
       Identique à 1...2, ou 1 .. 2, ou 1..2 (les espaces sont ignorés).
       À cause de l'utilisation généralisée de '...' dans les sources
       de données, j'ai décidé de l'utiliser comme opérateur d'échelle.
       Ceci, et aussi le fait que l'espace blanc autour de l'opérateur
       d'échelle est ignoré, crée un conflit d'analyse avec les constantes
       numériques commençant avec un point décimal.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Exemples</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>.1e7</entry>
      <entry>devrait être&nbsp;: 0.1e7</entry>
     </row>
     <row>
      <entry>.1 .. .2</entry>
      <entry>devrait être&nbsp;: 0.1 .. 0.2</entry>
     </row>
     <row>
      <entry>2.4 E4</entry>
      <entry>devrait être&nbsp;: 2.4E4</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   Ce qui suit, bien que cela ne soit pas une erreur de syntaxe, est interdit
   pour améliorer la qualité de la donnée&nbsp;:
  </para>
  <table>
   <title></title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>5 .. 2</entry>
      <entry>devrait être&nbsp;: 2 .. 5</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2>
  <title>Précision</title>
  <para>
   Les segments sont stockés en interne sous la forme de paires de nombres en
   virgule flottante de 32 bits. Cela signifie que les nombres avec plus de
   sept chiffres significatifs sont tronqués.
  </para>
  <para>
   Les nombres avec moins ou avec exactement sept chiffres significatifs
   conservent leur précision originale. C'est-à-dire que, si votre requête
   renvoie 0.00, vous serez sûr que les zéros qui suivent ne sont pas des
   conséquences du formatage&nbsp;: elles reflètent la précision de la donnée
   originale. Le nombre de zéro au début n'affectent pas la précision&nbsp;:
   deux chiffres significatifs sont considérés pour la valeur 0.0067.
  </para>
 </sect2>

 <sect2>
  <title>Utilisation</title>
  <para>
   La méthode d'accès pour SEG est un index GiST (gist_seg_ops), qui est une
   généralisation de R-tree. GiST permet l'implémentation postgres de
   R-tree, développé à l'origine pour supporter les types géométriques à
   deux dimensions comme les boîtes et les polygones et pour être utilisé
   avec tout type de données dont le domaine peut être partitionné en utilisant
   les concepts de contenance, d'intersection et d'égalité. En d'autres mots,
   tout ce qui peut contenir une partie ou tout de son propre type peut être
   indexé dans un index GiST. Ceci inclut, parmi d'autres, tous les types
   de données géométriques, quelque soit le nombre de dimensions (voir aussi
   le module contrib/cube).
  </para>
  <para>
   Voici les opérateurs supportés en utilisant la méthode d'accès GiST&nbsp;:
  </para>
  <itemizedlist>
   <listitem>
    <programlisting><![CDATA[
[a, b] << [c, d]        est à gauche de
    ]]></programlisting>
    <para>
     L'opérande gauche, [a, b], se trouve entièrement à gauche de l'opérande
     droit, [c, d], sur l'axe (-inf, inf). Cela signifie que
     [a, b] &lt;&lt; [c, d] est vérifié si b &lt; c
    </para>
   </listitem>
   <listitem>
    <programlisting>
[a, b] >> [c, d]        est à droite de
    </programlisting>
    <para>
        [a, b] se trouve entièrement à droite de [c, d].
        [a, b] &gt;&gt; [c, d] est vérifié si a &gt; d
    </para>
   </listitem>
   <listitem>
    <programlisting><![CDATA[
[a, b] &< [c, d]        Couvre une partie ou est à gauche de
    ]]></programlisting>
    <para>
        Ceci signifie <quote>ne s'étend pas à droite de</quote>.
        Ceci est vrai quand b &lt;= d.
    </para>
   </listitem>
   <listitem>
    <programlisting><![CDATA[
[a, b] &> [c, d]        Couvre une partie ou est à droite de
    ]]></programlisting>
    <para>
        Ceci signifie <quote>ne s'étend pas à gauche de</quote>.
        Ceci est vrai quand a >= c.
    </para>
   </listitem>
   <listitem>
    <programlisting>
[a, b] = [c, d]                Identique à
    </programlisting>
    <para>
        Les segments [a, b] et [c, d] sont identiques, autrement dit a == b
        et c == d
    </para>
   </listitem>
   <listitem>
    <programlisting><![CDATA[
[a, b] && [c, d]        Couvre une partie
    ]]></programlisting>
    <para>
        Les segments [a, b] et [c, d] se chevauchent en partie.
    </para>
   </listitem>
   <listitem>
    <programlisting><![CDATA[
[a, b] @> [c, d]                Contient
    ]]></programlisting>
    <para>
        Le segment [a, b] contient le segment [c, d], autrement dit
        a &lt;= c et b &gt;= d
    </para>
   </listitem>
   <listitem>
    <programlisting><![CDATA[
[a, b] <@ [c, d]                Est contenu dans
    ]]></programlisting>
    <para>
        Le segment [a, b] est contenu dans [c, d], autrement dit
        a &gt;= c et b &lt;= d
    </para>
   </listitem>
  </itemizedlist>
  <para>
   (Avant PostgreSQL 8.2, les opérateurs de contenance @&gt; et &lt;@ étaient
   appelés respectivement @ et ~. Ces noms sont toujours disponibles mais sont
   déclarés obsolètes et seront supprimés un jour. Notez que les anciens noms
   sont inversés par rapport à la convention suivie par les types de données
   géométriques&nbsp;!)
  </para>
  <para>
   Bien que les mnémoniques des opérateurs suivants sont questionnables, je
   les ai préservé pour maintenir une cohérence visuelle avec les autres
   types de données géométriques dans Postgres.
  </para>
  <para>
   Les autres opérateurs&nbsp;:
  </para>

  <programlisting><![CDATA[
[a, b] < [c, d]                Plus petit que
[a, b] > [c, d]                Plus grand que
  ]]></programlisting>
  <para>
   Ces opérateurs n'ont pas vraiment de sens sauf en ce qui concerne le tri.
   Ces opérateurs comparent en premier (a) à (c) et, s'ils sont égaux,
   comparent (b) à (d). Cela fait un bon tri dans la plupart des cas, ce qui
   est utile si vous voulez utiliser ORDER BY avec ce type.
  </para>

  <para>
   Il existe quelques fonctions potentiellement utiles définies dans seg.c
   qui ont disparu du schéma car j'ai arrêté de les utiliser. Certaines
   avaient pour but de supporter la conversion de type. Prévenez-moi si
   j'ai eu tort, je les rajouterais dans le schéma. J'apprécierais aussi
   d'autres idées pour améliorer le type et le rendre plus utile.
  </para>
  <para>
   Pour des exemples d'utilisation, voir sql/seg.sql
  </para>
  <para>
   Note&nbsp;: la performance d'un index R-tree peut dépendre largement de
   l'ordre des valeurs en entrée. Il pourrait être très utile de trier la table
   en entrée sur la colonne SEG (voir le script sort-segments.pl pour un
   exemple).
  </para>
 </sect2>

 <sect2>
  <title>Crédits</title>
  <para>
   Mes remerciements vont principalement au professeur Joe Hellerstein
   (<ulink url="http://db.cs.berkeley.edu/~jmh/"></ulink>) pour avoir élucidé
   l'idée centrale de GiST (<ulink
   url="http://gist.cs.berkeley.edu/"></ulink>). Mes remerciements aussi aux
   développeurs de PostgreSQL pour m'avoir permis de créer mon propre monde
   et de pouvoir y vivre sans pertubation. Argonne Lab et le département
   américain de l'énergie ont aussi toute ma gratitude pour les années de
   support dans ma recherche sur les bases de données.
  </para>
  <programlisting>
   Gene Selkov, Jr.
   Computational Scientist
   Mathematics and Computer Science Division
   Argonne National Laboratory
   9700 S Cass Ave.
   Building 221
   Argonne, IL 60439-4844
  </programlisting>
  <para>
   <email>selkovjr@mcs.anl.gov</email>
  </para>
 </sect2>

</sect1>
