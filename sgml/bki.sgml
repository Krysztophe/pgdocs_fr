<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/bki.sgml,v 1.6 2005/03/14 06:03:48 guillaume Exp $
 -->

<chapter id="bki">
 <title>Interface du moteur <acronym>BKI</acronym></title>

 <para>
  Les fichiers d'interface du moteur (<acronym>BKI</acronym>) sont des scripts
  écrits dans un langage spécial, qui est compris par le serveur
  <productname>PostgreSQL</productname> quand il est lancé dans le mode spécial
  <quote>bootstrap</quote>. Ce mode autorise la création des catalogues
  systèmes alors que les commandes SQL requièrent l'existence des catalogues.
  Les fichiers <acronym>BKI</acronym> peuvent donc être utilisés pour créer le
  système de base de données en tout premier lieu. (Et ils ne sont probablement
  pas utiles pour un autre emploi.)
 </para>

 <para>
  <application>initdb</application> utilise un fichier <acronym>BKI</acronym>
  pour faire une partie de son travail lors de la création d'un nouveau groupe
  de base de données. Le fichier en entrée utilisé par
  <application>initdb</application> est créé lors de la construction et de
  l'installation de <productname>PostgreSQL</productname> par un programme
  nommé <filename>genbki.sh</filename> qui lit les quelques fichiers d'en-têtes
  C spécialement formatés dans le répertoire
  <filename>src/include/catalog</filename> des sources. Le fichier
  <acronym>BKI</acronym> créé est appelé <filename>postgres.bki</filename> et
  est normalement installé dans le sous-répertoire <filename>share</filename>
  du répertoire d'installation.
 </para>

 <para>
  Des informations plus complètes sont disponibles dans la documentation pour
  <application>initdb</application>.
 </para>

 <sect1 id="bki-format">
  <title>Format des fichiers <acronym>BKI</acronym></title>

  <para>
   Cette section décrit comment le serveur <productname>PostgreSQL</productname>
   interprète les fichiers <acronym>BKI</acronym>. Cette description
   sera plus simple à comprendre si le fichier <filename>postgres.bki</filename>
   se trouve à portée de main comme exemple.
  </para>

  <para>
   L'entrée <acronym>BKI</acronym> consiste en une séquence de commandes. Les
   commandes sont constituées d'un certain nombre d'éléments, suivant la syntaxe de
   la commande. Les éléments sont habituellement séparés par des espaces blancs
   mais n'ont pas besoin de l'être s'il n'y a pas d'ambiguïté. Il n'existe pas
   de séparateur spécial pour les commandes&nbsp;; le prochain élément qui ne
   peut syntaxiquement pas appartenir à la commande précédente en lance une
   autre. (Habituellement, vous devriez mettre une nouvelle commande sur une
   nouvelle ligne pour plus de clarté.) Les éléments peuvent être certains mots
   clés, des caractères spéciaux (parenthèses, virgules, etc.), nombres ou
   chaînes de caractères entre guillemets doubles. Tous sont sensibles à la
   casse.
  </para>

  <para>
   Les lignes commençant avec un <literal>#</literal> sont ignorées.
  </para>

 </sect1>

 <sect1 id="bki-commands">
  <title>Commandes <acronym>BKI</acronym></title>

  <variablelist>
   <varlistentry>
    <term>
     create 
     <optional>bootstrap</optional>
     <optional>shared_relation</optional>
     <optional>without_oids</optional>
     <replaceable class="parameter">nomtable</replaceable>
     (<replaceable class="parameter">nom1</replaceable> =
     <replaceable class="parameter">type1</replaceable> <optional>,
     <replaceable class="parameter">nom2</replaceable> = <replaceable
     class="parameter">type2</replaceable>, ...</optional>)
    </term>

    <listitem>
     <para>
      Crée une table nommée <replaceable
      class="parameter">nomtable</replaceable> avec les colonnes données entre
      parenthèses.
     </para>

     <para>
      Les types de colonnes suivants sont supportés directement par
      <filename>bootstrap.c</>: <type>bool</type>,
      <type>bytea</type>, <type>char</type> (1 byte),
      <type>name</type>, <type>int2</type>,
      <type>int4</type>, <type>regproc</type>, <type>regclass</type>,
      <type>regtype</type>, <type>text</type>,
      <type>oid</type>, <type>tid</type>, <type>xid</type>,
      <type>cid</type>, <type>int2vector</type>, <type>oidvector</type>,
      <type>_int4</type> (array), <type>_text</type> (array),
      <type>_aclitem</type> (array). Bien qu'il soit possible de créer des
      tables contenant des colonnes d'autres types, ceci ne peut pas être fait
      tant que <structname>pg_type</> n'est pas créé et rempli avec les entrées
      appropriées.
     </para>

     <para>
      Quand <literal>bootstrap</> est spécifié, la table sera seulement
      construite sur disque&nbsp;; rien n'est saisi dans
      <structname>pg_class</structname>, <structname>pg_attribute</structname>,
      etc, pour elle. Du coup, la table ne sera pas accessible par des
      opérations SQL standards jusqu'à ce que de nouvelles entrées sont
      réalisées (avec des commandes <literal>insert</>). Cette option est
      utilisée pour créer <structname>pg_class</structname>, etc.
     </para>

     <para>
      La table est créée comme partagée si <literal>shared_relation</> est
      spécifié. Elle aura des OID sauf si <literal>without_oids</> est spécifié.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     open <replaceable class="parameter">nomtable</replaceable>
    </term>

    <listitem>
     <para>
      Ouvre la table nommée
      <replaceable class="parameter">nomtable</replaceable>
      pour plus de manipulations.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     close <optional><replaceable class="parameter">nomtable</replaceable></optional>
    </term>

    <listitem>
     <para>
      Ferme la table ouverte appelée <replaceable
      class="parameter">nomtable</replaceable>. Une erreur survient si
      <replaceable class="parameter">nomtable</replaceable> n'est pas déjà
      ouverte. Si <replaceable class="parameter">nomtable</replaceable> n'est
      pas indiqué, alors la table actuellement ouverte est fermée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     insert <optional>OID = <replaceable class="parameter">valeur_oid</replaceable></optional> (<replaceable class="parameter">valeur1</replaceable> <replaceable class="parameter">valeur2</replaceable> ...)
    </term>

    <listitem>
     <para>
      Insère une nouvelle ligne dans la table ouverte en utilisant <replaceable
      class="parameter">valeur1</replaceable>, <replaceable
      class="parameter">valeur2</replaceable>, etc., comme valeurs de ses
      colonnes et <replaceable
      class="parameter">valeur_oid</replaceable> pour son OID. Si
      <replaceable class="parameter">valeur_oid</replaceable> vaut zéro
      (0) ou si la clause est omise, alors le prochain OID disponible est
      utilisé.
     </para>

     <para>
      Les valeurs NULL peuvent être indiquées en utilisant le mot clé spécial
      <literal>_null_</literal>. Les valeurs contenant des espaces doivent être
      entre des guillemets doubles.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     declare <optional>unique</optional> index <replaceable
     class="parameter">nomindex</replaceable> on <replaceable
     class="parameter">nomtable</replaceable> using <replaceable
     class="parameter">nomma</replaceable> (<replaceable
     class="parameter">classeop1</replaceable> <replaceable
     class="parameter">nom1</replaceable> <optional>, ...</optional>)
    </term>

    <listitem>
     <para>
      Crée un index nommé <replaceable
      class="parameter">nomindex</replaceable> sur la table nommée
      <replaceable class="parameter">nomtable</replaceable> en utilisant la
      méthode d'accès nommée <replaceable class="parameter">nomma</replaceable>.
      Les champs de l'index sont appelés <replaceable
      class="parameter">nom1</replaceable>, <replaceable
      class="parameter">nom2</replaceable> etc., et les classes d'opérateur à
      utiliser sont respectivement <replaceable
      class="parameter">classeop1</replaceable>, <replaceable
      class="parameter">classeop2</replaceable> etc.
      Le fichier index est créé et les entrées du catalogue appropriées sont
      ajoutées pour lui, mais le contenu de l'index n'est pas initialisé par
      cette commande.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>build indices</term>

    <listitem>
     <para>
      Remplit les index précédemment déclarés.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="bki-example">
  <title>Exemple</title>

  <para>
   La séquence suivante de commandes créera la table
   <literal>test_table</literal> avec deux colonnes
   <literal>cola</literal> et <literal>colb</literal> de type, respectivement,
   <type>int4</type> et <type>text</type> et insèrera deux lignes dans la
   table.
<programlisting>
create test_table (cola = int4, colb = text)
open test_table
insert OID=421 ( 1 "value1" )
insert OID=422 ( 2 _null_ )
close test_table
</programlisting>
  </para>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->

