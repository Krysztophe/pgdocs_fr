<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/diskusage.sgml,v 1.6.2.1 2005/03/14 06:02:59 guillaume Exp $
-->

<chapter id="diskusage">
 <title>Surveillance de l'utilisation de l'espace disque</title>

 <para>
  Ce chapitre traite de la manière d'effectuer une surveillance sur
  l'utilisation de l'espace disque par un système de bases de données 
  <productname>PostgreSQL</productname>. Dans la version actuelle,
  l'administrateur de la base de données ne dispose pas de beaucoup
  de moyens de contrôles sur la manière dont les données sont stockées
  sur les disques. Ce chapitre est donc surtout informatif et peut vous
  donner une idée plus précise de la manière de gérer les disques
  en utilisant plutôt les outils fournis avec le système d'exploitation.
  
 </para>

 <sect1 id="disk-usage">
  <title>Déterminer l'utilisation de l'espace disque</Title>

  <indexterm zone="disk-usage">
   <primary>utilisation de l'espace disque</primary>
  </indexterm>

  <para>
   Chaque table possède un fichier d'en-tête principal dans lequel la plupart
   des données sont stockées. Afin de stocker les données des grosses colonnes,
   un fichier <acronym>TOAST</acronym> est également associé à la table dont le
   nom est basé sur l'OID (en fait il s'agit de
   <literal>pg_class.relfilenode</literal>).
   Pour finir, on lui associe un index dans la table <acronym>TOAST</acronym>. 
   Il peut y avoir par ailleurs d'autres index associés à la table de base.
  </para>

  <para>
  Vous pouvez surveiller l'espace disque en utilisant trois méthodes&nbsp;:
  depuis <application>psql</application> en utilisant les résultats de 
  la commande <command>VACUUM</command>, depuis <application>psql</application>
  en utilisant l'outil se trouvant dans <filename>contrib/dbsize</filename>,
  et depuis la ligne de commande en utilisant l'outil contenu dans 
  <filename>contrib/oid2name</filename>. En utilisant 
  <application>psql</application> sur une base de données sur laquelle ont
  été lancés <command>VACUUM</command> ou <command>ANALYZE</command>,
  vous pouvez lancer des requêtes vous permettant d'obtenir des informations
  sur la place occupée par n'importe quelle table&nbsp;:
<programlisting>
SELECT relfilenode, relpages FROM pg_class WHERE relname = 'customer';

 relfilenode | relpages 
-------------+----------
       16806 |       60
(1 ligne)
</programlisting>
   Chaque page utilise en général 8&nbsp;Ko de d'espace disque (ne pas oublier
   que <literal>relpage</literal> n'est mis à jour que par l'utilisation des 
   commandes <command>VACUUM</command> et <command>ANALYZE</command>.)
  </para>

  <para>
   Afin de connaître l'espace disque utilisé par les tables 
   <acronym>TOAST</acronym>, lancez une requête similaire à la suivante en
   remplaçant le nombre du <literal>relfilenode</literal> de la table (défini 
   par la requête ci-dessus)&nbsp;:
<programlisting>
SELECT relname, relpages
    FROM pg_class
    WHERE relname = 'pg_toast_16806' OR relname = 'pg_toast_16806_index'
    ORDER BY relname;

       relname        | relpages 
----------------------+----------
 pg_toast_16806       |        0
 pg_toast_16806_index |        1
</programlisting>
  </para>

  <para>
   Vous pouvez afficher également la taille des index&nbsp;:
<programlisting>
SELECT c2.relname, c2.relpages
    FROM pg_class c, pg_class c2, pg_index i
    WHERE c.relname = 'customer'
        AND c.oid = i.indrelid
        AND c2.oid = i.indexrelid
        ORDER BY c2.relname;

       relname        | relpages 
----------------------+----------
 customer_id_indexdex |       26
</programlisting>
  </para>

  <para>
   Vous pouvez trouver les tables les plus grosses en utilisant la requête
   suivante&nbsp;:
<programlisting>
SELECT relname, relpages FROM pg_class ORDER BY relpages DESC;

       relname        | relpages 
----------------------+----------
 bigtable             |     3290
 customer             |     3144
</programlisting>
  </para>

  <para>
   <filename>contrib/dbsize</filename> crée dans votre base de données 
   des fonctions permettant de trouver la taille des tables ou de la 
   base de données à partir de <application>psql</application> sans avoir 
   besoin d'exécuter <command>VACUUM</command> ou <command>ANALYZE</command>
   préalablement.
  </para>

  <para>
   Vous pouvez aussi utiliser l'utilitaire <filename>contrib/oid2name</filename>
   afin d'afficher l'utilisation du disque. Lisez les exemples contenus dans 
   le fichier <filename>README.oid2name</filename> dans ce même répertoire.
   Il inclut un script permettant d'afficher la quantité de disque utilisée par
   chaque base de données.
  </para>
 </sect1>

 <sect1 id="disk-full">
  <title>Échec sur disque plein</title>

  <para>
   La tâche la plus important de l'administrateur de base de données
   dans la surveillance de l'utilisation de disque est de s'assurer que l'espace
   disque ne viendra pas à manquer. Un disque plein a de fortes chances de mener
   à des index de base de données corrompus. Mais cet état du disque ne comporte
   pas que des risques au niveau base de données. Si les fichiers de WAL se
   trouvent sur le même disque que la base (comme cela doit être le cas avec
   une configuration par défaut) et que le disque est complètement rempli lors 
   de l'initialisation de la base de données, les fichiers de WAL risquent d'être
   soit incomplets, soit corrompus. Ce cas d'échec est détecté par le système de
   base de données qui refusera alors de démarrer.
  </para>

  <para>
   Si vous êtes dans l'incapacité d'ajouter de l'espace disque en supprimant
   des données annexes à la base de données, vous pouvez déplacer des fichiers 
   de la base de données sur d'autres systèmes de fichiers et créer un lien 
   symbolique à partir de l'emplacement d'origine. Notez cependant que 
   l'utilitaire <application>pg_dump</application> ne pourra sauvegarder 
   l'agencement entre les liens symboliques et les fichiers réels 
   que vous aurez choisi&nbsp;; ainsi une restauration ne pourra rétablir cet 
   agencement, se contentant de remettre tous les fichiers dans le même 
   répertoire. Afin d'éviter de se retrouver dans la situation de saturation
   d'espace disque, vous pouvez placer les fichiers WAL ou les base de données
   individuelles à différents endroits lors de leur création. Pour cela, lisez
   la documentation de la commande <command>initdb</command> ainsi que la
   <xref linkend="manage-ag-alternate-locs"> pour plus d'informations à ce sujet.
  </para>

  <tip>
   <para>
   Certains systèmes de fichiers réagissent mal lorsqu'ils sont presque pleins.
   À toutes fins utiles, n'attendez pas que le disque soit plein pour agir.
   </para>
  </tip>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
