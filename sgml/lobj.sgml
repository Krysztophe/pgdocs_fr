<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/lobj.sgml,v 1.6.2.1 2005/03/20 22:34:40 guillaume Exp $
-->

 <chapter id="largeObjects">
  <title id="largeObjects-title">Objets larges</title>

  <indexterm zone="largeobjects"><primary>objet large</></>
  <indexterm><primary>BLOB</><see>objet large</></>

   <para>
    Dans les versions de <productname>PostgreSQL</productname> antérieures à la
    7.1, la taille de toute ligne dans la base de données ne pouvait pas
    excéder la taille d'une page de données. Comme la taille d'une page de
    données est de 8192 octets (par défaut, mais cela peut être augmenté jusqu'à
    un maximum de 32768), la limite maximale sur la taille d'une donnée était
    assez basse. Pour supporter le stockage de valeurs atomiques plus
    importantes, <productname>PostgreSQL</productname> a fourni et continue de
    fournir une interface pour les objets larges. Cette interface propose un
    accès orienté fichier à des données utilisateurs stockées dans une structure
    spécifique aux objets larges.
   </para>

   <para>
    Ce chapitre décrit l'implémentation, la programmation et les interfaces du
    langage de requêtes pour les données de type objet large de
    <productname>PostgreSQL</productname>. Nous utilisons la bibliothèque C
    <application>libpq</application> pour les exemples de ce chapitre mais la
    plupart des interfaces natives de programmation de
    <productname>PostgreSQL</productname> supportent des fonctionnalités
    équivalentes. D'autres interfaces pourraient utiliser l'interface des objets
    larges en interne pour fournir un support générique des valeurs larges. Ceci
    n'est pas décrit ici.
   </para>

  <sect1 id="lo-history">
   <title>Historique</title>

   <para>
    <productname>POSTGRES 4.2</productname>, le prédécesseur indirect de
    <productname>PostgreSQL</productname>, supportait trois implémentations
    standards des objets larges&nbsp;: par des fichiers externes au serveur
    <productname>POSTGRES</productname>, par des fichiers externes gérés par le
    serveur <productname>POSTGRES</productname> et par des données stockées
    dans la base de données <productname>POSTGRES</productname>. Ceci a causé
    une énorme confusion parmi les utilisateurs. Du coup, seul le
    support des objets larges en tant que donnée stockée dans la base de données
    a été conservé dans <productname>PostgreSQL</productname>. Bien qu'il soit
    plus lent en accès, il fournit une intégrité stricte des données. Pour des
    raisons historiques, le schéma de stockage est référencé comme
    <firstterm>Inversion large objects</firstterm>. (Vous apercevrez le terme
    inversion utilisé occasionnellement pour signifier aussi un objet large.)
    Depuis <productname>PostgreSQL 7.1</productname>, tous les objets larges
    sont placés dans une table système appelée
    <classname>pg_largeobject</classname>.
   </para>

   <para>
    <indexterm><primary>TOAST</></>
    <indexterm><primary>pain tranché</><see>TOAST</></indexterm>
    <productname>PostgreSQL 7.1</productname> a introduit un mécanisme
    (nom de code <quote><acronym>TOAST</acronym></quote>) qui permet à des
    lignes de données d'être bien plus larges que des pages de données
    individuelles. Ceci rend l'interface des objets larges partiellement
    obsolète. Un des avantages restant de l'interface des objets larges est
    qu'il permet des tailles importantes, avec un maximum de 2&nbsp;Go alors que
    <acronym>TOAST</acronym> ne peut gérer qu'un maximum de 1&nbsp;Go.
   </para>

  </sect1>

  <sect1 id="lo-implementation">
   <title>Fonctionnalités d'implémentation</title>

   <para>
    L'implémentation des objets larges coupe les objets larges en
    <quote>morceaux</quote> (<foreignphrase>chunks</foreignphrase>) et stocke les
    morceaux dans les lignes de la base de données. Un index B-tree garantit des
    recherches rapides pour le bon numéro du morceau lors d'accès aléatoires en 
    lecture et écriture.
   </para>
  </sect1>

  <sect1 id="lo-interfaces">
   <title>Interfaces client</title>

   <para>
    Cette section décrit les possibilités que les bibliothèques d'interfaces
    client de <productname>PostgreSQL</productname> fournissent pour accéder
    aux objets larges. Toutes les manipulations d'objets larges utilisant ces
    fonctions <emphasis>doivent</emphasis> prendre place dans un bloc de
    transaction SQL. (Ce prérequis est forcé strictement avec
    <productname>PostgreSQL 6.5</productname> bien que c'était un prérequis implicite dans
    les versions précédentes, ce qui a conduit à des mauvais comportements si
    celui-ci était ignoré.) L'interface des objets larges de
    <productname>PostgreSQL</productname> prend comme modèle l'interface des
    systèmes de fichiers <acronym>Unix</acronym> avec des fonctions analogues
    pour <function>open</function>, <function>read</function>,
    <function>write</function>,
    <function>lseek</function>, etc.
   </para>

   <para>
    Les applications clients utilisant l'interface des objets larges dans
    <application>libpq</application> devraient inclure le fichier d'en-tête
    <filename>libpq/libpq-fs.h</filename> et établir un lien avec la
    bibliothèque <application>libpq</application>.
   </para>

   <sect2>
    <title>Créer un objet large</title>

    <para>
     La fonction
<synopsis>
Oid lo_creat(PGconn *conn, int mode);
</synopsis>
     <indexterm><primary>lo_creat</></>
     crée un nouvel objet large.
     <replaceable class="parameter">mode</replaceable>  est un masque décrivant
     les différents attributs du nouvel objet. Les constantes symboliques
     listées ici sont définies dans le fichier d'en-tête
     <filename>libpq/libpq-fs.h</filename>. Le type d'accès (lecture, écriture
     ou les deux) est contrôlé par une combinaison OU des bits
     <symbol>INV_READ</symbol> et <symbol>INV_WRITE</symbol>. Les 16 bits de
     poids faible du masque ont été utilisés historiquement à Berkeley pour
     désigner le numéro du gestionnaire de stockage sur lequel l'objet large
     devrait résider. Ces bits devraient toujours être à zéro maintenant. La
     valeur de retour est l'OID assigné au nouvel objet large.
    </para>

    <para>
     Un exemple&nbsp;:
<programlisting>
inv_oid = lo_creat(INV_READ|INV_WRITE);
</programlisting>
    </para>
   </sect2>

   <sect2>
    <title>Importer un objet large</title>

    <para>
     Pour importer un fichier du système d'exploitation en tant qu'objet large,
     appelez
<synopsis>
Oid lo_import(PGconn *conn, const char *filename);
</synopsis>
     <indexterm><primary>lo_import</></>
     <replaceable class="parameter">filename</replaceable> 
     spécifie le nom du fichier à importer comme objet large. Le code de retour
     est l'OID assigné au nouvel objet large.
    </para>
   </sect2>

   <sect2>
    <title>Exporter un objet large</title>

    <para>
     Pour exporter un objet large en tant que fichier du système
     d'exploitation, appelez
    <synopsis>
int lo_export(PGconn *conn, Oid lobjId, const char *filename);
</synopsis>
     <indexterm><primary>lo_export</></>
     L'argument <parameter>lobjId</parameter> spécifie l'OID de l'objet large à
     exporter et l'argument <parameter>filename</parameter> spécifie le nom du
     fichier.
    </para>
   </sect2>

   <sect2>
    <title>Ouvrir un objet large existant</title>

    <para>
     Pour ouvrir un objet large existant, appelez
<synopsis>
int lo_open(PGconn *conn, Oid lobjId, int mode);
</synopsis>
     <indexterm><primary>lo_open</></>
     L'argument <parameter>lobjId</parameter> spécifie l'OID de l'objet large à
     ouvrir. Les bits <parameter>mode</parameter> contrôlent si l'objet est
     ouvert en lecture (<symbol>INV_READ</symbol>), écriture
     (<symbol>INV_WRITE</symbol>) ou les deux. Un objet large ne peut pas être
     ouvert avant d'avoir été créé. <function>lo_open</function> renvoie un
     descripteur d'objet large pour une utilisation future avec
     <function>lo_read</function>, <function>lo_write</function>,
     <function>lo_lseek</function>, <function>lo_tell</function> et
     <function>lo_close</function>. Le descripteur est uniquement valide pour
     la durée de la transaction en cours.
</para>
</sect2>

<sect2>
<title>Écrire des données dans un objet large</title>

<para>
     La fonction
<synopsis>
int lo_write(PGconn *conn, int fd, const char *buf, size_t len);
</synopsis>
     <indexterm><primary>lo_write</></> écrit
     <parameter>len</parameter> octets de <parameter>buf</parameter>
     dans l'objet large <parameter>fd</parameter>. L'argument <parameter>fd</parameter>
     doit avoir été renvoyé par un appel précédent à
     <function>lo_open</function>. Le nombre d'octets réellement écrits est
     renvoyé. Dans le cas d'une erreur, une valeur négative est renvoyée.
</para>
</sect2>

<sect2>
<title>Lire des données à partir d'un objet large</title>

<para>
     La fonction
<synopsis>
int lo_read(PGconn *conn, int fd, char *buf, size_t len);
</synopsis>
     <indexterm><primary>lo_read</></> lit
     <parameter>len</parameter> octets d'un objet large
     <parameter>fd</parameter> et les place dans <parameter>buf</parameter>.
     L'argument <parameter>fd</parameter> doit avoir été renvoyé par un appel
     précédent à <function>lo_open</function>. Le nombre d'octets réellement lus
     est renvoyé. Dans le cas d'une erreur, une valeur négative est renvoyée.
</para>
</sect2>

<sect2>
<title>Recherche dans un objet large</title>

<para>
     Pour modifier l'emplacement courant de lecture ou écriture sur un objet 
     large, appelez
<synopsis>
int lo_lseek(PGconn *conn, int fd, int offset, int whence);
</synopsis>
     <indexterm><primary>lo_lseek</></> Cette fonction déplace le pointeur
     d'emplacement courant pour l'objet large décrit par <parameter>fd</parameter> au
     nouvel emplacement spécifié avec le décalage (<parameter>offset</parameter>). Les
     valeurs valides pour <parameter>whence</parameter> sont <symbol>SEEK_SET</symbol>
     (rechercher depuis le début de l'objet), <symbol>SEEK_CUR</symbol> (rechercher
     depuis la position courante) et <symbol>SEEK_END</symbol> (rechercher depuis la
     fin de l'objet). Le code de retour est le nouvel emplacement du pointeur.
</para>
</sect2>

<sect2>
<title>Obtenir la position de recherche d'un objet large</title>

<para>
     Pour obtenir la position actuelle de lecture ou écriture d'un objet 
     large, appelez
<synopsis>
int lo_tell(PGconn *conn, int fd);
</synopsis>
     <indexterm><primary>lo_tell</></> S'il y a une erreur, le code de retour
     est négatif.
</para>
</sect2>

<sect2>
<title>Fermer un descripteur d'objet large</title>

<para>
     Un objet large peut être fermé en appelant
<synopsis>
int lo_close(PGconn *conn, int fd);
</synopsis>
     <indexterm><primary>lo_close</></> où <parameter>fd</parameter> est un descripteur
     d'objet large renvoyé par <function>lo_open</function>. En cas de succès,
     <function>lo_close</function> renvoie zéro. En cas d'erreur, le code de
     retour est négatif.
</para>

<para>
     Tous les descripteurs d'objets larges restant ouverts à la fin d'une
     transaction seront automatiquement fermés.
</para>
</sect2>

   <sect2>
    <title>Supprimer un objet large</title>

    <para>
     Pour supprimer un objet large de la base de données, appelez
<synopsis>
int lo_unlink(PGconn *conn, Oid lobjId);
</synopsis>
     <indexterm><primary>lo_unlink</></> L'argument
     <parameter>lobjId</parameter> spécifie l'OID de l'objet large à supprimer.
     Dans le cas d'une erreur, le code de retour est négatif.
    </para>
   </sect2>


</sect1>

<sect1 id="lo-funcs">
<title>Fonctions du côté serveur</title>

<para>
     Il existe deux fonctions intégrées du côté serveur,
     <function>lo_import</function><indexterm><primary>lo_import</></>
     et
     <function>lo_export</function>,<indexterm><primary>lo_export</></>
     pour les accès aux objets larges, disponibles avec les commandes
     <acronym>SQL</acronym>. Voici un exemple de leur utilisation&nbsp;:
<programlisting>
CREATE TABLE image (
    nom             text,
    donnees         oid
);

INSERT INTO image (nom, donnees)
    VALUES ('superbe image', lo_import('/etc/motd'));

SELECT lo_export(image.donnees, '/tmp/motd') FROM image
    WHERE nom = 'superbe image';
</programlisting>
</para>

<para>
Ces fonctions lisent et écrivent des fichiers dans le système de fichiers du
serveur en utilisant les droits de l'utilisateur propriétaire de la base de
données. Du coup, leur emploi est restreint aux superutilisateurs. (Au
contraire, les fonctions d'import et d'export lisent et écrivent des fichiers
du système de fichiers en utilisant les droits du programme client. Leur emploi
n'est pas restreint.)
</para>
</sect1>

<sect1 id="lo-examplesect">
<title>Programme d'exemple</title>

<para>
     <xref linkend="lo-example"> est un programme d'exemple qui montre une
     utilisation de l'interface des objets larges avec <application>libpq</>.
     Des parties de ce programme disposent de commentaires au bénéfice de
     l'utilisateur. Ce programme est aussi disponible dans la distribution des
     sources (<filename>src/test/examples/testlo.c</filename>).
</para>

  <example id="lo-example">
   <title>Exemple de programme sur les objets larges avec
<application>libpq</application></title>
<programlisting>
/*--------------------------------------------------------------
 *
 * testlo.c--
 *    test utilisant des objets larges avec libpq
 *
 * Copyright (c) 1994, Regents of the University of California
 *
 *--------------------------------------------------------------
 */
#include &lt;stdio.h&gt;
#include &quot;libpq-fe.h&quot;
#include &quot;libpq/libpq-fs.h&quot;

#define BUFSIZE          1024

/*
 * importFile
 *    importe le fichier &quot;in_filename&quot; dans la base de données
 *    en tant qu'objet &quot;lobjOid&quot;
 *
 */
Oid
importFile(PGconn *conn, char *filename)
{
    Oid         lobjId;
    int         lobj_fd;
    char        buf[BUFSIZE];
    int         nbytes,
                tmp;
    int         fd;

    /*
     * ouvre le fichier à lire
     */
    fd = open(filename, O_RDONLY, 0666);
    if (fd &lt; 0)
    {                           /* error */
        fprintf(stderr, &quot;can't open unix file %s\n&quot;, filename);
    }

    /*
     * crée l'objet large
     */
    lobjId = lo_creat(conn, INV_READ | INV_WRITE);
    if (lobjId == 0)
        fprintf(stderr, &quot;can't create large object\n&quot;);

    lobj_fd = lo_open(conn, lobjId, INV_WRITE);

    /*
     * lit le fichier Unix écrit dans le fichier inversion
     */
    while ((nbytes = read(fd, buf, BUFSIZE)) &gt; 0)
    {
        tmp = lo_write(conn, lobj_fd, buf, nbytes);
        if (tmp &lt; nbytes)
            fprintf(stderr, &quot;error while reading large object\n&quot;);
    }

    (void) close(fd);
    (void) lo_close(conn, lobj_fd);

    return lobjId;
}

void
pickout(PGconn *conn, Oid lobjId, int start, int len)
{
    int         lobj_fd;
    char       *buf;
    int         nbytes;
    int         nread;

    lobj_fd = lo_open(conn, lobjId, INV_READ);
    if (lobj_fd &lt; 0)
    {
        fprintf(stderr, &quot;can't open large object %d\n&quot;,
                lobjId);
    }

    lo_lseek(conn, lobj_fd, start, SEEK_SET);
    buf = malloc(len + 1);

    nread = 0;
    while (len - nread &gt; 0)
    {
        nbytes = lo_read(conn, lobj_fd, buf, len - nread);
        buf[nbytes] = ' ';
        fprintf(stderr, &quot;&gt;&gt;&gt; %s&quot;, buf);
        nread += nbytes;
    }
    free(buf);
    fprintf(stderr, &quot;\n&quot;);
    lo_close(conn, lobj_fd);
}

void
overwrite(PGconn *conn, Oid lobjId, int start, int len)
{
    int         lobj_fd;
    char       *buf;
    int         nbytes;
    int         nwritten;
    int         i;

    lobj_fd = lo_open(conn, lobjId, INV_READ);
    if (lobj_fd &lt; 0)
    {
        fprintf(stderr, &quot;can't open large object %d\n&quot;,
                lobjId);
    }

    lo_lseek(conn, lobj_fd, start, SEEK_SET);
    buf = malloc(len + 1);

    for (i = 0; i &lt; len; i++)
        buf[i] = 'X';
    buf[i] = ' ';

    nwritten = 0;
    while (len - nwritten &gt; 0)
    {
        nbytes = lo_write(conn, lobj_fd, buf + nwritten, len - nwritten);
        nwritten += nbytes;
    }
    free(buf);
    fprintf(stderr, &quot;\n&quot;);
    lo_close(conn, lobj_fd);
}

/*
 * exportFile *    exporte l'objet large &quot;lobjOid&quot; dans le fichier
 * &quot;out_filename&quot;
 *
 */
void
exportFile(PGconn *conn, Oid lobjId, char *filename)
{
    int         lobj_fd;
    char        buf[BUFSIZE];
    int         nbytes,
                tmp;
    int         fd;

    /*
     * crée un &quot;objet&quot; inversion
     */
    lobj_fd = lo_open(conn, lobjId, INV_READ);
    if (lobj_fd &lt; 0)
    {
        fprintf(stderr, &quot;can't open large object %d\n&quot;,
                lobjId);
    }

    /*
     * ouvre le fichier à écrire
     */
    fd = open(filename, O_CREAT | O_WRONLY, 0666);
    if (fd &lt; 0)
    {                           /* error */
        fprintf(stderr, &quot;can't open unix file %s\n&quot;,
                filename);
    }

    /*
     * lit à partir du fichier Unix et écrit dans le fichier inversion
     */
    while ((nbytes = lo_read(conn, lobj_fd, buf, BUFSIZE)) &gt; 0)
    {
        tmp = write(fd, buf, nbytes);
        if (tmp &lt; nbytes)
        {
            fprintf(stderr, &quot;error while writing %s\n&quot;,
                    filename);
        }
    }

    (void) lo_close(conn, lobj_fd);
    (void) close(fd);

    return;
}

void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    char       *in_filename,
               *out_filename;
    char       *database;
    Oid         lobjOid;
    PGconn     *conn;
    PGresult   *res;

    if (argc != 4)
    {
        fprintf(stderr, &quot;Usage: %s database_name in_filename out_filename\n&quot;,
                argv[0]);
        exit(1);
    }

    database = argv[1];
    in_filename = argv[2];
    out_filename = argv[3];

    /*
     * initialise la connexion
     */
    conn = PQsetdb(NULL, NULL, NULL, NULL, database);

    /* check to see that the backend connection was successfully made */
    if (PQstatus(conn) == CONNECTION_BAD)
    {
        fprintf(stderr, &quot;Connection to database '%s' failed.\n&quot;, database);
        fprintf(stderr, &quot;%s&quot;, PQerrorMessage(conn));
        exit_nicely(conn);
    }

    res = PQexec(conn, &quot;begin&quot;);
    PQclear(res);

    printf(&quot;importing file %s\n&quot;, in_filename);
/*  lobjOid = importFile(conn, in_filename); */
    lobjOid = lo_import(conn, in_filename);
/*
    printf(&quot;as large object %d.\n&quot;, lobjOid);

    printf(&quot;picking out bytes 1000-2000 of the large object\n&quot;);
    pickout(conn, lobjOid, 1000, 1000);

    printf(&quot;overwriting bytes 1000-2000 of the large object with X's\n&quot;);
    overwrite(conn, lobjOid, 1000, 1000);
*/

    printf(&quot;exporting large object to file %s\n&quot;, out_filename);
/*    exportFile(conn, lobjOid, out_filename); */
    lo_export(conn, lobjOid, out_filename);

    res = PQexec(conn, &quot;end&quot;);
    PQclear(res);
    PQfinish(conn);
    exit(0);
}
</programlisting>
</example>

</sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil:if expand("%") == ""|browse confirm w|else|confirm w|endif
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
