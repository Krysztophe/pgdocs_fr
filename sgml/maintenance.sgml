<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/maintenance.sgml,v 1.6.2.1 2005/05/10 06:00:30 guillaume Exp $
-->

<chapter id="maintenance">
 <title>Planifier les tâches de maintenance</title>

 <indexterm zone="maintenance">
  <primary>maintenance</primary>
 </indexterm>

  <para>
   Pour bien fonctionner, un serveur <productname>PostgreSQL</productname>
   nécessite quelques opérations de maintenance régulières, décrites ci-après.
   Ces tâches sont par nature répétitives et peuvent facilement s'automatiser
   grâce aux outils standards d'UNIX, comme les scripts <application>cron</application>.
   La responsabilité de la mise en place de ces scripts et du contrôle de leur
   bon fonctionnement relève de l'administrateur de la base.
  </para>

  <para>
   Une opération de maintenance évidente est la sauvegarde régulière des données. 
   Sans une sauvegarde récente il est impossible de restaurer après un dommage grave
   (perte d'un disque, incendie, table supprimée par erreur, etc.). Les mécanismes de
   sauvegarde et restauration disponibles dans <productname>PostgreSQL</productname>
   sont détaillés dans le <xref linkend="backup">.
  </para>

  <para>
   L'autre tâche primordiale est de réaliser périodiquement un <quote>vacuum</>,
   c'est à dire <quote>faire le vide</> dans la base de données.
   Cette opération est détaillée dans la <xref linkend="routine-vacuuming">.
  </para>

  <para>
   La gestion du fichier de traces mérite aussi une attention régulière.
   Cela est détaillé dans la <xref linkend="logfile-maintenance">.
  </para>

  <para>
   <productname>PostgreSQL</productname> demande peu de maintenance par rapport
   à d'autres SGBDs. Néanmoins, un suivi vigilant de ces tâches participera beaucoup
   à rendre le système productif et agréable à utiliser.
  </para>

 <sect1 id="routine-vacuuming">
  <title>Nettoyages réguliers</title>

  <indexterm zone="routine-vacuuming">
   <primary>vacuum</primary>
  </indexterm>

  <para>
   La commande <command>VACUUM</> de <productname>PostgreSQL</productname>
   doit être exécutée régulièrement pour plusieurs raisons&nbsp;:

    <orderedlist>
     <listitem>
      <simpara>pour récupérer l'espace disque occupé par les lignes supprimées
      ou mises à jour&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour mettre à jour les statistiques utilisées par l'optimiseur de
      <productname>PostgreSQL</productname>&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour prévenir la perte des données les plus anciennes à cause
      d'un <firstterm>cycle de l'identifiant de transaction (XID)</>.</simpara>
     </listitem>
    </orderedlist>

   La fréquence et le périmètre des exécutions de <command>VACUUM</> variera
   pour chacune des raisons ci-dessus selon les besoins des sites. De plus, les
   administrateurs doivent appréhender chaque cas et développer une stratégie de
   maintenance appropriée. L'objectif de cette section est de décrire
   globalement les problèmes à résoudre&nbsp;; pour la syntaxe et les autres
   détails, voir la référence de la commande <command>VACUUM</>.
  </para>

  <para>
   À partir de <productname>PostgreSQL</productname> 7.2, la forme standard de 
   <command>VACUUM</> peut être exécutée en parallèle des opérations classiques de
   manipulation des données (select, insert, update, delete, mais pas les
   modifications de définition). Les opérations de nettoyage par
   <command>VACUUM</> sont largement moins pénalisantes qu'elles n'ont pu l'être
   par le passé et il n'est plus aussi impératif de les planifier pendant les
   plages d'utilisation peu intensives.
  </para>

  <sect2 id="vacuum-for-space-recovery">
   <title>Récupérer l'espace disque</title>

   <indexterm zone="vacuum-for-space-recovery">
    <primary>espace disque</primary>
   </indexterm>

   <para>
    Dans son fonctionnement normal, <productname>PostgreSQL</productname> ne
    supprime pas immédiatement les versions périmées des lignes après un <command>UPDATE</>
    ou un <command>DELETE</>.  Cette approche est nécessaire pour la consistance des accès
    concurrents (voir le <xref linkend="mvcc">)&nbsp;: la version de la ligne ne
    doit pas être supprimée tant qu'elle est susceptible d'être lue par une
    autre transaction. Mais finalement, une ligne qui est plus vieille que
    toutes les transactions en cours n'est plus utile du tout. La place qu'elle
    utilise doit être rendu pour être réutilisée par d'autres lignes afin
    d'éviter un accroissement constant du volume occupé sur le disque. Cela est
    réalisé en exécutant <command>VACUUM</>.
   </para>

   <para>
    Évidemment, une table qui subit beaucoup de mises à jour et suppressions
    nécessitera des nettoyages plus fréquents que les tables rarement modifiées.
    Il peut être pertinent de programmer périodiquement par <application>cron</>
    des tâches spécifiques qui nettoient uniquement les tables concernées et
    ignorent les tables que l'on sait peu modifiées. Ceci ne sera vraiment utile
    que s'il y a à la fois des tables volumineuses intensément modifiées et des
    tables volumineuses peu modifiées. En effet, le coût supplémentaire lié au
    nettoyage d'une petite table ne mérite pas que l'on s'en préoccupe.
   </para>

   <para>
    La forme standard de <command>VACUUM</> est particulèrement adaptée dans le but
    de maintenir une occupation stabilisée de l'espace disque. La forme standard repère toutes
    les lignes dont la version est périmée et rend l'espace disque qu'elles occupaient afin
    d'être réutilisé pour la table. En revanche, il n'y a pas de réelle libération d'espace
    pour le système d'exploitation. Pour rendre l'espace disque au système, on pourra utiliser
    <command>VACUUM FULL</>&nbsp;; cependant, est-il réellement nécessaire de
    libérer un espace qu'il faudra bientôt réallouer&nbsp;? Des exécutions
    raisonnablement fréquentes de <command>VACUUM</> sont plus efficaces que
    quelques <command>VACUUM FULL</> sporadiques pour maintenir les tables
    intensément modifiées.
   </para>

   <para>
    La meilleure stratégie pour la plupart des sites est de planifier un <command>VACUUM</>
    général sur toute la base une fois par jour, en dehors des horaires normaux de
    production, accompagné si nécessaire de nettoyages plus fréquents pour les tables
    subissant d'intenses modifications.  S'il y a plusieurs bases de données
    dans un cluster (groupe de bases de données), ne pas oublier de nettoyer
    chacune d'entre elles&nbsp;; l'exécutable <filename>vacuumdb</> peut
    s'avérer utile. Il est recommandé d'utiliser des <command>VACUUM</> simples,
    pas des <command>VACUUM FULL</>, pour l'entretien régulier et automatique de
    l'espace disque.
   </para>

   <para>
    <command>VACUUM FULL</> est recommandé quand on sait que la majorité des lignes
    d'une table ont été supprimées. Pour cette table, la taille stable sera réduite
    de façon significative par <command>VACUUM FULL</> dont le mécanisme est plus poussé.
   </para>

   <para>
    Pour les tables dont le contenu est souvent totalement supprimé, on préfèrera faire
    <command>TRUNCATE</> plutôt que <command>DELETE</> suivi de <command>VACUUM</>.
   </para>
  </sect2>

  <sect2 id="vacuum-for-statistics">
   <title>Maintenir les statistiques du planificateur</title>

   <indexterm zone="vacuum-for-statistics">
    <primary>statistiques</primary>
    <secondary>du planificateur</secondary>
   </indexterm>

   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>

   <para>
    L'optimiseur de requêtes de <productname>PostgreSQL</productname> s'appuie
    sur des informations statistiques sur le contenu des tables dans l'optique
    de générer des plans d'exécutions efficaces pour les requêtes. Ces
    statistiques sont collectées par la commande <command>ANALYZE</>, qui peut
    être invoquée seule ou comme une option de <command>VACUUM</>. Il est
    important d'avoir des statistiques relativement à jour sans quoi des mauvais
    choix dans les plans d'exécution pourraient pénaliser la performance de la base.
   </para>

   <para>
    À l'instar du nettoyage pour récupérer l'espace, les statistiques doivent
    être plus souvent collectées pour les tables intensément modifiées que pour
    celles qui le sont moins. Mais même si la table est très modifiée, il se
    peut que ces collectes soient inutiles si la distribution probabiliste des
    données évolue peu. Une règle simple pour décider est de voir comment
    évoluent les valeurs minimum et maximum des données. Par exemple, une
    colonne de type <type>timestamp</type> qui contient la date de mise à jour
    de la ligne aura une valeur maximum en continuelle croissance au fur et à
    mesure des modifications&nbsp;; une telle colonne nécessitera plus de
    collectes statistiques qu'une colonne qui contient par exemple les URLs des
    pages accédées sur un site web. La colonne qui contient les URLs peut très
    bien être aussi souvent modifiée mais la distribution probabiliste des
    données changera certainement moins rapidement.
   </para>

   <para>
    Il est possible d'exécuter <command>ANALYZE</> sur des tables spécifiques, voire des
    colonnes spécifiques&nbsp;; il a donc toute flexibilité pour mettre à jour
    certaines statistiques plus souvent que les autres en fonction des besoins
    de l'application. Quoi qu'il en soit, dans la pratique, l'utilité de cette
    fonctionnalité est douteuse. En effet, depuis
    <productname>PostgreSQL</productname> 7.2, <command>ANALYZE</> est une
    opération plutôt rapide, même pour les grosses tables, parce que la collecte
    se base sur un échantillon aléatoire de la table et non sur toutes les
    données. Il est donc probablement plus simple de l'utiliser systématiquement
    sur toute la base.
   </para>

   <tip>
    <para>
     Même si il n'est pas très productif de règler précisément la fréquence de
     <command>ANALYZE</> pour chaque colonne, il peut être intéressant d'ajuster le niveau
     de détail des statistiques collectées pour chaque colonne. Les colonnes très utilisées
     dans les clauses <literal>WHERE</> et dont la distribution n'est pas uniforme
     requièrent des histogrammes plus précis que les autres colonnes. Voir
     <command>ALTER TABLE SET STATISTICS</>.
    </para>
   </tip>

   <para>
    Pour la plupart des site, la meilleure stratégie est de programmer une collecte générale
    des statistiques sur toute la base, une fois par jour. Ceci peut être profitablement
    couplé avec un <command>VACUUM</> (la nuit par exemple). Quoi qu'il en soit, les
    administrateurs des bases dont les statistiques changent peu pourront juger que cela est
    exagéré et que des exécutions moins fréquentes de <command>ANALYZE</> sont
    bien suffisantes.
   </para>
  </sect2>

  <sect2 id="vacuum-for-wraparound">
   <title>Éviter les cycles des identifiants de transactions</title>

   <indexterm zone="vacuum-for-wraparound">
    <primary>identifiant de transaction</primary>
    <secondary>cycle</secondary>
   </indexterm>

   <para>
    Le mécanisme de contrôle de concurrence multiversion (<acronym>MVCC</>) de
    <productname>PostgreSQL</productname> s'appuie sur la possibilité de
    comparer des identifiants de transactions (<acronym>XID</>)&nbsp;; c'est un
    nombre croissant&nbsp;: la version d'une ligne dont le XID d'insertion est
    supérieur au XID de la transaction en cours est <quote>dans le futur</> et
    ne doit pas être visible de la transaction courante. Comme les identifiants
    ont une taille limitée (32 bits à ce jour), un groupe qui est en activité
    depuis longtemps (plus de 4 milliards de transactions) connaîtra un cycle
    des identifiants de transaction&nbsp;: le XID reviendra à 0 et soudainement
    les transactions du passé sembleront appartenir au futur - ce qui signifie
    qu'elles deviennent invisibles. En bref, perte de données totale. (En
    réalité, les données sont toujours là mais c'est un piètre réconfort
    puisqu'elles resteront inaccessibles.)
   </para>

   <para>
    Avant <productname>PostgreSQL</productname> 7.2, la seule parade contre ces cycles de XID
    était de ré-exécuter <command>initdb</> au minimum tous les 4 milliards de
    transaction. Bien sûr, cela n'était pas satisfaisant pour les sites
    connaissant un trafic important, donc une nouvelle solution a été élaborée.
    La nouvelle approche permet à un cluster de fonctionner indéfiniment, sans
    <command>initdb</> ni aucune sorte de réinitialisation. Le prix en est le
    suivant&nbsp;: <emphasis>toute table dans la base doit être nettoyée au
    moins une fois tous les milliards de transactions.</emphasis>
   </para>

   <para>
    Dans la pratique cette exigence n'est pas onéreuse mais comme son manquement
    aurait pour conséquence une perte totale des données (pas seulement de
    l'espace disque perdu ou des performances moindres), des dispositions ont
    été prises pour aider les administrateurs à surveiller le temps écoulé
    depuis le dernier <command>VACUUM</>. La suite de cette section en explique
    les détails.
   </para>

   <para>
    La nouvelle approche pour la comparaison des XIDs distingue deux XID
    spéciaux, numéros 1 et 2 (<literal>BootstrapXID</> et
    <literal>FrozenXID</>). Ces deux XIDs sont toujours considérés comme plus
    vieux que n'importe quel autre. Les XIDs normaux (ceux qui sont supérieurs à
    deux) sont comparés sur une base modulo-2<superscript>31</>. Cela signifie
    que pour chaque XID normal, il y en a deux milliards qui sont plus vieux et
    deux milliards qui sont plus récents. Une autre manière de le dire est que
    l'ensemble de définition des XIDs est circulaire et sans limite. De plus,
    une ligne créée avec un XID normal donné, la version de la ligne apparaîtra
    comme appartenant au passé pour les deux milliards de transactions qui
    suivront quelque soit le XID. Si la ligne existe encore après deux milliards
    de transactions, elle apparaîtra soudainement comme appartenant au futur.
    Pour éviter la disparition des données, les versions trop anciennes doivent
    se voir affecter le XID <literal>FrozenXID</> avant d'atteindre le seuil
    fatidique des deux milliards de transactions. Une fois qu'elles ont ce XID
    spécifique, elles appartiendront au passé pour toutes les transactions même
    en cas de cycle. Cette affectation est réalisée par <command>VACUUM</>.
   </para>

   <para>
    La politique normale de <command>VACUUM</> est d'affecter
    <literal>FrozenXID</> à toute les lignes dont le XID se situe à plus de un
    milliard de transactions dans le passé. Elle préserve le XID original tant
    qu'il est utile. (En réalité, la plupart des lignes existeront et
    disparaîtront avant d'être <quote>gelée</>. Avec cette méthode, l'intervalle
    de sécurité maximum entre les exécutions de <command>VACUUM</> pour une
    table est d'exactement un milliard de transactions&nbsp;: en attendant plus
    longtemps, on s'expose à conserver des versions qui n'étaient pas assez
    vielles pour se voir affecter <literal>FrozenXID</> lors de la précédente
    exécution et qui apparaissent maintenant dans le futur du fait d'un cycle -
    c'est-à-dire que les données semblent perdues. (Bien sûr, elles
    réapparaîtront après deux nouveaux milliards de transactions mais cela n'a
    pas d'intérêt).
   </para>

   <para>
    Puisque des exécutions périodiques de <command>VACUUM</> sont nécessaires de
    toutes manières, pour les raisons évoquées ci-dessus, il est très peu
    probable qu'une table ne soit pas nettoyée du tout durant un milliard de
    transactions. Pour aider les administrateurs à assurer que cette exigence
    est remplie, <command>VACUUM</> conserve des statistiques sur les XIDs dans
    la table système <literal>pg_database</>. Notamment, la table
    <literal>pg_database</> contient, pour chaque base, une colonne
    <literal>datfrozenxid</> qui est mise à jour après les <command>VACUUM</> de
    la base (c'est-à-dire <command>VACUUM</> qui ne spécifie aucune table
    particulière). La valeur qui est stockée est la limite en deçà de laquelle
    cette exécution de <command>VACUUM</> a marqué la ligne comme
    <quote>gelée</>. Tous les XIDs plus vieux que ce XID limite ont reçu le XID
    <literal>FrozenXID</> pour cette base. Pour obtenir cette information, il
    suffit d'exécuter la requête&nbsp;:

<programlisting>
SELECT datname, age(datfrozenxid) FROM pg_database;
</programlisting>

    La colonne <literal>age</> calcule le nombre de transactions effectuées entre le XID
    limite et le XID courant.
   </para>

   <para>
    Avec la méthode standard de gel du XID, La colonne <literal>age</> démarre à
    un milliard pour une base fraîchement nettoyée. Si l'<literal>age</>
    approche des deux milliards, la base doit de nouveau être nettoyée pour
    éviter les erreurs liées au cycle du XID. Il est recommendé d'exécuter un
    <command>VACUUM</> une fois tous les demi milliard de transactions pour
    garder une marge de sécurité maximale. Pour aider à remplir cette
    exigence, chaque <command>VACUUM</> émet un message si n'importe lequel des
    enregistrements de <literal>pg_database</> indique un <literal>age</> de plus de 1,5
    milliard de transactions, par exemple&nbsp;:

<programlisting>
play=# VACUUM;
WARNING:  some databases have not been vacuumed in 1613770184 transactions
HINT:  Better vacuum them within 533713463 transactions, or you may have a wraparound failure.
VACUUM
</programlisting>
   </para>

   <para>
    Avec l'option <command>FREEZE</>, la commande <command>VACUUM</> a un
    comportement plus poussé&nbsp;: les versions des lignes sont gelées si elles
    sont sufisamment vieilles pour être visibles de toutes les transactions en
    cours. En particulier, sur une base en lecture seulement, <command>VACUUM
    FREEZE</> aura pour résultat de geler toutes les lignes de la base. Donc,
    tant que la base n'est pas modifiée, aucun nettoyage supplémentaire n'est
    nécessaire pour éviter les problèmes de cycle du XID. Cette technique est
    notamment utilisée par <command>initdb</> pour préparer la base
    <literal>template0</>. Cela pourrait également être utilisé pour préparer
    n'importe quelle base créée par l'administrateur avec
    <literal>datallowconn</> = <literal>false</> dans <literal>pg_database</>,
    puisqu'il n'y a pas moyen d'exécuter <command>VACUUM</command> sur une base
    à laquelle on ne peut pas se connecter. On notera que
    <command>VACUUM</command> n'émet aucun message d'avertissement pour les
    enregistrements de <literal>pg_database</> où <literal>datallowconn</> =
    <literal>false</> afin de ne pas induire d'erreur&nbsp;; c'est donc
    à l'administrateur de s'assurer que ces bases sont correctement gelées.
   </para>

  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
  <title>Ré-indexation régulière</title>

  <indexterm zone="routine-reindex">
   <primary>ré-indexation</primary>
  </indexterm>

  <para>
   Dans certains cas, cela vaut la peine de reconstruire périodiquement les
   index par la commande <command>REINDEX</>. (Il y a aussi
   <filename>contrib/reindexdb</> qui peut ré-indexer une base entière).
   Quoiqu'il en soit, <productname>PostgreSQL</> 7.4 réduit nettement le besoin
   de cette maintenance en comparaison des versions précédentes.
  </para>
 </sect1>


 <sect1 id="logfile-maintenance">
  <title>Maintenance du fichier de traces</title>

  <indexterm zone="logfile-maintenance">
   <primary>traces serveur</primary>
   <secondary>maintenance du fichier de traces</secondary>
  </indexterm>

  <para>
   Il est bon de sauvegarder les traces du serveur de données plutôt que se
   contenter de les rediriger vers <filename>/dev/null</>. Les journaux de
   traces s'avèrent très précieux quand il s'agit de diagnostiquer un
   problème. Mais ces traces peuvent devenir volumineuses (notamment si le
   niveau de débogage est élevé) et il n'est pas souhaitable de les conserver
   indéfiniment. Il est nécessaire de <quote>recycler</> les journaux de traces
   de façon à supprimer les anciennes informations au fur et à mesures que de
   nouvelles apparaîssent.
  </para>

  <para>
   En redirigeant simplement <systemitem>stderr</> du
   <command>postmaster</command> dans un fichier, le seul moyen de tronquer le
   fichier est de redémarrer <command>postmaster</command>. Cela peut suffire
   pour les environnements de développement mais pas pour un serveur de
   production.
  </para>

  <para>
   La meilleure approche de production pour gérer ces traces est de les renvoyer
   vers <application>syslog</> qui gèrera le recyclage du fichier. Pour ce
   faire, on fixera le paramètre de configuration <literal>syslog</> à 2 (pour
   tracer vers <application>syslog</> uniquement) dans
   <filename>postgresql.conf</>. Il suffit alors d'envoyer le signal 
   <literal>SIGHUP</literal> au démon <application>syslog</> chaque fois qu'on
   voudra écrire dans un nouveau fichier. Pour automatiser la rotation des
   traces, on pourra configurer le programme
   <application>logrotate</application> pour s'appliquer aux fichiers de
   <application>syslog</application>.
  </para>

  <para>
   Sur la plupart des systèmes, <application>syslog</> n'est pas très sûr,
   particulièrement pour les messages volumineux&nbsp;; il peut arriver que
   ceux-ci soient tronqués voire perdus, juste quand on en a réellement
   besoin&nbsp;! On préfèrera peut-être rediriger <systemitem>stderr</> de
   <command>postmaster</> vers un programme qui réaliserait le recyclage des
   traces. En démarrant le serveur avec <command>pg_ctl</>,
   <systemitem>stderr</> est déjà redirigé vers <systemitem>stdout</>&nbsp;; une
   commande <quote>pipe</> alors suffira&nbsp;:
   
<programlisting>
pg_ctl start | logrotate
</programlisting>

   La distribution de <productname>PostgreSQL</> n'inclut pas de programme de
   rotation de traces adapté mais plusieurs sont disponibles sur Internet. Il y
   en a un dans la distribution d'Apache par exemple.
  </para>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->

