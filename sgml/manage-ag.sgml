<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/manage-ag.sgml,v 1.5 2005/01/30 22:59:24 guillaume Exp $
-->

<chapter id="managing-databases">

 <title>Administration des bases de données</title>

 <indexterm zone="managing-databases"><primary>base de données</></>

 <para>
  Chaque instance d'un serveur <productname>PostgreSQL</productname>
  gère une ou plusieurs bases de données. Les bases de données sont
  donc le niveau hiérarchique le plus élevé pour organiser des objets
  <acronym>SQL</acronym> (<quote>objets de base de données</quote>). Ce
  chapitre décrit les propriétés des bases de données et comment les
  créer, les administrer et les détruire.
 </para>

 <sect1 id="manage-ag-overview">

  <title>Aperçu</title>

  <indexterm zone="manage-ag-overview">
   <primary>schéma</primary>
  </indexterm>

  <para>
   Une base de données est un ensemble nommé d'objets
   <acronym>SQL</acronym> (<quote>objets de base de
   données</quote>). En général, chaque objet de base de données
   (table, fonction etc.) appartient à une et une seule base de
   données. (Mais certains catalogues système, par exemple
   <literal>pg_database</>, appartiennent à tout le groupe et sont
   accessibles depuis toutes les bases de données du groupe.) Plus
   précisément, une base de données est une collection de schémas et
   les schémas contiennent les tables, fonctions, etc. Ainsi, la
   hiérarchie complète est&nbsp;: serveur, base de données, schéma, table
   (ou un autre objet au lieu de table).
  </para>

  <para>
   Une application qui se connecte au serveur de base de données
   spécifie dans sa requête de connexion la base de données à laquelle
   elle veut se connecter. Il n'est pas possible d'accéder à plus
   d'une base de données via la même connexion. (Mais une application
   n'est pas limitée dans le nombre de connexions qu'elle établit avec
   une ou plusieurs bases de données.) Il est possible cependant
   d'accéder à plus d'un schéma via la même connexion. Les schémas
   sont une structure purement logique et c'est le système de gestion
   des privilèges qui décide qui peut accéder à quoi. Les bases de
   données sont séparées physiquement et le contrôle d'accès est géré
   au niveau de la connexion. Si une instance de serveur
   <productname>PostgreSQL</> doit héberger des projets ou des
   utilisateurs censés rester séparés et sans interaction, il est
   recommandé de les répartir sur plusieurs bases de données. Si les
   projets ou les utilisateurs sont reliés et doivent pouvoir partager
   leurs ressources, alors ils devraient être placés dans la même base
   de données mais éventuellement dans des schémas différents. Pour
   plus d'informations sur la manipulation des schémas, voir la <xref
   linkend="ddl-schemas">.
  </para>

  <note>
   <para>
    En <acronym>SQL</>, les bases de données sont appelées
    des <quote>catalogues</>.
   </para>
  </note>

 </sect1>

 <sect1 id="manage-ag-createdb">

  <title>Création d'une base de données</title>

  <para>
   Pour pouvoir créer une base de données, il faut que le serveur
   <productname>PostgreSQL</> soit lancé (voir la <xref
   linkend="postmaster-start">).
  </para>

  <para>
   Les bases de données sont créées à l'aide de la commande SQL
   <command>CREATE DATABASE</command>&nbsp;:<indexterm><primary>CREATE
   DATABASE</></>
    <synopsis>
     CREATE DATABASE <replaceable>nom</>;
    </synopsis>
   ou <replaceable>nom</> suit les règles habituelles pour les
   identifiants <acronym>SQL</acronym>. L'utilisateur actuel devient
   automatiquement le propriétaire de la nouvelle base de
   données. C'est au propriétaire de la base de données qu'il revient
   de la supprimer par la suite (ce qui supprime aussi tous les objets
   qu'elle contient, même s'ils ont un propriétaire différent).
  </para>

  <para>
   La création de bases de données est une opération protégée. Voir la <xref
   linkend="user-attributes"> sur la manière d'attribuer des droits.
  </para>

  <para>
   Comme vous devez être connecté au serveur de base de données pour
   exécuter la commande <command>CREATE DATABASE</command>, reste à
   savoir comment créer la première base de données d'un site. La
   première base de données est toujours créée par la commande
   <command>initdb</> quand l'aire de stockage des données est
   initialisée. (Voir la <xref linkend="creating-cluster">.) Cette base
   de données est appelée <literal>template1</>.
   <indexterm><primary>template1</></> Donc,
   pour créer la première base de données proprement dite, vous pouvez
   vous connecter à <literal>template1</>.
  </para>

  <para>
   Le nom <literal>template1</literal> n'a pas été choisi au hasard&nbsp;:
   quand une nouvelle base de données est créée, la base de donnée
   modèle <literal>template1</literal> est en fait clonée. Cela
   signifie que tous les changements effectués sur
   <literal>template1</literal> sont propagés à toutes les bases de
   données créées ultérieurement. Cela implique que vous ne devriez
   pas utiliser la base de données modèle pour votre travail
   quotidien mais cette propriété, utilisée judicieusement, peut être
   utile. Pour plus de détails, voir la <xref
   linkend="manage-ag-templatedbs">.
  </para>

  <para>
   Pour plus de confort, il existe aussi un programme que vous pouvez
   exécuter à partir du shell pour créer de nouvelles bases de
   données, <command>createdb</>.<indexterm><primary>createdb</></>
    <synopsis>
     createdb <replaceable class="parameter">nombase</replaceable>
    </synopsis>
   <command>createdb</> ne fait rien de magique. Il se connecte à la
   base de données <literal>template1</> et exécute la commande
   <command>CREATE DATABASE</>, exectement comme ci-dessus. La page de
   référence sur <command>createdb</> contient les détails de son
   invocation. Notez que <command>createdb</> sans aucun argument
   créera une base de donnée portant le nom de l'utilisateur courant,
   ce qui n'est peut-être pas ce que vous voulez.
  </para>

  <note>
   <para>
    Le <xref linkend="client-authentication"> contient des informations
    sur la manière de restreindre l'accès à une base de données.
   </para>
  </note>

  <para>
   Parfois vous voulez créer une base de données pour quelqu'un
   d'autre. Cet utilisateur doit devenir le propriétaire de la
   nouvelle base de données, afin de pouvoir la configurer et
   l'administrer lui-même. Pour faire ceci, utilisez l'une des
   commandes suivantes&nbsp;:
    <programlisting>
     CREATE DATABASE <replaceable>nombase</> OWNER
     <replaceable>nomutilisateur</>;
    </programlisting>
   dans l'environment SQL ou
    <programlisting>
     createdb -O <replaceable>nomutilisateur</> <replaceable>nombase</>
    </programlisting>
   dans le shell. Vous devez être super-utilisateur pour créer une
   base de données pour quelqu'un d'autre.
  </para>

 </sect1>

 <sect1 id="manage-ag-templatedbs">

  <title>Bases de données modèles</title>

  <para>
   En fait, <command>CREATE DATABASE</> fonctionne en copiant une base
   de données préexistante. Par défaut, cette commande copie la base
   de données système standard
   <literal>template1</>.<indexterm><primary>template1</></> Ainsi,
   cette base de données est le <quote>modèle</> à partir duquel de
   nouvelles bases de données sont créées. Si vous ajoutez des objets
   à <literal>template1</>, ces objets seront copiés dans les bases de
   données utilisateur créées ultérieurement. Ce comportement permet
   d'apporter des modifications locales au jeu standard d'objets des
   bases de données. Par exemple, si vous installez le langage de
   procédures <application>PL/pgSQL</> dans <literal>template1</>, celui-ci
   sera automatiquement disponible dans les bases de données
   utilisateur sans qu'il soit nécessaire de faire quelque chose de
   spécial au moment où ces bases de données sont créées.
  </para>

  <para>
   Il y a une seconde base de données système standard appelée
   <literal>template0</>.<indexterm><primary>template0</></> Cette
   base de données contient les mêmes données que le contenu initial
   de <literal>template1</>, c'est-à-dire seulement les objets
   standards prédéfinis dans votre version de
   <productname>PostgreSQL</productname>. <literal>template0</> ne
   devrait jamais être modifiée après <command>initdb</>. En indiquant
   à <command>CREATE DATABASE</> de copier <literal>template0</> au
   lieu de <literal>template1</>, vous pouvez créer une base de
   données utilisateur <quote>vierge</> qui ne contient aucun des
   ajouts locaux à <literal>template1</>. Ceci est particulièrement
   pratique quand on restaure un dump réalisé avec <literal>pg_dump</>&nbsp;:
   le script de dump devrait être restauré dans une base de données
   vierge pour pour être sûr de recréer le contenu correct de la base
   de données sauvegardée, sans survenue de conflits avec des objets qui
   auraient été ajoutés à <literal>template1</>.
  </para>

  <para>
   Pour créer une base de données à partir de
   <literal>template0</literal>, utilisez
    <programlisting>
     CREATE DATABASE <replaceable>nombase</> TEMPLATE template0;
    </programlisting>
   dans l'environnement SQL ou
    <programlisting>
     createdb -T template0 <replaceable>nombase</>
    </programlisting>
   dans le shell.
  </para>

  <para>
   Il est possible de créer des bases de données modèles
   supplémentaires et, à vrai dire, on peut copier n'importe quelle
   base de données d'un cluster en la désignant comme modèle à la
   commande <command>CREATE DATABASE</>. Il importe de comprendre,
   cependant, que ceci n'est pas (encore) à prendre comme une commande
   <quote><command>COPY DATABASE</command></quote> de portée
   générale. En particulier, il est essentiel que la base de données
   source soit inactive (pas de transactions en écriture en cours)
   pendant toute la durée de l'opération de copie. <command>CREATE
   DATABASE</> vérifie qu'aucune autre session que la sienne n'est
   connectée à la base de données source au début de l'opération, mais
   ceci ne garantit pas que des changements ne peuvent pas être
   effectués pendant le déroulement de la copie, ce qui aboutirait à
   une base de données copiée inconsistante. C'est pourquoi nous
   recommandons que les bases de données utilisées comme modèles
   soient mises en lecture seule.
  </para>

  <para>
   Deux drapeaux utiles existent dans
   <literal>pg_database</literal><indexterm><primary>pg_database</></>
   pour chaque base de données&nbsp;: les colonnes
   <literal>datistemplate</literal> et
   <literal>datallowconn</literal>. <literal>datistemplate</literal>
   peut être positionné à vrai pour indiquer qu'une base de données a
   vocation à servir de modèle à <command>CREATE DATABASE</>. Si ce
   drapeau est positionné à vrai, la base de données peut être clonée
   par tout utilisateur ayant le droit <literal>CREATEDB</>&nbsp;; s'il est
   positionné à faux, seuls les super-utilisateurs et le propriétaire
   de la base de données peuvent la cloner. Si
   <literal>datallowconn</literal> est positionné à faux, alors aucune
   nouvelle connexion à cette base de données n'est autorisée (mais
   les sessions existantes ne sont pas tuées simplement en
   positionnant ce drapeau à faux). La base de données
   <literal>template0</literal> est normalement marquée
   <literal>datallowconn = false</> pour empêcher qu'elle ne soit
   modifiée. Aussi bien <literal>template0</literal> que
   <literal>template1</literal> devraient toujours être marquées
   <literal>datistemplate = true</>.
  </para>

  <para>
   Après avoir préparé ou modifé une base de données modèle, c'est une
   bonne idée d'exécuter les commandes <command>VACUUM FREEZE</> ou
   <command>VACUUM FULL FREEZE</> dans cette base de données. Si cela
   est fait alors qu'il n'y a pas d'autre transaction ouverte dans la
   même base de données, alors il est garanti que toutes les lignes de
   la base de données seront <quote>gelées</> et ne seront pas sujettes
   à des problèmes de réutilisation d'IDs de transaction déjà
   attribués. C'est particulièrement important pour une base de
   données qui aura le drapeau <literal>datallowconn</literal>
   positionné à faux puisqu'il sera impossible d'effectuer les
   <command>VACUUM</> de maintenance sur une telle base de
   données. Voir la <xref linkend="vacuum-for-wraparound"> pour plus
   d'informations.
  </para>

  <note>
   <para>
    <literal>template1</> et <literal>template0</> n'ont pas de
    caractère particulier en dehors du fait que <literal>template1</>
    est la base de données source par défaut pour la commande
    <command>CREATE DATABASE</> et la base de données à laquelle se
    connectent par défaut divers programmes comme
    <command>createdb</>. Par exemple, on pourrait supprimer
    <literal>template1</> et la recréer à partir de
    <literal>template0</> sans effet secondaire gênant. Ce procédé
    peut être utile lorsque l'on a encombré <literal>template1</>
    d'objets inutiles.
   </para>
  </note>

 </sect1>

 <sect1 id="manage-ag-config">

  <title>Configuration d'une base de données</title>

  <para>
   Comme il est dit dans la <xref linkend="runtime-config">, le serveur
   <productname>PostgreSQL</> offre un grand nombre de variables de
   configuration à chaud. Vous pouvez spécifier des valeurs par défaut,
   valables pour une base de données particulière, pour nombre de ces
   variables.
  </para>

  <para>
   Par exemple, si pour une raison quelconque vous voulez désactiver
   l'optimiseur <acronym>GEQO</acronym> pour une base de donnée particulière,
   vous n'avez pas besoin de le désactiver pour toutes les bases de données ou
   de faire en sorte que tout client se connectant exécute la commande
   <literal>SET geqo TO off;</literal>. Pour appliquer ce réglage par défaut à
   la base de données en question, vous pouvez exécuter la commande 
    <programlisting>
     ALTER DATABASE mabase SET geqo TO off;
    </programlisting>
   Cela sauvegardera le réglage (mais ne l'appliquera pas immédiatement) et
   lors des connexions ultérieures, tout se passera comme si la commande
   <literal>SET geqo TO off;</literal> était exécutée juste avant de commencer
   la session. Notez que les utilisateurs peuvent cependant modifier ce
   réglage pendant la session&nbsp;; il s'agit seulement d'un réglage par
   défaut. Pour annuler un tel réglage par défaut, utilisez <literal>ALTER
   DATABASE <replaceable>nombase</> RESET
   <replaceable>nomvariable</>;</literal>.
  </para>

 </sect1>

 <sect1 id="manage-ag-alternate-locs">

  <title>Emplacements alternatifs</title>

   <para>
    Il est possible de créer une base de données à un emplacement différent de
    l'emplacement par défaut après installation. Mais n'oubliez pas que tous
    les accès base de données se font à travers le serveur de bases de
    données, et donc que ce nouvel emplacement doit être accessible au serveur.
   </para>

   <para>
    Les emplacements de bases de données alternatifs sont spécifiés par une
    variable d'environnement qui indique le chemin absolu de l'emplacement
    voulu. Cette variable d'environnement doit être présente dans
    l'environnement du serveur, donc elle doit avoir été définie avant le
    démarrage du serveur. (Ainsi, l'ensemble des emplacements alternatifs
    disponibles est sous le contrôle de l'administrateur du site&nbsp;; les
    simples utilisateurs ne peuvent pas le modifier.) Tout nom valide de
    variable d'environnement peut être utilisé pour spécifier un emplacement
    alternatif, bien qu'il soit recommandé d'utiliser des noms de variables
    ayant pour préfixe <literal>PGDATA</> afin d'éviter la confusion ou des
    conflits avec d'autres variables.
   </para>

   <para>
    Pour créer la variable dans l'environnement du serveur, vous devez d'abord
    stopper ce dernier, définir la variable, initialiser l'aire de stockage
    des données et finalement relancer le serveur. (Voir également la <xref
    linkend="postmaster-shutdown"> et la <xref linkend="postmaster-start">.)
    Pour définir une variable d'environnement, tapez
     <programlisting>
      PGDATA2=/home/postgres/data
      export PGDATA2
     </programlisting>
    dans un shell Bourne ou
     <programlisting>
      setenv PGDATA2 /home/postgres/data
     </programlisting>
    dans <command>csh</> ou <command>tcsh</>. Vous devez faire en sorte que
    cette variable d'environnement soit toujours définie dans l'environnement
    du serveur, sinon vous ne pourrez pas accéder à cette aire de stockage. Un
    moyen d'y parvenir est de la définir dans le script de démarrage du
    serveur.
   </para>

   <para>
    <indexterm><primary>initlocation</></>
    Pour créer une aire de stockage de données dans <envar>PGDATA2</>,
    assurez-vous tout d'abord que le répertoire appelé à la contenir (ici,
    <filename>/home/postgres</filename>) existe bien et qu'il est accessible
    en écriture au compte utilisateur qui exécute le serveur (voir la <xref
    linkend="postgres-user">). Ensuite, tapez sur la ligne de commande&nbsp;:
     <programlisting>
      initlocation PGDATA2
     </programlisting>
    (<emphasis>et non pas</emphasis> <literal>initlocation
    $PGDATA2</literal>). Vous pouvez alors relancer le serveur.
   </para>

   <para>
    Pour créer une base de données dans la nouvelle aire de stockage, utilisez
    la commande SQL
     <synopsis>
      CREATE DATABASE <replaceable>nom</> WITH LOCATION
      '<replaceable>emplacement</>';
     </synopsis>
    ou <replaceable>emplacement</> est le nom de la variable d'environnement que
    vous avez utilisé, <envar>PGDATA2</> dans cet exemple. La commande shell
    <command>createdb</> dispose de l'option <option>-D</> pour arriver au
    même résultat.
   </para>

   <para>
    Les bases de données créées dans des emplacements alternatifs peuvent être
    accédées et détruites de la même manière que n'importe quelle base de
    données.
   </para>

   <note>
    <para>
     Il est également possible de spécifier directement un chemin absolu à la
     commande <command>CREATE DATABASE</> sans passer par une variable
     d'environnement. Mais c'est interdit par défaut parce que cela
     constitue une brêche de sécurité. Pour l'autoriser, vous devez compiler
     <productname>PostgreSQL</> avec la macro du préprocesseur C
     <literal>ALLOW_ABSOLUTE_DBPATHS</> définie. Un moyen de le faire est
     d'exécuter la compilation de cette manière&nbsp;:
     <programlisting>
      gmake CPPFLAGS=-DALLOW_ABSOLUTE_DBPATHS all
     </programlisting>
    </para>
   </note>

 </sect1>

 <sect1 id="manage-ag-dropdb">

  <title>Destruction d'une base de données</title>

  <para>
   Les bases de données sont détruites à l'aide de la commande <command>DROP
   DATABASE</command>&nbsp;:<indexterm><primary>DROP DATABASE</></>
    <synopsis>
     DROP DATABASE <replaceable>nom</>;
    </synopsis>
   Une base de données ne peut être détruite que par son propriétaire
   (c'est-à-dire par l'utilisateur qui l'a créée) ou par un super-utilisateur.
   La destruction d'une base de données supprime tous les objets qu'elle
   contenait. La destruction d'une base de données est irréversible.
  </para>

  <para>
   Vous ne pouvez pas exécuter la commande <command>DROP DATABASE</command> en
   étant connecté à la base de données cible. Vous pouvez cependant être
   connecté à n'importe quelle autre base de données, y compris la base de
   données <literal>template1</>. Cette dernière est d'ailleurs la seule
   option possible pour détruire la dernière base de données utilisateur d'un
   groupe à l'aide de la commande <command>DROP DATABASE</command>.
  </para>

  <para>
   Par commodité, il existe également un programme shell pour détruire des
   bases de données&nbsp;:<indexterm><primary>dropdb</></>
    <synopsis>
     dropdb <replaceable class="parameter">nombase</replaceable>
    </synopsis>
   (Contrairement à <command>createdb</>, cette commande ne supprime pas par
   défaut la base de données qui porte le nom de l'utilisateur courant.)
  </para>

 </sect1>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
