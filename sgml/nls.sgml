<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/nls.sgml,v 1.4 2004/11/16 23:26:50 guillaume Exp $
-->

<chapter id="nls">
 <docinfo>
  <author>
   <firstname>Peter</firstname>
   <surname>Eisentraut</surname>
  </author>
 </docinfo>

 <title>Support natif des langages</title>

 <sect1 id="nls-translator">
  <title>Pour le traducteur</title>

  <para>
   Les programmes <productname>PostgreSQL</> (serveur et client) peuvent envoyer
   leur message dans votre langue préférée -- si les messages ont été traduits.
   Créer et maintenir les ensembles de messages traduits nécessite l'aide de
   personnes parlant leur propre langue et souhaitant contribuer à l'effort pour
   <productname>PostgreSQL</>. Vous n'avez pas besoin d'être un développeur
   pour cela. Cette section explique comment aider.
  </para>

  <sect2>
   <title>Prérequis</title>

   <para>
    Nous ne jugerons pas vos qualités en ce qui concerne votre langue -- cette
    section concerne seulement les outils logiciels. Théoriquement, vous n'avez
    besoin que d'un éditeur de texte. Mais ceci est dans le cas improbable où
    vous ne voulez pas tester vos traductions des messages. Lorsque vous
    configurez les sources, assurez-vous d'utiliser l'option
    <option>--enable-nls</option>. Ceci vous assurera aussi de la présence de la
    bibliothèque <application>libintl</application> et du programme
    <filename>msgfmt</filename> dont tous les utilisateurs finaux ont de toute
    façon besoin. Pour essayer votre travail, suivez les portions applicables
    des instructions d'installation.
   </para>

   <para>
    Si vous voulez commencer un nouvel effort de traduction ou si vous voulez
    faire un assemblage de catalogues de messages (décrite ci-après), vous
    aurez besoin respectivement des programmes <filename>xgettext</filename> et
    <filename>msgmerge</filename> dans une implémentation compatible GNU. Après,
    nous essaierons d'arranger cela de façon à ce que, si vous utilisez une
    distribution source du paquet, vous n'ayez pas besoin de
    <filename>xgettext</filename>. (Avec CVS, vous en aurez toujours besoin.) 
    <application>GNU Gettext 0.10.36</application> ou ultérieure est
     actuellement recommendé.
   </para>

   <para>
    Votre implémentation locale de gettext devrait être disponible avec sa
    propre documentation. Ceci est certainement dupliqué avec ce qui suit mais
    vous devez regarder ici pour des détails supplémentaires.
   </para>
  </sect2>

  <sect2>
   <title>Concepts</title>

   <para>
    Les pairs de messages originaux (anglais) et de leur (possibles)
    équivalents traduits sont conservés dans les <firstterm>catalogues de
    messages</firstterm>, un pour chaque programme (bien que des programmes liés
    peuvent gérer un catalogue de message) et pour chaque langue cible. Il
    existe deux formats de fichiers pour les catalogues de messages&nbsp;: le
    premier est le fichier <quote>PO</quote> (pour objet portable), qui est un
    fichier texte muni d'une syntaxe spéciale et que les traducteurs éditent. Le
    second est un fichier <quote>MO</quote> (pour objet machine), qui est un
    fichier binaire généré à partir du fichier PO respectif et qui est utilisé
    lorsque le programme internationalisé est exécuté. Les traducteurs ne
    s'occupent pas des fichiers MO&nbsp;; en fait, personne ne s'en occupe.
   </para>

   <para>
    L'extension du catalogue de messages est sans surprise, soit
    <filename>.po</filename> soit <filename>.mo</filename>. Le nom de base est
    soit le nom du programme qui l'accompagne soit la langue utilisée dans le
    fichier, suivant la situation. Ceci est un peu confus. Les exemples
    sont <filename>psql.po</filename> (fichier PO pour psql) ou
    <filename>fr.mo</filename> (fichier MO en français).
   </para>

   <para>
    Le format du fichier PO est illustré ici&nbsp;:
<programlisting>
# comment

msgid "chaîne originale"
msgstr "chaîne traduite"

msgid "encore une"
msgstr "de traduite"
"les chaînes peuvent être sur plusieurs lignes ainsi"

...
</programlisting>
    Les chaînes msgid sont extraites des sources du programme. (Elles n'ont pas
    besoin de l'être mais c'est le moyen le plus commun). Les lignes msgstr sont
    initialement vides puis remplies avec les chaînes traduites. Les chaînes
    contiennent des caractères d'échappement style C et peuvent être sur
    plusieurs lignes comme le montre l'exemple ci-dessus. (La ligne suivante
    doit être au début de la ligne.)
   </para>

   <para>
    Le caractère # introduit un commentaire. Si un espace blanc suit i
mmédiatement le caractère #, le commentaire est maintenu par le
traducteur. Il y a aussi des commentaires automatiques qui n'ont pas d'espace
blanc suivant immédiatement le #. Ils sont maintenus par les différents outils
qui opérent sur les fichiers PO et ont pour but d'aider le traducteur.
<programlisting>
#. commentaire automatique
#: fichier.c:1023
#, options, options
</programlisting>
    Les commentaires du style #. sont extraits du fichier source où le message
    est utilisé. Il est possible que le développeu a ajouté des informations
    pour le traducteur, telles que l'alignement attendu. Le commentai re #:
    indique l'emplacement exact où le message est utilisé dans le source. Le
    traducteur n'a pas besoin de regarder le source du programme mais il peut
    s'il subsiste un doute sur l'efficacité d'une traduction. Le commentaire #,
    contient des options décrivant le message d'une certaine façon. Il existe
    actuellement deux options&nbsp;: <literal>fuzzy</literal> est là si le
    message a des risques d'être obsolète à cause de changements dans les
    sources. Le traducteur doit alors vérifier ceci et supprimer cette option.
    Notez que les messages <quote>fuzzy</quote> ne sont pas disponibles pour
    l'utilisateur final. L'autre option est <literal>c-format</literal>
    indiquant que le message utilise le format de la fonction C
    <function>printf</function>. Ceci signifie que la traduction devrait aussi
    être de ce format avec le même nombre et le même type de variables. Il
    existe des outils pour vérifier ceci.
   </para>
  </sect2>

  <sect2>
   <title>Créer et maintenir des catalogues de messages</title>

   <para>
    OK, donc comment fait quelqu'un qui créer un catalogue de messages
    <quote>vide</quote>&nbsp;? Tout d'abord, allez dans le répertoire contenant
    le programme dont vous souhaitez traduire les messages. S'il existe un
    fichier <filename>nls.mk</filename>, alors ce programme est prévu pour une
    traduction.
   </para>

   <para>
    S'il y a déjà quelques fichiers <filename>.po</filename>, alors quelqu'un a
    déjà réalisé quelques travaux de traduction. Les fichiers sont nommés 
    <filename><replaceable>langue</replaceable>.po</filename>, où
    <replaceable>langue</replaceable> est le code de langue sur deux caractères
    d'après l'<ulink
    url="http://lcweb.loc.gov/standards/iso639-2/englangn.html">ISO
    639-1</ulink> (en minuscule), c'est-à-dire <filename>fr.po</filename> pour
    le français. S'il existe réellement un besoin pour plus d'un effort de
    traduction par langue alors les fichiers pourraient être renommés
<filename><replaceable>langue</replaceable>_<replaceable>region</replaceable>.
po</filename>
    où <replaceable>region</replaceable> est le code de langue sur deux
    caractères d'après l'<ulink
url="http://www.din.de/gremien/nas/nabd/iso3166ma/codlstp1/en_listp1.html">ISO
    3166-1</ulink> (en majuscule), c'est-à-dire
    <filename>pt_BR.po</filename> pour du portuguais au Brésil. Si vous voulez
    trouver la langue que vous souhaitez, vous pouvez commencer par travailler
    sur ce fichier.
   </para>

   <para>
    Si vous voulez commencer un nouvel effort de traduction, alors lancez
    d'abord la commande
<programlisting>
gmake init-po
</programlisting>
    Ceci créera un fichier
    <filename><replaceable>nomprog</replaceable>.pot</filename>.
    (<filename>.pot</filename> pour le distinguer des fichiers PO qui sont
    <quote>en production</quote>. Le <literal>T</> est pour
    <quote>template</> (NdT&nbsp;: modèle en anglais.)
    Copiez ce fichier sous le nom
    <filename><replaceable>langue</replaceable>.po</filename> et éditez-le.
    Pour faire savoir qu'une nouvelle langue est disponible, éditez aussi le
    fichier <filename>nls.mk</filename> et ajoutez le code de la langue (ou de
    la langue et du pays) avec une ligne ressemblant à ceci&nbsp;:
<programlisting>
AVAIL_LANGUAGES := de fr
</programlisting>
    (D'autres langues peuvent apparaître, bien sûr.)
   </para>

   <para>
    Comme le programme ou la bibliothèque change, des messages peuvent
    être modifiés ou ajoutés par les développeurs. Dans ce cas, vous n'avez pas
    besoin de tout recommencer depuis le début. À la place, lancez la commande
<programlisting>
gmake update-po
</programlisting>
    qui créera un nouveau catalogue de messages blanc (le fichier pot avec
    lequel vous avez commencé) et l'assemblera avec les fichiers PO existants.
    Si l'algorithme d'assemblage a une incertitude sur un message particulier,
    il le marquera <quote>fuzzy</quote> comme expliqué ci-dessus. Dans la cas où
    quelque chose se passe mal, l'ancien fichier PO est sauvegardé avec une
    extension <filename>.po.old</filename>.
   </para>
  </sect2>

  <sect2>
   <title>Éditer les fichiers PO</title>

   <para>
    Les fichiers PO sont éditables avec un éditeur texte standard. Le traducteur
    doit seulement modifier l'emplacement entre les guillemets après la
    directive msgstr, peut ajouter des commentaires et modifier le statut fuzzy.
    Il existe, de façon non surprenante un mode PO pour Emacs, que est assez
    utile.
   </para>

   <para>
    Les fichiers PO n'ont pas besoin d'être entièrement remplis. Le logiciel
    retournera automatiquement à la chaîne originale si une traduction n'est pas
    disponible ou est vide. Soumettre des traductions incomplètes pour les
    inclure dans les sources n'est pas un problème&nbsp;; cela permet à d'autres
    personnes de récupérer votre travail pour le continuer. Néanmoins, vous êtes
    encouragé à donner une haute priorité à la suppression des entrées fuzzy
    après avoir fait un assemblage. Rappellez-vous que les entrées fuzzy ne
    seront pas installées&nbsp;; elles servent seulement de référence à ce qui
    pourrait être une bonne traduction.
   </para>

   <para>
    Voici certaines choses à conserver en tête lors de l'édition des
    traductions&nbsp;:
    <itemizedlist>
     <listitem>
      <para>
       Assurez que si l'original se termine avec un retour chariot, la
       traduction le fait bien aussi. De même pour les tabulations, etc.
      </para>
     </listitem>

     <listitem>
      <para>
       Si l'original est une chaîne au format <function>printf</>, la
       traduction doit aussi l'être. La traduction a aussi besoin d'avoir les
       même spécificateurs de format et dans le même ordre. Quelque fois, les
       règles naturels de la langue rendent cela impossible ou tout au moins
       difficile. Dans ce cas, vous devez modifier les spécificateurs de format
       de cette façon&nbsp;:
<programlisting>
msgstr "Die Datei %2$s hat %1$u Zeichen."
</programlisting>
       Alors le premier emplacement sera utilisé par le deuxième argument de la
       liste. Le <literal><replaceable>chiffre</replaceable>$</literal> a
       besoin de suivre immédiatement le %, avant tout autre manipulateur de
       format. (Cette fonctionnalité existe réellement dans la famille des
       fonctions <function>printf</function>. Vous pouvez ne pas en avoir
       entendu parler car il a peu d'utilité en dehors de
       l'internationalisation des messages.)
      </para>
     </listitem>

     <listitem>
      <para>
       Si la chaîne originale contient une erreur linguitique, rapportez-la (ou
       corrigez-le vous-même dans le source du programme) et traduisez-le
       normalement. La chaîne corrigée peut être assemblée lorsque les
       programmes source auront été mis à jour. Si la chaîne originale contient
       une erreur, rapportez-la (ou corrigez-la vous-même) et ne la traduisez
       pas. À la place, marquez la chaîne avec un commentaire dans le fichier
       PO.
      </para>
     </listitem>

     <listitem>
      <para>
       Maintenez le style et le ton de la chaîne originale. Spécifiquement, les
       messages qui ne sont pas des phrases (<literal>cannot
       open file %s</literal>, soit <literal>n'a pas pu ouvrir le fichier
       %s</literal>) ne devraient probablement pas commencer avec une lettre
       capitale (si votre langue distingue la casse des lettres) ou finir avec
       un point (si votre langue utilise des marques de ponctuation). Lire <xref
       linkend="error-style-guide"> pourrait vous aider.
      </para>
     </listitem>

     <listitem>
      <para>
       Si vous ne savez pas ce que signifie un message ou s'il est ambigü,
       demandez sa signification sur la liste de diffusion des développeurs. Il
       y a des chances pour qu'un anglais natif puisse aussi ne pas le
       comprendre ou le trouver ambigü, donc il est mieux d'améliorer le
       message.
      </para>
     </listitem>

    </itemizedlist>
   </para>
  </sect2>

 </sect1>


 <sect1 id="nls-programmer">
  <title>Pour le développeur</title>

  <sect2 id="nls-mechanics">
   <title>Mécanique</title>

  <para>
   Cette section décrit comment implémenter le support natif d'un langage dans
   un programme ou dans une bibliothèque qui fait partie de la distribution
   <productname>PostgreSQL</>. Actuellement, cela s'applique seulement aux
   programmes C.
  </para>

  <procedure>
   <title>Ajouter le support NLS à un programme</title>

   <step>
    <para>
     Insérez le code dans la séquence de début du programme&nbsp;:
<programlisting>
#ifdef ENABLE_NLS
#include &lt;locale.h&gt;
#endif

...

#ifdef ENABLE_NLS
setlocale(LC_ALL, "");
bindtextdomain("<replaceable>nomprog</replaceable>", LOCALEDIR);
textdomain("<replaceable>nomprog</replaceable>");
#endif
</programlisting>
     (<replaceable>nomprog</replaceable> peut être choisi librement.)
    </para>
   </step>

   <step>
    <para>
     Quand un message, candidat pour une traduction, est trouvé,
     un appel à <function>gettext()</function> doit être inséré.
     C'est-à-dire&nbsp;:
<programlisting>
fprintf(stderr, "panic level %d\n", lvl);
</programlisting>
     devra être changé avec
<programlisting>
fprintf(stderr, gettext("panic level %d\n"), lvl);
</programlisting>
     (<symbol>gettext</symbol> est défini comme une opération nulle si NLS
     n'est pas configuré.)
    </para>

    <para>
     Ceci peut tendre à l'ajout d'un grand nombre d'appels. Un raccourci commun
     est
<programlisting>
#define _(x) gettext(x)
</programlisting>
     Une autre solution est possible si le programme fait la plupart de sa
     communication via une ou plusieurs fonctions, telles que
     <function>ereport()</function> pour le moteur. Ensuite, vous faites que
     cette fonction appelle <function>gettext</function> en interne pour toutes
     les chaînes en entrée.
    </para>
   </step>

   <step>
    <para>
     Ajoutez un fichier <filename>nls.mk</filename> dans le répertoire des
     sources du programme. Ce fichier sera lu comme un makefile.  Les
     affectations des variables suivantes seront certainement réalisées
     ici&nbsp;:

     <variablelist>
      <varlistentry>
       <term><varname>CATALOG_NAME</varname></term>

       <listitem>
        <para>
         Le nom du programme fourni avec l'appel à
         <function>textdomain()</function>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>AVAIL_LANGUAGES</varname></term>

       <listitem>
        <para>
         Liste des traductions fournies -- vide au début.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>GETTEXT_FILES</varname></term>

       <listitem>
        <para>
         Liste des fichiers contenant les chaînes traduites, c'est-à-dire
         celles marquées avec <function>gettext</function> ou une autre
         solution. Éventuellement, ceci incluera pratiquement tous les fichiers
         sources du programme. Si cette liste est trop longue, vous pouvez faire
         que le premier <quote>fichier</quote> est un <literal>+</literal> et
         que le deuxième mot est un fichier contenant un nom de fichier par
         ligne.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>GETTEXT_TRIGGERS</varname></term>

       <listitem>
        <para>
         Les outils qui génèrent des catalogues de messages pour que les
         traducteurs travaillent dessus ont besoin de connaître les appels de
         fonction contenent des chaînes à traduire. Par défaut, seuls les appels
         à <function>gettext()</function> sont reconnus. Si vous utilisez
         <function>_</function> ou d'autres identifiants, vous avez besoin de
         les lister ici. Si la chaîne traduisible n'est pas le premier argument,
         l'élément a besoin d'être de la forme <literal>func:2</literal> (pour
         le second argument).
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </step>

  </procedure>

  <para>
   Le système de traduction prendra automatiquement en charge la construction et
   l'installation des catalogues de messages.
  </para>
  </sect2>

  <sect2 id="nls-guidelines">
   <title>Guide d'écriture des messages</title>

  <para>
   Voici quelques lignes de conduite pour l'écriture de messages facilement
   traduisibles.

   <itemizedlist>
    <listitem>
     <para>
      Ne construisez pas de phrases à l'exécution, comme
<programlisting>
printf("Files were %s.\n", flag ? "copied" : "removed");
</programlisting>
      L'ordre des mots d'une phrase peut être différent dans d'autres langues.
      De même, même si vous pensez appeller gettext() sur chaque fragment, les
      fragments pourraient ne pas se traduire facilement séparement. Il est
      mieux de dupliquer un peu de code de façon à ce que chaque message à
      traduire soit un tout cohérent. Seuls les nombres, noms de fichiers et
      autres variables d'exécution devraient être insérés au moment de
      l'exécution dans le texte d'un message.
     </para>
    </listitem>

    <listitem>
     <para>
      Pour des raisons similaires, ceci ne fonctionnera pas&nbsp;:
<programlisting>
printf("copied %d file%s", n, n!=1 ? "s" : "");
</programlisting>
      parce qu'il assume la façon dont la forme plurielle est obtenue. Si vous
      pensez pouvoir le résoudre ainsi
<programlisting>
if (n==1)
    printf("copied 1 file");
else
    printf("copied %d files", n):
</programlisting>
      alors vous serez déçu. Certaines langues ont plus de deux formes avec 
      des règles particulières. Nous pourrions avoir une solution pour ceci dans
      le futur, mais actuellement il est mieux d'éviter ce problème. Vous pouvez
      écrire&nbsp;:
<programlisting>
printf("number of copied files: %d", n);
</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
      Si vous voulez communiquer quelque chose au traducteur, tel que la façon
      dont un message doit être aligné avec d'autres sorties, précédez
      l'occurence de la chaîne avec un commentaire commençant avec
      <literal>translator</literal>, c'est-à-dire
<programlisting>
/* translator: This message is not what it seems to be. */
</programlisting>
      Ces commentaires sont copiés dans les catalogues de messages de façon à
      ce que les traducteurs les voient.
     </para>
    </listitem>
   </itemizedlist>
  </para>
  </sect2>
 </sect1>

</chapter>
