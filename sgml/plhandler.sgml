<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/plhandler.sgml,v 1.2 2005/01/27 08:14:48 guillaume Exp $
-->

 <chapter id="plhandler">
   <title>Écrire un gestionnaire de langage procédural</title>

   <indexterm zone="plhandler">
    <primary>langage procédural</primary>
    <secondary>gestionnaire</secondary>
   </indexterm>

   <para>
   Tous les appels vers des fonctions écrites dans un langage autre que celui
    de l'interface <quote>version 1</quote> pour les langages compilés (ceci
    inclut les fonctions dans les langages procéduraux définis par
    l'utilisateur, les fonctions écrites en SQL et les fonctions utilisant
    l'interface de langage compilé version 0), passent par une fonction du
    <firstterm>gestionnaire d'appel</firstterm> spécifique au langage.
    L'exécution de la fonction est de la responsabilité du gestionnaire
    d'appels, par exemple l'interprétation texte source founi. Ce chapitre
    indique comment le gestionnaire d'appels d'un nouveau langage procédural
    peut être écrit.
   </para>

   <para>
    Le gestionnaire d'appel d'un langage procédural est une fonction
    <quote>normale</quote> qui doit être écrite dans un langage compilé tel que
    le C, en utilisant l'interface version-1, et enregistré avec
    <productname>PostgreSQL</productname> comme ne prenant aucun argument
    et retournant le type <type>language_handler</type>. Ce pseudo-type spécial
    identifie la fonction en tant que gestionnaire d'appel et l'empêche d'être
    appelé directement à partir des commandes SQL.
   </para>

   <para>
    Le gestionnaire d'appels est appelé de la même façon que n'importe quel
    autre fonction&nbsp;: il reçoit un pointeur vers une <type>struct</>ure
    <structname>FunctionCallInfoData</structname> contenant des valeurs en
    argument et une information sur la fonction appelée, et il doit renvoyer un
    résultat <type>Datum</type> (et, si possible, initialiser le champ
    <structfield>isnull</structfield> de la structure
    <structname>FunctionCallInfoData</structname> s'il souhaite renvoyer un
    résultat SQL null). La différence entre un gestionnaire d'appel et une
    fonction ordinaire est que le champ
    <structfield>flinfo-&gt;fn_oid</structfield> de la structure
    <structname>FunctionCallInfoData</structname> contiendra l'OID
    de la fonction à appeller, et non pas le gestionnaire d'appels lui-même.
    Le gestionnaire d'appels doit utiliser ce champ pour déterminer quelle
    fonction exécutée. De plus, la liste d'arguments passée a été configuré 
    en concordance avec la déclaration de la fonction cible, et non pas en
    fonction du gestionnaire d'appels.
   </para>

   <para>
    C'est au gestionnaire d'appels de récupérer de récupérer l'entrée de la
    fonction à partir de la table système <classname>pg_proc</classname> et
    d'analyser les types des arguments et de la valeur de retour de la fonction
    appelée. La clause <literal>AS</> à partir du
    <command>CREATE FUNCTION</command> de la fonction sera trouvée dans la
    colonne <literal>prosrc</literal> de la ligne de
    <classname>pg_proc</classname>. Cela pourrait être le texte du source du
    langage procédural lui-même (comme pour PL/Tcl), un chemin vers un fichier
    ou tout autre chose qui indique en détails ce que le gestionnaire d'appels
    doit faire.
   </para>

   <para>
    Souvent, la même fonction est appelée plusieurs fois par instruction SQL.
    Un gestionnaire d'appels peut éviter des recherches d'informations répétées
    sur la fonction appelée en utilisant le champ
    <structfield>flinfo-&gt;fn_extra</structfield>. Il sera initialement à
    <symbol>NULL</> mais pourra être configuré par le gestionnaire d'appels pour
    pointer vers l'information de la fonction appelée. Pour les appels
    suivants, si <structfield>flinfo-&gt;fn_extra</structfield> est déjà non
    <symbol>NULL</>, alors il peut être utilisé et l'étape de recherche
    d'information pourra être évitée. Le gestionnaire d'appels doit s'assurer
    que <structfield>flinfo-&gt;fn_extra</structfield> pointe sur la mémoire et
    qu'il y restera au moins jusqu'à la fin de la requête en cours car une
    structure de données <structname>FmgrInfo</structname> peut être conservée
    aussi longtemps. Une façon de le faire est d'allouer les données
    supplémentaires dans le contexte mémoire spécifié par
    <structfield>flinfo-&gt;fn_mcxt</structfield>&nbsp;; de telles données
    auront normalement la même espérance de vie que
    <structname>FmgrInfo</structname> lui-même. Mais le gestionnaire pourrait
    aussi choisir d'utiliser un contexte mémoire de plus longue durée de façon à
    cacher des informations sur les définitions des fonctions sur plusieurs
    requêtes.
   </para>

   <para>
    Lorsqu'une fonction en langage procédural est appelé via un déclencheur,
    aucun argument ne lui est passé dans le cas habituel mais le champ
    <structfield>context</structfield> de
    <structname>FunctionCallInfoData</structname> pointe sur une structure
    <structname>TriggerData</structname>, plutôt que d'être
    <symbol>NULL</> comme c'est le cas dans les appels de fonctions standards.
    Le gestionnaire d'un langage devrait fournir des mécanismes pour que les
    fonctions de langages procéduraux obtiennent des informations du
    déclencheur.
   </para>

   <para>
    Voici un modèle de gestionnaire de langage procédural écrit en C&nbsp;:
<programlisting>
#include "postgres.h"
#include "executor/spi.h"
#include "commands/trigger.h"
#include "fmgr.h"
#include "access/heapam.h"
#include "utils/syscache.h"
#include "catalog/pg_proc.h"
#include "catalog/pg_type.h"

PG_FUNCTION_INFO_V1(plsample_call_handler);

Datum
plsample_call_handler(PG_FUNCTION_ARGS)
{
    Datum          retval;

    if (CALLED_AS_TRIGGER(fcinfo))
    {
        /*
         * Appelé en tant que procédure d'un déclencheur
         */
        TriggerData    *trigdata = (TriggerData *) fcinfo->context;

        retval = ...
    }
    else
    {
        /*
         * Appelé en tant que fonction
         */

        retval = ...
    }

    return retval;
}
</programlisting>
    Seules quelques milliers de lignes de codes ont été ajoutées à la place des
    pointes pour compléter ce modèle.
   </para>

   <para>
    Après avoir compilé la fonction du gestionnaire dans un module chargeable
    (voir <xref linkend="dfunc">), les commandes enregistrent le langage
    procédural d'exemple&nbsp;:
<programlisting>
CREATE FUNCTION plsample_call_handler() RETURNS language_handler
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C;
CREATE LANGUAGE plsample
    HANDLER plsample_call_handler;
</programlisting>
   </para>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
