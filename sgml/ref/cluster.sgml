<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/cluster.sgml,v 1.7 2004/12/31 19:14:23 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-CLUSTER">
 <refmeta>
  <refentrytitle id="sql-cluster-title">CLUSTER</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CLUSTER</refname>
  <refpurpose>groupe une table suivant un index</refpurpose>
 </refnamediv>

 <indexterm zone="sql-cluster">
  <primary>CLUSTER</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CLUSTER <replaceable class="PARAMETER">nomindex</replaceable> ON <replaceable
class="PARAMETER">nomtable</replaceable>
CLUSTER <replaceable class="PARAMETER">nomtable</replaceable>
CLUSTER
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CLUSTER</command> demande à <productname>PostgreSQL</productname>
   de grouper la table spécifiée par <replaceable
   class="parameter">nomtable</replaceable> en se basant sur l'index spécifié
   par <replaceable class="parameter">nomindex</replaceable>. L'index doit déjà
   avoir été défini sur <replaceable class="parameter">nomtable</replaceable>.
  </para>

  <para>
   Quand une table est groupée, elle est physiquement réordonnée en se basant
   sur l'information de l'index. Ce groupement est une opération en une
   fois&nbsp;: quand une table est mise à jour après coup, les modifications ne
   prennent pas compte du groupement. C'est-à-dire qu'aucune tentative n'est
   réalisée pour stocker les nouvelles données ou les données mises à jour
   suivant l'ordre de l'index. Si vous le souhaitez, vous pouvez grouper
   périodiquement en lançant de nouveau la commande.
  </para>

  <para>
   Quand une table est groupée, <productname>PostgreSQL</productname> se
   rappelle de l'index avec laquelle elle a été groupée. La forme
   <command>CLUSTER <replaceable
   class="parameter">nomtable</replaceable></command> groupe de nouveau la
   table avec le même index qu'auparavant.
  </para>

  <para>
   <command>CLUSTER</command> sans aucun paramètre groupe toutes les
   tables de la base de données courante et dont l'utilisateur est
   propriétaire, ou toutes les tables s'il s'agit d'un superutilisateur. (Les
   tables qui n'ont jamais été groupées sont ignorées.) Cette forme de
   <command>CLUSTER</command> ne peut pas être appelée à partir d'une
   transaction ou d'une fonction.
  </para>

  <para>
   Quand une table est en cours de groupement, un verrou <literal>ACCESS
   EXCLUSIVE</literal> est acquis. Ceci empêche toutes les opérations de la
   base de données sur la table (à la fois en lecture et en écriture) tant que
   <command>CLUSTER</command> n'est pas terminée.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="PARAMETER">nomindex</replaceable></term>
    <listitem>
     <para>
      Le nom d'un index.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">nomtable</replaceable></term>
    <listitem>
     <para>
      Le nom (pouvant être qualifié du nom du schéma) d'une table.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    Dans les cas où vous accédez à des lignes seules de façon aléatoire à
    l'intérieur d'une table, l'ordre réel des données dans la table n'est pas
    important. Néanmoins, si vous avez tendance à accèder à quelques données
    plus que d'autres et qu'il existe un index qui les groupe ensemble, vous
    bénéficierez de l'utilisation de <command>CLUSTER</command>. Si vous
    demandez un ensemble de valeurs indexées à partir d'une table, ou une seule
    valeur indexée correspondant à plusieurs lignes, <command>CLUSTER</command>
    vous aidera car une fois que l'index a identifié la page principale pour la
    première ligne correspondante, toutes les autres lignes correspondantes
    sont déjà probablement sur la même page et vous économisez du coup des accès
    disque et accélérez ainsi la requête.
   </para>

   <para>
    Lors de l'opération de groupement, une copie temporaire de la table est créé
    pour contenir les données de la table dans l'ordre de l'index. Les copies
    temporaires de chaque index de la table sont aussi créées. Du coup, vous
    avez besoin d'espace libre sur le disque au moins égale à la somme de la
    taille de la table et des tailles des index.
   </para>

   <para>
    Comme <command>CLUSTER</command> se rappelle des informations de
    groupement, vous pouvez grouper les tables que vous voulez la
    première fois manuellement  et configurer et un événement temporisé
    similaire au <command>VACUUM</command> de façon à ce que les tables soient
    périodiquement groupées de nouveau.
   </para>

   <para>
    Comme le planificateur enregistre les statistiques des enregistrements
    suivant l'ordre des tables, il est conseillable de lancer
    <command>ANALYZE</command> sur la nouvelle table groupée. Sinon, le
    planificateur pourrait faire de mauvais choix pour les plans de requêtes.
   </para>

   <para>
    Il existe une autre façon de grouper les données. La commande
    <command>CLUSTER</command> réordonne la table originale en utilisant
    l'ordre de l'index que vous spécifiez. Ceci peut être lent sur les tables
    importantes parce que les lignes sont récupérées à partir de la pile dans
    l'ordre de l'index et que si la table n'est pas ordonnée, les entrées seront
    dans des pages aléatoires, donc il y a une page disque récupérée pour chaque
    ligne déplacée. (<productname>PostgreSQL</productname> a un cache mais la
    majorité d'une grande table ne tiendra pas dans le cache.) L'autre moyen de
    grouper une table est d'utiliser

<programlisting>
CREATE TABLE <replaceable class="parameter">nouvelletable</replaceable> AS
    SELECT <replaceable class="parameter">listecolonnes</replaceable> FROM
<replaceable class="parameter">table</replaceable> ORDER BY <replaceable
class="parameter">listecolonnes</replaceable>;
</programlisting>

    qui utilise le code de tri de <productname>PostgreSQL</productname> dans la
    clause <literal>ORDER BY</literal> pour créer l'ordre désiré&nbsp;; ceci est
    généralement bien plus rapide qu'un parcours d'index pour une donnée non 
    triée. Vous pouvez alors supprimer l'ancienne table, utiliser <command>ALTER
    TABLE ... RENAME</command> pour renommer <replaceable
    class="parameter">nouvelletable</replaceable> par l'ancien nom et recréer
    les index de la table. Néanmoins, cette approche ne préserve pas les OID,
    les contraintes, les relations de clés étrangères, les droits donnés et
    d'autres propriétés de la table --- tous ces éléments devront être recréés
    manuellement.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Grouper la table <literal>employes</literal> sur la base de son index
   <literal>emp_ind</literal>&nbsp;:
<programlisting>
CLUSTER emp_ind ON emp;
</programlisting>
  </para>

  <para>
   Grouper la relation <literal>employes</literal> en utilisant le même index
   qu'auparavant&nbsp;:
<programlisting>
CLUSTER emp;
</programlisting>
  </para>

  <para>
   Grouper toutes les tables de la base de données qui ont déjà été
   groupées&nbsp;:
<programlisting>
CLUSTER;
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas d'instruction <command>CLUSTER</command> dans le standard
   SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="app-clusterdb" endterm="app-clusterdb-title"></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->

