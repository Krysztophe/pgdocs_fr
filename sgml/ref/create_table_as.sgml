<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_table_as.sgml,v 1.8 2004/12/21 23:09:12 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-CREATETABLEAS">
 <refmeta>
  <refentrytitle id="sql-createtableas-title">CREATE TABLE AS</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TABLE AS</refname>
  <refpurpose>crée une nouvelle table à partir des résultats d'une
   requête</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createtableas">
  <primary>CREATE TABLE AS</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE
<replaceable>nom_table</replaceable> [
(<replaceable>nom_colonne</replaceable> [, ...] ) ]
    AS <replaceable>requête</replaceable>
</synopsis>
 </refsynopsisdiv>
  
 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE TABLE AS</command> crée une table et la remplit avec des
   données récupérées par une commande <command>SELECT</command> ou un
   <command>EXECUTE</command> qui lance une commande préparée
   <command>SELECT</command>. Les colonnes de table ont les noms et les types de
   données associés avec les colonnes en sortie du <command>SELECT</command>
   (sauf que vous pouvez surcharger les noms de colonne en donnant une liste
   explicite des nouveaux noms de colonnes).
  </para>

  <para>
   <command>CREATE TABLE AS</command> a une certaine ressemblance pour créer
   une vue mais elle est réellement assez différente&nbsp;: il crée une nouvelle
   table et évalue la requête juste une fois pour remplir la nouvelle table
   initialement. La nouvelle table ne tracera pas les changements suivants pour
   les tables source de la requête. En contraste, une vue ré-évalue son
   instruction <command>SELECT</command> à chaque fois qu'elle est appelée.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>
   
  <variablelist>
   <varlistentry>
    <term><literal>TEMPORARY</> ou <literal>TEMP</></term>
    <listitem>
     <para>
      Si spécifié, la table est créée comme une table temporaire.
      Référez-vous à <xref linkend="sql-createtable"
      endterm="sql-createtable-title"> pour plus de détails.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable>nom_table</replaceable></term>
    <listitem>
     <para>
      Le nom (parfois qualifié avec le nom du schéma) de la table à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable>nom_colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne dans une nouvelle table. Si les noms de colonnes ne
      sont pas fournis, ils sont pris des noms de colonnes en sortie de la
      requête. Si la table est créée à partir d'une commande
      <command>EXECUTE</command>, une liste de noms de colonnes peut ne pas
      être spécifiée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable>requête</replaceable></term>
    <listitem>
     <para>
      Une instruction de requête (c'est-à-dire une commande
      <command>SELECT</command> ou une commande <command>EXECUTE</command> qui
      exécute une commande <command>SELECT</command> préparée). Référez-vous
      à <xref linkend="sql-select" endterm="sql-select-title"> ou <xref
      linkend="sql-execute" endterm="sql-execute-title">, respectivement pour
      une description de la syntaxe autorisée.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Cette commande est équivalente fonctionnellement à <xref
   linkend="sql-selectinto" endterm="sql-selectinto-title"> mais il est préféré
   car il y a moins de risque de confusion avec les autres utilisations de la 
   syntaxe <command>SELECT ... INTO</command>.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Cette commande est modelée avec une fonctionnalité
   <productname>Oracle</productname>. Il n'existe pas de commande avec des
   fonctionnalités équivalents dans le standard SQL. Néanmoins, une combinaison
   de <literal>CREATE TABLE</literal> et <literal>INSERT ... SELECT</literal>
   peut accomplir la même chose avec un effort un peu plus important.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createtable" endterm="sql-createtable-title"></member>
   <member><xref linkend="sql-createview" endterm="sql-createview-title"></member>
   <member><xref linkend="sql-execute" endterm="sql-execute-title"></member>
   <member><xref linkend="sql-select" endterm="sql-select-title"></member>
   <member><xref linkend="sql-selectinto" endterm="sql-selectinto-title"></member>
  </simplelist>
 </refsect1>
 
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
