<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/declare.sgml,v 1.10 2005/07/15 06:14:32 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-DECLARE">
 <refmeta>
  <refentrytitle id="SQL-DECLARE-TITLE">DECLARE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>DECLARE</refname>
  <refpurpose>définit un curseur</refpurpose>
 </refnamediv>

 <indexterm zone="sql-declare">
  <primary>DECLARE</primary>
 </indexterm>

 <indexterm zone="sql-declare">
  <primary>curseur</primary>
  <secondary>DECLARE</secondary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
DECLARE <replaceable class="parameter">nom</replaceable> [ BINARY ] [
INSENSITIVE ] [ [ NO ] SCROLL ]
    CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable
class="parameter">requête</replaceable>
    [ FOR { READ ONLY | UPDATE [ OF <replaceable
class="parameter">colonnes</replaceable> [, ...] ] } ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>DECLARE</command> permet à un utilisateur de créer des curseurs
   qui peuvent être utilisés pour récupérer un petit nombre de lignes à la
   fois à partir d'une requête plus importante. Les curseurs peuvent renvoyer
   des données soit au format texte soit au format binaire en utilisant <xref
   linkend="sql-fetch" endterm="sql-fetch-title">.
  </para>

  <para>
   Les curseurs normaux renvoient des données au format texte, le même qu'un
   <command>SELECT</> produirait. Quand des données sont stockées nativement
   dans le format binaire, le système doit faire une conversion pour produire
   le format texte. Une fois que l'information revient au format texte,
   l'application cliente pourrait avoir besoin de la convertir en un format
   binaire pour la manipuler. De plus, des données au format texte sont souvent
   plus volumineuse qu'au format binaire. Les curseurs binaires renvoient
   les données dans une représentation binaire qui pourrait être plus facilement
   manipulée. Néanmoins, si vous avez l'intention d'afficher les données en
   texte, le récupérer au format texte vous épargne quelques efforts du côté
   client.
  </para>

  <para>
   Par exemple, si une requête renvoie une valeur de "un" à
   partir d'une colonne entier, vous obtenez une chaîne de
   <literal>1</> avec un curseur par défaut alors qu'avec un curseur binaire,
   vous obtenez un champ de quatre octets contenant la représentation
   interne de la valeur (dans l'ordre d'octets big-endian).
  </para>

  <para>
   Les curseurs binaires doivent être utilisés avec attention. Beaucoup
   d'applications, dont <application>psql</application>, ne sont pas
   préparées pour gérer des curseurs binaires et attendent leurs
   données au format texte.
  </para>

  <note>
   <para>
    Quand l'application cliente utilise le protocole de <quote>requête
    étendue</> pour lancer une commande <command>FETCH</>, le message du
    protocole Bind indique si la donnée doit être récupérée au format texte ou
    binaire. Ce choix surcharge la façon dont le curseur est défini. Le concept
    de curseur binaire en tant que tel est du coup obsolète lors de
    l'utilisation du protocole de requête étendue &mdash; tout curseur peut être
    traité soit en texte soit en binaire.
   </para>
  </note>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom du curseur à créer.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BINARY</literal></term>
    <listitem>
     <para>
      Fait que le curseur renvoie des données au format binaire plutôt qu'au
      format texte.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INSENSITIVE</literal></term>
    <listitem>
     <para>
      Indique que les données récupérées à partir du curseur ne doivent pas
      être affectées par les mises à jour des tables sous-jacente au curseur
      tant que celui-ci existe. Dans <productname>PostgreSQL</productname>, tous
      les curseurs sont insensibles&nbsp;; cet mot clé n'a actuellement aucun
      effet et est présent pour la compatibilité avec le standard SQL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SCROLL</literal></term>
    <term><literal>NO SCROLL</literal></term>
    <listitem>
     <para>
      <literal>SCROLL</literal> spécifie que le curseur peut être utilisé
      pour récupérer des lignes de façon non séquentielle (c'est-à-dire en
      arrière). Suivant la complexité du plan d'exécution de la requête,
      spécifier <literal>SCROLL</literal> pourrait induire des pertes de
      performance sur le temps d'exécution de la requête. <literal>NO
      SCROLL</literal> spécifie que le curseur ne peut pas être utilisé pour
      récupérer des lignes d'une façon non séquentielle.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH HOLD</literal></term>
    <term><literal>WITHOUT HOLD</literal></term>
    <listitem>
     <para>
      <literal>WITH HOLD</literal> spécifie que le curseur peut continuer à
      être utilisé après que la transaction qui l'a créé ait été validée avec
      succès. <literal>WITHOUT HOLD</literal> spécifie que le curseur ne peut
      être utilisé en dehors de la transaction qui l'a créé. Si ni
      <literal>WITHOUT HOLD</literal> ni <literal>WITH HOLD</literal> n'est
      spécifié, <literal>WITHOUT HOLD</literal> est la valeur par défaut.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">requête</replaceable></term>
    <listitem>
     <para>
      Une commande <command>SELECT</> qui fournit les lignes à renvoyer par 
      le curseur. Référez-vous à <xref linkend="sql-select"
      endterm="sql-select-title"> pour plus d'informations sur les requêtes
      valides.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FOR READ ONLY</literal></term>
    <term><literal>FOR UPDATE</literal></term>
    <listitem>
     <para>
      <literal>FOR READ ONLY</literal> indique que le curseur sera utilisé en
      mode lecture seule. <literal>FOR UPDATE</literal> indique que le curseur
      sera utilisé pour mettre à jour des tables. Comme les mises à jour de
      curseur ne sont pas supportées actuellement dans
      <productname>PostgreSQL</productname>, spécifier <literal>FOR
      UPDATE</literal> cause un message d'erreur et spécifier <literal>FOR
      READ ONLY</literal> n'a pas d'effet.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">colonnes</replaceable></term>
    <listitem>
     <para>
      Colonne(s) à mettre à jour par le curseur. Comme les mises à jour de
      curseur ne sont actuellement pas supportées dans
      <productname>PostgreSQL</productname>, la clause <literal>FOR
      UPDATE</literal> provoque un message d'erreur.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les mots clés <literal>BINARY</literal>, <literal>INSENSITIVE</literal> et
   <literal>SCROLL</literal> peuvent apparaître dans n'importe quel ordre.
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    Sauf si <literal>WITH HOLD</literal> est spécifié, le curseur créé par
    cette commande peut seulement être utilisée à l'intérieur d'une transaction.
    Du coup, <command>DECLARE</> sans <literal>WITH HOLD</literal> est inutile à
    l'extérieur d'un bloc de transaction&nbsp;: le curseur survivrait seulement
    jusqu'à la fin de l'instruction. Du coup,
    <productname>PostgreSQL</productname> rapporte une erreur si cette commande 
    est utilisée en dehors d'un bloc de transaction. Utilisez <xref
    linkend="sql-begin" endterm="sql-begin-title">, <xref linkend="sql-commit"
    endterm="sql-commit-title"> et <xref linkend="sql-rollback"
    endterm="sql-rollback-title"> pour définir un bloc de transaction.
   </para>

   <para>
    Si <literal>WITH HOLD</literal> est spécifié et que la transaction créant
    le curseur valide avec succès, le curseur peut continuer à être accédé par les
    transactions suivantes de la même session. (Mais si la transaction l'ayant
    créé est annulée, le curseur est supprimé.) Un curseur créé avec
    <literal>WITH HOLD</literal> est fermé quand une commande
    <command>CLOSE</command> explicite est lancée sur lui ou quand la session se
    termine. Dans l'implémentation actuelle, les lignes représentées par un
    curseur <literal>WITH HOLD</literal> sont copiées dans un fichier 
    temporaire ou dans une partie de
    la mémoire pour qu'elles restent disponibles pour les transactions
    suivantes.
   </para>

   <para>
    L'option <literal>SCROLL</> doit normalement être spécifiée lors de 
    la création d'un
    curseur qui sera utilisé avec des récupérations inverses. Ceci est requis
    par le standard SQL. Néanmoins, pour la compatibilité avec les anciennes
    versions, <productname>PostgreSQL</productname> autorise les récupérations
    en arrière sans <literal>SCROLL</>, si le plan de requête du curseur est
    assez simple pour qu'aucune surcharge ne soit nécessaire pour le supporter.
    Néanmoins, les développeurs d'applications ne doivent compter sur
    l'utilisation de la recherche en arrière à partir de curseurs qui n'ont pas
    été créés avec <literal>SCROLL</literal>. Si <literal>NO SCROLL</> est
    spécifié, alors les recherches inverses sont interdites dans tous les cas.
   </para>

   <para>
    Le standard SQL ne mentionne les curseurs que dans le
    <acronym>SQL</acronym> embarqué. Le serveur
    <productname>PostgreSQL</productname> n'implémente pas l'instruction
    <command>OPEN</command> pour les curseurs&nbsp;; un curseur est considéré
    ouvert à sa déclaration. Néanmoins, <application>ECPG</application>, le
    préprocesseur SQL embarqué de <productname>PostgreSQL</productname>,
    supporte les conventions des curseurs du SQL standard, dont celles
    utilisant les instructions <command>DECLARE</command> et
    <command>OPEN</command>.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Pour déclarer un curseur&nbsp;:
<programlisting>
DECLARE liahona CURSOR FOR SELECT * FROM films;
</programlisting>
   Voir <xref linkend="sql-fetch" endterm="sql-fetch-title"> pour plus
   d'exemples sur l'utilisation des curseurs.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Le standard SQL autorise les curseurs uniquement dans le
   <acronym>SQL</acronym> embarqué et dans des modules.
   <productname>PostgreSQL</> permet aux curseurs d'être utilisés
   interactivement.
  </para>

  <para>
   Le standard SQL autorise les curseurs à mettre à jour les données d'une
   table. Tous les curseurs <productname>PostgreSQL</> sont en lecture seule.
  </para>

  <para>
   Les curseurs binaires sont une extension
   <productname>PostgreSQL</productname>.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-close" endterm="sql-close-title"></member>
   <member><xref linkend="sql-fetch" endterm="sql-fetch-title"></member>
   <member><xref linkend="sql-move" endterm="sql-move-title"></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
