<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/explain.sgml,v 1.10 2005/06/20 20:52:03 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-EXPLAIN">
 <refmeta>
  <refentrytitle id="SQL-EXPLAIN-TITLE">EXPLAIN</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>EXPLAIN</refname>
  <refpurpose>affiche le plan d'exécution d'une instruction</refpurpose>
 </refnamediv>

 <indexterm zone="sql-explain">
  <primary>EXPLAIN</primary>
 </indexterm>

 <indexterm zone="sql-explain">
  <primary>instructions préparées</primary>
  <secondary>afficher le plan de requête</secondary>
 </indexterm>

 <indexterm zone="sql-explain">
  <primary>curseur</primary>
  <secondary>afficher le plan de requête</secondary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
EXPLAIN [ ANALYZE ] [ VERBOSE ] <replaceable
class="parameter">instruction</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   Cette commande affiche le plan d'exécution que l'optimiseur
   <productname>PostgreSQL</productname> génère pour l'instruction fournie. Le
   plan d'exécution affiche comment la (les) table(s) référencée(s) par
   l'instruction seront parcourue(s) &mdash; parcours séquentiel, parcours
   d'index, etc. &mdash; et si plusieurs tables sont référencées, quels
   algorithmes de jointure seront utilisés pour amener les lignes requises à
   partir de chaque table en entrée.
  </para>

  <para>
   La partie la plus critique de l'affichage est le coût d'exécution estimé de
   l'instruction, qui est l'impression que l'optimiseur a sur la durée que
   prendra l'exécution de l'instruction (mesuré en unité de récupération de
   pages disque). En fait, deux nombres sont affichés&nbsp;: le temps 
   d'exécution avant que la première ligne ne soit renvoyée et le temps total pour
   renvoyer toutes les lignes. Pour la plupart des requêtes, le temps total est
   ce qui importe mais dans des contextes tels qu'une sous-requête dans
   <literal>EXISTS</literal>, l'optimiseur choisit le plus petit temps de
   lancement plutôt que le plus petit temps total (car, de toute façon,
   l'exécuteur s'arrête après avoir récupéré une ligne). De même, si vous
   limitez le nombre de lignes à renvoyer avec une clause
   <literal>LIMIT</literal>, l'optimiseur fait une interpolation appropriée
   pour estimer le plan le moins cher.
  </para>

  <para>
   L'option <literal>ANALYZE</literal> fait que l'instruction est réellement 
   exécutée, pas uniquement planifiée. Le temps total passé sur chaque
   n&oelig;ud du plan (en millisecondes) et le nombre total de lignes renvoyées
   sont ajoutés à l'affichage. Ceci est utile pour voir si les estimations du
   planificateur sont proches de la réalité.
  </para>

  <important>
   <para>
    Gardez en tête que l'instruction est réellement exécutée quand
    <literal>ANALYZE</literal> est utilisé. Bien que <command>EXPLAIN</command>
    annule tout affichage qu'un <command>SELECT</command> renverrait, les
    autres effets immédiats de l'instruction ont lieu. Si vous souhaitez
    utiliser <command>EXPLAIN ANALYZE</command> sur une instruction
    <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command> ou <command>EXECUTE</command> sans que la commande
    n'affecte vos données, utilisez cette approche&nbsp;:
<programlisting>
BEGIN;
EXPLAIN ANALYZE ...;
ROLLBACK;
</programlisting>
   </para>
  </important>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><literal>ANALYZE</literal></term>
    <listitem>
     <para>
      Exécute la commande et affiche les temps d'exécution réels.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VERBOSE</literal></term>
    <listitem>
     <para>
      Affiche la représentation interne complète du plan plutôt qu'un simple
      résumé. Utiliser cette option est seulement utile pour un débogage. 
      Le formatage
      de la sortie de <literal>VERBOSE</literal> peut être modifié avec le
      paramètre de configuration <xref
      linkend="guc-explain-pretty-print">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">instruction</replaceable></term>
    <listitem>
     <para>
      Toute instruction <command>SELECT</>, <command>INSERT</>,
      <command>UPDATE</>, <command>DELETE</>, <command>EXECUTE</> ou
      <command>DECLARE</> dont vous souhaitez voir le plan d'exécution.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   La documentation sur l'utilisation que l'optimiseur fait des informations de coût
   est assez limitée dans <productname>PostgreSQL</productname>. Référez-vous
   à <xref linkend="using-explain"> pour plus d'informations.
  </para>

  <para>
   Pour permettre au planificateur de requêtes de
   <productname>PostgreSQL</productname> de prendre des décisions
   raisonnables lors de l'optimisation de requêtes, l'instruction
   <command>ANALYZE</command> doit être exécutée pour enregistrer les
   statistiques sur la distribution des données à l'intérieur de la table. Si
   vous n'avez pas fait ceci (ou si la distribution statistique des données dans
   la table a changé significativement depuis la dernière exécution
   d'<command>ANALYZE</command>), les coûts estimés ne sont pas conformes aux
   réelles propriétés de la requête et, par conséquence, un plan de requête
   médiocre pourrait être choisi.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 7.3, le plan était émis sous la
   forme d'un message <literal>NOTICE</literal>. Maintenant, il apparaît comme
   le résultat d'une requête (formaté comme une table composée d'une seule
   colonne de type texte).
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Pour afficher le plan d'une simple requête sur une table avec une seule
   colonne de type <type>integer</type> et 10000 lignes&nbsp;:

<programlisting>
EXPLAIN SELECT * FROM foo;

                       QUERY PLAN
---------------------------------------------------------
 Seq Scan on foo  (cost=0.00..155.00 rows=10000 width=4)
(1 row)
</programlisting>
  </para>

  <para>
   S'il existe un index et que nous utilisons une requête avec un condition
   <literal>WHERE</literal> indexable, <command>EXPLAIN</command> pourrait
   afficher un plan différent&nbsp;:

<programlisting>
EXPLAIN SELECT * FROM foo WHERE i = 4;

                         QUERY PLAN
--------------------------------------------------------------
 Index Scan using fi on foo  (cost=0.00..5.98 rows=1 width=4)
   Index Cond: (i = 4)
(2 rows)
</programlisting>
  </para>

  <para>
   Et voici un exemple d'un plan de requête pour une requête utilisant une
   fonction d'agrégat&nbsp;:

<programlisting>
EXPLAIN SELECT sum(i) FROM foo WHERE i &lt; 10;

                             QUERY PLAN
---------------------------------------------------------------------
 Aggregate  (cost=23.93..23.93 rows=1 width=4)
   -&gt;  Index Scan using fi on foo  (cost=0.00..23.92 rows=6 width=4)
         Index Cond: (i &lt; 10)
(3 rows)
</programlisting>
  </para>

  <para>
   Voici un exemple d'utilisation de <command>EXPLAIN EXECUTE</command> pour
   afficher le plan d'exécution d'une requête préparée&nbsp;:

<programlisting>
PREPARE query(int, int) AS SELECT sum(bar) FROM test
    WHERE id &gt; $1 AND id &lt; $2
    GROUP BY foo;

EXPLAIN ANALYZE EXECUTE query(100, 200);

                                                       QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=39.53..39.53 rows=1 width=8) (actual time=0.661..0.672 rows=7 loops=1)
   -&gt;  Index Scan using test_pkey on test  (cost=0.00..32.97 rows=1311 width=8) (actual time=0.050..0.395 rows=99 loops=1)
         Index Cond: ((id &gt; $1) AND (id &lt; $2))
 Total runtime: 0.851 ms
(4 rows)
</programlisting>
  </para>

  <para>
   Bien sûr, les nombres réellement affichés dépendent du contenu réel des tables
   impliquées. Notez aussi que les nombres, et même la stratégie de la requête
   sélectionnée, pourrait varier entre les versions de
   <productname>PostgreSQL</productname> à cause des améliorations du
   planificateur. De plus, la commande <command>ANALYZE</command> utilise une
   distribution aléatoire pour estimer les statistiques des données&nbsp;; du
   coup, il est possible que les estimations de coût changent après un lancement
   d'<command>ANALYZE</command>, même si la distribution réelle des données n'a
   pas changé dans la table.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas d'instruction <command>EXPLAIN</command> définie dans le
   standard SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-analyze" endterm="sql-analyze-title"></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
