<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/lock.sgml,v 1.7.2.1 2005/03/14 06:03:03 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-LOCK">
 <refmeta>
  <refentrytitle id="sql-lock-title">LOCK</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>LOCK</refname>
  <refpurpose>verrouille une table</refpurpose>
 </refnamediv>

 <indexterm zone="sql-lock">
  <primary>LOCK</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
LOCK [ TABLE ] <replaceable class="PARAMETER">nom</replaceable> [, ...] [ IN
<replaceable class="PARAMETER">mode_verrou</replaceable> MODE ]

où <replaceable class="PARAMETER">mode_verrou</replaceable> fait partie
de&nbsp;:

    ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE
    | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>LOCK TABLE</command> obtient un verrou de niveau table, attendant si
   nécessaire que tous les verrous en conflit soient lâchés. Une fois obtenu, le
   verrou est contenu jusqu'à la fin de la transaction en cours. (Il n'y a pas
   de commande <command>UNLOCK TABLE</command>&nbsp;; les verrous sont toujours
   abandonnés à la fin de la transaction.)
  </para>

  <para>
   Lors de l'acquisition automatique de verrous pour les commandes qui
   référencent des tables, <productname>PostgreSQL</productname> utilise
   toujours le mode de verrou le moins restrictif possible. <command>LOCK
   TABLE</command> est fourni pour les cas où vous pourriez avoir besoin de
   verrous plus restrictifs. Par exemple, supposez qu'une application exécute
   une transaction au niveau d'isolation de lecture validé pour s'assurer que
   les données de la table restent stables pendant la durée de la transaction.
   Pour réaliser ceci, vous pouvez obtenir un mode de verrou <literal>SHARE</>
   sur la table avant d'envoyer la requête. Ceci empêchera toute modification
   concurrente des données et assurera que les lectures de la table voient une
   vue stable des données validées parce que le mode de verrou <literal>SHARE</>
   est en conflit avec le verrou <literal>ROW EXCLUSIVE</> acquis par les
   modificateurs et votre instruction <command>LOCK TABLE <replaceable
   class="PARAMETER">nom</replaceable> IN SHARE MODE</command> attendra jusqu'à
   ce que tous déteneurs concurrents de verrous en mode <literal>ROW
   EXCLUSIVE</literal> valident ou annulent. Du coup, une fois le verrou obtenu,
   il ne reste aucune écriture en attente&nbsp;; de plus, aucune ne peut
   commencer tant que vous n'avez pas supprimé le verrou.
  </para>

  <para>
   Pour obtenir un effet similaire lors de l'exécution d'une transaction au
   niveau d'isolation sérialisable, vous devez exécuter l'instruction
   <command>LOCK TABLE</> avant d'exécuter toute instruction de modification de
   données. La vue des données par une transaction sérialisable des données sera
   gelée à la première instruction de modification des données. Un <command>LOCK
   TABLE</> plus tard empêchera toujours les écritures concurrentes --- mais il
   n'assurera pas que ce que la transaction lit correspond aux dernières
   données validées.
  </para>
  
  <para>
   Si une transaction de cette sorte va modifier les données de la table, alors
   elle devrait utiliser le mode de verrou <literal>SHARE ROW EXCLUSIVE</> au
   lieu du mode <literal>SHARE</>. Ceci nous assure que seule une transaction de
   ce type est en exécution à la fois. Sans cela, un verrou mortel est
   possible&nbsp;: deux transactions pourraient acquérir à la fois le mode
   <literal>SHARE</> et être ensuite incapable d'acquérir aussi le mode
   <literal>ROW EXCLUSIVE</> pour réellement effectuer leur mises à jour. (Notez
   que les propres verrous d'une transaction ne sont jamais en conflit, donc une
   transaction peut acquérir le mode <literal>ROW EXCLUSIVE</> lorsqu'il tient
   le mode <literal>SHARE</> --- mais pas si quelqu'un d'autre détient le mode
   <literal>SHARE</>.) Pour éviter les verrous bloquants, assurez-vous que
   toutes les transactions acquièrent des verrous sur les mêmes objets dans le
   même ordre, et si des modes multiples de verrous sont impliqués pour un seul
   objet, alors les transactions devraient toujours acquérir en premier le mode
   le plus restrictif.
  </para>

  <para>
   Plus d'informations sur les modes de verrou et les stratégies de verrouillage
   sont disponibles dans <xref linkend="explicit-locking">.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="PARAMETER">nom</replaceable></term>
    <listitem>
     <para>
      Le nom d'une table existante à verrouiller (pouvant être qualifié du nom
      du schéma).
     </para>

     <para>
      La commande <literal>LOCK a, b;</> est équivalente à <literal>LOCK a; LOCK
      b;</>. Les tables sont verrouillées une par une dans l'ordre spécifié dans
      la commande <command>LOCK</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">modeverrou</replaceable></term>
    <listitem>
     <para>
      Le mode verrou spécifie avec quels verrous ce verrou entre en conflit.
      Les modes de verrous sont décrits dans <xref linkend="explicit-locking">.
     </para>

     <para>
      Si aucun mode de verrou n'est spécifié, alors <literal>ACCESS
      EXCLUSIVE</literal>, le mode le plus restrictif, est utilisé.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

   <para>
    <literal>LOCK ... IN ACCESS SHARE MODE</> requiert les droits
    <literal>SELECT</> sur la table cible. Tous les autres formats de
    <command>LOCK</> requièrent les droits <literal>UPDATE</> et/ou
    <literal>DELETE</>.
   </para>

   <para>
    <command>LOCK</command> est utile seulement dans un bloc de transaction
    (pair <command>BEGIN</>/<command>COMMIT</>), car le verrou est supprimé
    aussitôt que la transaction se termine. Une commande <command>LOCK</>
    apparaissant à l'extérieur de tout bloc de transaction forme une transaction
    contenue dans elle-même, donc le verrou sera supprimé dès qu'il sera obtenu.
   </para>

  <para>
   <command>LOCK TABLE</> s'occupe seulement des verrous au niveau table et du
   coup, les noms de mode impliquant <literal>ROW</> sont tous mal nommés. Ces
   noms de mode devraient généralement être lus comme indiquant l'intention de
   l'utilisateur à acquérir des verrous de niveau ligne à l'intérieur de la
   table verrouillée. De plus, le mode <literal>ROW EXCLUSIVE</> est un verrou
   de table partageable. Gardez en tête que tous les modes de verrou ont des
   sémantiques identiques tant que <command>LOCK TABLE</> est concerné,
   différant seulement dans les règles où les modes entrent en conflit.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Exemples</title>

  <para>
   Obtenir un verrou <literal>SHARE</> sur une table avec clé primaire avant
   de réaliser des insertions dans une table disposant de la clé
   étrangère&nbsp;:

<programlisting>
BEGIN WORK;
LOCK TABLE films IN SHARE MODE;
SELECT id FROM films 
    WHERE nom = 'Star Wars: Episode I - The Phantom Menace';
-- Effectuer un ROLLBACK si aucun enregistrement n'est retourné
INSERT INTO commentaires_films VALUES 
    (_id_, 'SUPER ! Je l''attendais depuis si longtemps !');
COMMIT WORK;
</programlisting>
  </para>

  <para>
   Prendre un verrou <literal>SHARE ROW EXCLUSIVE</> sur une table avec clé
   primaire lors du début des opérations de suppression&nbsp;:

<programlisting>
BEGIN WORK;
LOCK TABLE films IN SHARE ROW EXCLUSIVE MODE;
DELETE FROM commentaires_films WHERE id IN
    (SELECT id FROM films WHERE score < 5);
DELETE FROM films WHERE score < 5;
COMMIT WORK;
</programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>
	  
  <para>
   <command>LOCK TABLE</command> n'existe pas dans le standard SQL, qui utilise
   à la place <command>SET TRANSACTION</command> pour spécifier des niveaux
   de concurrence sur les transactions. <productname>PostgreSQL</productname> a
   aussi cela&nbsp;; voir <xref linkend="SQL-SET-TRANSACTION"
   endterm="SQL-SET-TRANSACTION-TITLE"> pour les détails.
  </para>

  <para>
   Sauf pour les modes de verrous <literal>ACCESS SHARE</>, <literal>ACCESS
   EXCLUSIVE</> et <literal>SHARE UPDATE EXCLUSIVE</>, les modes de verrou
   <productname>PostgreSQL</productname> et la syntaxe
   <command>LOCK TABLE</command> sont compatibles avec ceux présents dans
   <productname>Oracle</productname>.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
