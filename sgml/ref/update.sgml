<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/update.sgml,v 1.9 2005/04/22 06:38:58 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-UPDATE">
 <refmeta>
  <refentrytitle id="SQL-UPDATE-TITLE">UPDATE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>UPDATE</refname>
  <refpurpose>met à jour les lignes d'une table</refpurpose>
 </refnamediv>

 <indexterm zone="sql-update">
  <primary>UPDATE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
UPDATE [ ONLY ] <replaceable class="PARAMETER">table</replaceable> SET
<replaceable class="PARAMETER">colonne</replaceable> = { <replaceable
class="PARAMETER">expression</replaceable> | DEFAULT } [, ...]
    [ FROM <replaceable class="PARAMETER">liste_from</replaceable> ]
    [ WHERE <replaceable class="PARAMETER">condition</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>UPDATE</command> modifie les valeurs des colonnes spécifiées pour
   toutes les lignes qui satisfont la condition. Seules les colonnes à
   modifier doivent être mentionnées dans la clause
   <literal>SET</literal>&nbsp;; Les autres colonnes conservent leur
   précédente valeur.
  </para>

  <para>
   Par défaut, <command>UPDATE</command> met à jour les lignes de la table
   spécifiée et toutes ses sous-tables. Si vous souhaitez ne mettre à jour que
   la table spécifique mentionnée, vous pouvez utiliser la clause
   <literal>ONLY</>.
  </para>

  <para>
   Il existe deux façons de modifier une table en utilisant les informations
   contenues dans d'autres tables de la base de données&nbsp;: en utilisant des
   sous-requêtes ou en spécifiant des tables supplémentaires dans la clause
   <literal>FROM</literal>. La technique la plus appropriée dépend des
   circonstances spécifiques.
  </para>

  <para>
   Vous devez avoir le droit <literal>UPDATE</literal> sur la table pour
   la mettre à jour, ainsi que le droit <literal>SELECT</literal> sur toutes les
   tables dont les valeurs sont lues dans <replaceable
   class="parameter">expression</replaceable> ou 
   <replaceable class="parameter">condition</replaceable>.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="PARAMETER">table</replaceable></term>
    <listitem>
     <para>
      Le nom de la table à mettre à jour (pouvant être qualifié du nom du
      schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">colonne</replaceable></term>
    <listitem>
     <para>
      Le nom d'une colonne dans <replaceable
      class="PARAMETER">table</replaceable>.
      Le nom de la colonne peut être qualifié avec un nom de sous-champ ou un
      indice de tableau si nécessaire.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">expression</replaceable></term>
    <listitem>
     <para>
      Une expression à affecter à la colonne. L'expression peut utiliser
      les anciennes valeurs de cette colonne ou d'autres colonnes de la table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT</literal></term>
    <listitem>
     <para>
      Initialise sa colonne à la valeur par défaut (qui vaut NULL si aucune
      expression spécifique par défaut ne lui a été affectée).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">liste_from</replaceable></term>
    <listitem>
     <para>
      Une liste d'expressions de tables, permettant aux colonnes des autres
      tables d'apparaître dans la condition <literal>WHERE</> et les
      expressions de mise à jour. Ceci est similaire à la liste de tables
      pouvant être spécifiée dans <xref linkend="sql-from"
      endterm="sql-from-title"> d'une instruction <command>SELECT</command>.
      Notez que la table cible ne doit pas apparaître dans
      <replaceable>liste_from</>, sauf si vous comptez faire une auto-jointure
      (auquel cas elle doit apparaître avec un alias dans
      <replaceable>liste_from</>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">condition</replaceable></term>
    <listitem>
     <para>
      Une expression qui renvoie une valeur de type <type>boolean</type>.
      Seules les lignes pour lesquelles cette expression renvoie
      <literal>true</> sont mises à jour.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Sorties</title>

  <para>
   En cas de succès, une commande <command>UPDATE</> renvoie un message
   de la forme
<screen>
UPDATE <replaceable class="parameter">total</replaceable>
</screen>
   Le <replaceable class="parameter">total</replaceable> est le nombre de
   lignes mises à jour. Si <replaceable class="parameter">total</replaceable>
   vaut 0, aucune ligne ne correspond à <replaceable
   class="parameter">condition</replaceable> (ceci n'est pas considéré comme une
   erreur).
  </para>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   Quand une clause <literal>FROM</> est présente, la table cible est jointe
   aux tables mentionnées dans <replaceable>liste_from</replaceable>, et chaque
   ligne en sortie de la jointure représente une opération de mise à jour pour
   la table cible. Lors de l'utilisation de <literal>FROM</>, vous devriez vous
   assurer que la jointure produit au moins une ligne en sortie pour chaque
   ligne à modifier. En d'autres termes, une ligne cible ne doit pas être
   jointe plus d'une fois à une ligne d'une autre table. Si c'est le cas, alors
   seulement une des lignes de jointures est utilisée pour mettre à jour la
   ligne cible mais celle qui est utilisée n'est pas prévisible.
  </para>

  <para>
   À cause de ce manque de déterminisme, il est plus sûr de ne référencer 
   d'autres tables qu'à l'intérieur de sous-requêtes, même si c'est plus 
   difficile à lire et plus lent que l'utilisation d'une jointure.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Modifie le mot <literal>Drame</> en <literal>Dramatique</> dans la colonne
   <structfield>genre</> de la table <structname>films</structname>&nbsp;:

<programlisting>
UPDATE films SET genre = 'Dramatique' WHERE genre = 'Drame';
</programlisting>
  </para>

  <para>
   Ajuste les entrées de température et réinitialise la précipitation à sa
   valeur par défaut dans une ligne de la table
   <structname>temps</structname>&nbsp;:

<programlisting>
UPDATE temps SET temp_basse = temp_basse+1, temp_haute = temp_basse+15, prcp =
DEFAULT
  WHERE ville = 'San Francisco' AND date = '2003-07-03';
</programlisting>
  </para>

  <para>
   Incrémente le total des ventes de la personne qui gère le compte d'Acme
   Corporation, en utilisant la syntaxe de la clause du
   <literal>FROM</literal>&nbsp;:
<programlisting>
UPDATE employes SET total_ventes = total_ventes + 1 FROM comptes
  WHERE compte.nom = 'Acme Corporation'
  AND employes.id = compte.vendeur;
</programlisting>

   Réalise la même opération en utilisant une sous-requête dans la clause
   <literal>WHERE</literal>&nbsp;:
<programlisting>
UPDATE employes SET total_ventes = total_ventes + 1 WHERE id =
  (SELECT vendeur FROM comptes WHERE nom = 'Acme Corporation');
</programlisting>

   Tente d'insérer un nouvel élément dans le stock avec la quantité. Si
   l'élément existe déjà, à la place, met à jour le total du stock de l'élément
   existant. Pour faire cela sans échec dans la transaction entière, utilise les
   points de sauvegarde.
   <programlisting>
BEGIN;
-- autres opérations
SAVEPOINT sp1;
INSERT INTO vins VALUES('Chateau Lafite 2003', '24');
-- Suppose que l'instruction ci-dessus échoue à cause d'une violation de clé
-- unique, donc nous lançons maintenant ces commandes:
ROLLBACK TO sp1;
UPDATE vins SET stock = stock + 24 WHERE nomvin = 'Chateau Lafite 2003';
-- continue avec les autres opérations, et enfin
COMMIT;
 </programlisting>
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Cette commande est conforme au standard <acronym>SQL</acronym>, à
   l'exception de la clause <literal>FROM</literal> qui est une extension
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   D'autres systèmes de bases de données offrent une option
   <literal>FROM</> dans laquelle la table cible est supposée être de nouveau
   indiquée dans le <literal>FROM</>. Ce n'est pas ainsi que
   <productname>PostgreSQL</productname> interprète <literal>FROM</>. Faites
   attention pour le portage d'applications utilisant cette extension.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
