<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/regress.sgml,v 1.4.2.4 2005/09/13 20:13:13 guillaume Exp $ -->

 <chapter id="regress">
  <title id="regress-title">Tests de régression</title>

  <indexterm zone="regress">
   <primary>tests de régression</primary>
  </indexterm>

  <indexterm zone="regress">
   <primary>test</primary>
  </indexterm>

  <para>
   Les tests de régression sont un ensemble complet de tests pour
   l'implémentation SQL dans <productname>PostgreSQL</productname>. Ils testent
   les opérations SQL standards ainsi que les fonctionnalités étendues de
   <productname>PostgreSQL</productname>. À partir de la version 6.1 de
   <productname>PostgreSQL</productname>, les tests de régressions sont mis à
   jour pour chaque sortie officielle.
  </para>

  <sect1 id="regress-run">
   <title>Lancer les tests</title>

  <para>
   Les tests de régression peuvent être lancés sur un serveur déjà installé et
   fonctionnel ou en utilisant une installation temporaire à l'intérieur du
   répertoire de construction. De plus, il existe un mode
   <quote>parallèle</quote> et un mode <quote>séquentiel</quote> pour lancer les
   tests. La méthode séquentielle lance chaque script de test à son tour, alors
   que la méthode parallèle lance plusieurs processus serveurs pour exécuter des
   groupes de tests en parallèle. Les tests parallèles donnent une certaine
   indication sur le bon fonctionnement des communications interprocessus et du
   verrouillage. Pour des raisons historiques, les tests séquentiels sont lancé
   habituellement avec une installation existante alors que la méthode parallèle
   utilise plutôt une installation temporaire mais il n'y a aucune raison
   technique à cela.
  </para>

  <para>
   Pour lancer les tests de régression après avoir lancé la construction mais
   avant l'installation, saisissez
<screen>
gmake check
</screen>
   dans le répertoire de niveau haut. (Ou vous pouvez changer le répertoire par
   <filename>src/test/regress</filename> et y lancer la commande.) Ceci
   commencera par construire plusieurs fichiers auxiliaires, tels que quelques
   exemples de fonctions déclencheurs définies par l'utilisateur, puis lancera
   le script de pilotage des tests. À la fin, vous devriez voir quelque chose
   comme
<screen>
<computeroutput>
======================
 All 93 tests passed.
======================
</computeroutput>
</screen>
   ou une note indiquant l'échec des tests.  Voir <xref
   linkend="regress-evaluation"> ci-dessous pour plus d'informations.
  </para>

   <para>
    Comme cette méthode de tests fonctionne sur un serveur temporaire, elle 
    ne fonctionnera pas en tant qu'utilisateur root (car le serveur refusera de
    se lancer en tant qu'utilisateur root) Si vous avez lancé la construction en
    tant que root, vous n'avez pas besoin de tout recommencer. À la place,
    rendez le répertoire des tests de régression modifiable par un autre
    utilisateur, devenez cet utilisateur et relancez les tests. Par exemple
<screen>
<prompt>root# </prompt><userinput>chmod -R a+w src/test/regress</userinput>
<prompt>root# </prompt><userinput>chmod -R a+w contrib/spi</userinput>
<prompt>root# </prompt><userinput>su - joeuser</userinput>
<prompt>joeuser$ </prompt><userinput>cd <replaceable>répertoire
construction haut niveau</></userinput>
<prompt>joeuser$ </prompt><userinput>gmake check</userinput>
</screen>
    (Le seul <quote>risque de sécurité</quote> possible ici est que les
    autres utilisateurs pourraient modifier les résultats des tests de
    régression dans votre dos. Utilisez le bon sens pour gérer les droits des
    utilisateurs.)
   </para>
   <para>
    Autrement, lancez les tests après l'installation.
   </para>

   <para>
    Les tests de régression en parallèle lancent quelques processus avec
    votre utilisateur. Actuellement, le nombre maximum est de vingt scripts de
    tests en parallèle, ce qui signifie 60 processus&nbsp;: il existe un
    processus serveur, un <application>psql</> et habituellement un processus
    parent pour le <application>psql</> de chaque script de tests. Si votre
    système force une limite par utilisateur sur le nombre de processus,
    assurez-vous que cette limite est d'au moins 65, sinon vous pourriez obtenir
    des échecs hasardeux dans les tests en parallèle. Si vous ne pouvez pas
    augmenter cette limite, vous pouvez diminuer le degré de parallélisme en
    initialisant le paramètre <literal>MAX_CONNECTIONS</> parameter. Par
exemple,
<screen>
gmake MAX_CONNECTIONS=10 check
</screen>
    ne lance pas plus de dix tests en même temps.
   </para>

   <para>
    Sur certains systèmes, le shell par défaut compatible Bourne
    (<filename>/bin/sh</filename>) a du mal à gérer autant de processus fils
    en parallèle. Cela pourrait causer des blocages ou des échecs dans les
    tests en parallèle. Dans de tels cas, spécifiez un shell compatible Bourne
    différent sur la liste de commande, par exemple&nbsp;:
<screen>
gmake SHELL=/bin/ksh check
</screen>
    Si aucun shell ne le permet, vous pouvez contourner le problème en diminuant
    le nombre de connexions comme indiqué ci-dessus.
   </para>

  <para>
   Pour lancer les tests après l'installation<![%standalone-ignore;[ (voir <xref
   linkend="installation">)]]>, initialisez un espace de données et lancez le
   serveur <![%standalone-ignore;[comme expliqué dans <xref
   linkend="runtime">,]]> puis lancez
<screen>
gmake installcheck
</screen>
   Les tests s'attendront à contacter le serveur sur l'hôte local et avec le
   numéro de port par défaut, sauf en cas d'indication contraire avec les
   variables d'environnement <envar>PGHOST</envar> et <envar>PGPORT</envar>.
  </para>
  </sect1>

  <sect1 id="regress-evaluation">
   <title>Évaluation des tests</title> 

   <para>
    Quelques installations de <productname>PostgreSQL</productname>
    proprement installées et totalement fonctionnelles peuvent
    <quote>échouer</quote> sur certains des tests de régression à cause de
    certains points spécifiques à la plateforme comme une représentation de
    nombres à virgules flottantes ou un support des fuseaux horaires. Les tests
    sont actuellement évalués en utilisant une simple comparaison
    <command>diff</command> avec les sorties générées sur un système de
    référence, donc les résultats sont sensibles aux petites différences
    système. Quand un test est rapporté comme <quote>échoué</quote>, toujours
    examiner les différences entre les résultats attendus et obtenus&nbsp;; vous
    pourriez très bien trouver que les différences ne sont pas significatives.
    Néanmoins, nous nous battons toujours pour maintenir des fichiers de
    références précis et à jour pour toutes les plateformes supportés de façon à
    ce que tous les tests puissent réussir.
   </para>

   <para>
    Les sorties actuelles des tests de régression sont dans les fichiers du
    répertoire <filename>src/test/regress/results</filename>. Le script de test
    utilise <command>diff</command> pour comparer chaque fichier de sortie avec
    les sorties de référence stockées dans le répertoire
    <filename>src/test/regress/expected</filename>. Toutes les différences sont
    conservées pour que vous puissiez les regarder dans
    <filename>src/test/regress/regression.diffs</filename>. (Ou vous pouvez
    lancer <command>diff</command> vous-même, si vous préférez.)
   </para>

   <sect2>
    <title>Différences dans les messages d'erreurs</title>
      
    <para>
     Certains des tests de régression impliquent des valeurs en
     entrée intentionnellement invalides. Les messages d'erreur peuvent
     provenir soit du code de <productname>PostgreSQL</productname> soit des
     routines système de la plateforme hôte. Dans ce dernier cas, les messages
     pourraient varier entre plateformes mais devraient toujours refléter des
     informations similaires. Ces différences dans les messages résulteront dans
     un test de régression <quote>échoué</quote> qui pourrait être validé après
     vérification.
    </para>
   </sect2>
    
   <sect2>
    <title>Différences au niveau des locales</title>

    <para>
     Si vous lancez des tests sur un serveur déjà installé mais initialisé avec
     une locale autre que C, alors il pourrait y avoir des différences dans les
     ordres de tris. La suite de tests de régression est initialisée pour gérer
     ce problème en fournissant des fichiers de résultats alternatifs qui
     ensemble gèrent un grand nombre de locales. Par exemple, pour le test
     <literal>char</literal>, le fichier <filename>char.out</filename> attendu
     gère les locales <literal>C</> et <literal>POSIX</>, et le fichier
     <filename>char_1.out</filename> gère beaucoup d'autres locales. Le pilote
     des tests de régression choisira automatiquement le meilleur fichier lors
     de la vérification et pour la calcul des différences d'échecs. (Ceci
     signifie que les tests de régression ne peuvent pas détecter si les
     résultats sont appropriés pour la locale configurée. Ils vont simplement
     récupérer le fichier résultat qui fonctionne le mieux.)
    </para>

    <para>
     Si, pour une quelconque raison, les fichiers attendus ne couvrent pas
     certaines locales, vous pouvez ajouter un nouveau fichier. Le schéma de
     nommage est
     <literal><replaceable>nom_test</>_<replaceable>chiffre</>.out</>. Le
     chiffre n'a en fait pas de signification. Rappelez-vous que le pilote des
     tests de régression considérera tous les fichiers comme étant des résultats
     de tests valides. Si les résultats de tests sont spécifiques à une
     plateforme, la technique décrite dans <xref linkend="regress-platform">
     devrait être utilisée à la place.
    </para>
   </sect2>
    
   <sect2>
    <title>Différences au niveau des dates/heures</title>

    <para>
     Quelques requêtes des tests d'<filename>horologie</filename> échoueront si
     vous lancez les tests un jour de changement de heure ou le lendemain de ce
     jour. Ces requêtes s'attendent à ce que les intervalles entre minuit hier,
     minuit aujourd'hui et minuit demain soient exactement 24 heures -- ce qui
     est faux lorsqu'un changement d'heure intervient.
    </para>

    <note>
     <para>
      Comme les règles de changement d'heure des USA sont utilisées, ce
      problème arrive toujours le premier dimanche d'avril, le dernier dimanche
      d'octobre et les lundis suivants quelque soit le changement d'heure
      effectif où vous vivez. Notez aussi que le problème apparaît ou disparaît
      à minuit, UTC-7 ou UTC-8, pas à un minuit chez vous. Donc, l'échec
      pourrait arriver plus tard le dimanche ou persister jusqu'au mardi suivant
      l'endroit où vous vivez.
     </para>
    </note>

    <para>
     La plupart des résultats date/heure sont dépendants de l'environnement
     de zone horaire. Les fichiers de référence sont générés pour la zone
     horaire <literal>PST8PDT</literal> (Berkeley, Californie), et il y aura
     des échecs apparents si les tests ne sont pas lancés avec ce paramétrage de
     fuseau horaire. Le pilote des tests de régression initialise la variable
     d'environnement <envar>PGTZ</envar> à <literal>PST8PDT</literal> ce qui
     nous assure normalement de bons résultats. Néanmoins, votre système
     d'exploitation doit fournir un support du fuseau horaire
     <literal>PST8PDT</literal> ou les tests dépendants du fuseau horaire
     échoueront. Pour vérifier que votre machine dispose de ce support,
     saisissez ce qui suit&nbsp;:
<screen>
env TZ=PST8PDT date
</screen>
     La commande ci-dessus devrait renvoyée l'heure système actuelle dans le
     fuseau horaire <literal>PST8PDT</literal>. Si le fuseau horaire
     <literal>PST8PDT</literal> n'est pas disponible, alors votre système
     pourrait avoir renvoyer l'heure en UTC. Si le fuseau horaire
     <literal>PST8PDT</literal> est manquant, vous pouvez initialiser les
     règles de fuseau horaire explicitement&nbsp;:
<programlisting>
PGTZ='PST8PDT7,M04.01.0,M10.05.03'; export PGTZ
</programlisting>
    </para>

    <para>
     Certains systèmes semblent ne pas accepter la syntaxe recommandée pour
     initialiser explicitement les règles du fuseau horaire locale&nbsp;; vous
     pourriez avoir besoin d'utilisant une variable <envar>PGTZ</envar>
     différente sur ces machines.
    </para>

    <para>
     Certains systèmes utilisant d'anciennes bibliothèques de fuseaux horaires
     échouent lors de l'application des corrections d'heure sur des dates
     antérieures à 1970, causant les heures <acronym>PDT</acronym> pré-1970 à
     être affichées en <acronym>PST</acronym> à la place. Ceci résultera en des
     différences localisées dans les résultats de tests.
    </para>
   </sect2>
    
   <sect2>
    <title>Différences sur les nombres à virgules flottantes</title>
      
    <para>
     Quelques tests impliquent des calculs sur des nombres flottants à 64 bits
     (<type>double precision</type>) à partir des colonnes des tables. Les
     différences dans les résultats impliquant les fonctions mathématiques de
     colonnes <type>double precision</type> ont été observées. Les tests de
     <literal>float8</> et <literal>geometry</> sont particulièrement sensibles
     aux petites différences sur les différentes plateformes, voire même avec
     différentes options de compilation. La comparaison d'un &oelig;il humain
     est nécessaire pour déterminer la vraie raison de ces différences qui sont
     habituellement sur les dix places à droite du point décimal.
    </para>

    <para>
     Certains systèmes affichent moins zéro comme <literal>-0</> alors que
     d'autres affichent seulement <literal>0</>.
    </para>

    <para>
     Certains systèmes signalent des erreurs avec <function>pow()</function> et
     <function>exp()</function> différemment suivant le mécanisme attendu du
     code de <productname>PostgreSQL</productname>.
    </para>
   </sect2>

   <sect2>
    <title>Différences dans l'ordre des lignes</title>
      
    <para>
     Vous pourriez voir des différences dans lesquelles les mêmes lignes sont
     affichées dans un ordre différent de celui qui apparaît dans le fichier de
     référence. Dans la plupart des cas, ce n'est pas à strictement parlé un
     bogue. La plupart des scripts de tests de régression ne sont pas assez
     stricts pour utiliser un <literal>ORDER BY</> sur chaque
     <literal>SELECT</>, et du coup l'ordre des lignes pourrait ne pas être
     correctement défini suivant la spécification SQL. En pratique, comme nous
     sommes avec les mêmes requêtes sur les mêmes données avec le même logiciel,
     nous obtenons habituellement le même résultat sur toutes les plateformes et
     le manque d'<literal>ORDER BY</> n'est pas un problème. Quelques requêtes
     affichent des différences d'ordre entre plateformes. (Les différentes
     d'ordre peuvent aussi être déclenchées par une locale autre que C.)
    </para>

    <para>
     Du coup, si vous voyez une différence dans l'ordre, vous n'avez pas à vous
     inquiéter sauf si la requête possède un <literal>ORDER BY</> que votre
     résultat ne respecte pas. Mais rapportez tout de même ce problème que nous
     ajoutions un <literal>ORDER BY</> à cette requête pour éliminer les faux
     <quote>échecs</quote> dans les versions suivantes.
    </para>

    <para>
     Vous pourriez vous demander pourquoi nous n'ordonnons pas toutes les
     requêtes des tests de régression explicitement pour supprimer ce problème
     une fois pour toutes. La raison est que cela rendrait les tests de
     régression moins utiles car ils tendraient à exercer des types de plans de
     requêtes produisant des résultats ordonnés à l'exclusion de celles qui ne
     le font pas.
    </para>
   </sect2>

   <sect2>
    <title>Le test <quote>random</quote></title>
      
    <para>
     Il existe au moins un cas dans le script de tests 
     de <literal>random</literal> qui a pour but de produire des résultats
     aléatoires. Ceci fait que random échoue aux tests de régression une fois de
     temps en temps (peut-être une fois toutes les cinq à dix tentatives).
     Saisir
<programlisting>
diff results/random.out expected/random.out
</programlisting>
     devrait seulement produire une ou plusieurs lignes différentes. Vous ne
     devez pas vous en faire sauf si les tests random échouent en permanence de
     façon répété. (Alors que si le test random n'est
     <emphasis>jamais</emphasis> un échec, vous <emphasis>devriez</emphasis>
     probablement vous inquiéter.)
    </para>
   </sect2>
  </sect1>

<!-- We might want to move the following section into the developer's guide. -->
  <sect1 id="regress-platform">
   <title>Fichiers de comparaison spécifiques à la plateforme</title>

   <para>
    Comme certains des tests produisent de façon inhérente des
    résultats spécifiques à la plateforme, nous avons fourni un moyen de fournir
    des fichiers de comparaison de résultats spécifiques à la plateforme.
    Fréquemment, la même variation s'applique entre plusieurs plateformes&nbsp;;
    plutôt que de fournir un fichier de comparaison séparé pour chaque
    plateforme, il existe un fichier de correspondance définissant les fichiers
    de comparaison à utiliser. Donc, pour éliminer les <quote>échecs</quote> dûs
    à des tests bogués pour une plateforme particulière, vous devez choisir ou
    créer un fichier de résultat variant puis ajouter une ligne dans le fichier
    de correspondance, à savoir <filename>src/test/regress/resultmap</filename>.
   </para>

   <para>
    Chaque ligne du fichier de correspondance est de la forme
<synopsis>
nomtest/modeleplateform=fichiercomparaison
</synopsis>
    Le nom de tests est juste le nom du module de tests de régression
    particulier. Le modèle de plateforme est un modèle dans le style des outils
    Unix <command>expr</> (c'est-à-dire une expression rationnelle avec une
    ancre implicite <literal>^</literal> au début). Il est testé avec le nom de
    plateforme affiche par <command>config.guess</command> suivi par
    <literal>:gcc</literal> ou <literal>:cc</literal>, suivant que vous utilisez
    un compilateur GNU ou le compilateur de base de votre système (sur les
    systèmes où il y a une différence). Le nom du fichier de comparaison est le
    nom du fichier de comparaison substitué.
   </para>

   <para>
    Par exemple&nbsp;: certains systèmes utilisant les anciennes bibliothèques
    de fuseaux horaires échouent à appliquer les changements de dates avant
    1970, faisant que les dates <acronym>PDT</acronym> avant 1970 soient
    affichées en <acronym>PST</acronym> à la place. Ceci fait certaines
    différences dans le test de régression d'<filename>horologie</>. Du coup,
    nous fournissons un fichier variant de comparaison, 
    <filename>horology-no-DST-before-1970.out</filename>, qui inclut les
    résultats attendus sur certains systèmes. Pour faire taire les faux messages
    d'<quote>échec</quote> sur les plateformes,
    <filename>resultmap</filename> inclut
<programlisting>
horology/.*-hpux=horology-no-DST-before-1970
</programlisting>
    qui se déclenchera sur chaque machine dont la sortie de
    <command>config.guess</command> inclut <literal>-hpux</literal>.
    D'autres lignes de <filename>resultmap</> sélectionne un fichier de
    comparaison pour d'autres plateformes si cela est approprié.
   </para>
    
  </sect1>
  
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
