<!--
$PostgreSQL: pgsql/doc/src/sgml/storage.sgml,v 1.4 2005/01/10 00:04:38 tgl Exp $
-->

<chapter id="storage">

<title>Stockage physique de la base de données</title>

<para>
Ce chapitre fournit un aperçu du format de stockage physique utilisé par les
bases de données <productname>PostgreSQL</productname>.
</para>

<sect1 id="storage-file-layout">

<title>Emplacement des fichiers de la base de données</title>

<para>
Cette section décrit le format de stockage au niveau des fichiers et
répertoires.
</para>

<para>
Toutes les données nécessaires pour un groupe de bases de données sont stockées
dans le répertoire data du groupe, habituellement référencé en tant que
<varname>PGDATA</> (d'après le nom de la variable d'environnement qui peut
être utilisé pour la définir). Un emplacement commun pour <varname>PGDATA</>
est <filename>/var/lib/pgsql/data</>. Plusieurs groupes, gérés par différents
postmasters, peuvent exister sur la même machine.
</para>

<para>
Le répertoire <varname>PGDATA</> contient plusieurs sous-répertoires et
fichiers de contrôle, comme indiqué dans le <xref
linkend="pgdata-contents-table">. En plus de ces éléments requis, les fichiers
de configuration du groupe, <filename>postgresql.conf</filename>,
<filename>pg_hba.conf</filename> et <filename>pg_ident.conf</filename> sont
traditionnellement stockés dans <varname>PGDATA</> (bien qu'il soit possible, 
à partir de la version 8.0 de <productname>PostgreSQL</productname>, de les
conserver ailleurs). 
</para>

<table tocentry="1" id="pgdata-contents-table">
<title>Contenu de <varname>PGDATA</></title>
<tgroup cols="2">
<thead>
<row>
<entry>Élément</entry>
<entry>Description</entry>
</row>
</thead>

<tbody>

<row>
 <entry><filename>PG_VERSION</></entry>
 <entry>Un fichier contenant le numéro de version majeur de
  <productname>PostgreSQL</productname></entry>
</row>

<row>
 <entry><filename>base</></entry>
 <entry>Sous-répertoire contenant les sous-répertoires par base de
  données</entry>
</row>

<row>
 <entry><filename>global</></entry>
 <entry>Sous-répertoire contenant les tables communes au groupe, telles que
  <structname>pg_database</></entry>
</row>

<row>
 <entry><filename>pg_clog</></entry>
 <entry>Sous-répertoire contenant les données d'état de validation des
  transactions</entry>
</row>

<row>
 <entry><filename>pg_subtrans</></entry>
 <entry>Sous-répertoire contenant les données d'états des
  sous-transaction</entry>
</row>

<row>
 <entry><filename>pg_tblspc</></entry>
 <entry>Sous-répertoire contenant les liens symboliques vers les espaces
  logiques</entry>
</row>

<row>
 <entry><filename>pg_xlog</></entry>
 <entry>Sous-répertoire contenant les fichiers WAL (Write Ahead Log)</entry>
</row>

<row>
 <entry><filename>postmaster.opts</></entry>
 <entry>Un fichier enregistrant les options en ligne de commande avec
  lesquelles le postmaster a été lancé la dernière fois</entry>
</row>

<row>
 <entry><filename>postmaster.pid</></entry>
 <entry>Un fichier verrou enregistrant le PID du postmaster et l'identifiant
  du segment de mémoire partagé (absent après l'arrêt de postmaster)</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
Pour chaque base de données dans le groupe, il existe un sous-répertoire dans
<varname>PGDATA</><filename>/base</>, nommé d'après l'OID de la base de données
dans <structname>pg_database</>. Ce sous-répertoire est l'emplacement par
défaut pour les fichiers de la base de données&nbsp;; en particulier, ses
catalogues système sont stockés ici.
</para>

<para>
Chaque table et index est stocké dans un fichier séparé, nommé d'après le
numéro <firstterm>filenode</> de la table ou de l'index, lequel se trouve dans
<structname>pg_class</>.<structfield>relfilenode</>.
</para>

<caution>
<para>
Notez que, bien que le filenode de la table correspond souvent à son OID,
cela n'est <emphasis>pas</> nécessairement le cas&nbsp;; certaines
opérations, comme <command>TRUNCATE</>, <command>REINDEX</>,
<command>CLUSTER</> et quelques formes d'<command>ALTER TABLE</>, peuvent
modifier le filenode tout en préservant l'OID. Évitez de supposer que filenode
et OID sont identiques.
</para>
</caution>

<para>
Quand une table ou un index dépasse 1&nbsp;Go, il est divisé en
<firstterm>segments</>. Le nom du fichier du premier segment est identique à
filenode&nbsp;; les segments suivants sont nommés filenode.1, filenode.2, etc.
Cet arrangement évite des problèmes sur les plateformes qui ont des limitations
sur les tailles des fichiers. Le contenu des tables et index est discuté plus
en détails dans <xref linkend="storage-page-layout">.
</para>

<para>
Une table qui contient des colonnes pouvant accueillir potentiellement de
grandes entrées auront une table <firstterm>TOAST</> associée. Elle est
utilisée pour le stockage de valeurs de champs trop importantes pour
conserver des lignes propres.
<structname>pg_class</>.<structfield>reltoastrelid</> établit un lien entre
une table et sa table <acronym>TOAST</>, si elle existe. Voir <xref
linkend="storage-toast"> pour plus d'informations.
</para>

<para>
Les espaces logiques rendent ce scénario plus compliqués. Chaque espace
logique défini par l'utilisateur contient un lien symbolique dans le répertoire
<varname>PGDATA</><filename>/pg_tblspc</>, pointant vers le répertoire physique
de l'espace logique (comme spécifié dans la commande <command>CREATE
TABLESPACE</>). Le lien symbolique est nommé d'après l'OID de l'espace logique.
À l'intérieur de l'espace logique, il existe un sous-répertoire pour chaque base de données contenant des éléments dans l'espace logique. Ce
sous-répertoire est nommé d'après l'OID de la base. Les tables comprises dans
ce répertoire suivent le schéma de nommage des filenodes. L'espace logique
<literal>pg_default</> n'est pas accèdé via <filename>pg_tblspc</> mais
correspond à <varname>PGDATA</><filename>/base</>. De façon similaire,
l'espace logique <literal>pg_global</> n'est pas accèdé via 
<filename>pg_tblspc</> mais correspond à 
<varname>PGDATA</><filename>/global</>.
</para>

</sect1>

<sect1 id="storage-toast">

<title>TOAST</title>

    <indexterm>
     <primary>TOAST</primary>
    </indexterm>
    <indexterm><primary>sliced bread</><see>TOAST</></indexterm>

<para>
Cette section fournit un aperçu de <acronym>TOAST</> (<foreignphrase>The
Oversized-Attribute Storage Technique</foreignphrase>, la technique de
stockage des attributs trop grands).
</para>

<para>
Comme <productname>PostgreSQL</productname> utilise une taille de page fixe
(habituellement 8&nbsp;Ko) et n'autorise pas qu'une ligne soit sur plusieurs
pages, il n'est pas possible de stocker de grandes valeurs directement dans les
champs. Avant <productname>PostgreSQL</> 7.1, il existait une limite en dur qui
valait juste en-dessous d'une page pour la taille totale d'une donnée sur une
ligne d'une table. A partir de la version 7.1, cette limite est dépassée en
permettant de compresser des valeurs plus importantes et/ou de les
diviser en plusieurs lignes physiques. Ceci survient de façon transparente
pour l'utilisateur, avec seulement un petit impact sur le code du serveur.
La technique est connu sous l'acronyme affectueux de <acronym>TOAST</> (ou <quote>the best thing since sliced bread</>).
</para>

<para>
Seuls certains types de données supportent <acronym>TOAST</> &mdash; il n'est
pas nécessaire d'imposer la surcharge sur les types de données qui ne 
produisent pas de grosses valeurs de données. Pour supporter 
<acronym>TOAST</>, un type de données doit avoir une représentation 
(<firstterm>varlena</>) à longueur variable, dans laquelle les premiers 32 bits
contiennent la longueur totale de la valeur en octets (ceci incluant la
longueur elle-même). <acronym>TOAST</> n'a aucune contrainte supplémentaire
sur la représentation. Toutes les fonctions niveau C supportant un type données
supportant <acronym>TOAST</> doivent faire attention à gérer les valeurs en
entrée <acronym>TOAST</>ées. (Ceci se fait normalement en appelant
<function>PG_DETOAST_DATUM</> avant de faire quoi que ce soit avec une valeur
en entrée&nbsp;; mais dans certains cas, des approches plus efficaces sont
possibles.)
</para>

<para>
<acronym>TOAST</> usurpe les deux bits de poids fort dans le mot contenant la
longueur varlena, limitant du coup la taille logique de toute valeur d'un
type de données <acronym>TOAST</>-able à 1&nbsp;Go (2<superscript>30</> - 1
octets). Quand les deux bits sont à zéro, cette valeur est une valeur
ordinaire, non <acronym>TOAST</>ée, du type de données. Un des bits initialisé
indique que la valeur a été compressée et doit être décompressée avant d'être
utilisée. L'autre indique que la valeur a été stocké ailleurs. Dans ce cas,
le reste de la valeur est réellement un pointeur et la vraie donnée se trouve
ailleurs. Quand les deux bits sont initialisés, les données sont stockées
ailleurs tout en étant compressées. Dans chaque cas, la longueur dans les bits
de poids faible du mot varlena indique la taille du datum, pas la taille de la
valeur logique qui serait extraite par la décompression ou la récupération
de la donnée.
</para>

<para>
Si une des colonnes d'une table est <acronym>TOAST</>-able, la table disposera
d'une table <acronym>TOAST</> associé, dont l'OID est stockée dans l'entrée
<structname>pg_class</>.<structfield>reltoastrelid</> de la table. Les valeurs
<acronym>TOAST</>ées hors-ligne sont conservées dans la table <acronym>TOAST</>
comme décrit avec plus de détails ci-dessous.
</para>

<para>
La technique de compression utilisée est un simple et rapide membre de la
famille LZ. Voir <filename>src/backend/utils/adt/pg_lzcompress.c</> pour les
détails.
</para>

<para>
Les valeurs hors ligne sont divisées (après compression si nécessaire) en
morceau d'au plus <literal>TOAST_MAX_CHUNK_SIZE</> octets (cette valeur est
un peu plus petite que <literal>BLCKSZ/4</>, soit à peu près 2000 octets par
défaut). Chaque morceau est stocké comme une ligne séparée dans la table
<acronym>TOAST</> de la table propriétaire. Chaque table <acronym>TOAST</>
contient les colonnes <structfield>chunk_id</> (un OID identifiant la valeur
<acronym>TOAST</>ée particulière), <structfield>chunk_seq</> (un numéro de
séquence pour le morceau de la valeur) et <structfield>chunk_data</> (la donnée
réelle du morceau). Un index unique sur <structfield>chunk_id</> et
<structfield>chunk_seq</> fournit une récupération rapide des valeurs. Un
pointeur datum représentant une valeur <acronym>TOAST</>ée hors-ligne a du coup
besoin de stocker l'OID de la table <acronym>TOAST</> dans laquelle chercher
et l'OID de la valeur spécifique (son <structfield>chunk_id</>). Pour la
facilité, les pointeurs datums stockent aussi la tille logique du datum (taille
de la donnée originale non compressée) et la taille stockée réelle (différente
si la compression a été appliquée). A partir du mot d'en-tête varlena,
la taille totale d'un pointeur datum <acronym>TOAST</> est du coup de 20 octets
quelque soit la taille réelle de la valeur représentée.
</para>

<para>
Le code <acronym>TOAST</> est déclenché seulement quand une valeur d'une ligne
à stocker est plus grande que <literal>BLCKSZ/4</> octets (habituellement
2&nbsp;Ko). Le code <acronym>TOAST</> compressera et/ou déplacera les valeurs
de champ jusqu'à ce que la valeur de la ligne soit plus petite que
<literal>BLCKSZ/4</> octets ou qu'aucun gain ne puisse être réalisé. Lors d'une
opération UPDATE, les valeurs des champs non modifiées sont habituellement
préservées ainsi&nbsp;; donc un UPDATE sur une ligne avec des valeurs hors
ligne n'induit pas de coûts à cause de <acronym>TOAST</> si aucune des valeurs
hors-ligne n'est modifiée.
</para>

<para>
Le code <acronym>TOAST</> reconnaît quatre stratégies différentes pour stocker
les colonnes <acronym>TOAST</>-able&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      <literal>PLAIN</literal> empêche soit la compression soit le stockage
      hors-ligne. Ceci est la seule stratégie possible strategy pour les 
      colonnes des types de données non <acronym>TOAST</>-ables.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>EXTENDED</literal> permet à la fois la compression et le
      stockage hors-ligne. Ceci est la valeur par défaut de la plupart des
      types de données <acronym>TOAST</>-ables. La compression sera tentée en
      premier, puis le stockage hors-ligne si la ligne est toujours trop
      grande.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>EXTERNAL</literal> autorise le stockage hors-ligne mais pas la
      compression. L'utilisation d'<literal>EXTERNAL</literal> rendra les
      opérations sur des sous-chaînes de grosses colonnes de type
      <type>text</type> et <type>bytea</type> plus rapide (au dépens d'un
      espace de stockage accrus) car ces opérations sont optimisées pour
      récupérer seulement les parties requises de la valeur hors-ligne
      lorsqu'elle n'est pas compressée.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>MAIN</literal> autorise la compression mais pas le stockage
      hors-ligne. (En fait, le stockage hors-ligne sera toujours réalisé
      pour de tels colonnes mais seulement comme dernier ressort s'il n'existe
      aucune autre solution pour diminuer suffisament la taille de la ligne.)
     </para>
    </listitem>
   </itemizedlist>

Chaque type de données <acronym>TOAST</>-able spécifie une stratégie pour les
colonnes de ce type de donnée mais la stratégie pour une colonne d'une table
donnée peut être modifiée avec <command>ALTER TABLE SET STORAGE</>.
</para>

<para>
Ce schéma a un certain nombre d'avantages comparés à une approche plus directe
comme autoriser le stockage des valeurs de lignes sur plusieurs pages. En
supposant que les requêtes sont habituellement qualifiées par comparaison avec
des valeurs de clé relativement petites, la grosse partie du travail de
l'exécuteur sera réalisée en utilisant l'entére principale de la ligne. Les
grandes valeurs des attributs <acronym>TOAST</>és seront seulement récupérées
(si elles sont sélectionnées) au moment où l'ensemble de résultats est
envoyé au client. Du coup, la table principale est bien plus petite
et un plus grand nombre de ses lignes tient dans le cache du tampon partagé.
Le tri l'utilise aussi et les tris seront réalisés le plus souvent entièrement
en mémoire. Un petit test a montré qu'une table contenant des pages HTML
typiques ainsi que les URL étaient stockées en mémoire sur la moitié de la
taille des données brutes en incluant la table <acronym>TOAST</> et que la
table principale contenait moins de 10&nbsp;% de la totalité des données (les
URL et quelques petites pages HTML). Il n'y a pas de différence à l'exécution
en comparaison avec une table non <acronym>TOAST</>ée, dans laquelle toutes les
pages HTLM ont été coupée à 7&nbsp;Ko pour tenir.
</para>

</sect1>

<sect1 id="storage-page-layout">

<title>Emplacement des pages de la base de données</title>

<para>
Cette section fournit un aperçu du format des pages utilisées par les tables et
index de <productname>PostgreSQL</productname>.<footnote>
  <para>
    En fait, les méthodes d'accès par index n'ont pas besoin d'utiliser ce 
    format de page. Toutes les méthodes d'indexage existants utilisent ce
    format basique mais les données conservées dans les métapages des index
    ne suivent habituellement pas les règles d'emplacement des éléments.
  </para>
</footnote>
Les séquences et tables <acronym>TOAST</> tables sont formatées comme des
tables standards.
</para>

<para>
Dans l'explication qui suit, un <firstterm>octet</firstterm> contient huit
bits. De plus, le terme <firstterm>élément</firstterm> fait référence à une
valeur de données individuelle qui est stockée sur une page. Dans une table,
un élément est une ligne&nbsp;; dans un index, un élément est une entrée
d'index.
</para>

<para>
Chaque table et index est stocké comme un tableau de <firstterm>pages</> d'une
taille fixe (habituellement 8&nbsp;Ko, bien qu'une taille de page différente
peut être sélectionnée lors de la compilation du serveur). Dans une table,
toutes les pages sont logiquement équivalentes pour qu'un élément (ligne)
particulier puisse être stocké sur n'importe quelle page. Dans les index, la
première page est généralement réservée comme <firstterm>métapage</> contenant
des informations de contrôle et il peut exister différents types de pages à
l'intérieur de l'index suivant la méthode d'accès à l'index.
</para>

<para>
<xref linkend="page-table"> affiche le contenu complet d'une page. Il existe
cinq parties sur chaque page.
</para>

<table tocentry="1" id="page-table">
<title>Aperçu du contenu d'une page</title>
<titleabbrev>Contenu d'une page</titleabbrev>
<tgroup cols="2">
<thead>
<row>
<entry>Élément</entry>
<entry>Description</entry>
</row>
</thead>

<tbody>

<row>
 <entry>PageHeaderData</entry>
 <entry>20 octets. Contient des informations générales sur la page avec des
  pointeurs sur les espaces libres.</entry>
</row>

<row>
 <entry>ItemPointerData</entry>
 <entry>Tableau de paires (décalage,longueur) pointant sur les éléments réels.
  Quatre octets par élément.</entry>
</row>

<row>
 <entry>Free space</entry>
 <entry>L'espace non alloué. Les pointeurs de nouveaux éléments sont alloués
  à partir du début de cette aire, les nouveaux éléments à partir de la
  fin.</entry>
</row>

<row>
 <entry>Items</entry>
 <entry>Les éléments eux-mêmes.</entry>
</row>

<row>
 <entry>Special space</entry>
 <entry>Données spécifiques des méthodes d'accès aux index. Différentes
  méthodes stockent différentes données. Vide pour les tables
  ordinaires.</entry>
</row>

</tbody>
</tgroup>
</table>

 <para>

  Les vingt premiers octets de chaque page consiste en un en-tête de page
  (PageHeaderData). Son format est détaillé dans <xref
  linkend="pageheaderdata-table">. Les deux premiers champs traquent l'entrée
  WAL la plus récente relative à cette page. Ils sont suivis par trois
  champs d'entiers sur deux octets (<structfield>pd_lower</structfield>,
  <structfield>pd_upper</structfield> et
  <structfield>pd_special</structfield>). Ils contiennent des décalages
  d'octets à partir du début de la page jusqu'au début de l'espace non alloué,
  jusqu'à la fin de l'espace non alloué, jusqu'au début de l'espace spécial.
  Les deux derniers octets de l'en-tête de page,
  <structfield>pd_pagesize_version</structfield>, stockent à la fois la taille
  de la page et un indicateur de versoin. A partir de la version 8.0 de
  <productname>PostgreSQL</productname> 8.0, le numéro de version est 2&nbsp;; 
  <productname>PostgreSQL</productname> 7.3 et 7.4 ont utilisé le numéro de
  version 1&nbsp;; les versions précédentes utilisaient le numéro de version 0.
  (Le contenu de la page basique et le format de l'en-tête n'ont pas changé
  dans ces versions mais la disposition de l'en-tête des lignes de tête a
  changé.) La taille de la page est seulement présente comme vérification
  croisée&nbsp;; il n'existe pas de support pour avoir plus d'une taille de
  page dans une installation.
  
 </para>
 
 <table tocentry="1" id="pageheaderdata-table">
 <title>Disposition de PageHeaderData</title>
 <titleabbrev>Disposition de PageHeaderData</titleabbrev>
 <tgroup cols="4">   
 <thead>
  <row> 
   <entry>Champ</entry>
   <entry>Type</entry>
   <entry>Longueur</entry>
   <entry>Description</entry>
  </row>
 </thead>
 <tbody>
  <row>
   <entry>pd_lsn</entry>
   <entry>XLogRecPtr</entry>
   <entry>8 octets</entry>
   <entry>LSN&nbsp;: dernier octet après le dernier octet de l'enregistrement
    xlog pour la dernière modification de cette page</entry>
  </row>
  <row>
   <entry>pd_tli</entry>
   <entry>TimeLineID</entry>
   <entry>4 octets</entry>
   <entry>TLI de la dernière modification</entry>
  </row>
  <row>
   <entry>pd_lower</entry>
   <entry>LocationIndex</entry>
   <entry>2 octets</entry>
   <entry>Décalage jusqu'au début de l'espace libre</entry>
  </row>
  <row>
   <entry>pd_upper</entry>
   <entry>LocationIndex</entry>
   <entry>2 octets</entry>
   <entry>Décalage jusqu'à la fin de l'espace libre</entry>
  </row>
  <row>
   <entry>pd_special</entry>
   <entry>LocationIndex</entry>
   <entry>2 octets</entry>
   <entry>Décalage jusqu'au début de l'espace spécial</entry>
  </row>
  <row>
   <entry>pd_pagesize_version</entry>
   <entry>uint16</entry>
   <entry>2 octets</entry>
   <entry>Taille de la page et disposition de l'information du numéro de
    version</entry>
  </row>
 </tbody>
 </tgroup>
 </table>

 <para>
  Tous les détails se trouvent dans
  <filename>src/include/storage/bufpage.h</filename>.
 </para>

 <para>

  Après l'en-tête de la page se trouvent les identifieurs d'élément 
  (<type>ItemIdData</type>), chacun nécessitant quatre octets. Un identifieur
  d'élément contient un décalage d'octet vers le début d'un élément, sa
  longueur en octets et quelques bits d'attributs qui affectent son
  interprétation. Les nouveaux identifieurs d'éléments sont alloués si
  nécessaire à partir du début de l'espace non alloué. Le nombre d'identifieurs
  d'éléments présents peut être déterminé en regardant
  <structfield>pd_lower</>, qui est augmenté pour allouer un nouvel
  identifieur. Comme un identifieur d'élément n'est jamais déplacé tant qu'il
  n'est pas libéré, son index pourrait être utilisé sur une base à long terme
  pour référencer un élément, même si l'élément lui-même est déplacé autour de
  la page pour compresser un espace libre. En fait, chaque pointeur vers un
  élément (<type>ItemPointer</type>, aussi connu sous le nom de
  <type>CTID</type>), créé par <productname>PostgreSQL</productname> consiste
  en un numéro de page et l'index de l'identifieur d'élément.

 </para>

 <para>
 
  Les éléments eux-mêmes sont stockés dans l'espace alloués, en marche arrière,
  à partir de la fin de l'espace non alloué. La structure exacte varie
  suivant le contenu de la table. Les tables et les séquences utilisent tous
  les deux une structure nommée <type>HeapTupleHeaderData</type>, décrite
  ci-dessous.

 </para>
 
 <para>
 
  La section finale est la <quote>section spéciale</quote> qui pourrait
  contenir tout ce que les méthodes d'accès souhaitent stocker. Par exemple,
  les index b-tree stockent des liens vers les enfants gauche et droit de la
  page ainsi que quelques autres données sur la structure de l'index. Les
  tables ordinaires n'utilisent pas du tout de section spéciale (indiquée
  en configurant <structfield>pd_special</> à la taille de la page).
  
 </para>
 
 <para>

  Toutes les lignes de la table sont structurées de la même façon. Il existe
  un en-tête à taille fixe (occupant 27 octets sur la plupart des machines),
  suivi par un bitmap null optionnel, un champ ID de l'objet optionnel et les
  données de l'utilisateur. L'en-tête est détaillé dans <xref
  linkend="heaptupleheaderdata-table">. Les données réelles de l'utilisateur
  (les colonnes de la ligne) commencent à un décalage indiqué par
  <structfield>t_hoff</>, qui doit toujours être un multiple de la distance
  MAXALIGN pour le plateforme. Le bitmap NULL est seulement présent si le bit
  <firstterm>HEAP_HASNULL</firstterm> est initialisé dans
  <structfield>t_infomask</structfield>. S'il est présent, il commence juste
  après l'en-tête fixe et occupe assez d'octets pour avoir un bit par colonnes
  de données (c'est-à-dire <structfield>t_natts</> bits ensemble). Dans cette
  liste de bits, un bit 1 indique une valeur non NULL, un bit 0 une valeur
  NULL. Quand le bitmap n'est pas présent, toutes les colonnes sont supposées
  non NULL. L'ID de l'objet est seulement présent si le bit
  <firstterm>HEAP_HASOID</firstterm> est initialisé dans
  <structfield>t_infomask</structfield>. S'il est présent, il apparaît juste
  avant la limite <structfield>t_hoff</>. Tout ajout nécessaire pour faire
  de <structfield>t_hoff</> un multiple de MAXALIGN apparaîtra comme le 
  bitmap NULL et l'ID de l'objet. (Ceci nous assure en retour que l'ID de
  l'objet est convenablement aligné.)
  
 </para>
 
 <table tocentry="1" id="heaptupleheaderdata-table">
 <title>Disposition de HeapTupleHeaderData</title>
 <titleabbrev>Disposition de HeapTupleHeaderData</titleabbrev>
 <tgroup cols="4">   
 <thead>
  <row> 
   <entry>Champ</entry>
   <entry>Type</entry>
   <entry>Longueur</entry>
   <entry>Description</entry>
  </row>
 </thead>
 <tbody>
  <row>
   <entry>t_xmin</entry>
   <entry>TransactionId</entry>
   <entry>4 octets</entry>
   <entry>insère le tampon XID</entry>
  </row>
  <row>
   <entry>t_cmin</entry>
   <entry>CommandId</entry>
   <entry>4 octets</entry>
   <entry>insère le tampon CID</entry>
  </row>
  <row>
   <entry>t_xmax</entry>
   <entry>TransactionId</entry>
   <entry>4 octets</entry>
   <entry>supprime le tampon XID</entry>
  </row>
  <row>
   <entry>t_cmax</entry>
   <entry>CommandId</entry>
   <entry>4 octets</entry>
   <entry>supprime le tampon CID (surcharge avec t_xvac)</entry>
  </row>
  <row>
   <entry>t_xvac</entry>
   <entry>TransactionId</entry>
   <entry>4 octets</entry>
   <entry>XID pour l'opération VACUUM déplaçant une version de ligne</entry>
  </row>
  <row>
   <entry>t_ctid</entry>
   <entry>ItemPointerData</entry>
   <entry>6 octets</entry>
   <entry>TID en cours pour cette version de ligne ou pour une version plus
    récente</entry>
  </row>
  <row>
   <entry>t_natts</entry>
   <entry>int16</entry>
   <entry>2 octets</entry>
   <entry>nombre d'attribues</entry>
  </row>
  <row>
   <entry>t_infomask</entry>
   <entry>uint16</entry>
   <entry>2 octets</entry>
   <entry>différents bits d'options flag bits</entry>
  </row>
  <row>
   <entry>t_hoff</entry>
   <entry>uint8</entry>
   <entry>1 octet</entry>
   <entry>décalage vers les données utilisateur</entry>
  </row>
 </tbody>
 </tgroup>
 </table>

 <para>
   Tous les détails sont disponibles dans
   <filename>src/include/access/htup.h</filename>.
 </para>

 <para>
 
  Interpréter les données réelles peut seulement se faire avec des informations
  obtenues à partir des autres tables, principalement
  <structname>pg_attribute</structname>. Les valeurs clés nécessaires pour
  identifier les emplacements des champs sont
  <structfield>attlen</structfield> et <structfield>attalign</structfield>.
  Il n'existe aucun moyen pour obtenir directement un attribut particulier,
  sauf quand il n'y a que des champs de largeur fixe et aucune colonne NULL.
  Tout ceci est emballé dans les fonctions
  <firstterm>heap_getattr</firstterm>, <firstterm>fastgetattr</firstterm>
  et <firstterm>heap_getsysattr</firstterm>.
  
 </para>
 <para>

  Pour lire les données, vous avez besoin d'examinez chaque attribut à son
  tout. Commencez par vérifier si le champ est NULL suivant le bitmap NULL.
  S'il l'est, allez au suivant. Puis, assurez-vous que vous avez le bon
  alignement. Si le champ est un champ à taille fixe, alors tous les octets
  sont placés simplement. S'il s'agit d'un champ à taille variable
  (attlen = -1), alors c'est un peu plus compliqué. Tous les types de données
  à longueur variable partagent la même structure commune de l'en-tête,
  <type>varattrib</type>, qui inclut la longueur totale de la valeur stockée
  et quelques bits d'option. Suivant les options, les données pourraient être
  soit dans la table de base soit dans une table <acronym>TOAST</>&nbsp;;
  elles pourraient aussi être compressées (voir <xref 
  linkend="storage-toast">).
  
 </para>
</sect1>

</chapter>