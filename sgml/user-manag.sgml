<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/user-manag.sgml,v 1.6 2005/01/30 22:59:27 guillaume Exp $
-->

<chapter id="user-manag">
 <title>Utilisateurs et droits de la base de données</title>

 <para>
  Chaque groupe de bases de données contient un ensemble
  d'utilisateurs. Ces utilisateurs sont différents des utilisateurs
  gérés par le système d'exploitation sur lequel le serveur tourne.
  Les utilisateurs possèdent des objets de la base (par exemple des
  tables) et peuvent affecter des droits sur ces objets à d'autres
  utilisateurs pour contrôler qui a accès à quel objet.
 </para>

 <para>
  Ce chapitre décrit comment créer et gérer des utilisateurs et
  introduit le système de droits. Plus d'informations sur les
  différents types d'objets de la base de données et les effets des
  droits sont disponibles dans le <xref linkend="ddl">.
 </para>

 <sect1 id="database-users">
  <title>Utilisateurs de la base de données</title>

  <indexterm zone="database-users">
   <primary>utilisateur</primary>
  </indexterm>

  <indexterm>
   <primary>CREATE USER</primary>
  </indexterm>

  <indexterm>
   <primary>DROP USER</primary>
  </indexterm>

  <para>
   Conceptuellement, les utilisateurs de la base sont totalement
   séparés des utilisateurs du système d'exploitation. En pratique,
   il peut être commode de maintenir une correspondance mais cela
   n'est pas requis. Le nom des utilisateurs est global à toute une
   installation de groupe de bases de données (et non individuelle pour
   chaque base). Pour créer un utilisateur, utilisez la commande SQL
   <command>CREATE USER</command>&nbsp;:
<synopsis>
CREATE USER <replaceable>nom_utilisateur</replaceable>;
</synopsis>
   <replaceable>nom_utilisateur</replaceable> suit les règles des
   identifiants SQL&nbsp;: soit sans guillemets et sans caractères spéciaux,
   soit entre double-guillemets. Pour supprimer un utilisateur existant,
   utilisez la commande analogue <command>DROP USER</command>&nbsp;:
<synopsis>
DROP USER <replaceable>nom_utilisateur</replaceable>;
</synopsis>
  </para>

  <indexterm>
   <primary>createuser</primary>
  </indexterm>

  <indexterm>
   <primary>dropuser</primary>
  </indexterm>

  <para>
   Pour une certaine facilité d'utilisation, les programmes
   <command>createuser</command> et
   <command>dropuser</command> sont fournis comme emballage de ces
   commandes SQL et peuvent être appelées depuis la ligne de commandes
   du shell&nbsp;:
<synopsis>
createuser <replaceable>nom_utilisateur</replaceable>
dropuser <replaceable>nom_utilisateur</replaceable>
</synopsis>
  </para>

  <para>
   Afin d'amorcer le système de base de données, un système récemment
   installé contient toujours un utilisateur prédéfini. Cet
   utilisateur aura l'identifiant fixe 1 et aura par défaut (à moins
   que cela ne soit modifié en lançant la commande
   <command>initdb</command>) aura le même nom que l'utilisateur
   du système d'exploitation qui a initialisé le groupe de bases de
   données. Pour créer plus d'utilisateurs, vous devez d'abord vous
   connecter en temps que cet utilisateur initial.
  </para>

  <para>
   Une identité utilisateur, et uniquement une, est active par
   connexion au serveur de bases de données. Le nom d'utilisateur
   à employer pour une connexion à une base particulière est indiqué
   par le client initialisant la demande de connexion et ce, de la
   manière qui lui est propre.  Par exemple, le programme
   <command>psql</command> utilise l'option de ligne de commandes
   <option>-U</option> pour préciser sous quel utilisateur il se
   connecte. Beaucoup d'applications (incluant <command>createuser</>
   et <command>psql</>) utilisent par défaut le nom courant de
   l'utilisateur du système d'exploitation. Par conséquence, il peut
   être pratique de maintenir une correspondance de nommage entre les
   deux ensembles d'utilisateurs.
  </para>

  <para>
   La configuration de l'authentification du client détermine avec
   quel utilisateur de la base, la connexion cliente donnée se
   connectera, comme cela est expliqué dans le
   <xref linkend="client-authentication">. (Donc, un client n'est pas
   nécessairement obligé de se connecter avec le même nom d'utilisateur
   que celui qu'il a dans le système d'exploitation&nbsp;; de la même
   manière, une personne n'est pas contrainte de choisir son vrai nom comme
   nom de connexion.) Comme l'identité de l'utilisateur détermine l'ensemble des
   droits disponibles pour le client connecté, il est important de configurer
   cela soigneusement quand un environnement multi-utilisateurs est mis en
   place.
  </para>
 </sect1>

 <sect1 id="user-attributes">
  <title>Attributs utilisateurs</title>

   <para>
    Un utilisateur de bases de données peut avoir un certain nombre
    d'attributs qui définissent ses droits et interagissent avec
    le système d'authentification du client.

    <variablelist>
     <varlistentry>
      <term>super-utilisateur (superuser)<indexterm><primary>superuser</></></term>
      <listitem>
       <para>
        Un super-utilisateur d'une base passe au travers de toutes les
	vérifications de droits. De plus, seul un super-utilisateur peut
	créer de nouveaux utilisateurs. Pour créer un super-utilisateur de la
	base de données, utilisez <literal>CREATE USER
	<replaceable>nom_utilisateur</replaceable>CREATEUSER</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>création de bases de données<indexterm><primary>base de
	données</><secondary>droit de création</></></term>
      <listitem>
       <para>
        Les droits de création de bases doivent être
        explicitement données à un utilisateur (à l'exception des
        super-utilisateurs qui passent au travers de toutes
        vérifications de droits). Pour créer un tel utilisateur,
        utilisez <literal>CREATE USER
        <replaceable>nom_utilisateur</replaceable> CREATEDB</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>mot de passe<indexterm><primary>mot de passe</></></term>
      <listitem>
       <para>
        Un mot de passe est seulement significatif si la méthode
        d'authentification du client exige que le client fournisse
        un mot de passe quand il se connecte à la base.  Les
        méthodes d'authentification <option>mot de passe</>,
        <option>md5</> et <option>crypt</> utilisent les mots de
        passe.  Les mots de passe de la base de données ne sont pas
        les mêmes que ceux du système d'exploitation.  Indiquez un
        mots de passe lors de la création d'un utilisateur avec
        <literal>CREATE USER
        <replaceable>nom_utilisateur</replaceable> PASSWORD
        '<replaceable>le_mot_de_passe</>'</literal>. 
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Les attributs d'un utilisateur peuvent être modifiés après sa
    création avec <command>ALTER USER</command>.<indexterm><primary>ALTER USER</></>
    Regardez les pages de références de <command>CREATE USER</command>
    et de <command>ALTER USER</command> pour les détails.
   </para>

  <para>
   Un utilisateur peut aussi configurer ses options par défaut pour de
   nombreux paramètres de configuration décris dans la
   <xref linkend="runtime-config">. Par exemple, si pour une raison
   ou une autre vous voulez désactiver les parcours d'index (conseil&nbsp;:
   ce n'est pas une bonne idée) à chaque fois que vous vous connectez, vous
   pouvez utiliser
<programlisting>
ALTER USER nom_utilisateur SET enable_indexscan TO off;
</programlisting>
   Cela sauve les paramètres (mais ne les applique pas immédiatement)
   et dans les connexions ultérieures, c'est comme si 
   <literal>SET enable_indexscan TO off;</literal> avait été appelé
   juste avant le démarrage de la session. Vous pouvez toujours
   modifier les paramètres durant la session. Pour défaire un des
   paramètres, utilisez <literal>ALTER USER <replaceable>nom_utilisateur</>
   RESET <replaceable>nom_variable</>;</literal>.
  </para>
 </sect1>

 <sect1 id="groups">
  <title>Groupes</title>

  <indexterm zone="groups">
   <primary>groupe</primary>
  </indexterm>

  <para>
   Comme dans Unix, les groupes sont une manière logique de grouper
   les utilisateurs pour faciliter la gestion des privilèges&nbsp;: les
   droits peuvent être accordés ou révoqués à un groupe entier.
   Pour créer un groupe, utilisez
<synopsis>
CREATE GROUP <replaceable>nom_groupe</replaceable>;
</synopsis>
   Pour rajouter ou supprimer des utilisateurs d'un groupe, utilisez
<synopsis>
ALTER GROUP <replaceable>nom_group</replaceable> ADD USER <replaceable>nom_utilisateur_1</replaceable>, ... ;
ALTER GROUP <replaceable>nom_group</replaceable> DROP USER <replaceable>nom_utilisateur_1</replaceable>, ... ;
</synopsis>
  </para>
 </sect1>

 <sect1 id="privileges">
  <title>Droits</title>

  <indexterm zone="privileges">
   <primary>droit</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>propriétairer</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>GRANT</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>REVOKE</primary>
  </indexterm>

  <comment>Étant déplacée dans le chapitre DDL, cette partie disparaîtra
  éventuellement d'ici peu.</comment>

  <para>
   Quand un objet base de données est créé, il est affecté à un
   propriétaire. Ce dernier est l'utilisateur qui a exécuté
   l'instruction de création. Pour changer le propriétaire d'une
   table, d'un index, d'une séquence ou d'une vue, utilisez la
   commande <command>ALTER TABLE</command>. Par défaut, seul le
   propriétaire (ou le super-utilisateur) peut faire n'importe quoi
   avec un objet. Afin de laisser les autres utilisateurs utiliser
   l'objet, des <firstterm>droits</firstterm> doivent être
   accordés.
  </para>

  <para>
   Il existe différents privilèges&nbsp;: <literal>SELECT</>,
   <literal>INSERT</>, <literal>UPDATE</>, <literal>DELETE</>,
   <literal>RULE</>, <literal>REFERENCES</>, <literal>TRIGGER</>,
   <literal>CREATE</>, <literal>TEMPORARY</>, <literal>EXECUTE</>,
   <literal>USAGE</> et <literal>ALL</>. Pour plus d'informations sur
   le support des différents types de privilèges par
   <productname>PostgreSQL</productname>, regardez la page de
   référence <xref linkend="sql-grant" endterm="sql-grant-title">.
   Le droit de modifier ou de détruire un objet est toujours
   uniquement le privilège du propriétaire. Pour affecter des
   droits, la commande <command>GRANT</command> est utilisée.
   Ainsi, si <literal>joe</literal> est un utilisateur existant et
   <literal>comptes</literal> est une table existante, le droit
   pour mettre à jour la table peut être accordé avec

<programlisting>
GRANT UPDATE ON comptes TO joe;
</programlisting>
   L'utilisateur qui exécute cette commande doit être le propriétaire
   de la table. Pour accorder un droit à un groupe, utilisez
<programlisting>
GRANT SELECT ON comptes TO GROUP staff;
</programlisting>
   Le nom d'<quote>utilisateur</quote> spécial
   <literal>PUBLIC</literal> peut être utilisé pour accorder un
   privilège à chaque utilisateur du système. Écrire
   <literal>ALL</literal> à la place d'un droit spécifique
   signifie que tous les droits seront accordés.
  </para>

  <para>
   Pour révoquer un privilège, utilisez la commande nommée
   <command>REVOKE</command>&nbsp;:
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
   Les droits spéciaux d'un propriétaire d'une table (par exemple,
   le droit de faire <command>DROP</>, <command>GRANT</>,
   <command>REVOKE</>, etc) sont toujours implicites et ne peuvent pas
   être accordés ou révoqués. Mais le propriétaire d'une table peut
   choisir de révoquer ses propres droits ordinaires, par exemple
   mettre une table en lecture seule pour lui-même aussi bien que pour
   les autres.
  </para>
 </sect1>

 <sect1 id="perm-functions">
  <title>Fonctions et déclencheurs (triggers)</title>

  <para>
   Les fonctions et les déclencheurs autorisent à l'intérieur du
   serveur les utilisateurs à insérer du code que d'autres
   utilisateurs ne connaissent pas mais peuvent exécuter. Par
   conséquent, les deux mechanismes permettent aux utilisateurs
   d'utiliser un <quote>cheval de Troie</quote> contre d'autres avec
   une relative impunité. La seule protection réelle est d'effectuer
   un fort contrôle sur ceux qui peuvent définir des fonctions.
  </para>

  <para>
   Les fonctions écrites dans n'importe quel langage à l'exception de
   SQL tourne à l'intérieur d'un processus d'arrière-plan du serveur,
   avec les droits du système d'exploitation accordés processus
   démon du serveur de base de données. Il est alors possible de
   changer les structures de données internes du serveur à partir de
   fonctions auxquelles il est fait confiance.  Par conséquence, de
   telles fonctions peuvent éviter tous les contrôles d'accès du
   système. Ceci est un problème inhérent avec la définition de
   fonctions C par les utilisateurs.
  </para>
 </sect1>

</chapter>
