<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/user-manag.sgml,v 1.9 2005/05/10 06:01:33 guillaume Exp $
-->

<chapter id="user-manag">
 <title>Utilisateurs et droits de la base de données</title>

 <para>
  Chaque groupe de bases de données contient un ensemble
  d'utilisateurs. Ces utilisateurs sont différents des utilisateurs
  gérés par le système d'exploitation sur lequel le serveur tourne.
  Les utilisateurs possèdent des objets de la base (par exemple des
  tables) et peuvent affecter des droits sur ces objets à d'autres
  utilisateurs pour contrôler qui a accès à quel objet.
 </para>

 <para>
  Ce chapitre décrit comment créer et gérer des utilisateurs et
  introduit le système de droits. Plus d'informations sur les
  différents types d'objets de la base de données et les effets des
  droits sont disponibles dans le <xref linkend="ddl">.
 </para>

 <sect1 id="database-users">
  <title>Utilisateurs de la base de données</title>

  <indexterm zone="database-users">
   <primary>utilisateur</primary>
  </indexterm>

  <indexterm>
   <primary>CREATE USER</primary>
  </indexterm>

  <indexterm>
   <primary>DROP USER</primary>
  </indexterm>

  <para>
   Conceptuellement, les utilisateurs de la base sont totalement
   séparés des utilisateurs du système d'exploitation. En pratique,
   il peut être commode de maintenir une correspondance mais cela
   n'est pas requis. Le nom des utilisateurs est global à toute une
   installation de groupe de bases de données (et non individuelle pour
   chaque base). Pour créer un utilisateur, utilisez la commande SQL
   <xref linkend="sql-createuser" endterm="sql-createuser-title">&nbsp;:
<synopsis>
CREATE USER <replaceable>nom_utilisateur</replaceable>;
</synopsis>
   <replaceable>nom_utilisateur</replaceable> suit les règles des
   identifiants SQL&nbsp;: soit sans guillemets et sans caractères spéciaux,
   soit entre double-guillemets. Pour supprimer un utilisateur existant,
   utilisez la commande analogue <xref linkend="sql-dropuser"
   endterm="sql-dropuser-title">&nbsp;:
<synopsis>
DROP USER <replaceable>nom_utilisateur</replaceable>;
</synopsis>
  </para>

  <indexterm>
   <primary>createuser</primary>
  </indexterm>

  <indexterm>
   <primary>dropuser</primary>
  </indexterm>

  <para>
   Pour une certaine facilité d'utilisation, les programmes
   <xref linkend="app-createuser"> et <xref linkend="app-dropuser"> sont
   fournis comme emballage de ces commandes SQL et peuvent être appelées depuis
   la ligne de commande du shell&nbsp;:
<synopsis>
createuser <replaceable>nom_utilisateur</replaceable>
dropuser <replaceable>nom_utilisateur</replaceable>
</synopsis>
  </para>

  <para>
   Pour déterminer l'ensemble des utilisateurs existants, examinez le catalogue
   système <structname>pg_user</> existant, par exemple
<synopsis>
SELECT usename FROM pg_user;
</synopsis>
   La méta-commande <literal>\du</> du programme <xref linkend="app-psql"> est
   aussi utile pour lister les utilisateurs existants.
  </para>

  <para>
   Afin d'amorcer le système de base de données, un système récemment
   installé contient toujours un utilisateur prédéfini. Cet
   utilisateur aura l'identifiant fixe 1 et aura par défaut (à moins
   que cela ne soit modifié en lançant la commande
   <command>initdb</command>) le même nom que l'utilisateur
   du système d'exploitation qui a initialisé le groupe de bases de
   données. Pour créer plus d'utilisateurs, vous devez d'abord vous
   connecter en temps que cet utilisateur initial.
  </para>

  <para>
   Une identité utilisateur, et uniquement une, est active par
   connexion au serveur de bases de données. Le nom d'utilisateur
   à employer pour une connexion à une base particulière est indiqué
   par le client initialisant la demande de connexion et ce, de la
   manière qui lui est propre.  Par exemple, le programme
   <command>psql</command> utilise l'option de ligne de commandes
   <option>-U</option> pour préciser sous quel utilisateur il se
   connecte. Beaucoup d'applications (incluant <command>createuser</>
   et <command>psql</>) utilisent par défaut le nom courant de
   l'utilisateur du système d'exploitation. Par conséquence, il peut
   être pratique de maintenir une correspondance de nommage entre les
   deux ensembles d'utilisateurs.
  </para>

  <para>
   La configuration de l'authentification du client détermine avec
   quel utilisateur de la base, la connexion cliente donnée se
   connectera, comme cela est expliqué dans le
   <xref linkend="client-authentication">. (Donc, un client n'est pas
   nécessairement obligé de se connecter avec le même nom d'utilisateur
   que celui qu'il a dans le système d'exploitation&nbsp;; de la même
   façon que le nom de connexion d'un utilisateur peut ne pas correspondre à
   son vrai nom.) Comme l'identité de l'utilisateur détermine l'ensemble des
   droits disponibles pour le client connecté, il est important de configurer
   cela soigneusement quand un environnement multi-utilisateurs est mis en
   place.
  </para>
 </sect1>

 <sect1 id="user-attributes">
  <title>Attributs utilisateurs</title>

   <para>
    Un utilisateur de bases de données peut avoir un certain nombre
    d'attributs qui définissent ses droits et interagissent avec
    le système d'authentification du client.

    <variablelist>
     <varlistentry>
      <term>super-utilisateur (superuser)<indexterm><primary>superuser</></></term>
      <listitem>
       <para>
        Un super-utilisateur d'une base passe au travers de toutes les
	vérifications de droits. De plus, seul un super-utilisateur peut
	créer de nouveaux utilisateurs. Pour créer un super-utilisateur de la
	base de données, utilisez <literal>CREATE USER
	<replaceable>nom_utilisateur</replaceable> CREATEUSER</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>création de bases de données<indexterm><primary>base de
	données</><secondary>droit de création</></></term>
      <listitem>
       <para>
        Les droits de création de bases doivent être
        explicitement données à un utilisateur (à l'exception des
        super-utilisateurs qui passent au travers de toutes
        vérifications de droits). Pour créer un tel utilisateur,
        utilisez <literal>CREATE USER
        <replaceable>nom_utilisateur</replaceable> CREATEDB</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>mot de passe<indexterm><primary>mot de passe</></></term>
      <listitem>
       <para>
        Un mot de passe est seulement significatif si la méthode
        d'authentification du client exige que le client fournisse
        un mot de passe quand il se connecte à la base.  Les
        méthodes d'authentification <option>mot de passe</>,
        <option>md5</> et <option>crypt</> utilisent les mots de
        passe.  Les mots de passe de la base de données ne sont pas
        les mêmes que ceux du système d'exploitation.  Indiquez un
        mots de passe lors de la création d'un utilisateur avec
        <literal>CREATE USER
        <replaceable>nom_utilisateur</replaceable> PASSWORD
        '<replaceable>le_mot_de_passe</>'</literal>. 
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Les attributs d'un utilisateur peuvent être modifiés après sa
    création avec <command>ALTER USER</command>.<indexterm><primary>ALTER USER</></>
    Regardez les pages de références de <xref linkend="sql-createuser"
    endterm="sql-createuser-title"> et de <xref linkend="sql-alteruser"
    endterm="sql-alteruser-title"> pour plus de détails.
   </para>

  <para>
   Un utilisateur peut aussi configurer ses options par défaut pour de
   nombreux paramètres de configuration décris dans la
   <xref linkend="runtime-config">. Par exemple, si pour une raison
   ou une autre vous voulez désactiver les parcours d'index (conseil&nbsp;:
   ce n'est pas une bonne idée) à chaque fois que vous vous connectez, vous
   pouvez utiliser
<programlisting>
ALTER USER nom_utilisateur SET enable_indexscan TO off;
</programlisting>
   Cela sauve les paramètres (mais ne les applique pas immédiatement)
   Dans les connexions ultérieures de cet utilisateur, c'est comme si 
   <literal>SET enable_indexscan TO off;</literal> avait été appelé
   juste avant le démarrage de la session. Vous pouvez toujours
   modifier les paramètres durant la session. Pour défaire un des
   paramètres, utilisez <literal>ALTER USER <replaceable>nom_utilisateur</>
   RESET <replaceable>nom_variable</>;</literal>.
  </para>
 </sect1>

 <sect1 id="groups">
  <title>Groupes</title>

  <indexterm zone="groups">
   <primary>groupe</primary>
  </indexterm>

  <para>
   Comme dans Unix, les groupes sont une manière logique de grouper
   les utilisateurs pour faciliter la gestion des privilèges&nbsp;: les
   droits peuvent être accordés ou révoqués à un groupe entier.
   Pour créer un groupe, utilisez la commande SQL <xref
   linkend="sql-creategroup" endterm="sql-creategroup-title">&nbsp;:
<synopsis>
CREATE GROUP <replaceable>nom_groupe</replaceable>;
</synopsis>
   Pour rajouter ou supprimer des utilisateurs d'un groupe, utilisez<xref
   linkend="sql-altergroup" endterm="sql-altergroup-title">&nbsp;:
<synopsis>
ALTER GROUP <replaceable>nom_group</replaceable> ADD USER <replaceable>nom_utilisateur_1</replaceable>, ... ;
ALTER GROUP <replaceable>nom_group</replaceable> DROP USER <replaceable>nom_utilisateur_1</replaceable>, ... ;
</synopsis>

   Pour détruire un groupe, utilisez <xref
   linkend="sql-dropgroup" endterm="sql-dropgroup-title">&nbsp;:
<synopsis>
DROP GROUP <replaceable>name</replaceable>;
</synopsis>
   Ceci supprime uniquement le groupe, pas les utilisateurs membres du groupe.
  </para>

  <para>
   Pour déterminer l'ensemble des groupes existants, examinez le catalogue
   système <structname>pg_group</>, par exemple&nbsp;:
<synopsis>
SELECT groname FROM pg_group;
</synopsis>
   La méta-commande <literal>\dg</> du programme <xref linkend="app-psql"> est
   aussi utile pour afficher les groupes existants.
  </para>
 </sect1>

 <sect1 id="privileges">
  <title>Droits</title>

  <indexterm zone="privileges">
   <primary>droit</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>propriétairer</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>GRANT</primary>
  </indexterm>

  <indexterm zone="privileges">
   <primary>REVOKE</primary>
  </indexterm>

  <remark>Étant déplacée dans le chapitre DDL, cette partie disparaîtra
  éventuellement d'ici peu.</remark>

  <para>
   Quand un objet est créé, il est affecté à un
   propriétaire. Ce dernier est habituellement l'utilisateur qui a exécuté
   l'instruction de création. Pour la plupart des objets, l'état initial est
   quel seul le propriétaire (ou un superutilisateur) peut faire quelque chose
   avec cet objet. Afin de laisser les autres utilisateurs utiliser
   l'objet, des <firstterm>droits</firstterm> doivent être
   accordés. Il existe différents privilèges&nbsp;: <literal>SELECT</>,
   <literal>INSERT</>, <literal>UPDATE</>, <literal>DELETE</>,
   <literal>RULE</>, <literal>REFERENCES</>, <literal>TRIGGER</>,
   <literal>CREATE</>, <literal>TEMPORARY</>, <literal>EXECUTE</> et
   <literal>USAGE</>. Pour plus d'informations sur
   le support des différents types de privilèges par
   <productname>PostgreSQL</productname>, regardez la page de
   référence <xref linkend="sql-grant" endterm="sql-grant-title">.
  </para>

  <para>
   Pour affecter des droits, la commande <command>GRANT</command> est utilisée.
   Ainsi, si <literal>joe</literal> est un utilisateur existant et
   <literal>comptes</literal> est une table existante, le droit
   pour mettre à jour la table peut être accordé avec

<programlisting>
GRANT UPDATE ON comptes TO joe;
</programlisting>
   Pour accorder un droit à un groupe, utilisez
<programlisting>
GRANT SELECT ON comptes TO GROUP staff;
</programlisting>
   Le nom spécial
   <literal>PUBLIC</literal> peut être utilisé pour accorder un
   privilège à chaque utilisateur du système. Écrire
   <literal>ALL</literal> à la place d'un droit spécifique
   signifie que tous les droits s'appliquant à l'objet seront accordés.
  </para>

  <para>
   Pour révoquer un privilège, utilisez la commande nommée
   <command>REVOKE</command>&nbsp;:
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
  </para>

  <para>
   Les droits spéciaux d'un propriétaire d'un objet (par exemple,
   le droit de modifier ou détruire un objet) sont toujours implicites
   et ne peuvent pas être accordés ou révoqués. Mais le propriétaire peut
   choisir de révoquer ses propres droits ordinaires, par exemple
   mettre une table en lecture seule pour lui-même aussi bien que pour
   les autres.
  </para>

  <para>
   Un objet peut être affecté à un nouveau propriétaire avec une commande
   <command>ALTER</command> du genre approprié pour l'objet. Seuls les
   superutilisateurs peuvent faire ceci.
  </para>
 </sect1>

 <sect1 id="perm-functions">
  <title>Fonctions et déclencheurs (triggers)</title>

  <para>
   Les fonctions et les déclencheurs autorisent à l'intérieur du
   serveur les utilisateurs à insérer du code que d'autres
   utilisateurs ne connaissent pas mais peuvent exécuter. Par
   conséquent, les deux mechanismes permettent aux utilisateurs
   d'utiliser un <quote>cheval de Troie</quote> contre d'autres avec
   une relative facilité. La seule protection réelle est d'effectuer
   un fort contrôle sur ceux qui peuvent définir des fonctions.
  </para>

  <para>
   Les fonctions sont exécutées à l'intérieur du processus serveur avec les
   droits au niveau système d'exploitation du démon serveur de la base de
   données. Si le langage de programmation utilisé par la fonction autorise les
   accès mémoire non contrôlés, il est possible de modifier les structures de
   données internes du serveur. Du coup, parmi d'autres choses, de telles
   fonctions peuvent dépasser les contrôles d'accès au système. Les langages de
   fonctions qui permettent un tel accès sont considérées <quote>sans
   confiance</> et <productname>PostgreSQL</productname> autorise uniquement les
   superutilisateurs à écrire des fonctions dans ces langages.
  </para>
 </sect1>

</chapter>
