<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/wal.sgml,v 1.9 2005/07/15 06:14:30 guillaume Exp $ -->

<chapter id="wal">
 <title>Write-Ahead Logging (<acronym>WAL</acronym>)</title>

 <indexterm zone="wal">
  <primary>WAL</primary>
 </indexterm>

 <indexterm>
  <primary>log transaction</primary>
  <see>WAL</see>
 </indexterm>

  <para>
   <firstterm>Write-Ahead Logging</firstterm> (<acronym>WAL</acronym>)
   est une approche standard pour l'écriture d'un journal de
   transactions.  Sa description détaillée peut être trouvée dans la
   plupart (si ce n'est tous) des livres sur le traitement
   transactionnel. Brièvement, le concept central des
   <acronym>WAL</acronym> est que les changements des fichiers de
   données (où résident les tables et les index) doivent être effectués
   uniquement après que ces changements aient été écrits dans un journal,
   c'est-à-dire quand l'enregistrement du journal décrivant les changements a
   été écrit vers le
   stockage permanent.  Si nous suivons cette procédure, nous n'avons
   pas besoin d'écrire les pages de données vers le disque à chaque
   validation de transaction car nous savons que dans l'éventualité
   d'une défaillance, nous serons capables de récupérer la base de
   données en utilisant le journal&nbsp;: chaque changement qui n'a pas été
   appliqué aux pages de données peut être ré-exécuté depuis les
   enregistrements du journal. (Ceci est une récupération roll-forward,
   aussi connue sous le nom de REDO.)
  </para>

  <sect1 id="wal-benefits">
   <title>Avantages des <acronym>WAL</acronym></title>

   <indexterm zone="wal-benefits">
    <primary>fsync</primary>
   </indexterm>

   <para>
    Le premier avantage majeur en utilisant les <acronym>WAL</acronym>
    est la réduction significative du nombre d'écritures sur le disque
    puisque uniquement le journal des transactions a besoin d'être écrit sur le
    disque au moment où la transaction est validée plutôt que chaque fichier de
    données modifié par la transaction. Dans un environnement
    multi-utilisateurs, la validation de nombreuses transactions peut être
    accomplie avec un seul <function>fsync()</function> du journal.  De plus, ce
    dernier est écrit séquentiellement et donc, le coût de
    synchronisation du journal est largement moindre que le coût d'écriture des
    pages de données. Ceci est spécialement vrai pour les serveurs gérant
    beaucoup de petites transactions touchant différentes parties du stockage de
    données.
   </para>

   <para>
    Le second avantage est la cohérence des pages de données.  La
    vérité est qu'avant <acronym>WAL</acronym>,
    <productname>PostgreSQL</productname> n'était pas capable de
    garantir la cohérence en cas de défaillance (crash).  Avant
    <acronym>WAL</acronym>, une défaillance quelconque durant
    l'écriture pouvait être le résultat&nbsp;:

    <orderedlist>
     <listitem>
      <simpara>de lignes d'un index pointant vers des lignes
      inexistantes d'une table&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>de lignes perdues d'un index dans des opérations de
      séparation&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>de tables ou de contenu de pages d'index totalement
      corrompues à cause d'une écriture partielle des pages de
      données</simpara>
     </listitem>
    </orderedlist>

    Les problèmes avec les index (les problèmes 1 et 2) auraient pû être
    corrigés avec des appels supplémentaires à <function>fsync</function> mais
    il n'est pas évident de traiter le dernier cas sans <acronym>WAL</acronym>.
    <acronym>WAL</acronym> sauve le contenu entier de la page de données dans le
    journal si cela est requis pour assurer la cohérence de la page et permettre
    la récupération après défaillance.
   </para>

   <para>
    Enfin, les <acronym>WAL</acronym> rendent possible le support de sauvegarde
    en ligne et de récupération à un moment, comme décrit dans <xref
    linkend="backup-online">. En archivant les données WAL, nous pouvons
    supporter le retour à tout instant couvert par les données disponibles
    dans les WAL&nbsp;: nous installons simplement une ancienne sauvegarde
    physique de la base de données et nous rejouons les journaux WAL jusqu'au
    moment désiré. Qui plus est, la sauvegarde physique n'a pas besoin d'être
    une image instantanée de l'état de la base de données &mdash; si elle a été
    faire pendant une période de temps, alors rejouer les journaux WAL pour
    cette période corrigera toute inconsistance interne.
   </para>
  </sect1>

 <sect1 id="wal-configuration">
  <title>Configuration de <acronym>WAL</acronym></title>

  <para>
   Il y a plusieurs paramètres de configuration associés à
   <acronym>WAL</acronym> qui affectent les performances de la base de
   de données.  Cette section explique leur utilisation.  Consultez la
   <xref linkend="runtime-config"> pour des détails sur la
   mise en place de ces paramètres de configuration.
  </para>

  <para>
   Dans la séquence des transactions, les
   <firstterm>points de contrôles</firstterm><indexterm><primary>points de
   contrôle</></> (checkpoints) sont des
   points qui garantissent que les fichiers de données ont été mis à
   jour avec toutes les informations enregistrées dans le journal avant le
   point de contrôle.  Au moment du point de contrôle, toutes les
   les pages de données non propres sont écrites sur le disque et une
   entrée spéciale, pour le point de contrôle, est écrite dans le
   journal.  Cela a pour résultat qu'en cas de défaillance, la procédure de
   récupération sait à partir de quelle entrée du journal (connu sous
   le nom d'entrée de récupération) il doit démarrer l'opération de
   de récupération (REDO) puisque tous les changements faient sur les
   fichiers de données avant cette entrée sont déjà sur le disque.
   Après avoir fait un point de contrôle, tous les segments de journaux
   écrits avant l'entrée de récupération ne sont plus nécessaires et
   peuvent être recyclés ou supprimés. (Quand la sauvegarde des
   <acronym>WAL</acronym> est en cours, les segments de journaux
   doivent être archivés avant d'être recyclés ou supprimés).
  </para>

  <para>
   Le processus d'écriture en tâche de fond lancera automatiquement un point de
   contrôle de temps en temps. Un point de contrôle est créé tous les <xref
   linkend="guc-checkpoint-segments"> segments de journaux ou dès que <xref
   linkend="guc-checkpoint-timeout"> secondes se sont
   écoulées.  Les paramètres par défaut sont respectivement 3 segments
   et 300 secondes.  Il est également possible de forcer la création
   d'un point de contrôle en utilisant la commande SQL
   <command>CHECKPOINT</command>.
  </para>

  <para>
   Réduire <varname>checkpoint_segments</varname> et/ou
   <varname>checkpoint_timeout</varname> a pour conséquence de faire
   des points de contrôle plus fréquent.  Ceci permet une récupération
   plus rapide après une défaillance (puisque moins de travail a
   besoin d'être récupéré).  Cependant, il faut équilibrer cela avec
   l'augmentation du coût d'écriture des pages de données non propres.
   De plus, après chaque point de contrôle, pour être certain de
   l'intégrité des pages de données, la première modification d'une
   page de données a pour conséquence d'écrire dans le journal le contenu
   entier de la page.  Donc, un intervalle trop petit de points de
   contrôles augmente le volume écrit dans le journal WAL, ce qui annule, en
   partie, les avantages d'utiliser un petit intervalle.  Dans tous les
   cas, cela causera plus d'accès en entrées/sorties (I/O) du disque.
  </para>

  <para>
   Les points de contrôle sont assez coûteux, tout d'abord parce qu'ils
   écrivent tous les tampons utilisés, et ensuite parce que cela suscite un
   trafic WAL supplémentaire comme indiqué ci-dessus. Du coup, il est conseillé
   de configurer les paramètres en relation assez haut pour que ces points de
   contrôle n'arrivent pas trop fréquemment. En tant que simple vérification de
   santé de vos paramètres, vous pouvez configurer le paramètre <xref
   linkend="guc-checkpoint-warning">. Si les points de contrôle arrivent plus
   rapidement que <varname>checkpoint_warning</> secondes, un message sera
   affiché dans les journaux du serveur, recommandant d'accroître
   <varname>checkpoint_segments</varname>. Une apparition occasionnelle d'un
   message ne doit pas vous alarmer mais, s'il apparaît souvent, alors les
   paramètres de contrôle devraient être augmentés.
  </para>

  <para>
   Il y aura au moins un fichier segment WAL et normalement
   pas plus de 2 * <varname>checkpoint_segments</varname> + 1
   fichiers.  Chaque fichier de segment fait normalement 16&nbsp;Mo (bien
   que cette taille puisse être modifiée lors de la construction). Vous pouvez
   utiliser cela pour estimer l'espace disque
   nécessaire pour <acronym>WAL</acronym>. D'habitude, quand les vieux fichiers 
   segment de journaux ne sont plus nécessaires, ils sont recyclés
   (renommés pour devenir les prochains segments dans une séquence
   numérotée).  Si, dû à un pic temporaire du taux d'écriture des journaux,
   il y a plus de 2 * <varname>checkpoint_segments</varname> + 1
   fichiers segments, ceux inutilisés seront effacés au lieu d'être
   recyclés jusqu'à ce que le système soit en-dessous de cette limite.
  </para>

  <para>
   Il y a deux fonctions <acronym>WAL</acronym> couramment utilisées&nbsp;:
   <function>LogInsert</function> et <function>LogFlush</function>.
   <function>LogInsert</function> est utilisée pour placer une
   nouvelle entrée à l'intérieur des tampons <acronym>WAL</acronym> en mémoire
   partagée.  Si il n'y a plus
   d'espace pour une nouvelle entrée, <function>LogInsert</function>
   devra écrire (bouger dans le cache du noyau) quelques tampons
   <acronym>WAL</acronym> remplis.  Ceci n'est pas désirable parce que
   <function>LogInsert</function> est utilisée lors de chaque
   modification bas niveau de la base (par exemple, insertion d'une
   ligne) quand un verrou exclusif est posé sur des pages de données
   affectées, donc l'opération nécessite d'être aussi rapide que
   possible.  Pire encore, écrire des tampons <acronym>WAL</acronym>
   peut aussi forcer la création d'un nouveau segment de journal ce qui
   peut prendre beaucoup plus de temps.  Normalement, les tampons
   <acronym>WAL</acronym> devrait être écrits et vidés par une requête
   de <function>LogFlush</function> qui est faite, la plupart du
   temps, au moment de la validation d'une transaction pour assurer
   que les entrées de la transaction sont écrites vers un stockage
   permanent.  Sur les systèmes avec une importante écriture de journaux,
   les requêtes de <function>LogFlush</function> peuvent ne pas
   arriver assez souvent pour empêcher <function>LogInsert</function> d'avoir
   à écrire.  Sur de tel système, on devrait augmenter le nombre de tampons
   <acronym>WAL</acronym> en modifiant le paramètre de configuration <xref
   linkend="guc-wal-buffers">. Par défaut, le nombre de tampons est de 8. 
   Augmenter cette valeur augmentera considérablement l'utilisation de la
   mémoire partagée. (Il devrait être noté qu'il existe actuellement peu de
   preuves pour suggérer que l'augmentation de <varname>wal_buffers</> au-delà
   de la valeur par défaut est intéressant.)
  </para>

  <para>
   Le paramètre <xref linkend="guc-commit-delay"> définit combien de
   micro-secondes le processus serveur dormira après l'écriture d'une
   entrée de validation dans le journal avec
   <function>LogInsert</function> avant d'exécuter un 
   <function>LogFlush</function>.  Ce délai permet aux autres
   processus du serveur d'ajouter leurs entrées de validation dans le
   fichier de journal afin de tout écrire vers le disque avec une seule
   synchronisation du journal.  Aucune mise en sommeil n'aura lieu si
   <xref linkend="guc-fsync"> n'est pas disponible ou si moins de
   <xref linkend="guc-commit-siblings"> autres sessions sont, à ce
   moment, dans des transactions actives&nbsp;; cela évite de dormir quand
   il est improbable qu'une autre session fasse bientôt une
   validation.  Notez que dans la plupart des plate-formes, la
   résolution d'une requête de sommeil est de 10 millisecondes, donc
   un <varname>commit_delay</varname> différent de zéro et configuré
   entre 1 et 10000 micro-secondes aura le même effet.  Les bonnes
   valeurs pour ce paramètre ne sont pas encore claires&nbsp;; les essais
   sont encouragés.
  </para>

  <para>
   Le paramètre <xref linkend="guc-wal-sync-method"> détermine comment 
   <productname>PostgreSQL</productname> demandera au noyau de forcer les mises
   à jour <acronym>WAL</acronym> sur le disque. Toutes les options devraient
   être les mêmes dans la mesure où la fiabilité ne disparaît pas,
   mais c'est avec des options spécifiques à la plate-forme que ça
   sera le plus rapide.  Notez que ce paramètre est ignoré si
   <varname>fsync</varname> a été désactivé.
  </para>

  <para>
   Configurer le paramètre <xref linkend="guc-wal-debug"> avec une
   valeur différente de zéro aura pour résultat d'enregistrer dans les
   journaux du serveur l'appel WAL à chaque <function>LogInsert</function>
   et <function>LogFlush</function>.  En ce moment, il n'est fait
   aucune différence entre les valeurs supérieures à zéro.  Cette
   option pourra être remplacée par un mécanisme plus général dans le
   futur.
  </para>
   <para>
   Activer le paramètre de configuration <xref linkend="guc-wal-debug"> (en
   supposant que <productname>PostgreSQL</productname> ait été compilé avec son
   support) résultera dans l'enregistrement de chaque appel
   <acronym>WAL</acronym> à <function>LogInsert</function> et
   <function>LogFlush</function> dans les journaux du serveur. Cette option
   pourrait être remplacée par un mécanisme plus général dans le futur.
  </para>
</sect1>

 <sect1 id="wal-internals">
  <title>Internes</title>

  <para>
   <acronym>WAL</acronym> est automatiquement disponible&nbsp;; aucune
   action n'est requise de la part de l'administrateur excepté
   de s'assurer que l'espace disque requis par les journaux
   WAL est présent et que tous les réglages sont faits (regardez
   la <xref linkend="wal-configuration">).
  </para>

  <para>
   Les journaux <acronym>WAL</acronym> sont stockés dans le répertoire
   <filename>pg_xlog</filename> sous le répertoire de données, comme un ensemble
   de fichiers segments, chacun d'une taille de 16&nbsp;Mo normalement. Chaque
   segment est divisé en pages de normalement 8&nbsp;Ko. Les en-têtes de
   l'entrée du journal sont décrites dans
   <filename>access/xlog.h</filename>&nbsp;; le contenu de l'entrée dépend
   du type de l'événement qui est enregistré.  Les fichiers segments
   sont nommés avec un chiffre qui est toujours incrémenté et qui
   commence à <filename>000000010000000000000000</filename>.  Les nombres ne
   bouclent pas à présent, mais cela devrait prendre beaucoup de temps
   pour épuiser le stock de nombres disponibles.
  </para>

  <para>
   Les tampons <acronym>WAL</acronym> et la structure de contrôle sont
   situés dans la mémoire partagée et sont manipulés par les processus
   enfants du serveur. Ils sont protégés par des verrous légers.  La
   demande en mémoire partagée est dépendante du nombre de tampons.
   La taille par défaut des tampons <acronym>WAL</acronym> est 8
   tampons de 8&nbsp;Ko chacun, soit 64&nbsp;Ko au total.
  </para>

  <para>
   Il est avantageux que le journal soit situé sur un autre disque que
   celui des fichiers principaux de la base de données.  Cela peut
   être réalisé en déplaçant le répertoire
   <filename>pg_xlog</filename> vers un autre emplacement (alors que
   le serveur est arrêté naturellement) et en créant un lien
   symbolique de l'endroit d'origine dans le répertoire principal de
   données au nouvel emplacement.
  </para>

  <para>
   Le but de <acronym>WAL</acronym>, s'assurer que le journal est écrit
   avant l'altération des entrées dans la base, peut être renversé par
   les lecteurs des disques<indexterm><primary>disques durs</></> qui
   faussement rapportent une écriture
   réussie au noyau quand, en fait, ils ont seulement mis en cache
   les données et ne les ont pas encore stockées sur le disque.  Une
   coupure de courant dans ce genre de situation peut toujours mener à
   la corruption irrécupérable des données.  Les administrateurs
   devraient s'assurer que les disques contenant les journaux
   <acronym>WAL</acronym> de <productname>PostgreSQL</productname> ne
   produisent pas ce genre de faux rapports.
  </para>

  <para>
   Après qu'un point de contrôle ait été fait et que le journal a été
   écrit, la position du point de contrôle est sauvegardée dans le
   fichier <filename>pg_control</filename>.  Donc, quand la
   restauration doit être faite, le serveur lit en premier
   <filename>pg_control</filename> et ensuite l'entrée du point de
   contrôle&nbsp;; ensuite, il exécute l'opération REDO en parcourant vers
   l'avant à partir de la position du journal indiquée dans l'entrée du
   point de contrôle. Parce que l'ensemble du contenu des pages de
   données est sauvegardé dans le journal à la première modification de
   page après un point de contrôle, toutes les pages changées depuis
   le point de contrôle seront restaurées dans un état cohérent.
  </para>

  <para>
   Pour gérer le cas où <filename>pg_control</filename> est corrompu, nous
   devons supporter la possibilité de parcourir des segments de journaux
   existants en ordre inverse &mdash; de plus récent au plus ancien &mdash; pour
   trouver le dernier point de vérification. Ceci n'a pas encore été implémenté.
   <filename>pg_control</filename> est assez petit (moins d'une page disque)
   pour ne pas être sujet aux problèmes d'écriture partielle et, au moment où
   ceci est écrit, il n'y a eu aucun rapport d'échecs de la base de données
   uniquement à cause de son incapacité à lire <filename>pg_control</filename>.
   Donc, bien que cela soit théoriquement un point faible,
   <filename>pg_control</filename> ne semble pas être un problème en pratique.
  </para>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
