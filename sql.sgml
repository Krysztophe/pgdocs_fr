<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/sql.sgml,v 1.7 2005/09/15 07:03:23 guillaume Exp $
-->

 <chapter id="sql-intro">
  <title>SQL</title>

  <abstract>
   <para>
    Ce chapitre introduit les concepts mathématiques sur lesquels
    s'appuient les bases de données relationnelles. Il n'est pas
    requis de le lire, donc si vous vous enlisez ou si vous voulez
    obtenir directement des exemples simples, vous pouvez aller directement
    au prochain chapitre et revenir quand vous aurez
    plus de temps et de patience. Ce truc est supposé être
    amusant&nbsp;!
   </para>

   <para>
    Ce contenu est à l'origine extrait de la thèse de Master de
    Stefan Simkovics (<xref linkend="sim98" endterm="sim98"/>).
   </para>
  </abstract>

  <para>
   <acronym>SQL</acronym> est devenu le langage d'interrogation
   relationnel le plus populaire. Le nom
   <quote><acronym>SQL</acronym></quote> est une abréviation pour
   <firstterm>Structured Query Language</firstterm> (Langage de
   requêtes structuré). En 1974, Donald Chamberlin et d'autres
   personnes de chez IBM Research ont défini le langage SEQUEL
   (<firstterm>Structured English Query Language</firstterm>). Ce
   langage a d'abord été implémenté dans un prototype d'IBM appelé
   SEQUEL-XRM en 1974-75. En 1976-77, une version révisée de SEQUEL
   appelée SEQUEL/2 a été définie et le nom fut changé en
   <acronym>SQL</acronym> par la suite.
  </para>

  <para>
   Un nouveau prototype appelé System R a été développé par IBM en
   1977. System R implémentait un large sous-ensemble de SEQUEL/2
   (maintenant <acronym>SQL</acronym>) et de nombreux changements ont
   été apportés à <acronym>SQL</acronym> durant ce projet. System R a été
   installé dans un certain nombre de sites utilisateurs, à la fois
   sur les sites internes d'IBM et sur certains sites clients
   sélectionnés. Grâce au succès et à l'acceptation du System R sur
   ces sites utilisateurs, IBM commença à développer des produits
   commerciaux basés sur la technologie du System R et qui
   implémentaient le langage <acronym>SQL</acronym>.
  </para>

  <para>
   Au cours des années suivantes, IBM et aussi un certain nombre
   d'autres fournisseurs ont annoncé des produits
   <acronym>SQL</acronym> comme
   <productname>SQL/DS</productname> (IBM),
   <productname>DB2</productname> (IBM),
   <productname>ORACLE</productname> (Oracle Corp.),
   <productname>DG/SQL</productname> (Data General Corp.),
   et <productname>SYBASE</productname> (Sybase Inc.).
  </para>

  <para>
   Maintenant <acronym>SQL</acronym> est aussi une norme officielle.
   En 1982, l'American National Standards Institute
   (<acronym>ANSI</acronym>) demanda à son comité chargé des bases
   de données (X3H2) de développer une proposition pour un langage
   relationnel standard. Cette proposition a été ratifiée en 1986
   et comprenait essentiellement le dialecte d'IBM pour
   <acronym>SQL</acronym>. En 1987, cette norme
   <acronym>ANSI</acronym> a été aussi acceptée comme norme
   internationale par l'International Organization for Standardization
   (<acronym>ISO</acronym>). Cette version originale de la norme de
   <acronym>SQL</acronym> est souvent désignée, officieusement, sous
   le nom <quote><abbrev>SQL/86</abbrev></quote>. En 1989, la norme
   d'origine a été etendue et cette nouvelle norme est souvent
   désignée, une fois encore officieusement, sous le nom
   <quote><abbrev>SQL/89</abbrev></quote>. Egalement en 1989, un
   standard lié appelé
   <firstterm>Database Language Embedded <acronym>SQL</acronym></firstterm>
   (<acronym>ESQL</acronym>) a été développé.
  </para>

  <para>
   Les comités <acronym>ISO</acronym> et <acronym>ANSI</acronym> ont
   travaillé pendant de nombreuses années sur la définition d'une
   version considérablement étendue de la norme d'origine, désignée
   officieusement <firstterm><acronym>SQL2</acronym></firstterm> ou
   <firstterm><acronym>SQL/92</acronym></firstterm>. Cette version
   est devenue une norme approuvée -
   <quote>International Standard ISO/IEC 9075:1992,
   Language de Bases de Données <acronym>SQL</acronym></quote> - vers
   la fin de 1992. <acronym>SQL/92</acronym> est la version
   normalement sous-entendue quand les gens parlent de
   <quote>la norme <acronym>SQL</acronym></quote>. Une description
   détaillée de <acronym>SQL/92</acronym> est donnée dans
   <xref linkend="date97" endterm="date97"/>. Au moment où ce document
   est écrit, une nouvelle norme désignée officieusement sous le nom
   de <firstterm><acronym>SQL3</acronym></firstterm> est en
   développement. Il est prévu de faire de <acronym>SQL</acronym> un
   langage de Turing complet, c'est-à-dire que toutes les requêtes
   calculables (par exemple les requêtes récursives) seront possibles.
   Ceci est maintenant terminé avec SQL:2003.
  </para>

  <sect1 id="rel-model">
   <title>Le Modèle Relationnel de Données</title>

  <para>
    Comme mentionné précédemment, <acronym>SQL</acronym> est un
    langage relationnel. Cela signifie qu'il est basé sur le
    <firstterm>modèle relationnel de données</firstterm> publié pour
    la première fois par E.F. Codd en 1970. Nous donnerons une
    description formelle du modèle relationnel plus tard (dans
    <xref linkend="formal-notion" endterm="formal-notion"/>)
    mais d'abord nous voulons le regarder d'un point de vue plus
    intuitif.
  </para>

  <para>
    Une <firstterm>base de données relationnelle</firstterm> est une
    une base qui est perçue par ses utilisateurs comme une
    <firstterm>collection de tables</firstterm> (et rien d'autre que
    des tables). Une table est constituée de lignes et de colonnes où
    chaque ligne représente un enregistrement et chaque colonne
    représente un attribut des enregistrements contenus dans la table.
    <xref linkend="supplier-fig" endterm="supplier-fig"/> montre un
    exemple d'une base constituée par trois tables&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       FOURNISSEUR est une table qui contient le numéro (FNUM), le nom
       (FNOM) et la ville (VILLE) des fournisseurs.
      </para>
     </listitem>

     <listitem>
      <para>
       PIECE est la table qui contient le numéro (PNUM), le nom (PNOM)
       et le prix (PRIX) des pièces.
      </para>
     </listitem>

     <listitem>
      <para>
       VENTES stocke l'information&nbsp;: quelle pièce (PNUM) est vendue par
       quel fournisseur (FNUM). Elle sert dans un sens à relier les
       deux autres tables ensemble.
      </para>
     </listitem>
    </itemizedlist>

    <example>
     <title id="supplier-fig">La base de données des fournisseurs et des pièces</title>
     <programlisting>
FOURNISSEUR:                VENTES:
 FNUM |  FNOM   | VILLE      FNUM | PNUM
------+---------+--------   ------+------
  1   |  Smith  | Londre       1  |  1
  2   |  Jones  | Paris        1  |  2
  3   |  Adams  | Vienne       2  |  4
  4   |  Blake  | Rome         3  |  1
                               3  |  3
                               4  |  2
PIECE:                         4  |  3
 PNUM |  PNOM  |  PRIX         4  |  4
------+--------+--------
  1   | Vis    |   10
  2   | Ecrou  |    8
  3   | Boulon |   15
  4   | Came   |   25
     </programlisting>
    </example>
   </para>

   <para>
    Les tables PIECE et FOURNISSEUR peuvent être considérées comme
    des <firstterm>entités</firstterm> et VENTES peut être considérée
    comme une <firstterm>relation</firstterm> entre une pièce
    particulière et un fournisseur particulier.
   </para>

   <para>
    Nous verrons plus tard, comment <acronym>SQL</acronym> opère sur
    des tables comme celles définies au dessus mais auparavant nous
    étudierons la théorie du modèle relationnel.
   </para>
  </sect1>

  <sect1 id="relmodel-formal">
   <title id="formal-notion">Formalisation du Modèle Relationnel de Données</title>

   <para>
    Le concept mathématique fondamental du modèle relationnel est la
    <firstterm>relation</firstterm>, définie dans la théorie des
    ensembles, qui est un sous-ensemble du produit cartésien d'une
    liste de domaines. Cette relation, dépendant de la théorie des
    ensembles, donne au modèle son nom (ne le confondez pas avec la
    relation du <firstterm>modèle entité-relation</firstterm>).
    Formellement, un domaine est simplement un ensemble de valeurs.
    Par exemple l'ensemble des entiers est un domaine. L'ensemble des
    chaînes de caractères de longueur 20 et les nombres réels sont
    également des exemples de domaines.
   </para>

   <para>
<!--
\begin{definition}
Le <firstterm>produit cartésien</firstterm> des domaines $D_{1},
    D_{2},\ldots, D_{k}$ écrit
\mbox{$D_{1} \times D_{2} \times \ldots \times D_{k}$} est l'emsemble
de tous les $k$-tuples $(v_{1},v_{2},\ldots,v_{k})$ tel que \mbox{$v_{1} \in
D_{1}, v_{2} \in D_{2}, \ldots, v_{k} \in D_{k}$}.
\end{definition}
-->
    Le <firstterm>produit cartésien</firstterm> des domaines
    <parameter>D<subscript>1</subscript></parameter>,
    <parameter>D<subscript>2</subscript></parameter>,
    ...
    <parameter>D<subscript>k</subscript></parameter>,
    écrit
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>
    est l'ensemble de tous les k-tuples &lt;
    <parameter>v<subscript>1</subscript></parameter>,
    <parameter>v<subscript>2</subscript></parameter>,
    ...
    <parameter>v<subscript>k</subscript></parameter> &gt;,
    tel que
    <parameter>v<subscript>1</subscript></parameter> &isin; 
    <parameter>D<subscript>1</subscript></parameter>,
    <parameter>v<subscript>2</subscript></parameter> &isin; 
    <parameter>D<subscript>2</subscript></parameter>,
    ...
    <parameter>v<subscript>k</subscript></parameter> &isin; 
    <parameter>D<subscript>k</subscript></parameter>.
   </para>

   <para>
    Par exemple, quand nous avons
<!--
 $k=2$, $D_{1}=\{0,1\}$ et
$D_{2}=\{a,b,c\}$, alors $D_{1} \times D_{2}$ est
$\{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)\}$.
-->
    <parameter>k</parameter>=2,
    <parameter>D<subscript>1</subscript></parameter>=<literal>{0,1}</literal> et
    <parameter>D<subscript>2</subscript></parameter>=<literal>{a,b,c}</literal> alors
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> est
    <literal>{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)}</literal>.
   </para>

   <para>
<!--
\begin{definition}
Une relation est n'importe quel sous-ensemble d'un produit cartésien
de un ou plusieurs domaines : $R \subseteq$ \mbox{$D_{1} \times D_{2} \times \ldots \times D_{k}$}
\end{definition}
-->
    Une relation est n'importe quel sous-ensemble d'un produit
    cartésien de un ou plusieurs domaines&nbsp;:
    <parameter>R</parameter> &sube;
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>.
   </para>

   <para>
    Par exemple <literal>{(0,a),(0,b),(1,a)}</literal> est une
    relation ; c'est en fait un sous-ensemble de
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter>
    mentionné ci-dessus.
   </para>

   <para>
    Les membres de la relation sont appelés tuples. On dit que chaque
    relation d'un produit cartésien
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>
    a <literal>k</literal> arité et est donc un ensemble de
    k-tuples.
   </para>

   <para>
    Une relation peut être vue comme une table (comme nous l'avons
    déjà dit, rappelez vous
    <xref linkend="supplier-fig" endterm="supplier-fig"/> où
    chaque tuple est représenté par une ligne et chaque colonne
    correspond à un composant du tuple. Donner des noms (appelés
    attributs) aux colonnes mène à la définition d'un
    <firstterm>schéma de relations</firstterm>.
   </para>

   <para>
<!--
\begin{definition}
Un {\it schéma de relations} $R$ est un ensemble fini d'attributs
\mbox{$\{A_{1},A_{2},\ldots,A_{k}\}$}. Il y a un domaine $D_{i}$ pour
chaque attribut $A_{i}, 1 \le i \le k$ d'où les valeurs des attributs
sont prises. Nous écrivons souvent un schéma de relations de la façon
suivante&nbsp;:
\mbox{$R(A_{1},A_{2},\ldots,A_{k})$}.
\end{definition}
-->
    Un <firstterm>schéma de relations</firstterm> <literal>R</literal>
    est un ensemble fini d'attributs 
    <parameter>A<subscript>1</subscript></parameter>,
    <parameter>A<subscript>2</subscript></parameter>,
    ...
    <parameter>A<subscript>k</subscript></parameter>.
    Il y a un domaine
    <parameter>D<subscript>i</subscript></parameter>,
    pour chaque attribut
    <parameter>A<subscript>i</subscript></parameter>
    (1 &lt;= <literal>i</literal> &lt;= <literal>k</literal>)
    d'où les valeurs des attributs sont prises. Nous écrivons souvent
    un schéma de relations de la façon suivante&nbsp;:
    <literal>R(<parameter>A<subscript>1</subscript></parameter>,
    <parameter>A<subscript>2</subscript></parameter>,
    ...
    <parameter>A<subscript>k</subscript></parameter>)</literal>.

    <note>
     <para>
      Un <firstterm>schéma de relation</firstterm> est juste une sorte
      de modèle où <firstterm>relation</firstterm> est une instance
      d'un <firstterm>schéma de relations</firstterm>. La relation
      est constituée de tuples (et ils peuvent donc être vus comme une
      table) ; ce n'est pas le cas du schéma de relations. 
     </para>
    </note>
   </para>

   <sect2>
    <title id="domains">Domaines contre types de données</title>

    <para>
     Nous avons souvent parlé de <firstterm>domaines</firstterm> dans
     la section précédente. Rappelons qu'un domaine est,
     formellement, juste un ensemble de valeurs (par exemple,
     l'ensemble des entiers ou des nombres réels). En termes de
     systèmes de bases de données nous parlons souvent de
     <firstterm>types de données</firstterm> au lieu de domaines.
     Quand nous définissons une table, nous devons prendre une
     décision à propos de quels attributs inclure. De plus, nous
     avons à décider quel type de données va être stocké comme
     attribut des valeurs. Par exemple les valeurs de
     <classname>FNOM</classname> de la table
     <classname>FOURNISSEUR</classname> seront des chaînes de
     caractères, tandis que <classname>FNUM</classname> stockera des
     entiers. Nous définissons cela en assignant un type de données à
     chaque attribut. Le type de <classname>FNOM</classname> sera
     <type>VARCHAR(20)</type> (ceci est le type <acronym>SQL</acronym>
     pour les chaînes de caractères de longueur &lt;= 20), le type de
     <classname>FNUM</classname> sera <type>INTEGER</type>. Avec
     l'assignation d'un type de données, nous avons aussi sélectionné
     un domaine pour l'attribut. Le domaine de
     <classname>FNOM</classname> est l'ensemble de toutes les chaînes
     de caractères de longueur &lt;= 20, le domaine de
     <classname>FNUM</classname> est l'ensemble de tous les nombres
     entiers.
    </para>
   </sect2>
  </sect1>

  <sect1 id="relmodel-oper">
   <title id="operations">Operations dans un Modèle Relationnel de Données</title>

   <para>
    Dans la section précédente
    (<xref linkend="formal-notion" endterm="formal-notion"/>) nous
    avons défini la notion mathématique d'un modèle relationnel.
    Maintenant nous savons comment les données peuvent être stockées
    en utilisant un modèle relationnel de données mais nous ne
    connaissons pas encore comment faire avec toutes ces tables pour
    retrouver quelque chose dans la base. Par exemple quelqu'un peut
    demander le nom de tous les fournisseurs qui vendent la pièce
    'Vis'. Par conséquent, deux genres différents de notations pour
    exprimer les opérations sur des relations ont été définis&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       L'<firstterm>Algébre Relationnelle</firstterm> qui est une
       notation algébrique, où les requêtes sont exprimées en
       appliquant des opérateurs spécialisés aux relations.
      </para>
     </listitem>

     <listitem>
      <para>
       Le <firstterm>Calcul Relationnel</firstterm> qui est une
       notation logique, où les requêtes sont exprimées en formulant
       des restrictions logiques que les tuples, dans la réponse,
       doivent satisfaire.
      </para>
    </listitem>
    </itemizedlist>
   </para>

   <sect2>
    <title id="rel-alg">Algébre relationnelle</title>

    <para>
     L'<firstterm>Algébre Relationnelle</firstterm> fût introduite par
     E. F. Codd en 1972. Elle est constituée d'un ensemble d'opérations
     sur les relations&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        SELECT (&sigma;)&nbsp;: extrait les <firstterm>tuples</firstterm>
        d'une relation qui satisfait une restriction donnée. Soit
        <parameter>R</parameter> une table qui contient un attribut
        <parameter>A</parameter>.
	&sigma;<subscript>A=a</subscript>(R) = {t &isin; R &mid; t(A) = a}
        où <literal>t</literal> dénote un tuple de
        <parameter>R</parameter> et <literal>t(A)</literal> dénote la
        valeur de l'attribut <parameter>A</parameter> du tuple
        <literal>t</literal>.
       </para>
      </listitem>

      <listitem>
       <para>
        PROJECT (&pi;)&nbsp;: extrait des <firstterm>attributes</firstterm>
        (colonnes) spécifiques de la relation. Soit
        <classname>R</classname> la relation qui contient un attribut
        <classname>X</classname>.
        &pi;<subscript>X</subscript>(<classname>R</classname>) = {t(X) &mid; t &isin; <classname>R</classname>},
        où <literal>t</literal>(<classname>X</classname>) dénote la
        valeur de l'attribut <classname>X</classname> du tuple
        <literal>t</literal>.
       </para>
      </listitem>

      <listitem>
       <para>
        PRODUCT (&times;)&nbsp;: construit le produit cartésien de deux
        relations. Soit <classname>R</classname> une table d'arité
        (nombre d'attributs)
        <literal>k</literal><subscript>1</subscript> et
        <classname>S</classname> une table d'arité
        <literal>k</literal><subscript>2</subscript>.
        <classname>R</classname> &times; <classname>S</classname> est
        l'ensemble de tous les 
        <literal>k</literal><subscript>1</subscript>
        + <literal>k</literal><subscript>2</subscript>-tuples dont les
        premiers composants
        <literal>k</literal><subscript>1</subscript> forment un tuple
        dans <classname>R</classname> et dont les derniers composants
        <literal>k</literal><subscript>2</subscript> forment un tuple
        dans <classname>S</classname>.
       </para>
      </listitem>

      <listitem>
       <para>
        UNION (&cup;)&nbsp;: construit l'union (dans le sens de la théorie
        des ensembles) de deux tables. Soit les tables
        <classname>R</classname> et <classname>S</classname>
        (les deux tables doivent avoir la même arité), l'union
        <classname>R</classname> &cup; <classname>S</classname> est
        l'ensemble des tuples qui sont dans <classname>R</classname>,
        ou dans <classname>S</classname>, ou dans les deux tables.
       </para>
      </listitem>

      <listitem>
       <para>
        INTERSECT (&cap;)&nbsp;: contruit l'intersection (dans le sens de
        la théorie des ensembles) de deux tables. Soit les tables
        <classname>R</classname> et <classname>S</classname>,
        <classname>R</classname> &cap; <classname>S</classname> est
        l'ensemble des tuples qui sont dans <classname>R</classname>
        et dans <classname>S</classname>. Il est encore requis que
        <classname>R</classname> et <classname>S</classname> aient la 
        même arité.
       </para>
      </listitem>

      <listitem>
       <para>
        DIFFERENCE (&minus; ou &setmn;)&nbsp;: construit l'ensemble
        de différence de deux tables. Soit <classname>R</classname>
        et <classname>S</classname> deux tables une fois encore avec
        la même arité.
        <classname>R</classname> - <classname>S</classname> est
        l'ensemble des tuples de <classname>R</classname> qui ne
        sont pas dans <classname>S</classname>. 
       </para>
      </listitem>

      <listitem>
       <para>
        JOIN (&prod;)&nbsp;: connecte deux tables par leurs attributs
        communs. Soit <classname>R</classname> une table avec les
        attributs <classname>A</classname>, <classname>B</classname>
        et <classname>C</classname> ; soit <classname>S</classname>
        une table avec les attributs <classname>C</classname>,
        <classname>D</classname> et <classname>E</classname>. Il y a
        un attribut commun aux deux relations, l'attribut
        <classname>C</classname>.
<!--
	<classname>R</classname> &prod; <classname>S</classname> =
	&pi;<subscript><classname>R</classname>.<classname>A</classname>,<classname>R</classname>.<classname>B</classname>,<classname>R</classname>.<classname>C</classname>,<classname>S</classname>.<classname>D</classname>,<classname>S</classname>.<classname>E</classname></subscript>(&sigma;<subscript><classname>R</classname>.<classname>C</classname>=<classname>S</classname>.<classname>C</classname></subscript>(<classname>R</classname> &times; <classname>S</classname>)).
-->
        R &prod; S = &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S)).
        Que faisons nous ici ? Nous calculons d'abord le produit
        cartésien
        <classname>R</classname> &times; <classname>S</classname>.
        Puis nous selectionnons les tuples dont la valeur pour
        l'attribut commun <classname>C</classname> est égale
        (&sigma;<subscript>R.C = S.C</subscript>). Maintenant nous
        avons une table qui contient l'attribut
        <classname>C</classname> deux fois et nous corrigeons cela en
        ne projetant pas la colonne dupliquée.
       </para>

       <example>
        <title id="join-example">Une jointure interne</title>

        <para>
         Regardons les tables qui sont produites lors de l'évaluation
         des étapes nécessaires pour une jointure. Soit les deux
         tables suivantes&nbsp;:

         <programlisting>
R:                 S:
 A | B | C          C | D | E
---+---+---        ---+---+---
 1 | 2 | 3          3 | a | b
 4 | 5 | 6          6 | c | d
 7 | 8 | 9
         </programlisting>
        </para>
       </example>

       <para>
        Nous calculons d'abord le produit cartésien
        <classname>R</classname> &times; <classname>S</classname> et
        obtenons&nbsp;:

	<programlisting>
R x S:
 A | B | R.C | S.C | D | E
---+---+-----+-----+---+---
 1 | 2 |  3  |  3  | a | b
 1 | 2 |  3  |  6  | c | d
 4 | 5 |  6  |  3  | a | b
 4 | 5 |  6  |  6  | c | d
 7 | 8 |  9  |  3  | a | b
 7 | 8 |  9  |  6  | c | d
        </programlisting>
       </para>

       <para>
        Après la sélection
        &sigma;<subscript>R.C=S.C</subscript>(R &times; S)
        nous avons&nbsp;:

        <programlisting>
 A | B | R.C | S.C | D | E
---+---+-----+-----+---+---
 1 | 2 |  3  |  3  | a | b
 4 | 5 |  6  |  6  | c | d
         </programlisting>
       </para>

       <para>
        Pour supprimer la colonne en double
        <classname>S</classname>.<classname>C</classname>
        nous la supprimons de la projection avec l'opération
        suivante&nbsp;:
        &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S))
        et obtenons&nbsp;:

        <programlisting>
 A | B | C | D | E
---+---+---+---+---
 1 | 2 | 3 | a | b
 4 | 5 | 6 | c | d
        </programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
         DIVIDE (&divide;)&nbsp;: Soit <classname>R</classname> une table
         avec les attributs A, B, C et D, et soit
         <classname>S</classname> une table avec les attributs C et D.
         Nous définissons alors la division par&nbsp;:

        <programlisting>
R &divide; S = {t &mid; &forall; t<subscript>s</subscript> &isin; S &exist; t<subscript>r</subscript> &isin; R
        </programlisting>

        tel que
t<subscript>r</subscript>(A,B)=t&and;t<subscript>r</subscript>(C,D)=t<subscript>s</subscript>}
        où t<subscript>r</subscript>(x,y) dénote un tuple de la table
        <classname>R</classname> qui est seulement constitué des
        composants <literal>x</literal> et <literal>y</literal>.
        Notez que le tuple <literal>t</literal> est uniquement
        constitué des composants <classname>A</classname> et
        <classname>B</classname> de la relation
        <classname>R</classname>.
       </para>

       <para id="divide-example">
        Soit les tables suivantes&nbsp;:

        <programlisting>
R:                    S:
 A | B | C | D         C | D
---+---+---+---       ---+---
 a | b | c | d         c | d
 a | b | e | f         e | f
 b | c | e | f
 e | d | c | d
 e | d | e | f
 a | b | d | e
        </programlisting>

        R &divide; S donne

        <programlisting>
 A | B
---+---
 a | b
 e | d
        </programlisting>
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Pour une description et une définition de l'algèbre relationnelle
     plus détaillées référez-vous à
     [<xref linkend="ull88" endterm="ull88"/>] ou
     [<xref linkend="date04" endterm="date04"/>].
    </para>

    <example>
     <title id="suppl-rel-alg">Une requête utilisant l'algèbre relationnelle</title>
     <para>
      Rappelons que nous avons formulé tous ces opérateurs
      relationnels pour être capable de retrouver des données depuis
      une base. Retournons à notre exemple de la section précédente
      (<xref linkend="operations" endterm="operations"/>) où quelqu'un
      veut savoir le nom de tous les fournisseurs qui vendent la pièce
      <literal>Vis</literal>. Cette question peut être posée, en
      utilisant l'algèbre relationnelle, par les opérateurs suivants&nbsp;:

      <programlisting>
&pi;<subscript>FOURNISSEUR.FNOM</subscript>(&sigma;<subscript>PIECE.PNOM='Vis'</subscript>(FOURNISSEUR &prod; VENTES &prod; PIECE))
      </programlisting>
     </para>

     <para>
      Nous appelons cette opération une requête. Si nous évaluons la
      requête précédente sur nos tables d'exemples
      (<xref linkend="supplier-fig" endterm="supplier-fig"/>) nous
      obtiendrons le résultat suivant&nbsp;:

      <programlisting>
 FNOM
-------
 Smith
 Adams
      </programlisting>
     </para>
    </example>
   </sect2>

   <sect2 id="rel-calc">
    <title>Calcul relationnel</title>

    <para>
     Le calcul relationnel est basé sur la
     <firstterm>logique du premier ordre</firstterm>. Il y a deux
     variantes du calcul relationnel&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        Le <firstterm>Domain Relational Calculus</firstterm>
        (<acronym>DRC</acronym>) (calcul relationnel de domaine), où
        les variables représentent les composants (attributs) des
        tuples.
       </para>
      </listitem>

      <listitem>
       <para>
        Le <firstterm>Tuple Relational Calculus</firstterm>
        (<acronym>TRC</acronym>) (calcul relationnel de tuple), où les
        variables représentent les tuples.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Nous voulons seulement parler du calcul relationnel de tuple
     parce que c'est un des fondements de la plupart des langages
     relationnels. Pour plus de détails sur <acronym>DRC</acronym> (et
     aussi <acronym>TRC</acronym>) regardez
     <xref linkend="date04" endterm="date04"/> ou
     <xref linkend="ull88" endterm="ull88"/>.
    </para>
   </sect2>

   <sect2>
    <title>Calcul relationnel de tuple</title>

    <para>
     Les requêtes utilisées dans <acronym>TRC</acronym> sont de la
     forme suivante&nbsp;:

     <programlisting>
x(A) &mid; F(x)
     </programlisting>

     où <literal>x</literal> est un tuple variable,
     <classname>A</classname> est un ensemble d'attributs et
     <literal>F</literal> est une formule. La relation résultante est
     constituée de tous les tuples <literal>t(A)</literal> qui
     satisfont <literal>F(t)</literal>.
    </para>

    <para>
     Si nous voulons répondre à la question de l'exemple
     <xref linkend="suppl-rel-alg" endterm="suppl-rel-alg"/> en
     utilisant <acronym>TRC</acronym> nous formulons la requête
     suivante&nbsp;:

     <programlisting>
{x(FNOM) &mid; x &isin; FOURNISSEUR &and;
    &exist; y &isin; VENTES &exist; z &isin; PIECE (y(FNUM)=x(FNUM) &and;
    z(PNUM)=y(PNUM) &and;
    z(PNOM)='Vis')}
     </programlisting>
    </para>

    <para>
     L'évaluation de la requête sur les tables de
     <xref linkend="supplier-fig" endterm="supplier-fig"/>
     mène, une fois encore, au même résultat que dans
     <xref linkend="suppl-rel-alg" endterm="suppl-rel-alg"/>.
    </para>
   </sect2>

   <sect2 id="alg-vs-calc">
    <title>Algèbre relationnelle contre calcul relationnel</title>

    <para>
     L'algèbre relationnelle et le calcul relationnel ont la même
     <firstterm>puissance d'expression</firstterm> ; c'est-à-dire que
     toutes les requêtes qui peuvent être formulées en utilisant
     l'algèbre relationnelle peuvent aussi l'être en utilisant le calcul
     relationnel et vice versa. Ceci fût en premier prouvé par
     E. F. Codd en 1972. Cette preuve est fondée sur un algorithme
     (<quote>algorithme de réduction de Codd</quote>) par lequel une
     expression arbitraire de calcul relationnel peut être reduite à
     une expression d'algèbre relationnelle sémantiquement équivalente.
     Pour plus de détails sur cela, reférez-vous à
     <xref linkend="date04" endterm="date04"/> et
     <xref linkend="ull88" endterm="ull88"/>.
    </para>

    <para>
     Il a parfois été dit que les langages basés sur le calcul
     relationnel sont de <quote>haut niveau</quote> ou <quote>plus
     déclaratif</quote> que les langages basés sur l'algèbre
     relationnelle parce que l'algèbre spécifie (partiellement) l'ordre
     des opérations tandis que le calcul relationnel laisse le
     compilateur ou l'interpréteur déterminer l'ordre d'évaluation
     le plus efficace.
    </para>
   </sect2>
  </sect1>

  <sect1 id="sql-language">
   <title>Le langage <acronym>SQL</acronym></title>

   <para>
    Comme c'est le cas avec beaucoup de langages relationnels
    modernes, <acronym>SQL</acronym> est basé sur le calcul
    relationnel de tuple. Cela a pour conséquence que chaque requête
    qui peut être formulée en utilisant le calcul relationnel de tuple
    (ou son équivalent, l'algèbre relationnelle) peut aussi être
    formulée en utilisant <acronym>SQL</acronym>. Cependant
    <acronym>SQL</acronym> a des possibilités au delà de la portée de
    l'algèbre ou du calcul relationnel. Voici une liste de
    fonctionnalités supplémentaires fournies par
    <acronym>SQL</acronym> et qui ne font pas partie de l'algèbre ou
    du calcul relationnels&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Commandes pour l'insertion, la suppression ou la modification
       des données.
      </para>
     </listitem>

     <listitem>
      <para>
       Possibilités arithmétiques&nbsp;: dans <acronym>SQL</acronym> il est
       possible d'inclure des opérations arithmétiques aussi bien que
       des comparaisons, par exemple

       <programlisting>
A &lt; B + 3.
       </programlisting>

       Notez que + et les autres opérateurs arithmétiques
       n'apparaissent ni dans l'algèbre relationnelle ni dans le calcul
       relationnel.
      </para>
     </listitem>

     <listitem>
      <para>
       Commandes d'allocation et d'impression&nbsp;: il est possible
       d'imprimer une relation construite par une requête et d'affecter
       un nom à une relation calculée.
      </para>
     </listitem>

     <listitem>
      <para>
       Fonctions d'agrégat&nbsp;: les opérations comme
       <firstterm>average</firstterm> (moyenne),
       <firstterm>sum</firstterm> (somme),
       <firstterm>max</firstterm> (maximum), etc. peuvent être
       appliqués aux colonnes d'une relation pour obtenir une
       quantité unique.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect2 id="select">
    <title id="select-title">Select</title>

    <para>
     La commande la plus souvent utilisée en <acronym>SQL</acronym>
     est l'instruction <command>SELECT</command>, servant à retrouver
     les données. La syntaxe est&nbsp;:

     <synopsis>
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="PARAMETER">expression_distincte</replaceable> [, ...] ) ] ]
    * | <replaceable class="PARAMETER">expression_cible</replaceable> [ AS <replaceable class="PARAMETER">nom_résultat</replaceable> ] [, ...]
    [ INTO [ TEMPORARY | TEMP ] [ TABLE ] <replaceable class="PARAMETER">nouvelle_table</replaceable> ]
    [ FROM <replaceable class="PARAMETER">source</replaceable> [, ...] ]
    [ WHERE <replaceable class="PARAMETER">condition</replaceable> ]
    [ GROUP BY <replaceable class="PARAMETER">expression_agrégat</replaceable> [, ...] ]
    [ HAVING <replaceable class="PARAMETER">condition_agrégat</replaceable> [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class="PARAMETER">select</replaceable> ]
    [ ORDER BY <replaceable class="PARAMETER">expression_tri</replaceable> [ ASC | DESC | USING <replaceable class="PARAMETER">opérateur</replaceable> ] [, ...] ]
    [ LIMIT { <replaceable class="PARAMETER">compte</replaceable> | ALL } ]
    [ OFFSET <replaceable class="PARAMETER">début</replaceable> ]
    [ FOR { UPDATE | SHARE } [ OF <replaceable class="parameter">nom_table</replaceable> [, ...] ] [ NOWAIT ] ]
     </synopsis>
    </para>

    <para>
     Maintenant nous allons illustrer la syntaxe complexe de
     l'instruction <command>SELECT</command> avec différents exemples.
     Les tables utilisées sont définies dans
     <xref linkend="supplier-fig" endterm="supplier-fig"/>.
    </para>

    <sect3>
     <title>Selects simples</title>

     <para>
      Voici quelques exemples simples utilisant l'instruction
      <command>SELECT</command>&nbsp;:

      <example>
       <title id="simple-query">Requête simple avec qualification</title>
       <para>
        Pour retrouver tous les tuples de la table PIECE où l'attribut
        PRIX est supérieur à 10, nous formulons la requête suivante&nbsp;:

        <programlisting>
SELECT * FROM PIECE
    WHERE PRIX &gt; 10;
        </programlisting>

        et nous obtenons la table&nbsp;:

        <programlisting>
 PNUM |  PNOM   |  PRIX
------+---------+--------
  3   |  Boulon |   15
  4   |  Came   |   25
        </programlisting>
       </para>

       <para>
        Utiliser <quote>*</quote> dans l'instruction
        <command>SELECT</command> donnera tous les attributs de la
        table. Si nous voulons retrouver seulement les attributs
        PNNOM et PRIX de la table PIECE nous utilisons l'instruction&nbsp;:

        <programlisting>
SELECT PNOM, PRIX 
    FROM PIECE
    WHERE PRIX &gt; 10;
        </programlisting>

        Dans ce cas, le résultat est&nbsp;:

        <programlisting>
                       PNOM  |  PRIX
                     --------+--------
                      Boulon |   15
                      Came   |   25
        </programlisting>

        Notez que le <command>SELECT</command>
        d'<acronym>SQL</acronym> correspond à la
        <quote>projection</quote> en algèbre relationnelle et non pas à
        une <quote>sélection</quote> (pour plus de détails, regardez
        <xref linkend="rel-alg" endterm="rel-alg"/>).
       </para>

       <para>
        Les qualifications dans la clause WHERE peuvent aussi être
        connectées logiquement en utilisant les mots-clé OR, AND et
        NOT&nbsp;:

        <programlisting>
SELECT PNOM, PRIX 
    FROM PIECE
    WHERE PNOM = 'Boulon' AND
         (PRIX = 0 OR PRIX &lt;= 15);
        </programlisting>

	mènera au résultat&nbsp;:

        <programlisting>
  PNOM  |  PRIX
--------+--------
 Boulon |   15
        </programlisting>
       </para>

       <para>
        Les opérations arithmétiques peuvent être utilisées dans la
        liste cible et dans la clause WHERE. Par exemple si nous
        voulons savoir combien cela coûterait si nous prenions deux
        unités de chaque pièce, nous pouvons utiliser la requête
        suivante&nbsp;:

        <programlisting>
SELECT PNOM, PRIX * 2 AS DOUBLE
    FROM PIECE
    WHERE PRIX * 2 &lt; 50;
        </programlisting>

        et nous obtenons&nbsp;:

        <programlisting>
 PNOM   |  DOUBLE
--------+---------
 Vis    |    20
 Ecrou  |    16
 Boulon |    30
       </programlisting>

        Notez que le mot DOUBLE après le mot-clé AS est le nouveau
        titre de la seconde colonne. Cette technique peut être
        utilisée pour chaque élément de la liste cible pour assigner
        un nouveau titre au résultat d'une colonne. Ce nouveau titre
        est souvent utilisé comme alias. Un alias ne peut pas être
        employé dans le reste de la requète.
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>Jointure</title>

     <para id="simple-join">
      L'exemple suivant montre comment les
      <firstterm>jointures</firstterm> sont réalisées en
      <acronym>SQL</acronym>.
     </para>

     <para>
      Pour joindre les trois tables FOURNISSEUR, PIECE et VENTES grâce
      à leurs attributs communs, nous formulons la requête suivante&nbsp;:

      <programlisting>
SELECT F.FNOM, P.PNOM
    FROM FOURNISSEUR F, PIECE P, VENTES VE
    WHERE F.FNUM = VE.FNUM AND
          P.PNUM = VE.PNUM;
      </programlisting>

      et nous obtenons la table suivante en résultat&nbsp;:

      <programlisting>
 FNOM  | PNOM
-------+-------
 Smith | Vis
 Smith | Ecrou
 Jones | Came
 Adams | Vis
 Adams | Boulon
 Blake | Ecrou
 Blake | Boulon
 Blake | Came
      </programlisting>
     </para>

     <para>
      Dans la clause FROM nous avons introduit les alias pour chaque
      relation parce qu'elles ont des noms d'attributs communs
      (FNUM et PNUM). Maintenant nous pouvons faire une distinction
      entre les noms d'attributs communs en préfixant simplement le
      nom de l'attribut avec l'alias suivi d'un point. La jointure
      est calculée de la même façon que ce qui a été montré dans
      <xref linkend="join-example" endterm="join-example"/>. D'abord
      le produit cartésien

      FOURNISSEUR &times; PIECE &times; VENTES

      est calculé. Ensuite, seulement les tuples qui satisfont les
      conditions données dans la clause WHERE sont sélectionnés
      (c'est-à-dire que les attributs avec un nom commun doivent être
      égaux). Enfin, nous projetons seulement F.FNOM et P.PNOM.
     </para>

     <para>
      Une autre manière d'exécuter des jointures est d'utiliser la
      syntaxe SQL JOIN comme suit&nbsp;:
      <programlisting>
select fnom, pnom from frournisseur
	JOIN ventes USING (fnum)
	JOIN piece USING (pnum);
      </programlisting>
      cela donne encore&nbsp;:
      <programlisting>
 fnom  | pnom
-------+-------
 Smith | Vis
 Adams | Vis
 Smith | Ecrou
 Blake | Ecrou
 Adams | Boulon
 Blake | Boulon
 Jones | Came
 Blake | Came
(8 rows) 
      </programlisting>
     </para>

     <para>
      Une table jointe, créée en utilisant la syntaxe JOIN, est une
      référence de table de liste d'articles qui se produit dans une
      clause FROM et avant n'importe quelle clause WHERE, GROUP BY ou
      HAVING. Les autres références de tables, incluant les noms de
      table ou les autres clauses JOIN peuvent être inclues dans une
      clause FROM si elles sont séparées par des virgules. Les
      tables jointes sont logiquement comme n'importe quelles autres
      tables listées dans la clause FROM.
     </para>

     <para>
      Les jointures SQL sont principalement de deux types, les
      jointure produits - CROSS JOIN - (jointures non qualifiées) et
      les <firstterm>jointures qualifiées</firstterm>. Les jointures
      qualifiées peuvent être de plus subdivisées en se basant sur la
      façon dont la <firstterm>condition de jointure</firstterm> est spécifiée
      (ON, USING ou NATURAL) et la façon comment elle est appliquée (jointure
      interne (INNER JOIN) ou externe (OUTER JOIN)).
     </para>

     <variablelist>
      <title>Les types de jointures</title>
      <varlistentry>
       <term>Jointure produit (CROSS JOIN)</term>
       <listitem>
        <cmdsynopsis>
         <arg choice="req"> <replaceable class="parameter">T1</replaceable> </arg>
         <command> CROSS JOIN </command>
         <arg choice="req"> <replaceable class="parameter">T2</replaceable> </arg>
        </cmdsynopsis>

        <para>
         Une jointure produit prend deux tables T1 et T2 ayant
         respectivement N et M lignes et retourne la table jointe
         contenant toutes les lignes jointes N*M possibles. Pour
         chaque ligne L1 de T1, chaque ligne L2 de T2 est jointe avec
         L1 pour rapporter une ligne LJ dans la table jointe qui est
         constituée de tous les champs de L1 et L2. Une jointure
         produit est équivalente à un INNER JOIN ON TRUE.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Jointures qualifiées</term>
       <listitem>

        <cmdsynopsis>
         <arg choice="req"> <replaceable class="parameter">T1</replaceable> </arg>
         <arg choice="opt"> NATURAL </arg>
         <group choice="opt">
          <arg choice="opt"> INNER </arg>
          <arg>
           <group choice="req">
            <arg choice="plain"> LEFT </arg>
            <arg choice="plain"> RIGHT </arg>
            <arg choice="plain"> FULL </arg>
           </group>
           <arg choice="opt"> OUTER </arg>
          </arg>
         </group>
         <command> JOIN </command>
         <arg choice="req"> <replaceable class="parameter">T2</replaceable> </arg>
         <group choice="req">
          <arg> ON <replaceable>condition_recherche</replaceable></arg>
          <arg> USING ( <replaceable>liste_colonnes_jointure</replaceable> ) </arg>
         </group>
        </cmdsynopsis>

        <para>
         Une jointure qualifiée doit spécifier ses conditions de
         jointure en fournissant une (est seulement une) clause
         NATUREL, ON ou USING. La clause ON prend une
         <replaceable>condition_recherche</replaceable> qui est du
         même type que la condition de la clause WHERE. La clause
         USING prend une liste de noms de colonnes, séparés par une
         virgule, que la table jointe doit avoir en commun et joint
         les tables sur l'égalité de ces colonnes. La clause NATUREL
         est une abréviation pour la clause USING qui liste tous les
         noms communs de colonnes des deux tables. Un effet
         secondaire de USING et NATURAL est que uniquement une copie
         de chaque colonne jointe est emise dans la table résultat (à
         l'inverse de la définition du JOIN de l'algèbre relationnelle
         montrée plus tôt).
        </para>

        <!-- begin join semantics -->
        <variablelist>
         <varlistentry>
          <term>
           <cmdsynopsis>
            <arg> INNER </arg>
            <command> JOIN </command>
           </cmdsynopsis>
          </term>
          <listitem>
           <para>
            Pour chaque ligne L1 de T1, la table jointe a une ligne
            pour chaque ligne dans T2 qui satisfait la condition de
            jointure avec L1.
           </para>
           <tip>
            <para>
             Les mots INNER et OUTER sont optionnels pour toutes les
             jointures. INNER est choisi par défaut. L'utilisation de
             LEFT, RIGHT et FULL sous-entend une jointure externe
             (OUTER JOIN).
            </para>
           </tip>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>
           <cmdsynopsis>
            <arg choice="plain"> LEFT </arg>
            <arg> OUTER </arg>
            <command> JOIN </command>
           </cmdsynopsis>
          </term>
          <listitem>
           <para>
            Une jointure interne (INNER JOIN) est d'abord exécutée.
            Ensuite, pour chaque ligne dans T1 qui ne satisfait la
            condition de jointure avec aucune ligne dans T2, une ligne
            jointe supplémentaire est renvoyée avec les champs nuls
            pour les colonnes de T2.
           </para>
           <tip>
            <para>
             La table jointe a toujours une ligne pour chaque ligne
             dans T1.
            </para>
           </tip>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>
           <cmdsynopsis>
            <arg choice="plain"> RIGHT </arg>
            <arg> OUTER </arg>
            <command> JOIN </command>
           </cmdsynopsis>
          </term>
          <listitem>
           <para>
            Une jointure interne (INNER JOIN) est d'abord exécutée.
            Ensuite, pour chaque ligne dans T2 qui ne satisfait la
            condition de jointure avec aucune ligne de T1, une ligne
            jointe supplémentaire est renvoyée avec des champs nuls
            pour les colonnes de T1.
           </para>
           <tip>
            <para>
             La table jointe a toujours une ligne pour chaque ligne
             dans T2.
            </para>
           </tip>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>
           <cmdsynopsis>
            <arg choice="plain"> FULL </arg>
            <arg> OUTER </arg>
            <command> JOIN </command>
           </cmdsynopsis>
          </term>
          <listitem>
           <para>
            Une jointure interne (INNER JOIN) est d'abord exécutée.
            Ensuite, pour chaque ligne dans T1 qui ne satisfait la
            condition de jointure avec aucune ligne de T2, une ligne
            jointe supplémentaire est renvoyée avec des champs nuls
            pour les colonnes de T2. De plus, pour chaque ligne dans
            T2 qui ne satisfait la condition de jointure avec aucune
            ligne de T1, une ligne jointe supplémentaire est renvoyée
            des champs nuls pour les colonnes de T1.
           </para>
           <tip>
            <para>
             La table jointe a toujours une ligne pour chaque ligne
             dans T1 et une ligne pour chaque ligne de T2.
            </para>
           </tip>
          </listitem>
         </varlistentry>
        </variablelist>
        <!-- end join semantics -->

       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      Les jointures de tous types peuvent être chaînées ensembles.
      Elles peuvent aussi être placées où
      <replaceable class="parameter">T1</replaceable>,
      <replaceable class="parameter">T2</replaceable>, ou
      <replaceable class="parameter">T1</replaceable> et
      <replaceable class="parameter">T2</replaceable> peuvent être des
      tables jointes. Les parenthèses peuvent être utilisées autour
      de la clause JOIN pour contrôler l'ordre des jointures qui sont,
      par défaut, exécutées de gauche à droite. 
     </para>

    </sect3>

    <sect3>
     <title id="aggregates-tutorial">Les opérateurs d'agrégat</title>

     <para>
      <acronym>SQL</acronym> fournit des fonctions d'agrégat (par
      exemple AVG, COUNT, SUM, MIN, MAX) qui prennent en argument
      une expression. L'expression est évaluée à chaque ligne qui
      satisfait la clause WHERE, et l'opérateur d'agrégat calcule
      avec cet ensemble de valeurs en entrée. Normalement un agrégat
      ne fournit qu'un résultat pour l'ensemble des instructions
      <command>SELECT</command>. Mais si vous groupez les lignes
      d'une requête, alors un calcul séparé est effectué avec les
      lignes de chaque groupe, et un résultat agrégé est fournit par
      groupe (regardez la prochaine section).

      <example>
       <title id="aggregates-example">Agrégats</title>

       <para>
        Si nous voulons connaître le coût moyen de toutes les pièces
        de la table PIECE, nous utilisons la requête suivante&nbsp;:

        <programlisting>
SELECT AVG(PRIX) AS AVG_PRIX
    FROM PIECE;
        </programlisting>
       </para>

       <para>
        Le résultat est&nbsp;:

        <programlisting>
 AVG_PRIX
----------
   14.5
        </programlisting>
       </para>

       <para>
        Si nous voulons connaître combien de pièces sont définies dans
        la table PIECE, nous utilisons l'instruction&nbsp;:

        <programlisting>
SELECT COUNT(PNUM)
    FROM PIECE;
        </programlisting>

        et obtenons&nbsp;:

        <programlisting>
 COUNT
-------
   4
        </programlisting>

       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>Agrégation par groupes</title>

     <para>
      <acronym>SQL</acronym> permet la partition en groupe des tuples
      d'une table. Les opérateurs d'agrégat décrits ci-dessus
      peuvent être appliqués aux groupes &mdash; c'est-à-dire que la
      valeur d'un opérateur d'agrégat n'est plus calculée avec toutes
      les valeurs d'une colonne spécifique mais avec toutes les
      valeurs d'un groupe. Un opérateur d'agrégat est donc évalué
      séparément pour chaque groupe.
     </para>

     <para>
      Le partitionnement des tuples en groupes est fait en utilisant
      le mot-clé <command>GROUP BY</command> suivit de la liste des
      attributs qui définissent le groupe. Si nous avons
      <command>GROUP BY A<subscript>1</subscript>, &tdot;,
      A<subscript>k</subscript></command> nous divisons la relation en
      groupes de sorte que deux tuples sont dans le même groupe si et
      seulement si ils ont la même valeur pour tous les attributs
      A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript>.

      <example>
       <title id="aggregates-groupby">Agrégats</title>
       <para>
        Si nous voulons connaître combien de pièces sont vendues par
        chaque fournisseur, nous formulons la requête&nbsp;:

        <programlisting>
SELECT F.FNUM, F.FNOM, COUNT(VE.PNUM)
    FROM FOURNISSEUR F, VENTES VE
    WHERE F.FNUM = VE.FNUM
    GROUP BY F.FNUM, F.FNOM;
        </programlisting>

        et obtenons&nbsp;:

        <programlisting>
 FNUM | FNOM  | COUNT
------+-------+-------
  1   | Smith |   2
  2   | Jones |   1
  3   | Adams |   2
  4   | Blake |   3
        </programlisting>
       </para>

       <para>
        Maintenons regardons ce qu'il s'est passé.
        D'abord, la jointure de la table FOURNISSEUR et VENTES est
        faite&nbsp;:

        <programlisting>
 F.FNUM | F.FNOM  | VE.PNUM
--------+---------+---------
   1    |  Smith  |    1
   1    |  Smith  |    2
   2    |  Jones  |    4
   3    |  Adams  |    1
   3    |  Adams  |    3
   4    |  Blake  |    2
   4    |  Blake  |    3
   4    |  Blake  |    4
        </programlisting>
       </para>

       <para>
        Ensuite nous partitionnons les tuples en groupes, en mettant
        tous les tuples qui on la même valeur pour F.FNUM et F.FNOM,
        ensembles&nbsp;:

        <programlisting>
 F.FNUM | F.FNOM  | VE.PNUM
--------+---------+--------
   1    |  Smith  |   1
                  |   2
---------------------------
   2    |  Jones  |   4
---------------------------
   3    |  Adams  |   1
                  |   3
---------------------------
   4    |  Blake  |   2
                  |   3
                  |   4
        </programlisting>
       </para>

       <para>
        Dans notre exemple, nous avons quatre groupes et maintenant
        nous pouvons appliquer l'opérateur d'agrégat COUNT à chaque
        groupe. Cela nous mène au résultat final de la requête donné
        plus haut.
       </para>
      </example>
     </para>

     <para>
      Notez que pour qu'une requête utilisant GROUP BY et des
      opérateurs d'agrégat ait un sens, la liste cible peut seulement
      faire référence directement qu'à des attributs qui sont groupés.
      Les autres attributs peuvent uniquement être utilisés à
      l'intérieur de l'argument d'une fonction d'agrégat. Autrement
      il ne pourrait pas y avoir une valeur unique à associer avec les
      autres attributs.
     </para>

     <para>
      Remarquez aussi que ça n'a pas de sens d'avoir un agrégat
      d'agrégat, par exemple AVG(MAX(sno)), parce qu'un
      <command>SELECT</command> passe seulement une fois sur un
      un groupe et une agrégat. Vous pouvez avoir un résultat de
      ce genre en utilisant une table temporaire ou un sous-SELECT
      dans une clause FROM pour faire le premier niveau d'agrégat.
     </para>
    </sect3>

    <sect3>
     <title>Having</title>

     <para>
      La clause HAVING fonctionne à peu près comme la clause WHERE.
      Elle est utilisée pour prendre en compte seulement les groupes
      qui satisfont les critères qui lui sont donnés. WHERE filtre
      les lignes non désirées avant que les groupes et les agrégats
      soient appliqués tandis que HAVING filtre des lignes non
      désirées après leur groupement. Par conséquence, WHERE ne peut
      se référer au résultat des fonctions d'agrégat. D'un autre
      côté, il n'y a aucun intérêt à écrire une condition HAVING qui
      n'implique pas une fonction d'agrégat&nbsp;! Si votre condition
      n'implique pas d'agrégats, vous pouvez tout aussi bien l'écrire
      dans un WHERE et de ce fait, éviter le calcul des agrégats pour
      les groupes que vous n'allez pas utiliser de toute façon. 

      <example>
       <title id="having-example">Having</title>

       <para>
        Si nous voulons seulement les fournisseurs vendant plus d'une
        pièce, nous utilisons la requête&nbsp;:

	<programlisting>
SELECT F.FNUM, F.FNOM, COUNT(VE.PNUM)
    FROM FOURNISSEUR F, VENTES VE
    WHERE F.FNUM = VE.FNUM
    GROUP BY F.FNUM, F.FNOM
    HAVING COUNT(VE.PNUM) &gt; 1;
        </programlisting>

        et obtenons&nbsp;:

        <programlisting>
 FNUM | FNOM  | COUNT
------+-------+-------
  1   | Smith |   2
  3   | Adams |   2
  4   | Blake |   3
        </programlisting>
       </para>
      </example>
     </para>
    </sect3>


    <sect3>
     <title>Sous-requêtes</title>

     <para>
      Dans les clauses WHERE et HAVING, l'utilisation de sous-requêtes
      (sous-select) est permise à chaque endroit où une valeur est
      attendue. Dans ce cas, la valeur doit être obtenue en évaluant
      d'abord la sous-requête. L'utilisation de sous-requêtes
      augmente la puissance d'expression de <acronym>SQL</acronym>.

      <example>
       <title id="subselect-example">Sous-select</title>

       <para>
        Si nous voulons connaître toutes les pièces ayant un prix plus
        élevé que la pièce appelée 'Vis', nous utilisons la requête&nbsp;:

        <programlisting>
SELECT * 
    FROM PIECE 
    WHERE PRIX &gt; (SELECT PRIX FROM PIECE
                   WHERE PNOM='Vis');
        </programlisting>
       </para>

       <para>
       Le résultat est&nbsp;:

	<programlisting>
 PNUM |  PNOM   |  PRIX
------+---------+--------
  3   |  Boulon |   15
  4   |  Came   |   25
        </programlisting>
       </para>

       <para>
        Quand nous regardons la requête précédente, nous pouvons voir
        le mot-clé <command>SELECT</command> deux fois. La première
        fois au début de la requête - nous nous y référerons sous le
        nom <command>SELECT</command> externe - et la seconde fois
        dans la clause WHERE qui commence une requête emboîtée - que
        nous appelons <command>SELECT</command> interne. Pour chaque
        tuple du <command>SELECT</command> externe, le
        <command>SELECT</command> interne doit être évalué. Après
        chaque évaluation, nous connaissons le prix du tuple nommé
        'Vis' et nous pouvons vérifier si le prix du tuple actuel est
        plus élevé. (En fait, dans cet exemple, la requête interne a
        seulement besoin d'être évaluée une fois puisqu'elle ne dépend
        pas de l'état de la requête externe.)
       </para>

       <para>
        Si nous voulons connaître tous les fournisseurs qui ne vendent
        aucune pièce (par exemple pour être capable de supprimer ces
        fournisseurs de la base), nous utilisons&nbsp;: 

        <programlisting>
SELECT * 
    FROM FOURNISSEUR F
    WHERE NOT EXISTS
        (SELECT * FROM VENTES VE
         WHERE VE.FNUM = F.FNUM);
        </programlisting>
       </para>

       <para>
        Dans notre exemple, le resultat sera vide car chaque
        fournisseur vend au moins une pièce. Notez que nous utilisons
        F.FNUM depuis le <command>SELECT</command> externe à
        l'intérieur de la clause WHERE d'un <command>SELECT</command>
        interne. Ici, la sous-requête doit être évaluée à nouveau
        pour chaque tuple de la requête externe, c'est-à-dire que la
        valeur pour F.FNUM est toujours prise du tuple courant du
        <command>SELECT</command> externe.
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>Sous-requêtes dans un FROM</title>

     <para>
      Une manière légèrement différente d'utiliser les sous-requêtes
      consiste à les mettre dans une clause FROM. C'est une
      caractéristique utile car une sous-requête de ce genre peut
      générer de nombreuses colonnes et lignes, tandis qu'une
      sous-requête utilisée dans une expression doit délivrer juste un
      seul résultat. Cela nous donne aussi plus qu'un seul niveau de
      groupement/agrégat sans avoir besoin d'une table temporaire.

      <example>
       <title id="subselect-in-from-example">Sous-select dans un FROM</title>

       <para>
        Si nous voulons connaître le prix moyen le plus élevé d'une
        pièce parmi tous nos fournisseurs, nous ne devons pas écrire
        MAX(AVG(PRIX)) mais&nbsp;:

        <programlisting>
SELECT MAX(subtable.prixmoyen)
    FROM (SELECT AVG(P.PRIX) AS prixmoyen
          FROM FOURNISSEUR F, PIECE P, VENTES VE
          WHERE F.FNUM = VE.FNUM AND
                P.PNUM = VE.PNUM
          GROUP BY F.FNUM) subtable;
        </programlisting>

        La sous-requête retourne une ligne par fournisseur (car nous 
        utilisons un GROUP BY) et ensuite nous agrégeons les lignes
        dans la requête externe.
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>Union, Intersection, Exception</title>

     <para>
      Ces opérations calculent l'union, l'intersection et la
      différence (au sens de la théorie des ensembles) des tuples
      renvoyés par deux sous-requêtes.

      <example>
       <title id="union-example">Union, Intersection, Exception</title>

       <para>
        La requête suivante est un exemple d'union&nbsp;:

        <programlisting>
SELECT F.FNUM, F.FNOM, F.VILLE
    FROM FOURNISSEUR F
    WHERE F.FNOM = 'Jones'
UNION
    SELECT F.FNUM, F.FNOM, F.VILLE
    FROM FOURNISSEUR F
    WHERE F.FNOM = 'Adams';
        </programlisting>

et donne le resultat&nbsp;:

	<programlisting>
 FNUM | FNOM  | VILLE
------+-------+--------
  2   | Jones | Paris
  3   | Adams | Vienne
        </programlisting>
       </para>

       <para>
        Ici, un exemple pour l'intersection&nbsp;:

        <programlisting>
SELECT F.FNUM, F.FNOM, F.VILLE
    FROM FOURNISSEUR F
    WHERE F.FNOM &gt; 1
INTERSECT
    SELECT F.FNUM, F.FNOM, F.VILLE
    FROM FOURNISSEUR F
    WHERE F.FNOM &lt; 3;
        </programlisting>

	donne le resultat&nbsp;:

        <programlisting>
 FNUM | FNOM  | Ville
------+-------+--------
  2   | Jones | Paris
        </programlisting>

        Le seul tuple retourné par les deux parties de la requête est
        le seul ayant FNUM=2.
       </para>

       <para>
        Et pour finir un exemple pour l'exception&nbsp;:

        <programlisting>
SELECT F.FNUM, F.FNOM, F.VILLE
    FROM FOURNISSEUR F
    WHERE F.FNOM &gt; 1
EXCEPT
    SELECT F.FNUM, F.FNOM, F.VILLE
    FROM FOURNISSEUR F
    WHERE F.FNOM &gt; 3;
        </programlisting>

	donne le resultat&nbsp;:

	<programlisting>
 FNUM | FNOM  | VILLE
------+-------+--------
  2   | Jones | Paris
  3   | Adams | Vienne
        </programlisting>
       </para>
      </example>
     </para>
    </sect3>
   </sect2>

   <sect2 id="datadef">
    <title>Définition de données</title>

    <para>
     Il existe un ensemble de commandes utilisées pour la définition
     de données qui sont inclues dans le langage
     <acronym>SQL</acronym>.
    </para>

    <sect3 id="create">
     <title id="create-title">CREATE TABLE</title>

     <para>
      La commande la plus fondamentale pour la définition de données
      est celle qui crée une nouvelle relation (une nouvelle table).
      La syntaxe de la commande <command>CREATE TABLE</command> est&nbsp;:

      <synopsis>
CREATE TABLE <replaceable class="parameter">nom_table</replaceable>
    (<replaceable class="parameter">nom_attribut_1</replaceable> <replaceable class="parameter">type_attribut_1</replaceable>
     [, <replaceable class="parameter">nom_attribut_2</replaceable> <replaceable class="parameter">type_attribut_2</replaceable> 
     [, ...]]);
      </synopsis>

      <example>
       <title id="table-create">Création d'une table</title>

       <para>
        Pour créer les tables définies dans
        <xref linkend="supplier-fig" endterm="supplier-fig"/>
        l'instruction <acronym>SQL</acronym> suivante est utilisée&nbsp;:

        <programlisting>
CREATE TABLE FOURNISSEUR
    (FNUM  INTEGER,
     FNOM  VARCHAR(20),
     VILLE VARCHAR(20));
        </programlisting>

        <programlisting>
CREATE TABLE PIECE
    (PNUM  INTEGER,
     PNOM  VARCHAR(20),
     PRIX  DECIMAL(4 , 2));
        </programlisting>

        <programlisting>
CREATE TABLE VENTES
    (FNUM INTEGER,
     PNUM INTEGER);
        </programlisting>
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>Les types de données dans <acronym>SQL</acronym></title>

     <para>
      Voici une liste de quelques types de données qui sont supportés
      par <acronym>SQL</acronym>&nbsp;:

      <itemizedlist>
       <listitem>
        <para>
         INTEGER&nbsp;: entier signé sur 4 octets (précision 31 bits).
        </para>
       </listitem>

       <listitem>
        <para>
         SMALLINT&nbsp;: entier signé sur 2 octets (précision 15 bits).
        </para>
       </listitem>

       <listitem>
        <para>
         DECIMAL&nbsp;: (<replaceable
class="parameter">p</replaceable>[,<replaceable
class="parameter">q</replaceable>])&nbsp;:
         nombre décimal signé, défini par
         <replaceable class="parameter">p</replaceable> chiffres au
         total, dont <replaceable class="parameter">q</replaceable>
         chiffres à droite du point. Si
         <replaceable class="parameter">q</replaceable> est omis, il
         est considéré comme valant 0.
        </para>
       </listitem>

       <listitem>
        <para>
         FLOAT&nbsp;: nombre à virgule flottante signé sur 8 octets.
        </para>
       </listitem>

       <listitem>
        <para>
         VARCHAR&nbsp;: (<replaceable class="parameter">n</replaceable>)&nbsp;:
         chaîne de caractères de longueur variable et d'au maximum
         <replaceable class="parameter">n</replaceable> caractères.
        </para>
       </listitem>

       <listitem>
        <para>
         CHAR&nbsp;: (<replaceable class="parameter">n</replaceable>)&nbsp;:
         chaîne de caractères de longueur fixe (exactement
         <replaceable class="parameter">n</replaceable> caractères).
        </para>
       </listitem>

      </itemizedlist>
     </para>
    </sect3>

    <sect3>
     <title>CREATE INDEX</title>

     <para>
      Les index sont utilisés pour accélérer l'accès à une relation.
      Si une relation <classname>R</classname> a un index sur un
      attribut <classname>A</classname> alors nous pouvons retrouver
      tous les tuples <replaceable>t</replaceable> ayant
      <replaceable>t</replaceable>(<classname>A</classname>) =
      <replaceable>a</replaceable> dans un temps à peu près
      proportionnel au nombre de ces tuples
      <replaceable>t</replaceable> plutôt qu'au temps proportionnel à
      la taille de <classname>R</classname>.
     </para>

     <para>
      Pour créer un index dans <acronym>SQL</acronym>, la commande
      <command>CREATE INDEX</command> est utilisée. La syntaxe est&nbsp;:

      <programlisting>
CREATE INDEX <replaceable class="parameter">nom_index</replaceable> 
    ON <replaceable class="parameter">nom_table</replaceable> ( <replaceable class="parameter">name_attribut</replaceable> );
      </programlisting>
     </para>

     <para>
      <example>
       <title id="index-create">Création d'un index</title>

       <para>
        Pour créer un index nommé I sur l'attribut FNOM de la relation
        FOURNISSEUR nous utilisons l'instruction suivante&nbsp;:

      <programlisting>
CREATE INDEX I ON FOURNISSEUR (FNOM);
      </programlisting>
     </para>

       <para>
        L'index créé est maintenu automatiquement, c'est-à-dire que
        toutes les fois qu'un nouveau tuple est inséré dans la
        relation FOURNISSEUR, l'index I est adapté. Notez que les
        seuls changements qu'un utilisateur peut percevoir quand un
        index est présent, sont l'augmentation de la vitesse pour
        les <command>SELECT</command> et une diminution de la vitesse
        pour les mises à jour (UPDATE).
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>CREATE VIEW</title>

     <para>
      Une vue peut être considérée comme une
      <firstterm>table virtuelle</firstterm>, c'est-à-dire une table
      qui n'existe pas <emphasis>physiquement</emphasis> dans la base
      mais est perçu par un utilisateur comme si cela était le cas.
      Par contraste, quand nous parlons d'une
      <firstterm>table de la base</firstterm> il y a réellement un
      stockage physique de chaque ligne de la table quelque part sur
      le support de stockage physique.
     </para>

     <para>
      Les vues n'ont pas leurs propres données physiquement séparées et
      stockées de manière distincte. Au lieu de cela, le système
      stocke la définition de la vue (c'est-à-dire les règles à propos
      de comment accéder aux tables de la base physiquement stockées
      pour matérialiser la vue) quelque part dans les catalogues
      systèmes (regardez 
      <xref linkend="tutorial-catalogs-title" endterm="tutorial-catalogs-title"/>).
      Pour un approfondissement sur les différentes techniques
      d'implémentation des vues, reférez vous à
<!--
      la section
      <xref linkend="view-impl" endterm="view-impl"/>.
-->
      <citetitle>SIM98</citetitle>.
     </para>

     <para>
      Dans <acronym>SQL</acronym>, la commande
      <command>CREATE VIEW</command> est utilisée pour définir une
      vue. La syntaxe est&nbsp;:

      <programlisting>
CREATE VIEW <replaceable class="parameter">nom_vue</replaceable>
    AS <replaceable class="parameter">requête</replaceable>
      </programlisting>

      où <replaceable class="parameter">requête</replaceable> est une
      instruction select valide comme cela a été défini dans
      <xref linkend="select-title" endterm="select-title"/>. Notez que
      la <replaceable class="parameter">requête</replaceable> n'est
      pas exécutée quand la vue est créée. Elle est juste stockée
      dans les <firstterm>catalogues systèmes</firstterm> et est
      exécutée toutes les fois qu'une demande pour la vue est faite.
     </para>

     <para>
      Voici des exemples de définition de vues (nous utilisons une
      fois de plus les tables de
      <xref linkend="supplier-fig" endterm="supplier-fig"/>)&nbsp;:

      <programlisting>
CREATE VIEW Fournisseurs_Londres
    AS SELECT F.FNOM, P.PNOM
        FROM FOURNISSEUR F, PIECE P, VENTES VE
        WHERE F.FNUM = VE.FNUM AND
              P.PNUM = VE.PNUM AND
              F.VILLE = 'Londres';
      </programlisting>
     </para>

     <para>
      Maintenant nous pouvons utiliser la
      <firstterm>relation virtuelle</firstterm>
      <classname>Fournisseurs_Londres</classname> comme si c'était une
      autre table de la base&nbsp;:

      <programlisting>
SELECT * FROM Fournisseurs_Londres
    WHERE PNAME = 'Vis';
      </programlisting>

      qui nous retournera la table suivante&nbsp;:

      <programlisting>
 FNOM  | PNOM
-------+-------
 Smith | Vis                 
      </programlisting>
     </para>

     <para>
      Pour calculer ce résultat, le système de bases de données a
      fait, dans un premier temps, un accès <emphasis>caché</emphasis>
      aux tables de la base FOURNISSEUR, VENTES et PIECE. Cela a été
      fait en exécutant la requête donnée dans la définition de la vue
      Après, les qualifications addtionnelles (fournies dans la
      requête sur la vue) peuvent être appliquées pour obtenir la
      table de résultat.
     </para>
    </sect3>

    <sect3>
     <title>DROP TABLE, DROP INDEX, DROP VIEW</title>

     <para>
      Pour détruire une table (et tous les tuples stockés dans cette
      table) la commande <command>DROP TABLE</command> est utilisée&nbsp;:

      <programlisting>
DROP TABLE <replaceable class="parameter">nom_table</replaceable>;
       </programlisting>
      </para>

     <para>
      Pour détruire la table FOURNISSEUR utilisez l'instruction
      suivante&nbsp;:

      <programlisting>
DROP TABLE FOURNISSEUR;
      </programlisting>
     </para>

     <para>
      La commande <command>DROP INDEX</command> est utilisée pour
      détruire un index&nbsp;:

      <programlisting>
DROP INDEX <replaceable class="parameter">nom_index</replaceable>;
      </programlisting>
     </para>

     <para>
      Pour finir, pour détruire une vue donnée, utilisez la commande
      <command>DROP VIEW</command>&nbsp;:

      <programlisting>
DROP VIEW <replaceable class="parameter">nom_vue</replaceable>;
      </programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2>
    <title>Manipulation de données</title>

    <sect3>
     <title>INSERT INTO</title>

     <para>
      Une fois qu'une table est créée (regardez
      <xref linkend="create-title" endterm="create-title"/>), elle peut
      être remplie avec des tuples en utilisant la commande
      <command>INSERT INTO</command>. La syntaxe est&nbsp;:

      <programlisting>
INSERT INTO <replaceable class="parameter">nom_table</replaceable> (<replaceable class="parameter">nom_attribut_1</replaceable> 
    [, <replaceable class="parameter">nom_attribut_2</replaceable> [,...]])
    VALUES (<replaceable class="parameter">valeur_attribut_1</replaceable> [, <replaceable class="parameter">valeur_attribut_2</replaceable> [, ...]]);
      </programlisting>
     </para>

     <para>
      Pour insérer le premier tuple dans la relation FOURNISSEUR (de
      <xref linkend="supplier-fig" endterm="supplier-fig"/>) nous
      utilisons l'instruction suivante&nbsp;:

      <programlisting>
INSERT INTO FOURNISSEUR (FNUM, FNOM, VILLE)
    VALUES (1, 'Smith', 'Londres');
      </programlisting>
     </para>

     <para>
      Pour insérer le premier tuple de la relation VENTES, nous
      utilisons&nbsp;:

      <programlisting>
INSERT INTO VENTES (FNUM, PNUM)
    VALUES (1, 1);
      </programlisting>
     </para>
    </sect3>

    <sect3>
     <title>UPDATE</title>

     <para>
      Pour changer une ou plusieurs valeurs d'attributs des tuples
      d'une relation, on utilise la commande
      <command>UPDATE</command>. La syntaxe est&nbsp;:

      <programlisting>
UPDATE <replaceable class="parameter">nom_table</replaceable>
    SET <replaceable class="parameter">nom_attribut_1</replaceable> = <replaceable class="parameter">valeur_1</replaceable> 
        [, ... [, <replaceable class="parameter">nom_attribut_k</replaceable> = <replaceable class="parameter">valeur_k</replaceable>]]
    WHERE <replaceable class="parameter">condition</replaceable>;
      </programlisting>
     </para>

     <para>
      Pour changer la valeur de l'attribut PRIX de la pièce 'Vis' dans
      la relation PIECE nous utilisons&nbsp;:

      <programlisting>
UPDATE PIECE
    SET PRIX = 15
    WHERE PNOM = 'Vis';
      </programlisting>
     </para>

     <para>
      La nouvelle valeur de l'attribut PRIX du tuple dont le nom est
      'Vis' est maintenant 15.
     </para>
    </sect3>

    <sect3>
     <title>DELETE</title>

     <para>
      Pour supprimer un tuple d'une table particulière, utilisez la
      commande DELETE FROM. La syntaxe est&nbsp;:

      <programlisting>
DELETE FROM <replaceable class="parameter">nom_table</replaceable>
    WHERE <replaceable class="parameter">condition</replaceable>;
      </programlisting>
     </para>

     <para>
      Pour supprimer le fournisseur appelé 'Smith' de la table
      FOURNISSEUR l'instruction suivante est utilisée&nbsp;:

      <programlisting>
DELETE FROM FOURNISSEUR
    WHERE FNOM = 'Smith';
      </programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2 id="tutorial-catalogs">
    <title id="tutorial-catalogs-title">Catalogues systèmes</title>

    <para>
     Dans chaque systèmes de bases de données <acronym>SQL</acronym>,
     des <firstterm>catalogues systèmes</firstterm> sont utilisés pour
     garder une trace de quels tables, vues, index, etc. sont
     définis dans la base. Ces catalogues systèmes peuvent être
     intérrogés comme s'ils étaient des relations quelconques. Par
     exemple, il y a un catalogue utilisé pour la définition des
     vues. Ce catalogue stocke les requêtes de la définition de la
     vue. Toutes les fois qu'une requête sur la vue est faite, le
     système obtient d'abord la
     <firstterm>requête de définition de la vue</firstterm> du
     catalogue et matérialise la vue avant de traiter la requête de
     l'utilisateur (regardez
<!--
      la section
      <xref linkend="view-impl" endterm="view-impl"/>.
    <citetitle>SIM98</citetitle>
-->
     <xref linkend="sim98" endterm="sim98"/>
     pour une description plus de détaillée). Pour plus
     d'informations sur les catalogues systèmes, référez vous à
     <xref linkend="date04" endterm="date04"/>.
    </para>
   </sect2>

   <sect2>
    <title><acronym>SQL</acronym> intégré</title>

    <para>
     Dans cette section nous aurons un aperçu de comment
     <acronym>SQL</acronym> peut être intégré à un langage hôte (par
     exemple <literal>C</literal>). Il y a principalement deux
     raisons pour lesquelles nous pouvons avoir envie d'utiliser
     <acronym>SQL</acronym> depuis une langage hôte&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        Il y a des requêtes qui ne peuvent pas être formulées en
        utilisant le <acronym>SQL</acronym> pur (par exemple les
        requêtes récursives). Pour être capable de traiter ce genre
        de requêtes nous avons besoin d'un langage hôte avec une
        puissance d'expression plus grande que celle de
        <acronym>SQL</acronym>.
       </para>
      </listitem>

      <listitem>
       <para>
        Nous voulons simplement accéder à une base de données depuis
        une application qui est écrite dans le langage hôte (par
        exemple un système de réservation de tickets, avec une
        interface utilisateur graphique, écrit en C et dont les
        informations à propos de chaque ticket encore disponible sont
        stockées dans une base qui peut être accessible en utilisant
        le <acronym>SQL</acronym> intégré).
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Un programme utilisant <acronym>SQL</acronym> intégré dans un
     langage hôte est constitué d'instructions du langage hôte et
     d'instructions
     <firstterm><acronym>SQL</acronym> intégrées</firstterm>
     (<acronym>ESQL</acronym>). Chaque instruction
     <acronym>ESQL</acronym> commence avec le mot-clé
     <command>EXEC SQL</command>. Les instructions
     <acronym>ESQL</acronym> sont transformées en instructions du
     langage hôte par le <firstterm>pré-compilateur</firstterm> (qui
     habituellement insère des appels aux routines des librairies qui
     fournissent des commandes <acronym>SQL</acronym> variées).
    </para>

    <para>
     Quand nous regardons les exemples dans
     <xref linkend="select-title" endterm="select-title"/> nous
     réalisons que le resultat des requêtes est souvent un ensemble de
     tuples. La plus part des langages hôte n'ont pas été conçus pour
     opérer sur ces ensembles, nous avons donc besoin d'un méchanisme
     pour accéder individuellement à chaque tuple d'un ensemble de
     tuples retournés par une instruction SELECT. Ce méchanisme peut
     être fourni en déclarant un <firstterm>curseur</firstterm>. Après
     cela, nous pouvons utiliser la commande <command>FETCH</command>
     pour retrouver un tuple et positionner le curseur sur le prochain
     tuple.
    </para>

    <para>
     Pour plus de détails sur <acronym>SQL</acronym> intégré, référez
     vous à
     <xref linkend="date97" endterm="date97"/>,
     <xref linkend="date04" endterm="date04"/>,
     ou à
     <xref linkend="ull88" endterm="ull88"/>.
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->