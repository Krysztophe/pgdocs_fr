<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="sslinfo">
 <title>sslinfo</title>

 <indexterm zone="sslinfo">
  <primary>sslinfo</primary>
 </indexterm>

 <para>
  Le module <filename>sslinfo</filename> fournit des informations sur le
  certificat SSL que le client actuel a fourni lors de sa connexion à
  <productname>PostgreSQL</productname>. Le module est inutile (la plupart des
  fonctions renvoient NULL) si la connexion actuelle n'utilise pas SSL.
 </para>

 <para>
  Cette extension ne se construira pas du tout sauf si l'installation était
  configurée avec <literal>--with-openssl</literal>.
 </para>

 <sect2>
  <title>Fonctions</title>

  <variablelist>
   <varlistentry>
    <term><function>
ssl_is_used() returns boolean
    </function></term>
    <listitem>
    <para>
     Renvoie TRUE si la connexion actuelle au serveur utilise SSL.
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>
ssl_client_cert_present() returns boolean
    </function></term>
    <listitem>
    <para>
     Renvoie TRUE si le client actuel a présenté un certificat client SSL au
     serveur. (Le serveur pourrait être configuré pour réclamer un certificat
     client.)
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>
ssl_client_serial() returns numeric
    </function></term>
    <listitem>
    <para>
     Renvoie un numéro de série du certificat actuel du client. La combinaison
     du numéro de série de certificat et du créateur du certificat
     garantit une identification unique du certificat (mais pas son propriétaire
     &mdash; le propriétaire doit régulièrement changer ses clés et obtenir de
     nouveaux certifications à partir du créateur).
    </para>

    <para>
     Donc, si vous utilisez votre propre CA et autorisez seulement les
     certificats de ce CA par le serveur, le numéro de série est le moyen le
     plus fiable (bien que difficile à retenir) pour identifier un utilisateur.
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>
ssl_client_dn() returns text
    </function></term>
    <listitem>
    <para>
     Renvoie le sujet complet du certificat actuel du client, convertissant
     des données dans l'encodage actuel de la base de données. Nous supposons
     que si vous utilisez des caractères non ASCII dans le noms des
     certificats, votre base de données est capable de représenter ces
     caractères aussi. Si votre bases de données utilise l'encodage SQL_ASCII,
     les caractères non ASCII seront représentés par des séquences UTF-8.
    </para>

    <para>
     Le résultat ressemble à ceci&nbsp;: <literal>/CN=Somebody /C=Some
     country/O=Some organization</literal>.
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>
ssl_issuer_dn() returns text
    </function></term>
    <listitem>
    <para>
     Renvoie le nom complet du créateur du certificat actuel du client,
     convertissant les données caractères dans l'encodage actuel de la base
     de données. Les conversions d'encodage sont gérées de la même façon que
     pour <function>ssl_client_dn</function>.
    </para>
    <para>
     La combinaison de la valeur en retour de cette fonction avec le numéro de
     série du certificat identifie de façon unique le certificat.
    </para>
    <para>
     Cette fonction est réellement utile si vous avez plus d'un certificat
     d'un CA de confiance dans le fichier <filename>root.crt</filename> de
     votre serveur, ou si ce CA a envoyé quelques certificats intermédiaires
     d'autorité.
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>
ssl_client_dn_field(fieldname text) returns text
    </function></term>
    <listitem>
    <para>
     Cette fonction renvoie la valeur du champ spécifié dans le sujet du
     certificat, ou NULL si le champ n'est pas présent. Les noms du champ
     sont des constantes de chaîne qui sont converties dans des identifieurs
     d'objet ASN1 en utilisant la base de données des objets OpenSSL. Les
     valeurs suivantes sont acceptables&nbsp;:
    </para>
    <programlisting>
commonName (alias CN)
surname (alias SN)
name
givenName (alias GN)
countryName (alias C)
localityName (alias L)
stateOrProvinceName (alias ST)
organizationName (alias O)
organizationUnitName (alias OU)
title
description
initials
postalCode
streetAddress
generationQualifier
description
dnQualifier
x500UniqueIdentifier
pseudonym
role
emailAddress
    </programlisting>
    <para>
     Tous ces champs sont optionnels, sauf
     <structfield>commonName</structfield>. L'inclusion des champs dépend
     entièrement de la politique de votre CA. Par contre, la signification des
     champs est strictement définie par les standards X.500 et X.509, donc
     vous ne pouvez pas leur donner des significations arbitraires.
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>
ssl_issuer_field(fieldname text) returns text
    </function></term>
    <listitem>
    <para>
     Identique à <function>ssl_client_dn_field</function>, mais pour le
     créateur du certificat, plutôt que pour le sujet du certificat.
    </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
  <title>Auteur</title>

  <para>
   Victor Wagner <email>vitus@cryptocom.ru</email>, Cryptocom LTD
  </para>

  <para>
   E-Mail du groupe de développement Cryptocom OpenSSL&nbsp;:
   <email>openssl@cryptocom.ru</email>
  </para>
 </sect2>

</sect1>
