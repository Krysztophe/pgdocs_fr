<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/syntax.sgml,v 1.13 2005/09/15 07:03:23 guillaume Exp $
-->

<chapter id="sql-syntax">
 <title>Syntaxe SQL</title>

 <indexterm zone="sql-syntax">
  <primary>syntaxe</primary>
  <secondary>SQL</secondary>
 </indexterm>

 <para>
  Ce chapitre décrit la syntaxe de SQL. Il donne les fondements pour comprendre
  les chapitres suivants qui iront plus en détail sur la façon dont les
  commandes SQL sont appliquées pour définir et modifier des données.
 </para>

 <para>
  Nous avertissons aussi nos utilisateurs, déjà familiers avec le SQL, qu'ils 
  doivent lire ce chapitre très attentivement car il existe plusieurs règles et
  concepts implémentés différemment suivant les bases de données SQL ou
  spécifiques à <productname>PostgreSQL</productname>.
 </para>

 <sect1 id="sql-syntax-lexical">
  <title>Structure lexicale</title>

  <indexterm>
   <primary>token</primary>
  </indexterm>

  <para>
   Une entrée SQL consiste en une séquence de <firstterm>commandes</firstterm>.
   Une commande est composée d'une séquence de <firstterm>jetons</firstterm>,
   terminés par un point-virgule (<quote>;</quote>). La fin du flux en entrée
   termine aussi une commande. Les jetons valides dépendent de la
   syntaxe particulière de la commande.
  </para>

  <para>
   Un jeton peut être un <firstterm>mot clé</firstterm>, un
   <firstterm>identifieur</firstterm>, un <firstterm>identifieur entre
   guillemets</firstterm>, un <firstterm>littéral</firstterm> (ou une
   constante) ou un symbole de caractère spécial. Les jetons sont normalement
   séparés par des espaces blancs (espace, tabulation, nouvelle ligne) mais
   n'ont pas besoin de l'être s'il n'y a pas d'ambiguïté (ce qui est seulement
   le cas si un caractère spécial est adjacent à des jetons d'autres types).
  </para>

  <para>
   De plus, des <firstterm>commentaires</firstterm> peuvent se trouver dans
   l'entrée SQL. Ce ne sont pas des jetons, ils sont réellement équivalents à un
   espace blanc.
  </para>

   <para>
    Par exemple, ce qui suit est (syntaxiquement) valide pour une entrée
    SQL :
<programlisting>
SELECT * FROM MA_TABLE;
UPDATE MA_TABLE SET A = 5;
INSERT INTO MA_TABLE VALUES (3, 'salut ici');
</programlisting>
    C'est une séquence de trois commandes, une par ligne (bien que cela ne soit
    pas requis ; plusieurs commandes peuvent se trouver sur une même ligne et
    une commande peut se répartir sur plusieurs lignes).
   </para>

  <para>
   La syntaxe SQL n'est pas très cohérente en ce qui concerne les jetons
   identifieurs des commandes et lesquels sont des opérandes ou des paramètres.
   Les premiers jetons sont généralement le nom de la commande. Dans 
   l'exemple ci-dessus, nous parlons d'une commande
   <quote>SELECT</quote>, d'une commande <quote>UPDATE</quote> et d'une commande
   <quote>INSERT</quote>. Mais en fait, la commande <command>UPDATE</command>
   requiert toujours un jeton <token>SET</token> apparaissant dans une certaine
   position, et cette variante particulière de <command>INSERT</command>
   requiert aussi un <token>VALUES</token> pour être complète. Les règles précises
   de syntaxe pour chaque commande sont décrites dans la <xref
   linkend="reference">.
  </para>

  <sect2 id="sql-syntax-identifiers">
   <title>Identifieurs et mots clés</title>

   <indexterm zone="sql-syntax-identifiers">
    <primary>identifieur</primary>
    <secondary>syntaxe de</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>nom</primary>
    <secondary>syntaxe de</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>mot clé</primary>
    <secondary>syntaxe de</secondary>
   </indexterm>

   <para>
    Les jetons tels que <token>SELECT</token>, <token>UPDATE</token> ou
    <token>VALUES</token> dans l'exemple ci-dessus sont des exemples de
    <firstterm>mots clés</firstterm>, c'est-à-dire des mots qui ont une
    signification dans le langage SQL. Les jetons <token>MA_TABLE</token> et
    <token>A</token> sont des exemples d'<firstterm>identifieurs</firstterm>.
    Ils identifient des noms de tables, colonnes ou d'autres objets de la base
    de données suivant la commande qui a été utilisée. Du coup, ils sont
    quelques fois simplement nommés des <quote>noms</quote>. Les mots clés et
    les identifieurs ont la même structure lexicale, signifiant que quelqu'un ne
    peut pas savoir si un jeton est un identifieur ou un mot clé sans connaître
    le langage. Une liste complète des mots clé est disponible dans l'<xref
    linkend="sql-keywords-appendix">.
   </para>

   <para>
    Les identifieurs et les mots clés SQL doivent commencer avec une lettre
    (<literal>a</literal>-<literal>z</literal>, mais aussi des lettres de
    marques diacritiques différentes et des lettres non latines) ou un tiret bas
    (<literal>_</literal>). Les caractères suivants dans un identifieur ou dans
    un mot clé peuvent être des lettres, des tirets-bas, des chiffres
    (<literal>0</literal>-<literal>9</literal>) ou des signes dollar
    (<literal>$</>). Notez que les signes dollar ne sont pas autorisés en tant
    qu'identifieur suivant le standard SQL, donc leur utilisation pourrait
    rendre les applications moins portables. Le standard SQL ne définira pas un
    mot clé contenant des chiffres ou commençant ou finissant par un tiret bas,
    donc les identifieurs de cette forme sont sûr de passer les conflits
    possibles avec les futures extensions du standard.
   </para>

   <para>
   
<indexterm><primary>identifieur</primary><secondary>longueur</secondary>
</indexterm>
    Le système utilise au plus <symbol>NAMEDATALEN</symbol>-1 caractères
    d'un identifieur ; les noms longs peuvent être écrits dans des
    commandes mais ils seront tronqués. Par défaut, <symbol>NAMEDATALEN</symbol>
    vaut 64. Du coup, la taille maximum de l'identifieur est de 63. Si cette
    limite est problématique, elle peut être élevée en modifiant
    <symbol>NAMEDATALEN</symbol> dans
    <filename>src/include/postgres_ext.h</filename>.
   </para>

   <para>
    <indexterm>
     <primary>sensibilité à la casse</primary>
     <secondary>des commandes SQL</secondary>
    </indexterm>
    L'identifieur et les noms de mots clés sont insensibles à la casse. Du coup,
<programlisting>
UPDATE MA_TABLE SET A = 5;
</programlisting>
    peut aussi s'écrire de cette façon
<programlisting>
uPDaTE ma_TabLE SeT a = 5;
</programlisting>
    Une convention couramment utilisée revient à écrire les mots clés en
    majuscule et les noms en minuscule, c'est-à-dire
<programlisting>
UPDATE ma_table SET a = 5;
</programlisting>
   </para>

   <para>
    <indexterm>
     <primary>marques de citation</primary>
     <secondary>et identifieurs</secondary>
    </indexterm>
    Voici un deuxième type d'identifieur : l'<firstterm>identifieur
    délimité</firstterm> ou l'<firstterm>identifieur entre
    guillemets</firstterm>. Il est formé en englobant une séquence arbitraire de
    caractères entre des guillemets doubles (<literal>"</literal>). <!-- "
    font-lock mania --> Un identifieur délimité est toujours un identifieur,
    jamais un mot clé. Donc, <literal>"select"</literal> pourrait être utilisé
    pour faire référence à une colonne ou à une table nommée
    <quote>select</quote>, alors qu'un <literal>select</literal> sans guillemets
    sera pris pour un mot clé et du coup, pourrait provoquer une erreur
    d'analyse lorsqu'il est utilisé alors qu'un nom de table ou de colonne est
    attendu. L'exemple peut être écrit avec des identifieurs entre guillemets
    comme ceci :
<programlisting>
UPDATE "ma_table" SET "a" = 5;
</programlisting>
   </para>

   <para>
    Les identifieurs entre guillemets peuvent contenir tout caractère autre
    qu'un guillemet double (pour inclure un guillemet double, écrivez deux
    guillemets doubles). Ceci permet la construction de noms de tables et de
    colonnes qui ne seraient pas possible autrement, comme des noms
    contenant des espaces ou des arobases. La limitation de la longueur
    s'applique toujours.
   </para>

   <para>
    Mettre un identifieur entre guillemets le rend sensible à la casse
    alors que les noms sans guillemets sont toujours convertis en minuscules. Par
    exemple, les identifieurs <literal>FOO</literal>, <literal>foo</literal> et
    <literal>"foo"</literal> sont considérés identiques par
    <productname>PostgreSQL</productname> mais <literal>"Foo"</literal> et
    <literal>"FOO"</literal> sont différents des trois autres et entre eux. La
    mise en minuscule des noms sans guillemets avec <productname>PostgreSQL</>
    n'est pas compatible avec le standard SQL qui indique que les noms sans
    guillemets devraient être mis en majuscule. Du coup, <literal>foo</literal>
    devrait être équivalent à <literal>"FOO"</literal> et non pas à
    <literal>"foo"</literal> en respect avec le standard. Si vous voulez écrire
    des applications portables, nous vous conseillons de toujours mettre entre
    guillemets un nom particulier ou de ne jamais le mettre.
   </para>
  </sect2>


  <sect2 id="sql-syntax-constants">
   <title>Constantes</title>

   <indexterm zone="sql-syntax-constants">
    <primary>constante</primary>
   </indexterm>

   <para>
    Il existe trois <firstterm>types implicites de constantes</firstterm> dans
    <productname>PostgreSQL</productname> : les chaînes, les chaînes de
    bits et les nombres. Les constantes peuvent aussi être spécifiées avec des
    types explicites, ce qui peut activer des représentations plus précises 
    et gérées plus efficacement par le système. Les constantes implicites sont
    décrites ci-dessous ; ces constantes sont discutées dans les
    sous-sections suivantes.
   </para>

   <sect3 id="sql-syntax-strings">
    <title>Constantes de chaînes</title>

    <indexterm zone="sql-syntax-strings">
     <primary>chaîne de caractère</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     <indexterm>
      <primary>marques de citation</primary>
      <secondary>échappement</secondary>
     </indexterm>
     Une constante de type chaîne en SQL est une séquence arbitraire de
     caractères entourée par des guillemets simples (<literal>'</literal>),
     c'est-à-dire <literal>'Ceci est une chaîne'</literal>. La façon standard
     d'écrire un guillemet simple dans une chaîne constante est d'écrire deux
     guillemets simples adjacents, par exemple <literal>'Le cheval
     d''Anne'</literal>. <productname>PostgreSQL</productname> autorise aussi
     l'échappement des guillemets simples avec un antislash (<literal>\'</literal>).
     Néanmoins, les prochaines versions de <productname>PostgreSQL</productname>
     ne permettront plus ceci, donc les applications utilisant des antislashs
     doivent passer à la méthode standard indiquée ci-dessus.
    </para>

    <para>
     Une autre extension de <productname>PostgreSQL</productname> fait que les
     échappements style C sont disponibles :
     <literal>\b</literal> est un retour arrière, <literal>\f</literal> est un
     retour chariot, <literal>\n</literal> est une nouvelle ligne,
     <literal>\r</literal> est un retour chariot, <literal>\t</literal> est une
     tabulation. La forme <literal>\<replaceable>chiffres</replaceable></literal>,
     est aussi supporté. <replaceable>chiffres</replaceable> représente une
     valeur d'un octet en octal. La forme
     <literal>\x<replaceable>chiffres hexa</replaceable></literal>,
     est aussi supporté mais <replaceable>chiffres hexa</replaceable> représente
     une valeur d'un octet en hexadécimal (il est de votre responsabilité que les
     séquences d'octets créées soient composées de caractères valides dans le
     codage de l'ensemble des caractères). Tout autre caractère suivant un
     antislash est pris littéralement. Du coup, pour inclure un antislash dans
     une constante de type chaîne, saisissez deux antislashs.
    </para>

    <note>
    <para>
     Alors que les chaînes ordinaires supportent maintenant les échappements
     style C avec l'antislash, les prochaines versions génèreront des messages
     d'avertissements lors d'un tel usage et traiteront éventuellement les
     antislashs comme des caractères litteraux pour se conformer au standard.
     La bonne façon de spécifier un traitement des échappements est d'utiliser
     la syntaxe de la chaîne d'échappement pour indiquer que le traitement des
     échappements est souhaité. La syntaxe de chaîne d'échappement est spécifiée
     en écrivant la lettre <literal>E</literal> (majuscule ou minuscule) juste
     avant la chaîne, par exemple <literal>E'\041'</>. Cette méthode fonctionnera
     dans toutes les prochaines versions de <productname>PostgreSQL</productname>.
    </para>
    </note>

    <para>
     Le caractère de code zéro ne peut pas être dans une constante de type
     chaîne.
    </para>

    <para>
     Deux constantes de type chaîne séparées par un espace blanc
     <emphasis>avec au moins une nouvelle ligne</emphasis> sont concaténées et
     traitées réellement comme si la chaîne avait été écrite dans une constante.
     Par exemple :
<programlisting>
SELECT 'foo'
'bar';
</programlisting>
     est équivalent à
<programlisting>
SELECT 'foobar';
</programlisting>
     mais
<programlisting>
SELECT 'foo'      'bar';
</programlisting>
     n'a pas une syntaxe valide (ce comportement légèrement bizarre est
     spécifié par le standard <acronym>SQL</acronym> ;
     <productname>PostgreSQL</productname> suit le standard).
    </para>
   </sect3>

   <sect3 id="sql-syntax-dollar-quoting">
     <title>Constantes de chaînes avec guillemet dollar</title>

     <indexterm>
       <primary>guillemet dollar</primary>
     </indexterm>

     <para>
       Alors que la syntaxe standard pour la spécification des constantes de
       chaînes est généralement agréable, elle peut être difficile à comprendre
       quand la chaîne désirée contient un grand nombre de guillemets ou
       d'antislashs car chacun d'entre eux doit être doublé. Pour permettre la
       saisie de requêtes plus lisibles dans de telles situations,
       <productname>PostgreSQL</productname> fournit une autre façon, appelée
       <quote>guillemet dollar</quote>, pour écrire des constantes de chaînes.
       Une constante de chaîne avec guillemet dollar consiste en un signe
       dollar (<literal>$</literal>), une <quote>balise</quote> optionnelle
       de zéro ou plus de caractères, un autre signe dollar, une séquence
       arbitraire de caractères qui constitue le contenu de la chaîne, un signe
       dollar, la même balise et un signe dollar. Par exemple, voici deux
       façons de spécifier la chaîne <quote>Le cheval d'Anne</> en utilisant
       les guillemets dollar :
     <programlisting>
       $$Le cheval d'Anne$$
       $UneBalise$Le cheval d'Anne$UneBalise$
     </programlisting>
       Notez qu'à l'intérieur de la chaîne avec guillemet dollar, les
       guillemets simples peuvent être utilisés sans devoir être échappés. En
       fait, aucun caractère à l'intérieur d'une chaîne avec guillemet dollar
       n'a besoin d'être échappé : le contenu est toujours écrit
       littéralement. Les antislashs ne sont pas spéciaux, pas plus que les
       signes dollar, sauf s'ils font partie d'une séquence correspondant à
       la balise ouvrante.
     </para>
   
     <para>
       Il est possible d'imbriquer les constantes de chaînes avec guillemets
       dollar en utilisant différentes balises pour chaque niveau
       d'imbrication. Ceci est habituellement utilisé lors de l'écriture de
       définition de fonctions. Par exemple :
     <programlisting>
       $fonction$
       BEGIN
       RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
       END;
       $fonction$
     </programlisting>
       Ici, la séquence <literal>$q$[\t\r\n\v\\]$q$</> représente une chaîne
       littérale avec guillemet dollar <literal>[\t\r\n\v\\]</>, qui sera
       reconnu quand le corps de la fonction est exécuté par
       <productname>PostgreSQL</>. Mais comme la séquence ne correspond pas au
       délimiteur <literal>$fonction$</>, il s'agit juste de quelques
       caractères à l'intérieur de la constante pour ce qu'en sait la
       chaîne externe.
     </para>

     <para>
      La balise d'une chaîne avec guillemets dollar, si elle existe, suit les
      mêmes règles qu'un identificateur sans guillemets, sauf qu'il ne peut
      pas contenir de signes dollar. Les balises sont sensibles à la casse,
      du coup <literal>$balise$Contenu de la chaîne$balise$</literal> est
      correct mais <literal>$BALISE$Contenu de la chaîne$balise$</literal> ne
      l'est pas.
     </para>

     <para>
      Une chaîne avec guillemets dollar suivant un mot clé ou un identifieur
      doit en être séparé par un espace blanc ; sinon, le délimiteur du
      guillemet dollar serait pris comme faisant parti de l'identifieur
      précédent.
     </para>

     <para>
      Le guillemet dollar ne fait pas partie du standard SQL mais c'est un
      moyen bien plus agréable pour écrire des chaînes littérales que 
      d'utiliser la syntaxe des guillemets simples, bien que compatible avec
      le standard. Elle est particulièrement utile  pour représenter des
      constantes de type chaîne à l'intérieur d'autres constantes, comme cela
      est souvent le cas avec les définitions de fonctions. Avec la syntaxe des
      guillemets simples, chaque antislash dans l'exemple précédent devrait
      avoir été écrit avec quatre antislashs, ce qui sera réduit à deux
      antislashs dans l'analyse de la constante originale, puis à un lorsque
      la constante interne est analysée de nouveau lors de l'exécution de la
      fonction.
     </para>
   </sect3>

   <sect3 id="sql-syntax-bit-strings">
    <title>Constantes de chaînes de bits</title>

    <indexterm zone="sql-syntax-bit-strings">
     <primary>chaîne de bit</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     Les constantes de chaînes de bits ressemblent aux constantes de chaînes
     standards avec un <literal>B</literal> (majuscule ou minuscule) juste avant le
     guillemet du début (sans espace blanc), c'est-à-dire
     <literal>B'1001'</literal>. Les seuls caractères autorisés dans les
     constantes de type chaîne de bits sont <literal>0</literal> et
     <literal>1</literal>.
    </para>

    <para>
     Autrement, les constantes de chaînes de bits peuvent être spécifiées en
     notation hexadécimale en utilisant un <literal>X</literal> avant (minuscule
     ou majuscule), c'est-à-dire <literal>X'1FF'</literal>. Cette notation est
     équivalente à une constante de chaîne de bits avec quatre chiffres binaires
     pour chaque chiffre hexadécimal.
    </para>

    <para>
     Les deux formes de constantes de chaînes de bits peuvent être continuées 
     sur plusieurs lignes de la même façon que les constantes de chaînes
     habituelles. Le guillemet dollar ne peut pas être utilisé dans une constante
     de chaîne de bits.
    </para>
   </sect3>

   <sect3>
    <title>Constantes numériques</title>

    <indexterm>
     <primary>nombre</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     Les constantes numériques sont acceptées dans ces formes générales :
<synopsis>
<replaceable>chiffres</replaceable>
<replaceable>chiffres</replaceable>.<optional><replaceable>chiffres</replaceable></optional><optional>e<optional>+-</optional><replaceable>chiffres</replaceable></optional>
<optional><replaceable>chiffres</replaceable></optional>.<replaceable>chiffres</replaceable><optional>e<optional>+-</optional><replaceable>chiffres</replaceable></optional>
<replaceable>chiffres</replaceable>e<optional>+-</optional><replaceable>chiffres</replaceable>
</synopsis>
     où <replaceable>chiffres</replaceable> est un ou plusieurs chiffres
     décimaux (de 0 à 9). Au moins un chiffre doit être avant ou après le point
     décimal, s'il est utilisé. Au moins un chiffre doit suivre l'indicateur
     d'exponentiel (<literal>e</literal>), s'il est présent. Il peut ne pas
     y avoir d'espaces ou d'autres caractères imbriqués dans la constante. Notez
     que tout signe plus ou moins en avant n'est pas forcément considéré comme
     faisant part de la constante ; il est un opérateur appliqué à la
     constante.
    </para>

    <para>
     Voici quelques exemples de constantes numériques valides :
<literallayout>
42
3.5
4.
.001
5e2
1.925e-3
</literallayout>
    </para>

    <para>
     <indexterm><primary>integer</primary></indexterm>
     <indexterm><primary>bigint</primary></indexterm>
     <indexterm><primary>numeric</primary></indexterm>
     Une constante numérique contenant soit un point décimal soit un
     exposant est tout d'abord présumée du type <type>integer</> si sa valeur
     est contenue dans le type <type>integer</> (32 bits) ; sinon, il est
     présumé de type <type>bigint</> si sa valeur entre dans un type
     <type>bigint</> (64 bits) ; sinon, il est pris pour un type
     <type>numeric</>. Les constantes contenant des poins décimaux et/ou des
     exposants sont toujours présumées de type <type>numeric</>.
    </para>

    <para>
     Le type de données affecté initialement à une constante numérique 
     est seulement un point de départ pour les algorithmes de résolution de
     types. Dans la plupart des cas, la constante sera automatiquement convertie
     dans le type le plus approprié suivant le contexte. Si nécessaire, vous
     pouvez forcer l'interprétation d'une valeur numérique sur un type de
     données spécifiques en la convertissant. <indexterm><primary>conversion de
     type</primary></indexterm> Par exemple, vous pouvez forcer une valeur
     numérique à être traitée comme un type <type>real</> (<type>float4</>) en
     écrivant

<programlisting>
REAL '1.23'  -- style chaîne
1.23::REAL   -- style PostgreSQL (historique)
</programlisting>

      Ce sont en fait des cas spéciaux des notations de conversion générales
      discutées après.
     </para>
    </sect3>

   <sect3 id="sql-syntax-constants-generic">
    <title>Constantes d'autres types</title>

    <indexterm>
     <primary>type de données</primary>
     <secondary>constante</secondary>
    </indexterm>

    <para>
     Une constante de type <emphasis>arbitrary</emphasis> peut être saisie en
     utilisant une des notations suivantes :
<synopsis>
<replaceable>type</replaceable> '<replaceable>chaîne</replaceable>'
'<replaceable>chaîne</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>chaîne</replaceable>' AS <replaceable>type</replaceable> )
</synopsis>
     Le texte de la chaîne constante est passé dans la routine de conversion
     pour le type
     appelé <replaceable>type</replaceable>. Le résultat est une constante du
     type indiqué. La conversion explicite de type peut être omise s'il n'y
     a pas d'ambiguïté sur le type de la constante (par exemple, lorsqu'elle est
     affectée directement à une colonne de la table), auquel cas elle est
     convertie automatiquement.
    </para>


    <para>
     La constante chaîne peut être écrite en utilisant soit la notation SQL
     standard soit les guillemets dollar.
    </para>
    <para>
     Il est aussi possible de spécifier une conversion de type en utilisant une
     syntaxe style fonction :
<synopsis>
<replaceable>nom_type</replaceable> ( '<replaceable>chaîne</replaceable>' )
</synopsis>
     mais tous les noms de type ne peuvent pas être utilisés ainsi ; voir
     la <xref linkend="sql-syntax-type-casts"> pour plus de détails.
    </para>

    <para>
     Les syntaxes <literal>::</literal>, <literal>CAST()</literal> et d'appels
     de fonctions sont aussi utilisables pour spécifier les conversions de
     type à l'exécution d'expressions arbitraires, comme discuté dans la <xref
     linkend="sql-syntax-type-casts">. Mais, la forme
     <literal><replaceable>type</replaceable>
     '<replaceable>chaîne</replaceable>'</literal> peut seulement être utilisée
     pour spécifier le type d'une constante littérale. Une autre restriction sur
     <literal><replaceable>type</replaceable>
     '<replaceable>chaîne</replaceable>'</literal> est qu'il ne fonctionne pas
     pour les types de tableau ; utilisez <literal>::</literal> ou
     <literal>CAST()</literal> pour spécifier le type d'une constante de type
     tableau.
    </para>

    <para>
     La syntaxe de <literal>CAST()</> est conforme au standard SQL.  La syntaxe
     <literal><replaceable>type</replaceable> '<replaceable>chaine</replaceable>'</literal>
     est une généralisation du standard : SQL spécifie cette syntaxe
     uniquement pour quelques types de données mais
     <productname>PostgreSQL</productname> l'autorise pour tous les types. La
     syntaxe <literal>::</literal> est un usage historique dans
     <productname>PostgreSQL</productname>, comme l'est la syntaxe d'appel de
     fonction.
    </para>
   </sect3>
  </sect2>

  <sect2 id="sql-syntax-operators">
   <title>Opérateurs</title>

   <indexterm zone="sql-syntax-operators">
    <primary>opérateur</primary>
    <secondary>syntaxe</secondary>
   </indexterm>

   <para>
    Un nom d'opérateur est une séquence d'au plus <symbol>NAMEDATALEN</symbol>-1
    (63 par défaut) caractères provenant de la liste suivante :
<literallayout>
+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
</literallayout>

    Néanmoins, il existe quelques restrictions sur les noms d'opérateurs :
    <itemizedlist>
     <listitem>
      <para>
       <literal>--</literal> et <literal>/*</literal> ne peuvent pas apparaître
       quelque part dans un nom d'opérateur car ils seront pris pour le début
       d'un commentaire.
      </para>
     </listitem>

     <listitem>
      <para>
       Un nom d'opérateur à plusieurs caractères ne peut pas finir avec
       <literal>+</> ou <literal>-</>, sauf si le nom contient aussi un de ces
       caractères :
<literallayout>
~ ! @ # % ^ &amp; | ` ?
</literallayout>
       Par exemple, <literal>@-</literal> est un nom d'opérateur autorisé mais
       <literal>*-</literal> ne l'est pas. Cette restriction permet à
       <productname>PostgreSQL</productname> d'analyser des requêtes
       compatibles avec SQL sans requérir des espaces entre les jetons.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Lors d'un travail avec des noms d'opérateurs ne faisant pas partie du
    standard SQL, vous aurez habituellement besoin de séparer les opérateurs
    adjacents avec des espaces pour éviter toute ambiguïté. Par exemple, si
    vous avez défini un opérateur unaire gauche nommé <literal>@</literal>,
    vous ne pouvez pas écrire <literal>X*@Y</literal> ; vous devez écrire
    <literal>X* @Y</literal> pour vous assurer que
    <productname>PostgreSQL</productname> le lit comme deux noms d'opérateurs,
    et non pas comme un seul.
   </para>
  </sect2>

  <sect2>
   <title>Caractères spéciaux</title>

  <para>
   Quelques caractères non alphanumériques ont une signification spéciale,
   différente de celui d'un opérateur. Les détails sur leur utilisation sont
   disponibles à l'endroit où l'élément de syntaxe respectif est décrit. Cette
   section existe seulement pour avertir de leur existence et pour résumer le
   but de ces caractères.

   <itemizedlist>
    <listitem>
     <para>
      Un signe dollar (<literal>$</literal>) suivi de chiffres est utilisé pour
      représenter un paramètre de position dans le corps de la définition d'une
      fonction ou d'une instruction préparée. Dans d'autres contextes, le signe
      dollar pourrait faire partie d'un identifieur ou d'une constante de type
      chaîne utilisant le dollar comme guillemet.
     </para>
    </listitem>

    <listitem>
     <para>
      Les parenthèses (<literal>()</literal>) ont leur signification habituelle
      pour grouper leurs expressions et renforcer la précédence. Dans certains
      cas, les parenthèses sont requises car faisant partie de la syntaxe fixée
      d'une commande SQL particulière.
     </para>
    </listitem>

    <listitem>
     <para>
      Les crochets (<literal>[]</literal>) sont utilisés pour sélectionner les
      éléments d'un tableau. Voir la <xref linkend="arrays"> pour plus
      d'informations sur les tableaux.
     </para>
    </listitem>

    <listitem>
     <para>
      Les virgules (<literal>,</literal>) sont utilisées dans quelques
      constructions syntaxiques pour séparer les éléments d'une liste.
     </para>
    </listitem>

    <listitem>
     <para>
      Le point-virgule (<literal>;</literal>) termine une commande SQL. Il ne
      peut pas apparaître quelque part dans une commande, sauf à l'intérieur
      d'une constante de type chaîne ou d'un identifieur entre guillemets.
     </para>
    </listitem>

    <listitem>
     <para>
      Le caractère deux points (<literal>:</literal>) est utilisé pour
      sélectionner des <quote>morceaux</quote> de tableaux (voir la <xref
      linkend="arrays">). Dans certains dialectes SQL (tel que le SQL embarqué),
      il est utilisé pour préfixer les noms de variable.
     </para>
    </listitem>

    <listitem>
     <para>
      L'astérisque (<literal>*</literal>) est utilisé dans certains contextes
      pour indiquer tous les champs de la ligne d'une table ou d'une valeur
      composite. Elle a aussi une signification spéciale lorsqu'elle est
      utilisée comme argument de la fonction d'agrégat <function>COUNT</function>.
     </para>
    </listitem>

    <listitem>
     <para>
      Le point (<literal>.</literal>) est utilisé dans les constantes
      numériques et pour séparer les noms de schéma, table et colonne.
     </para>
    </listitem>
   </itemizedlist>

   </para>
  </sect2>

  <sect2 id="sql-syntax-comments">
   <title>Commentaires</title>

   <indexterm zone="sql-syntax-comments">
    <primary>commentaire</primary>
    <secondary sortas="SQL">en SQL</secondary>
   </indexterm>

   <para>
    Un commentaire est une séquence arbitraire de caractères commençant avec
    deux tirets et s'étendant jusqu'à la fin de la ligne, par exemple :
<programlisting>
-- Ceci est un commentaire standard en SQL
</programlisting>
   </para>

   <para>
    Autrement, les blocs de commentaires style C peuvent être utilisés :
<programlisting>
/* commentaires multilignes
 * et imbriqués: /* bloc de commentaire imbriqué */
 */
</programlisting>
    où le commentaire commence avec <literal>/*</literal> et s'étend jusqu'à
    l'occurrence de <literal>*/</literal>. Ces blocs de commentaires
    s'imbriquent, comme spécifié dans le standard SQL mais pas comme dans le
    langage C. De ce fait, vous pouvez commenter des blocs importants de code
    pouvant contenir des blocs de commentaires déjà existants.
   </para>

   <para>
    Un commentaire est supprimé du flux en entrée avant une analyse plus
    poussée de la syntaxe et est remplacé par un espace blanc.
   </para>
  </sect2>

  <sect2 id="sql-precedence">
   <title>Précédence lexicale</title>

   <indexterm zone="sql-precedence">
    <primary>opérateur</primary>
    <secondary>précédence</secondary>
   </indexterm>

   <para>
    Le <xref linkend="sql-precedence-table"> affiche la précédence et
l'associativité des opérateurs dans <productname>PostgreSQL</>. La plupart des
opérateurs ont la même précédence et sont associatifs par la gauche. La
précédence et l'associativité des opérateurs sont codées en dur dans
l'analyseur. Ceci pourrait conduire à un comportement non intuitif ; par
exemple, les opérateurs booléens <literal>&lt;</> et <literal>&gt;</> ont une
précédence différente des opérateurs booléens <literal>&lt;=</> et
<literal>&gt;=</>. De même, vous aurez quelque fois besoin d'ajouter des
parenthèses lors de l'utilisation de combinaisons d'opérateurs binaires et
unaires. Par exemple :
<programlisting>
SELECT 5 ! - 6;
</programlisting>
   sera analysé comme
<programlisting>
SELECT 5 ! (- 6);
</programlisting>
    parce que l'analyseur n'a aucune idée, jusqu'à ce qu'il soit trop
    tard, que <token>!</token> est défini comme un opérateur suffixe, et non pas
    préfixe. Pour obtenir le comportement désiré dans ce cas, vous devez
    écrire :
<programlisting>
SELECT (5 !) - 6;
</programlisting>
    C'est le prix à payer pour l'extensibilité.
   </para>

   <table id="sql-precedence-table">
    <title>Précédence des opérateurs (en ordre décroissant)</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>Opérateur/Élément</entry>
       <entry>Associativité</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><token>.</token></entry>
       <entry>gauche</entry>
       <entry>séparateur de noms de table et de colonne</entry>
      </row>

      <row>
       <entry><token>::</token></entry>
       <entry>gauche</entry>
       <entry>conversion de type,
        style <productname>PostgreSQL</productname></entry>
      </row>

      <row>
       <entry><token>[</token> <token>]</token></entry>
       <entry>gauche</entry>
       <entry>sélection d'un élément d'un tableau</entry>
      </row>

      <row>
       <entry><token>-</token></entry>
       <entry>droite</entry>
       <entry>négation unaire</entry>
      </row>

      <row>
       <entry><token>^</token></entry>
       <entry>gauche</entry>
       <entry>exponentiel</entry>
      </row>

      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
       <entry>gauche</entry>
       <entry>multiplication, division, modulo</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>gauche</entry>
       <entry>addition, soustraction</entry>
      </row>

      <row>
       <entry><token>IS</token></entry>
       <entry></entry>
       <entry><literal>IS TRUE</>, <literal>IS FALSE</>, <literal>IS UNKNOWN</>,
        <literal>IS NULL</></entry>
      </row>

      <row>
       <entry><token>ISNULL</token></entry>
       <entry></entry>
       <entry>test pour NULL</entry>
      </row>

      <row>
       <entry><token>NOTNULL</token></entry>
       <entry></entry>
       <entry>test pour non NULL</entry>
      </row>

      <row>
       <entry>(autres)</entry>
       <entry>gauche</entry>
       <entry>tout autre opérateur natif et défini par l'utilisateur</entry>
      </row>

      <row>
       <entry><token>IN</token></entry>
       <entry></entry>
       <entry>appartenance à un ensemble</entry>
      </row>

      <row>
       <entry><token>BETWEEN</token></entry>
       <entry></entry>
       <entry>compris entre</entry>
      </row>

      <row>
       <entry><token>OVERLAPS</token></entry>
       <entry></entry>
       <entry>surcharge un intervalle de temps</entry>
      </row>

      <row>
       <entry><token>LIKE</token> <token>ILIKE</token>
<token>SIMILAR</token></entry>
       <entry></entry>
       <entry>correspondance de modèles de chaînes</entry>
      </row>

      <row>
       <entry><token>&lt;</token> <token>&gt;</token></entry>
       <entry></entry>
       <entry>inférieur, supérieur à</entry>
      </row>

      <row>
       <entry><token>=</token></entry>
       <entry>droite</entry>
       <entry>égalité, affectation</entry>
      </row>

      <row>
       <entry><token>NOT</token></entry>
       <entry>droite</entry>
       <entry>négation logique</entry>
      </row>

      <row>
       <entry><token>AND</token></entry>
       <entry>gauche</entry>
       <entry>conjonction logique</entry>
      </row>

      <row>
       <entry><token>OR</token></entry>
       <entry>gauche</entry>
       <entry>disjonction logique</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Notez que les règles de précédence des opérateurs s'appliquent aussi aux
    opérateurs définis par l'utilisateur qui ont le même nom que les
    opérateurs internes mentionnés ici. Par exemple, si vous définissez un
    opérateur <quote>+</quote> pour un type de données personnalisé, il aura la
    même précédence que l'opérateur interne <quote>+</quote>, peu importe ce
    que fait le votre.
   </para>

   <para>
    Lorsqu'un nom d'opérateur qualifié par un schéma est utilisé
    dans la syntaxe <literal>OPERATOR</>, comme par exemple dans
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    la construction <literal>OPERATOR</> est prise pour avoir la
    précédence par défaut affichée dans le <xref linkend="sql-precedence-table">
    pour les opérateurs <quote>autres</>. Ceci est vrai quelque soit le nom
    spécifique de l'opérateur apparaissant à l'intérieur de
    <literal>OPERATOR()</>.
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-expressions">
  <title>Expressions de valeurs</title>

  <indexterm zone="sql-expressions">
   <primary>expression</primary>
   <secondary>syntaxe</secondary>
  </indexterm>

  <indexterm zone="sql-expressions">
   <primary>expression de valeur</primary>
  </indexterm>

  <indexterm>
   <primary>scalaire</primary>
   <see>expression</see>
  </indexterm>

  <para>
   Les expressions de valeurs sont utilisées dans une grande variété de
   contextes, tels que dans la liste cible d'une commande
   <command>SELECT</command>, dans les nouvelles valeurs de colonnes d'une
   commande <command>INSERT</command> ou <command>UPDATE</command>, ou dans les
   conditions de recherche d'un certain nombre de commandes. Le résultat d'une
   expression de valeurs est quelque fois appelé
   <firstterm>scalaire</firstterm>, pour le distinguer du résultat d'une
   expression de table (qui est une table). Les expressions de valeurs sont
   aussi appelées des <firstterm>expressions scalaires</firstterm> (voire même
   simplement des <firstterm>expressions</firstterm>). La syntaxe d'expression
   permet le calcul des valeurs à partir de morceaux primitifs en utilisant les
   opérations arithmétiques, logiques, d'ensemble et autres.
  </para>

  <para>
   Une expression de valeur peut être :

   <itemizedlist>
    <listitem>
     <para>
      Une constante ou une valeur littérale.
     </para>
    </listitem>

    <listitem>
     <para>
      Une référence de colonne.
     </para>
    </listitem>

    <listitem>
     <para>
      Une référence de paramètre de position, dans le corps d'une définition de
      fonction ou d'instruction préparée.
     </para>
    </listitem>

    <listitem>
     <para>
      Une expression indicée.
     </para>
    </listitem>

    <listitem>
     <para>
      Une expression de sélection de champs.
     </para>
    </listitem>

    <listitem>
     <para>
      Un appel d'opérateur.
     </para>
    </listitem>

    <listitem>
     <para>
      Un appel de fonction.
     </para>
    </listitem>

    <listitem>
     <para>
      Une expression d'agrégat.
     </para>
    </listitem>

    <listitem>
     <para>
      Une conversion de type.
     </para>
    </listitem>

    <listitem>
     <para>
      Une sous-requête scalaire.
     </para>
    </listitem>

    <listitem>
     <para>
      Un constructeur de tableau.
     </para>
    </listitem>

    <listitem>
     <para>
      Un constructeur de ligne.
     </para>
    </listitem>

    <listitem>
     <para>
      Toute expression de tableau entre parenthèses, utile pour grouper
      des sous-expressions et surcharger la
      précédence.<indexterm><primary>parenthèses</></>
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   En plus de cette liste, il existe un certain nombre de constructions pouvant
   être classées comme une expression mais ne suivant aucune règle de syntaxe
   générale. Elles ont généralement la sémantique d'une fonction ou d'un
   opérateur et sont expliquées à l'emplacement approprié dans le <xref
   linkend="functions">. Un exemple est la clause <literal>IS NULL</literal>.
  </para>

  <para>
   Nous avons déjà discuté des constantes dans la <xref
   linkend="sql-syntax-constants">. Les sections suivantes discutent des
   options restantes.
  </para>

  <sect2>
   <title>Références de colonnes</title>

   <indexterm>
    <primary>référence de colonne</primary>
   </indexterm>

   <para>
    Une colonne peut être référencée avec la forme
<synopsis>
<replaceable>correlation</replaceable>.<replaceable>nom_colonne</replaceable>
</synopsis>
   </para>

   <para>
    <replaceable>correlation</replaceable> est le nom d'une table (parfois
    qualifié par son nom de schéma) ou un alias d'une table définie au moyen de
    la clause <literal>FROM</literal> ou un des mots clés <literal>NEW</literal>
    ou <literal>OLD</literal> (<literal>NEW</literal> et <literal>OLD</literal>
    peuvent seulement apparaître dans les règles de réécriture alors que les
    autres noms de corrélation peuvent être utilisés dans toute instruction
    SQL). Le nom de corrélation et le point de séparation peuvent être omis si
    le nom de colonne est unique dans les tables utilisées par la requête
    courante (voir aussi le <xref linkend="queries">).
   </para>
  </sect2>

  <sect2>
   <title>Paramètres de position</title>

   <indexterm>
    <primary>paramètre</primary>
    <secondary>syntaxe</secondary>
   </indexterm>

   <indexterm>
    <primary>$</primary>
   </indexterm>

   <para>
    Un paramètre de position est utilisé pour indiquer une valeur fournie en
    externe par une instruction SQL. Les paramètres sont utilisés dans des
    définitions de fonction SQL et dans les requêtes préparées. Quelques
    bibliothèques clients supportent aussi la spécification de valeurs de
    données séparément de la chaîne de commande SQL, auquel cas les paramètres
    sont utilisés pour référencer les valeurs de données en dehors. Le format
    d'une référence de paramètre est :
<synopsis>
$<replaceable>numéro</replaceable>
</synopsis>
   </para>

   <para>
    Par exemple, considérez la définition d'une fonction
    <function>dept</function> comme

<programlisting>
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE nom = $1 $$
    LANGUAGE SQL;
</programlisting>

    Ici, <literal>$1</literal> référence la valeur du premier argument de la
    fonction à chaque appel de cette commande.
   </para>
  </sect2>

  <sect2>
   <title>Indices</title>

   <indexterm>
    <primary>indice</primary>
   </indexterm>

   <para>
    Si une expression récupère une valeur de type tableau, alors un élément
    spécifique du tableau peut être extrait en écrivant
<synopsis>
<replaceable>expression</replaceable>[<replaceable>indice</replaceable>]
</synopsis>
    ou des éléments adjacents (un <quote>morceau de tableau</>) peuvent
    être extrait en écrivant
<synopsis>
<replaceable>expression</replaceable>[<replaceable>indice_bas</replaceable>:<replaceable>indice_haut</replaceable>]
</synopsis>
    Ici, les crochets <literal>[ ]</literal> doivent apparaître littéralement.
    Chaque <replaceable>indice</replaceable> est lui-même une expression, qui
    doit contenir une valeur entière.
   </para>

   <para>
    En général, l'<replaceable>expression</replaceable> de type tableau doit
    être entre parenthèses mais ces dernières peuvent être omises lorsque l'expression à
    indicer est seulement une référence de colonne ou une position de paramètre.
    De plus, les indices multiples peuvent être concaténés lorsque le tableau
    original est multi-dimensionnel. Par exemple,

<programlisting>
ma_table.colonnetableau[4]
ma_table.colonnes_deux_d[17][34]
$1[10:42]
(fonctiontableau(a,b))[42]
</programlisting>

    Dans ce dernier exemple, les parenthèses sont requises. Voir la <xref
    linkend="arrays"> pour plus d'informations sur les tableaux.
   </para>
  </sect2>

  <sect2>
   <title>Sélection de champs</title>

   <indexterm>
    <primary>sélection de champs</primary>
   </indexterm>

   <para>
    Si une expression récupère une valeur de type composite (type row), alors un
    champ spécifique de la ligne est extrait en écrivant
<synopsis>
<replaceable>expression</replaceable>.<replaceable>nom_champ</replaceable>
</synopsis>
   </para>

   <para>
    En général, l'<replaceable>expression</replaceable> de ligne doit être
    entre parenthèses mais les parenthèses peuvent être omises lorsque
    l'expression à partir de laquelle se fait la sélection est seulement une
    référence de table ou un paramètre de position. Par exemple,

<programlisting>
ma_table.macolonne
$1.unecolonne
(fonctionligne(a,b)).col3
</programlisting>

    Donc, une référence de colonne qualifiée est réellement un cas spécial de 
    syntaxe de sélection de champ.
   </para>
  </sect2>

  <sect2>
   <title>Appels d'opérateurs</title>

   <indexterm>
    <primary>opérateur</primary>
    <secondary>appel</secondary>
   </indexterm>

   <para>
    Il existe trois syntaxes possibles pour l'appel d'un opérateur :
    <simplelist>
     <member><replaceable>expression</replaceable>
     <replaceable>opérateur</replaceable> <replaceable>expression</replaceable>
     (opérateur binaire préfixe)</member>
     <member><replaceable>opérateur</replaceable>
     <replaceable>expression</replaceable> (opérateur unaire préfixe)</member>
     <member><replaceable>expression</replaceable>
     <replaceable>opérateur</replaceable> (opérateur unaire suffixe)</member>
    </simplelist>
    où le jeton <replaceable>opérateur</replaceable> suit les règles de syntaxe
    de la <xref linkend="sql-syntax-operators">, ou est un des mots clés
    <token>AND</token>, <token>OR</token> et <token>NOT</token>, ou est un nom
    d'opérateur qualifié de la forme
<synopsis>
<literal>OPERATOR(</><replaceable>schema</><literal>.</><replaceable>
nom_operateur</><literal>)</>
</synopsis>
    Quel opérateur particulier existe et est-il unaire ou binaire dépend des
    opérateurs définis par le système ou l'utilisateur. Le <xref
    linkend="functions"> décrit les opérateurs internes.
   </para>
  </sect2>

  <sect2>
   <title>Appels de fonctions</title>

   <indexterm>
    <primary>fonction</primary>
    <secondary>appel</secondary>
   </indexterm>

   <para>
    La syntaxe pour un appel de fonction est le nom d'une fonction (qualifié ou
    non du nom du schéma) suivi par sa liste d'arguments entre
    parenthèses :

<synopsis>
<replaceable>fonction</replaceable>(<optional><replaceable>expression</replaceable> <optional>,<replaceable>expression</replaceable> ... </optional></optional> )
</synopsis>
   </para>

   <para>
    Par exemple, ce qui suit calcule la racine carré de 2 :
<programlisting>
sqrt(2)
</programlisting>
   </para>

   <para>
    La liste des fonctions intégrées se trouve dans le <xref
    linkend="functions">. D'autres fonctions pourraient être ajoutées par
    l'utilisateur.
   </para>
  </sect2>

  <sect2 id="syntax-aggregates">
   <title>Expressions d'agrégat</title>

   <indexterm zone="syntax-aggregates">
    <primary>fonction d'agrégat</primary>
    <secondary>appel</secondary>
   </indexterm>

   <para>
    Une <firstterm>expression d'agrégat</firstterm> représente l'application
    d'une fonction d'agrégat à travers les lignes sélectionnées par une requête.
    Une fonction d'agrégat réduit les nombres entrés en une seule valeur de
    sortie, comme la somme ou la moyenne des valeurs en entrée. La syntaxe d'une
    expression d'agrégat est une des suivantes :

<synopsis>
<replaceable>nom_agregat</replaceable> (<replaceable>expression</replaceable>)
<replaceable>nom_agregat</replaceable> (ALL <replaceable>expression</replaceable>)
<replaceable>nom_agregat</replaceable> (DISTINCT <replaceable>expression</replaceable>)
<replaceable>nom_agregat</replaceable> ( * )
</synopsis>

    où <replaceable>nom_agregat</replaceable> est un agrégat précédemment
    défini (parfois qualifié d'un nom de schéma) et 
    <replaceable>expression</replaceable> est toute expression de valeur qui ne
    contient pas lui-même une expression d'agrégat.
   </para>

   <para>
    La première forme d'expression d'agrégat appelle l'agrégat pour
    toutes les lignes en entrée pour lesquelles l'expression donnée ne trouve
    pas une valeur NULL (en fait, c'est à la fonction d'agrégat de savoir si
    elle doit ignorer ou non les valeurs NULL... mais toutes les fonctions
    standards le font). La seconde forme est identique à la première car
    <literal>ALL</literal> est ajouté par défaut. La troisième forme implique
    l'agrégat pour toutes les valeurs de l'expression non NULL et distinctes
    trouvées dans les lignes en entrée. La dernière forme appelle l'agrégat une
    fois pour chaque ligne en entrée qu'elle soit NULL ou non ; comme
    aucune valeur particulière en entrée n'est spécifiée, c'est généralement
    utile pour la fonction d'agrégat <function>count()</function>.
   </para>

   <para>
    Par exemple, <literal>count(*)</literal> trouve le nombre total de lignes
    en entrée ; <literal>count(f1)</literal> récupère le nombre de lignes
    en entrée pour lesquelles <literal>f1</literal> n'est pas NULL ;
    <literal>count(distinct f1)</literal> retrouve le nombre de valeurs
    distinctes non NULL de <literal>f1</literal>.
   </para>

   <para>
    Les fonctions d'agrégat prédéfinies sont décrites dans la <xref
    linkend="functions-aggregate">. D'autres fonctions d'agrégat
    pourraient être ajoutées par l'utilisateur. 
   </para>

   <para>
    Une expression d'agrégat pourrait apparaître dans la liste de résultat ou
    dans la clause <literal>HAVING</> d'une commande <command>SELECT</>. Elle est
    interdite dans d'autres clauses, telles que <literal>WHERE</>, parce que ces
    clauses sont logiquement évaluées avant que les résultats des agrégats ne
    soient formés.
   </para>

   <para>
    Lorsqu'une expression d'agrégat apparaît dans une sous-requête (voir la
    <xref linkend="sql-syntax-scalar-subqueries"> et la
    <xref linkend="functions-subquery">), l'agrégat est normalement évalué sur
    les lignes de la sous-requête. Mais, une exception arrive si l'argument de
    l'agrégat contient seulement des niveaux externes de variables :
    ensuite, l'agrégat appartient au niveau externe le plus proche et est évalué
    sur les lignes de cette requête. L'expression de l'agrégat en un tout est
    une référence externe pour la sous-requête dans laquelle il apparaît et agit
    comme une constante sur toute évaluation de cette requête. La restriction
    apparaissant seulement dans la liste de résultat ou dans la clause
    <literal>HAVING</> s'applique avec respect du niveau de requête auquel
    appartient l'agrégat.
   </para>
  </sect2>

  <sect2 id="sql-syntax-type-casts">
   <title>Conversions de type</title>

   <indexterm>
    <primary>type de données</primary>
    <secondary>conversion de type</secondary>
   </indexterm>

   <indexterm>
    <primary>conversion de type</primary>
   </indexterm>

   <para>
    Une conversion de type spécifie une conversion à partir d'un type de
    données en un autre. <productname>PostgreSQL</productname> accepte deux
    syntaxes équivalentes pour les conversions de type :
<synopsis>
CAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )
<replaceable>expression</replaceable>::<replaceable>type</replaceable>
</synopsis>
    La syntaxe <literal>CAST</> est conforme à SQL ; la syntaxe avec
    <literal>::</literal> est historique dans
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    Lorsqu'une conversion est appliquée à une expression de valeur pour un
    type connu, il représente une conversion de type à l'exécution. Cette
    conversion réussira seulement si une opération convenable de conversion de
    type a été définie. Notez que ceci est subtilement différent de
    l'utilisation de conversion avec des constantes, comme indiqué dans la <xref
    linkend="sql-syntax-constants-generic">. Une conversion appliquée à une
    chaîne littérale représente l'affectation initiale d'un type pour une
    valeur constante littérale, et donc cela réussira pour tout type (si le
    contenu de la chaîne littérale est une syntaxe acceptée en entrée pour le
    type de donnée).
   </para>

   <para>
    Une conversion de type explicite pourrait être habituellement omise s'il
    n'y a pas d'ambiguïté sur le type qu'une expression de valeur pourrait
    produire (par exemple, lorsqu'elle est affectée à une colonne de
    table) ; le système appliquera automatiquement une conversion de type
    dans de tels cas. Néanmoins, la conversion automatique est réalisée
    seulement pour les conversions marquées <quote>OK pour application
    implicite</> dans les catalogues système. D'autres conversions peuvent être
    appelées avec la syntaxe de conversion explicite. Cette restriction a pour
    but d'empêcher l'application silencieuse de conversions surprenantes.
   </para>

   <para>
    Il est aussi possible de spécifier une conversion de type en utilisant une
    syntaxe de type fonction :
<synopsis>
<replaceable>nom_type</replaceable> ( <replaceable>expression</replaceable> )
</synopsis>
    Néanmoins, ceci fonctionne seulement pour les types dont les noms sont 
    aussi valides en tant que noms de fonctions. Par exemple, <literal>double
    precision</literal> ne peut pas être utilisé de cette façon mais son
    équivalent <literal>float8</literal> le peut. De même, les noms
    <literal>interval</>, <literal>time</> et <literal>timestamp</> peuvent
    seulement être utilisés de cette façon s'ils sont entre des guillemets
    doubles à cause des conflits de syntaxe. Du coup, l'utilisation de la
    syntaxe de conversion du style fonction amène à des inconsistances et
    devrait probablement être évitée dans les nouvelles applications.

    (La syntaxe style fonction est en fait seulement un appel de fonction.
    Quand un des deux standards de syntaxe de conversion est utilisé pour faire
    une conversion à l'exécution, elle appellera en interne une fonction
    enregistrée pour réaliser la conversion. Par convention, ces fonctions de
    conversion ont le même nom que leur type de sortie et, du coup, la
    <quote>syntaxe style fonction</> n'est rien de plus qu'un appel direct à la
    fonction de conversion sous-jacente. Évidemment, une application portable ne
    devrait pas s'y fier.)
   </para>
  </sect2>

  <sect2 id="sql-syntax-scalar-subqueries">
   <title>Sous-requêtes scalaires</title>

   <indexterm>
    <primary>sous-requête</primary>
   </indexterm>

   <para>
    Une sous-requête scalaire est une requête <command>SELECT</command>
    ordinaire entre parenthèses renvoyant exactement une ligne avec une colonne
    (voir le <xref linkend="queries"> pour plus d'informations sur l'écriture
    des requêtes). La requête <command>SELECT</command> est exécutée et la
    seule valeur renvoyée est utilisée dans l'expression de valeur englobante.
    C'est une erreur d'utiliser une requête qui renvoie plus d'une ligne ou plus
    d'une colonne comme requête scalaire. Mais si, lors d'une exécution
    particulière, la sous-requête ne renvoie pas de lignes, alors il n'y a pas
    d'erreur ; le résultat scalaire est supposé NULL. La sous-requête peut
    référencer des variables de la requête englobante, qui agiront comme des
    constantes durant toute évaluation de la sous-requête. Voir aussi la <xref
    linkend="functions-subquery"> pour d'autres expressions impliquant des
    sous-requêtes.
   </para>

   <para>
    Par exemple, ce qui suit trouve la ville disposant de la population la plus
    importante dans chaque état :
<programlisting>
SELECT nom, (SELECT max(pop) FROM villes WHERE villes.etat = etat.nom)
    FROM etats;
</programlisting>
   </para>
  </sect2>

  <sect2 id="sql-syntax-array-constructors">
   <title>Constructeurs de tableaux</title>

   <indexterm>
    <primary>tableau</primary>
    <secondary>constructeur</secondary>
   </indexterm>

   <indexterm>
    <primary>ARRAY</primary>
   </indexterm>

   <para>
    Un constructeur de tableau est une expression qui construit une valeur de
    tableau à partir de valeurs de ses membres. Un constructeur de tableau
    simple utilise le mot clé <literal>ARRAY</literal>, un crochet ouvrant
    <literal>[</>, une ou plusieurs expressions (séparées par des virgules)
    pour les valeurs des éléments du tableau et finalement un crochet fermant
    <literal>]</>. Par exemple :
<programlisting>
SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)
</programlisting>
    Le type d'élément du tableau est le type commun des expressions des membres,
    déterminé en utilisant les mêmes règles que pour les constructions
    <literal>UNION</> ou <literal>CASE</> (voir la <xref
    linkend="typeconv-union-case">). 
   </para>

   <para>
    Les valeurs de tableaux multidimensionnels peuvent être construits par des
    constructeurs de tableaux imbriqués. Pour les constructeurs internes, le mot
    clé <literal>ARRAY</literal> peut être omis. Par exemple, ces
    expressions produisent le même résultat :

<programlisting>
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)
</programlisting>

    Comme les tableaux multidimensionnels doivent être rectangulaires, les
    constructeurs internes du même niveau doivent produire des
    sous-tableaux de dimensions identiques.
  </para>

  <para>
    Les éléments d'un constructeur de tableau multidimensionnel peuvent être
    tout ce qui récupère un tableau du bon type, pas seulement une construction
    d'un tableau imbriqué. Par exemple :
<programlisting>
CREATE TABLE tab(f1 int[], f2 int[]);

INSERT INTO tab VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM tab;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
</programlisting>
  </para>

  <para>
   Il est aussi possible de construire un tableau à partir des résultats d'une
   sous-requête. Avec cette forme, le constructeur de tableau est écrit avec le
   mot clé <literal>ARRAY</literal> suivi par une sous-requête entre
   parenthèses (et non pas des crochets). Par exemple :
<programlisting>
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                          ?column?
-------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31}
(1 row)
</programlisting>
   La sous-requête doit renvoyer une seule colonne. Le tableau à une dimension
   résultant aura un élément pour chaque ligne dans le résultat de la
   sous-requête, avec un type élément correspondant à celui de la colonne en
   sortie de la sous-requête.
  </para>

  <para>
   Les indices d'une valeur de tableau construit avec <literal>ARRAY</literal>
   commencent toujours à un. Pour plus d'informations sur les tableaux, voir la
   <xref linkend="arrays">.
  </para>

  </sect2>

  <sect2 id="sql-syntax-row-constructors">
    <title>Constructeurs de lignes</title>

    <indexterm>
      <primary>type composite</primary>
      <secondary>constructeur</secondary>
    </indexterm>

    <indexterm>
      <primary>type de ligne</primary>
      <secondary>constructeur</secondary>
    </indexterm>

    <indexterm>
      <primary>ROW</primary>
    </indexterm>

    <para>
      Un constructeur de ligne est une expression qui construit une valeur de
      ligne (aussi appelée une valeur composite) à partir des valeurs de ses
      membres. Un constructeur de ligne consiste en un mot clé
      <literal>ROW</literal>, une parenthèse gauche, zéro ou plus d'une
      expression (séparées par des virgules) pour les valeurs des champs de la
      ligne, et finalement une parenthèse droite. Par exemple,
      <programlisting>
        SELECT ROW(1,2.5,'ceci est un test');
      </programlisting>
      Le mot clé <literal>ROW</> est optionnel lorsqu'il y a plus d'une expression
      dans la liste.
  </para>

  <para>
    Par défaut, la valeur créée par une expression <literal>ROW</> est d'un
    type d'enregistrement anonyme. Si nécessaire, il peut être converti en un
    type composite nommé &mdash; soit le type de ligne d'une table soit un type
    composite créé avec <command>CREATE TYPE AS</>. Une conversion explicite
    pourrait être nécessaire pour éviter une ambiguïté. Par exemple :
<programlisting>
  CREATE TABLE ma_table(f1 int, f2 float, f3 text);

  CREATE FUNCTION recup_f1(ma_table) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

  -- Aucune conversion nécessaire parce que seul un recup_f1() existe
  SELECT recup_f1(ROW(1,2.5,'ceci est un test'));
  recup_f1
  --------
  1
  (1 row)

  CREATE TYPE mon_typeligne AS (f1 int, f2 text, f3 numeric);

  CREATE FUNCTION recup_f1(mon_typeligne) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

  -- Maintenant, nous avons besoin d'une conversion pour indiquer la fonction à appeler:
  SELECT recup_f1(ROW(1,2.5,'ceci est un test'));
  ERROR:  function recup_f1(record) is not unique

  SELECT recup_f1(ROW(1,2.5,'ceci est un test')::ma_table);
  getf1
  -------
  1
  (1 row)

  SELECT recup_f1(CAST(ROW(11,'ceci est un test',2.5) AS mon_typeligne));
  getf1
  -------
  11
  (1 row)
</programlisting>
</para>

  <para>
   Les constructeurs de lignes peuvent être utilisés pour construire des valeurs
   composites à stocker dans une colonne de table de type composite ou pour être
   passé à une fonction qui accepte un paramètre composite. De plus, il est
   possible de comparer deux valeurs de lignes ou pour tester une ligne avec
   <literal>IS NULL</> ou <literal>IS NOT NULL</>, par exemple
<programlisting>
  SELECT ROW(1,2.5,'ceci est un test') = ROW(1, 3, 'pas le même');
  
  SELECT ROW(a, b, c) IS NOT NULL FROM table;
</programlisting>
   Pour plus de détails, voir la <xref linkend="functions-comparisons">. Les
   constructeurs de lignes peuvent aussi être utilisés en connexion avec
   des sous-requêtes, comme discuté dans la <xref linkend="functions-subquery">.
  </para>

  </sect2>

  <sect2 id="syntax-express-eval">
   <title>Règles d'évaluation des expressions</title>

   <indexterm>
    <primary>expression</primary>
    <secondary>ordre d'évaluation</secondary>
   </indexterm>

   <para>
    L'ordre d'évaluation des sous-expressions n'est pas défini. En   
    particulier, les entrées d'un opérateur ou d'une fonction ne sont pas
    nécessairement évaluées de la gauche vers la droite ou dans un autre ordre
    fixé.
   </para>

   <para>
    De plus, si le résultat d'une expression peut être déterminé par
    l'évaluation de certaines parties de celle-ci, alors d'autres
    sous-expressions devraient ne pas être évaluées du tout. Par exemple, si
    vous écrivez :
<programlisting>
SELECT true OR une_fonction();
</programlisting>
    alors <literal>une_fonction()</literal> pourrait (probablement) ne pas être
    appelée du tout. Pareil dans le cas suivant :
<programlisting>
SELECT une_fonction() OR true;
</programlisting>
    Notez que ceci n'est pas identique au <quote>court-circuitage</quote> de
    gauche à droite des opérateurs booléens utilisé par certains langages de
    programmation.
   </para>

   <para>
    En conséquence, il est déconseillé d'utiliser des fonctions ayant des
    effets de bord dans une partie des expressions complexes. Il est
    particulièrement dangereux de se fier aux effets de bord ou à l'ordre
    d'évaluation dans les clauses <literal>WHERE</> et <literal>HAVING</> car
    ces clauses sont reproduites de nombreuses fois lors du développement du
    plan d'exécution. Les expressions booléennes (combinaisons
    <literal>AND</>/<literal>OR</>/<literal>NOT</>) dans ces clauses pourraient
    être réorganisées d'une autre façon autorisée dans l'algèbre
    booléenne.
   </para>

   <para>
    Quand il est essentiel de forcer l'ordre d'évaluation, une construction
    <literal>CASE</> (voir la <xref linkend="functions-conditional">) peut
être utilisée. Par exemple, c'est une façon, non sûre, d'essayer d'éviter
une division par zéro dans une clause <literal>WHERE</> :
<programlisting>
SELECT ... WHERE x &lt;&gt; 0 AND y/x &gt; 1.5;
</programlisting>
    Mais ceci est sûr :
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
    Une construction <literal>CASE</> utilisée de cette façon déjouera les
    tentatives d'optimisation, donc cela ne sera fait que si nécessaire (dans
    cet exemple particulier, il serait sans doute mieux de contourner le
    problème en écrivant <literal>y &gt; 1.5*x</>).
   </para>
  </sect2>
 </sect1>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
