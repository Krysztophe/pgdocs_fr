
<sect1 id="tablefunc">
 <title>tablefunc</title>
 
 <indexterm zone="tablefunc">
  <primary>tablefunc</primary>
 </indexterm>

 <para>
  <literal>tablefunc</literal> fournit des fonctions permettant de convertir
  les lignes d'une requête en champs.
 </para>
 <sect2>
  <title>Fonctions</title>
  <table>
   <title></title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Retour</entry>
      <entry>Commentaires</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <literal>
        normal_rand(int numvals, float8 mean, float8 stddev)
       </literal>
      </entry>
      <entry>
       renvoie un ensemble de valeurs float8 normalement distribuées
      </entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>crosstabN(text sql)</literal></entry>
      <entry>renvoie un ensemble de row_name plus N valeurs de catégorie</entry>
      <entry>
       crosstab2(), crosstab3() et crosstab4() sont définis pour vous mais
       vous pouvez créer des fonctions crosstab supplémentaires en suivant
       les instructions de cette documentation.
      </entry>
     </row>
     <row>
      <entry><literal>crosstab(text sql)</literal></entry>
      <entry>renvoie un ensemble de row_name plus N colonnes de valeurs
       de catégorie</entry>
      <entry>
       nécessite une syntaxe pour un type composite anonyme dans la clause
       FROM. Voir les instructions dans cette documentation.
      </entry>
     </row>
     <row>
      <entry><literal>crosstab(text sql, N int)</literal></entry>
      <entry></entry>
      <entry>
       <para>version obsolète de crosstab()</para>
       <para>
        l'argument N est maintenant ignoré car le nombre de colonnes de
	valeurs est toujours déterminé par la requête appelant
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <literal>
        connectby(text relname, text keyid_fld, text parent_keyid_fld
        [, text orderby_fld], text start_with, int max_depth
        [, text branch_delim])
       </literal>
      </entry>
      <entry>
       renvoie keyid, parent_keyid, level, une chaîne branch optionnelle et
       une colonne serial optionnelle pour ordonner les suivants
      </entry>
      <entry>
       nécessite une syntaxe pour un type composite anonyme dans la clause
       FROM. Voir les instructions dans cette documentation.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect3>
   <title><literal>normal_rand</literal></title>
    <programlisting>
normal_rand(int numvals, float8 mean, float8 stddev) RETURNS SETOF float8
    </programlisting>
    <para>
     <literal>numvals</literal> est le nombre de valeurs à renvoyer à partir
     de la fonction. <literal>mean</literal> est la moyenne de la distribution
     normale des valeurs et <literal>stddev</literal> est la déviation standard
     de la distribution normale des valeurs.
    </para>
    <para>
     Renvoie un ensemble float8 de valeurs prises au hasard dans la
     distribution (Gaussienne).
    </para>
    <para>
     Exemple&nbsp;:
    </para>
    <programlisting>
  test=# SELECT * FROM
  test=# normal_rand(1000, 5, 3);
     normal_rand
----------------------
     1.56556322244898
     9.10040991424657
     5.36957140345079
   -0.369151492880995
    0.283600703686639
       .
       .
       .
     4.82992125404908
     9.71308014517282
     2.49639286969028
(1000 rows)
    </programlisting>
    <para>
     Renvoie 1000 valeurs avec une moyenne de 5 et une déviation standard de 3.
    </para>
  </sect3>


  <sect3>
   <title><literal>crosstabN(text sql)</literal></title>
    <programlisting>
crosstabN(text sql)
    </programlisting>
    <para>
     Le paramètre <literal>sql</literal> est une instruction SQL qui produit
     l'ensemble source des données. L'instruction SQL doit renvoyer une colonne
     row_name, une colonne category, et une colonne value.
     <literal>row_name</literal> et value doivent être de type text. La
     fonction renvoie un ensemble de <literal>row_name</literal> plus N
     colonnes category.
    </para>
    <para>
     Le <literal>sql</literal> fourni doit produire ensemble ressemblant à
     celui-ci&nbsp;:
    </para>
<programlisting>
row_name    cat    value
---------+-------+-------
 row1      cat1    val1
 row1      cat2    val2
 row1      cat3    val3
 row1      cat4    val4
 row2      cat1    val5
 row2      cat2    val6
 row2      cat3    val7
 row2      cat4    val8
 </programlisting>
    <para>
     La valeur renvoyée est un <literal>SETOF table_crosstab_N</literal> qui
     est défini par&nbsp;:
    </para>
    <programlisting>
CREATE TYPE tablefunc_crosstab_N AS (
    row_name TEXT,
    category_1 TEXT,
    category_2 TEXT,
        .
        .
        .
    category_N TEXT
);
    </programlisting>
    <para>
     pour les fonctions installées par défaut avec N valant 2, 3 ou 4.
    </para>
    <para>
     Par exemple, la fonction crosstab2 fourni produit un ensemble ressemblant
     à ceci&nbsp;:
    </para>
    <programlisting><![CDATA[
                      <== values  columns ==>
           row_name   category_1   category_2
           ---------+------------+------------
             row1        val1         val2
             row2        val5         val6
    ]]></programlisting>
    <note>
     <orderedlist>
      <listitem><para>Le sql résultant doit être ordonné par
       1,2.</para></listitem>
      <listitem>
       <para>
        Le nombre des colonnes de valeurs dépend de la description de la
	ligne dans le type déclaré en retour.
       </para>
      </listitem>
      <listitem>
       <para>
        Les valeurs manquantes (c'est-à-dire pas assez de lignes adjacentes
	du même row_name pour remplir le nombre de colonnes values en
	résultat) sont remplies avec des NULL.
       </para>
      </listitem>
      <listitem>
       <para>
        Les valeurs supplémentaires (c'est-à-dire trop de lignes adjacentes
	du même row_name pour remplir le nombre de colonnes values en
	résultat) sont ignorées.
       </para>
      </listitem>
      <listitem>
       <para>
        Les lignes ne contenant que des NULL dans les colonnes de valeurs
	sont ignorées.
       </para>
      </listitem>
      <listitem>
       <para>
        Les valeurs par défauts sont dans un but d'illustration. Vous pouvez
	créer vos propres types de retour et vos propres fonctions basées sur
	la fonction crosstab() de la fonction. Voir ci-dessous pour les détails.
       </para>
      </listitem>
     </orderedlist>
    </note>
    <para>
     Exemple&nbsp;:
    </para>
    <programlisting>
create table ct(id serial, rowclass text, rowid text, attribute text, value text);
insert into ct(rowclass, rowid, attribute, value) values('group1','test1','att1','val1');
insert into ct(rowclass, rowid, attribute, value) values('group1','test1','att2','val2');
insert into ct(rowclass, rowid, attribute, value) values('group1','test1','att3','val3');
insert into ct(rowclass, rowid, attribute, value) values('group1','test1','att4','val4');
insert into ct(rowclass, rowid, attribute, value) values('group1','test2','att1','val5');
insert into ct(rowclass, rowid, attribute, value) values('group1','test2','att2','val6');
insert into ct(rowclass, rowid, attribute, value) values('group1','test2','att3','val7');
insert into ct(rowclass, rowid, attribute, value) values('group1','test2','att4','val8');

select * from crosstab3(
  'select rowid, attribute, value
   from ct
   where rowclass = ''group1''
   and (attribute = ''att2'' or attribute = ''att3'') order by 1,2;');

 row_name | category_1 | category_2 | category_3
----------+------------+------------+------------
 test1    | val2       | val3       |
 test2    | val6       | val7       |
(2 rows)
    </programlisting>
   </sect3>

  <sect3>
   <title><literal>crosstab(text)</literal></title>
   <programlisting>
crosstab(text sql)
crosstab(text sql, int N)
   </programlisting>
   <para>
    Le paramètre <literal>sql</literal> est une instruction SQL qui produit
    source de données. L'instruction SQL doit renvoyer une colonne
    <literal>row_name</literal>, une colonne <literal>category</literal>
    et une colonne <literal>value</literal>. <literal>N</literal> est un
    argument obsolète&nbsp;; ignoré si fourni (auparavant cela aurait
    correspondu au nombre des colonnes category déterminé par la
    requête appelante).
   </para>
   <para>
   </para>
   <para>
    Par exemple, la requête fournie doit produire un ensemble identique à celui
    ci-dessous&nbsp;:
   </para>
<programlisting>
 row_name    cat    value
----------+-------+-------
  row1      cat1    val1
  row1      cat2    val2
  row1      cat3    val3
  row1      cat4    val4
  row2      cat1    val5
  row2      cat2    val6
  row2      cat3    val7
  row2      cat4    val8
</programlisting>
   <para>
    Renvoie un <literal>SETOF RECORD</literal> devant être défini avec une
    définition de colonne dans la clause FROM de l'instruction SELECT, par
    exemple&nbsp;:
   </para>
   <programlisting>
    SELECT *
    FROM crosstab(sql) AS ct(row_name text, category_1 text, category_2 text);
   </programlisting>
   <para>
    La fonction exemple crosstab produit ce type d'ensemble&nbsp;:
   </para>
   <programlisting><![CDATA[
            <== values  columns ==>
row_name   category_1   category_2
 ---------+------------+------------
   row1        val1         val2
   row2        val5         val6
   ]]></programlisting>
   <para>
    Notez qu'il suit ces règles&nbsp;:
   </para>
    <orderedlist>
     <listitem><para>Le résultat de la requête doit être ordonné par 1,2.</para></listitem>
     <listitem>
      <para>
      Le nombre de colonnes values est déterminé par la définition de la colonne
      fournie dans la clause FROM. Cette clause doit définir une colonne row_name
      (du même type de données que la première colonne résultat d'une requête SQL)
      suivie par N colonnes category (du même type de données que la troisième
      colonne du résultat de la requête SQL). Vous pouvez configurer autant de
      colonnes category que vous souhaitez.
      </para>
     </listitem>
     <listitem>
      <para>
      Les valeurs manquantes (c'est-à-dire sans lignes suffisamment adjacentes
      du même row_name pour remplir le nombre des colonnes values résultantes)
      sont remplies avec des valeurs NULL.
      </para>
     </listitem>
     <listitem>
      <para>
      Les valeurs supplémentaires (c'est-à-dire trop de lignes adjacentes du
      même row_name pour remplir le nombre des colonnes values du résultat)
      sont ignorées.
      </para>
     </listitem>
     <listitem>
      <para>
      Les lignes ne contenant que des NULLS dans leur colonnes sont ignorées.
      </para>
     </listitem>
     <listitem>
      <para>
      Vous pouvez toujours éviter d'avoir à écrire une clause FROM qui définit
      les colonnes en sortie en configurant une fonction crosstab personnalisée
      qui a le type ligne désiré en sortie dans sa définition.
      </para>
     </listitem>
    </orderedlist>
    <para>
     Il existe deux façon de configurer une fonction crosstab personnalisée&nbsp;:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Crée un type composite pour définir le type en retour, comme dans les
       exemples du script d'installation. Puis, définir un nom de fonction
       unique acceptant un paramètre texte et renvoyant un setof de votre type.
       Par exemple, si vos données source produisent des row_names qui sont
       de type TEXT et des valeurs qui sont de type FLOAT8, et que vous voulez
       cinq colonnes category&nbsp;:
      </para>
      <programlisting>
      CREATE TYPE my_crosstab_float8_5_cols AS (
          row_name TEXT,
          category_1 FLOAT8,
          category_2 FLOAT8,
          category_3 FLOAT8,
          category_4 FLOAT8,
          category_5 FLOAT8
      );

      CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)
        RETURNS setof my_crosstab_float8_5_cols
        AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
      </programlisting>
     </listitem>
     <listitem>
      <para>
       Utiliser les paramètres OUT pour définir implicitement le type en retour.
       Le même exemple pourrait aussi avoir été créé ainsi&nbsp;:
      </para>
      <programlisting>
      CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(IN text,
          OUT row_name TEXT,
          OUT category_1 FLOAT8,
          OUT category_2 FLOAT8,
          OUT category_3 FLOAT8,
          OUT category_4 FLOAT8,
          OUT category_5 FLOAT8)
        RETURNS setof record
        AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
      </programlisting>
     </listitem>
    </itemizedlist>
    <para>
     Exemple&nbsp;:
    </para>
    <programlisting>
CREATE TABLE ct(id SERIAL, rowclass TEXT, rowid TEXT, attribute TEXT, value TEXT);
INSERT INTO ct(rowclass, rowid, attribute, value) VALUES('group1','test1','att1','val1');
INSERT INTO ct(rowclass, rowid, attribute, value) VALUES('group1','test1','att2','val2');
INSERT INTO ct(rowclass, rowid, attribute, value) VALUES('group1','test1','att3','val3');
INSERT INTO ct(rowclass, rowid, attribute, value) VALUES('group1','test1','att4','val4');
INSERT INTO ct(rowclass, rowid, attribute, value) VALUES('group1','test2','att1','val5');
INSERT INTO ct(rowclass, rowid, attribute, value) VALUES('group1','test2','att2','val6');
INSERT INTO ct(rowclass, rowid, attribute, value) VALUES('group1','test2','att3','val7');
INSERT INTO ct(rowclass, rowid, attribute, value) VALUES('group1','test2','att4','val8');

SELECT *
FROM crosstab(
  'select rowid, attribute, value
   from ct
   where rowclass = ''group1''
   and (attribute = ''att2'' or attribute = ''att3'') order by 1,2;', 3)
AS ct(row_name text, category_1 text, category_2 text, category_3 text);

 row_name | category_1 | category_2 | category_3
----------+------------+------------+------------
 test1    | val2       | val3       |
 test2    | val6       | val7       |
(2 rows)
    </programlisting>

  </sect3>

  <sect3>
   <title><literal>crosstab(text, text)</literal></title>
   <programlisting>
crosstab(text source_sql, text category_sql)
   </programlisting>

   <para>
    <literal>source_sql</literal> est une instruction SQL qui produit l'ensemble
    des données sources. L'instruction SQL doit renvoyer une colonne
    <literal>row_name</literal>, une colonne <literal>category</literal> et une
    colonne <literal>value</literal>. Il pourrait aussi avoir une ou plusieurs
    colonnes <emphasis>extra</emphasis>.
   </para>
   <para>
    La première colonne doit être <literal>row_name</literal>. Les colonnes
    <literal>category</literal> et <literal>value</literal> doivent être les
    deux dernières colonnes, dans cet ordre. Les colonnes
    <emphasis>extra</emphasis> doivent être les colonnes 2 à
    (N - 2), où N est le nombre total de colonnes.
   </para>
   <para>
    Les colonnes <emphasis>extra</emphasis> sont supposées être identiques pour
    toutes les lignes avec le même <literal>row_name</literal>. Les valeurs
    renvoyées sont copiées à partir de la première ligne avec un
    <literal>row_name</literal> donné et les valeurs suivantes de ces colonnes
    sont ignorées jusqu'à la modification de <literal>row_name</literal>.
   </para>
   <para>
    C'est-à-dire que <literal>source_sql</literal> doit produire un ensemble qui
    ressemble à ceci&nbsp;:
   </para>
   <programlisting>
 SELECT row_name, extra_col, cat, value FROM foo;

     row_name    extra_col   cat    value
    ----------+------------+-----+---------
      row1         extra1    cat1    val1
      row1         extra1    cat2    val2
      row1         extra1    cat4    val4
      row2         extra2    cat1    val5
      row2         extra2    cat2    val6
      row2         extra2    cat3    val7
      row2         extra2    cat4    val8
   </programlisting>

   <para>
    <literal>category_sql</literal> doit être une instruction SQL qui produit
    un ensemble distinct de catégories. L'instruction SQL doit renvoyer une
    colonne category. <literal>category_sql</literal> doit produire au moins
    une ligne de résultat. Sinon une erreur est générée.
    <literal>category_sql</literal> ne doit pas produire de catégories
    dupliquées, sinon une erreur est là-aussi générée. Par exemple&nbsp;:
   </para>
   <programlisting>
SELECT DISTINCT cat FROM foo;
    cat
  -------
    cat1
    cat2
    cat3
    cat4
   </programlisting>
   <para>
    La fonction renvoie <literal>SETOF RECORD</literal> qui doit être définie
    avec une définition de colonnes dans la clause FROM de l'instruction SELECT.
    Par exemple&nbsp;:
   </para>
   <programlisting>
    SELECT * FROM crosstab(source_sql, cat_sql)
    AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);
   </programlisting>
   <para>
    La fonction exemple crosstab produit un ensemble identique à celui
    ci-dessous&nbsp;:
   </para>
   <programlisting><![CDATA[
                      <== values  columns ==>
           row_name   extra   cat1   cat2   cat3   cat4
           ---------+-------+------+------+------+------
             row1     extra1  val1   val2          val4
             row2     extra2  val5   val6   val7   val8
   ]]></programlisting>
   <para>
    Notez qu'il suit les règles suivantes&nbsp;:
   </para>
   <orderedlist>
    <listitem><para>source_sql doit être ordonnée par row_name (la première
     colonne).</para></listitem>
     <listitem>
      <para>
      Les valeurs manquantes (c'est-à-dire sans lignes suffisamment adjacentes
      du même row_name pour remplir le nombre des colonnes values résultantes)
      sont remplies avec des valeurs NULL.
      </para>
     </listitem>
     <listitem>
      <para>
      Les valeurs supplémentaires (c'est-à-dire les lignes sans category trouvée
      dans le résultat de category_sql) sont ignorées.
      </para>
     </listitem>
     <listitem>
      <para>
      Les lignes ne contenant que des NULLS dans leur colonnes sont ignorées.
      </para>
     </listitem>
    <listitem>
     <para>
      Vous pouvez créer des fonctions prédéfinies pour éviter d'avoir à écrire
      les noms de colonnes/types du résultat dans chaque requête. Voir les
      exemples pour crosstab(text).
     </para>
    </listitem>
   </orderedlist>

   <programlisting>
CREATE TABLE cth(id serial, rowid text, rowdt timestamp, attribute text, val text);
INSERT INTO cth VALUES(DEFAULT,'test1','01 March 2003','temperature','42');
INSERT INTO cth VALUES(DEFAULT,'test1','01 March 2003','test_result','PASS');
INSERT INTO cth VALUES(DEFAULT,'test1','01 March 2003','volts','2.6987');
INSERT INTO cth VALUES(DEFAULT,'test2','02 March 2003','temperature','53');
INSERT INTO cth VALUES(DEFAULT,'test2','02 March 2003','test_result','FAIL');
INSERT INTO cth VALUES(DEFAULT,'test2','02 March 2003','test_startdate','01 March 2003');
INSERT INTO cth VALUES(DEFAULT,'test2','02 March 2003','volts','3.1234');

SELECT * FROM crosstab
(
  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',
  'SELECT DISTINCT attribute FROM cth ORDER BY 1'
)
AS
(
       rowid text,
       rowdt timestamp,
       temperature int4,
       test_result text,
       test_startdate timestamp,
       volts float8
);
 rowid |          rowdt           | temperature | test_result |      test_startdate      | volts  
-------+--------------------------+-------------+-------------+--------------------------+--------
 test1 | Sat Mar 01 00:00:00 2003 |          42 | PASS        |                          | 2.6987
 test2 | Sun Mar 02 00:00:00 2003 |          53 | FAIL        | Sat Mar 01 00:00:00 2003 | 3.1234
(2 rows)
   </programlisting>
  </sect3>
  <sect3>
   <title>
    <literal>connectby(text, text, text[, text], text, text, int[, text])</literal>
   </title>
   <programlisting>
connectby(text relname, text keyid_fld, text parent_keyid_fld
            [, text orderby_fld], text start_with, int max_depth
            [, text branch_delim])
   </programlisting>
   <table>
    <title>Paramètres de <literal>connectby</literal></title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Paramètre</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>relname</literal></entry>
       <entry>Nom de la relation source</entry>
      </row>
      <row>
       <entry><literal>keyid_fld</literal></entry>
       <entry>Nom du champ clé</entry>
      </row>
      <row>
       <entry><literal>parent_keyid_fld</literal></entry>
       <entry>Nom du champ key_parent</entry>
      </row>
      <row>
       <entry><literal>orderby_fld</literal></entry>
       <entry>
        Si l'ordre optionnel des enfants est désiré&nbsp;: nom du champ pour
	ce tri
       </entry>
      </row>
      <row>
       <entry><literal>start_with</literal></entry>
       <entry>
        Valeur racine de l'arbre en tant que valeur texte quelque soit
        <literal>keyid_fld</literal>
       </entry>
      </row>
      <row>
       <entry><literal>max_depth</literal></entry>
       <entry>
        Zéro (0) pour une profondeur illimitée, sinon restriction du niveau
	à cette profondeur
       </entry>
      </row>
      <row>
       <entry><literal>branch_delim</literal></entry>
       <entry>
         Si la valeur de la branche optionnelle est souhaitée, cette chaîne est
	 utilisée comme délimiteur. Lorsqu'elle n'est pas fournie, une valeur
	 par défaut, '~', est uniquement utilisée en interne pour détecter une
         récursion, et aucun champ branch n'est renvoyé.
       </entry>
      </row>
      </tbody>
     </tgroup>
    </table>
    <para>
     La fonction renvoie un <literal>SETOF RECORD</literal> qui doit être défini
     avec une définition de colonne dans la clause FROM de l'instruction SELECT.
     Par exemple&nbsp;:
    </para>
    <programlisting>
    SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')
      AS t(keyid text, parent_keyid text, level int, branch text);
    </programlisting>
    <para>
     ou
    </para>
    <programlisting>
    SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)
      AS t(keyid text, parent_keyid text, level int);
    </programlisting>
    <para>
     ou
    </para>
    <programlisting>
    SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
      AS t(keyid text, parent_keyid text, level int, branch text, pos int);
    </programlisting>
    <para>
     ou
    </para>
    <programlisting>
    SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)
      AS t(keyid text, parent_keyid text, level int, pos int);
    </programlisting>
    <para>
     Notez qu'il suit ces règles&nbsp;:
    </para>
    <orderedlist>
     <listitem><para>keyid et parent_keyid doivent avoir le même type</para></listitem>
     <listitem>
      <para>
      La définition de la colonne *doit* inclure une troisième colonne de type
      INT4 pour la sortie de la valeur du niveau
      </para>
     </listitem>
     <listitem>
      <para>
      Si le champ branch n'est pas voulu, omettez le paramètre en entrée
      branch_delim *et* le champ branch dans la définition des colonnes de la
      requête. Notez que, quand branch_delim n'est pas fourni, une valeur par
      défaut, '~', est utilisée en interne pour branch_delim pour détecter les
      récursions, même si le champ branch n'est pas renvoyé.
      </para>
     </listitem>
     <listitem>
      <para>
      Si le champ branch est souhaité, il doit correspondre à la quatrième
      colonne dans la définition des colonnes de la requête et il doit être
      de type TEXT.
      </para>
     </listitem>
     <listitem>
      <para>
      Les paramètres représentant les noms de la table et du champ doivent
      inclure des guillemets doubles si les noms contiennent des caractères en
      majuscule et en minuscule ou s'ils contiennent des caractères spéciaux.
      </para>
     </listitem>
     <listitem>
      <para>
      Si le tri des enfants est souhaité, le paramètre en entrée orderby_fld
      *et* un nom pour le champ serial résultant (type INT32) dans la
      définition de la requête doivent être précisés.
      </para>
     </listitem>
    </orderedlist>
    <para>
     Exemple&nbsp;:
    </para>
    <programlisting>
CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);

INSERT INTO connectby_tree VALUES('row1',NULL, 0);
INSERT INTO connectby_tree VALUES('row2','row1', 0);
INSERT INTO connectby_tree VALUES('row3','row1', 0);
INSERT INTO connectby_tree VALUES('row4','row2', 1);
INSERT INTO connectby_tree VALUES('row5','row2', 0);
INSERT INTO connectby_tree VALUES('row6','row4', 0);
INSERT INTO connectby_tree VALUES('row7','row3', 0);
INSERT INTO connectby_tree VALUES('row8','row6', 0);
INSERT INTO connectby_tree VALUES('row9','row5', 0);

-- with branch, without orderby_fld
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text);
 keyid | parent_keyid | level |       branch
-------+--------------+-------+---------------------
 row2  |              |     0 | row2
 row4  | row2         |     1 | row2~row4
 row6  | row4         |     2 | row2~row4~row6
 row8  | row6         |     3 | row2~row4~row6~row8
 row5  | row2         |     1 | row2~row5
 row9  | row5         |     2 | row2~row5~row9
(6 rows)

-- without branch, without orderby_fld
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int);
 keyid | parent_keyid | level
-------+--------------+-------
 row2  |              |     0
 row4  | row2         |     1
 row6  | row4         |     2
 row8  | row6         |     3
 row5  | row2         |     1
 row9  | row5         |     2
(6 rows)

-- with branch, with orderby_fld (notice that row5 comes before row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text, pos int) ORDER BY t.pos;
 keyid | parent_keyid | level |       branch        | pos 
-------+--------------+-------+---------------------+-----
 row2  |              |     0 | row2                |   1
 row5  | row2         |     1 | row2~row5           |   2
 row9  | row5         |     2 | row2~row5~row9      |   3
 row4  | row2         |     1 | row2~row4           |   4
 row6  | row4         |     2 | row2~row4~row6      |   5
 row8  | row6         |     3 | row2~row4~row6~row8 |   6
(6 rows)

-- without branch, with orderby_fld (notice that row5 comes before row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int, pos int) ORDER BY t.pos;
 keyid | parent_keyid | level | pos
-------+--------------+-------+-----
 row2  |              |     0 |   1
 row5  | row2         |     1 |   2
 row9  | row5         |     2 |   3
 row4  | row2         |     1 |   4
 row6  | row4         |     2 |   5
 row8  | row6         |     3 |   6
(6 rows)
    </programlisting>
   </sect3>
 </sect2>
 <sect2>
  <title>Auteur</title>
  <para>
   Joe Conway
  </para>
 </sect2>
</sect1>

