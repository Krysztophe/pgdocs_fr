<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="tablefunc">
 <title>tablefunc</title>

 <indexterm zone="tablefunc">
  <primary>tablefunc</primary>
 </indexterm>

 <para>
  Le module <filename>tablefunc</filename> inclut plusieurs fonctions
  permettant de renvoyer des tables (c'est-à-dire plusieurs lignes). Ces 
  fonctions sont utiles directement et comme exemples sur la façon d'écrire
  des fonctions C qui renvoient plusieurs lignes.
 </para>

 <sect2>
  <title>Fonctions</title>

  <table>
   <title>Fonctions <filename>tablefunc</filename></title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Retour</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><function>normal_rand(int numvals, float8 mean, float8 stddev)</function></entry>
      <entry><type>setof float8</type></entry>
      <entry>
       Renvoie un ensemble de valeurs float8 normalement distribuées
      </entry>
     </row>
     <row>
      <entry><function>crosstab(text sql)</function></entry>
      <entry><type>setof record</type></entry>
      <entry>
       Renvoie une <quote>table pivot</quote> contenant les noms des lignes
       ainsi que <replaceable>N</replaceable> colonnes de valeur, où
       <replaceable>N</replaceable> est déterminé par le type de ligne
       spécifié par la requête appelant
      </entry>
     </row>
     <row>
      <entry><function>crosstab<replaceable>N</replaceable>(text sql)</function></entry>
      <entry><type>setof table_crosstab_<replaceable>N</replaceable></type></entry>
      <entry>
       Produit une <quote>table pivot</quote> contenant les noms des lignes
       ainsi que <replaceable>N</replaceable> colonnes de valeurs.
       <function>crosstab2</function>, <function>crosstab3</function> et
       <function>crosstab4</function> sont prédéfinies mais vous pouvez créer
       des fonctions <function>crosstab<replaceable>N</replaceable></function>
       supplémentaires de la façon décrite ci-dessous
      </entry>
     </row>
     <row>
      <entry><function>crosstab(text source_sql, text category_sql)</function></entry>
      <entry><type>setof record</type></entry>
      <entry>
       Produit une <quote>table pivot</quote> avec les colonnes des valeurs
       spécifiées par une autre requête
      </entry>
     </row>
     <row>
      <entry><function>crosstab(text sql, int N)</function></entry>
      <entry><type>setof record</type></entry>
      <entry>
       <para>Version obsolète de <function>crosstab(text)</function>.
        Le paramètre <replaceable>N</replaceable> est ignoré car le nombre
	de colonnes de valeurs est toujours déterminé par la requête
	appelante
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <function>
        connectby(text relname, text keyid_fld, text parent_keyid_fld
        [, text orderby_fld ], text start_with, int max_depth
        [, text branch_delim ])
       </function>
      </entry>
      <entry><type>setof record</type></entry>
      <entry>
       Produit une représentation d'une structure hiérarchique en arbre
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect3>
   <title><function>normal_rand</function></title>

    <programlisting>
normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8
    </programlisting>

    <para>
     <function>normal_rand</function> produit un ensemble de valeurs
     distribuées au hasard (distribution gaussienne).
    </para>

    <para>
     <parameter>numvals</parameter> est le nombre de valeurs que la fonction
     doit renvoyer. <parameter>mean</parameter> est la moyenne de la
     distribution normale des valeurs et <parameter>stddev</parameter> est la
     déviation standard de la distribution normale des valeurs.
    </para>

    <para>
     Par exemple, cet appel demande 1000 valeurs avec une moyenne de 5 et une
     déviation standard de 3&nbsp;:
    </para>

    <programlisting>
test=# SELECT * FROM normal_rand(1000, 5, 3);
     normal_rand
----------------------
     1.56556322244898
     9.10040991424657
     5.36957140345079
   -0.369151492880995
    0.283600703686639
       .
       .
       .
     4.82992125404908
     9.71308014517282
     2.49639286969028
(1000 rows)
    </programlisting>
  </sect3>

  <sect3>
   <title><function>crosstab(text)</function></title>

   <programlisting>
crosstab(text sql)
crosstab(text sql, int N)
   </programlisting>

   <para>
    La fonction <function>crosstab</function> est utilisé pour créer un
    affichage <quote>pivot</quote> où les données sont listées de gauche à
    droite plutôt que de haut en bas. Par exemple, avec ces données
    <programlisting>
row1    val11
row1    val12
row1    val13
...
row2    val21
row2    val22
row2    val23
...
    </programlisting>
    l'affiche ressemble à ceci
    <programlisting>
row1    val11   val12   val13   ...
row2    val21   val22   val23   ...
...
    </programlisting>
    La fonction <function>crosstab</function> prend un paramètre texte qui est
    une requête SQL produisant des données brutes formatées de la façon
    habituelle et produit une table avec un autre formatage.
   </para>

   <para>
    Le paramètre <parameter>sql</parameter> est une instruction SQL qui produit
    l'ensemble source des données. Cette instruction doit renvoyer une colonne
    <structfield>row_name</structfield>, une colonne
    <structfield>category</structfield> et une colonne
    <structfield>value</structfield>. <parameter>N</parameter> est un paramètre
    obsolète, ignoré quand il est fourni (auparavant, il devait correspondre
    au nombre de colonnes de valeurs en sortie, mais maintenant ceci est
    déterminé par la requête appelant).
   </para>

   <para>
    Par exemple, la requête fournie peut produire un ensemble ressemblant à
    ceci&nbsp;:
   </para>

<programlisting>
 row_name    cat    value
----------+-------+-------
  row1      cat1    val1
  row1      cat2    val2
  row1      cat3    val3
  row1      cat4    val4
  row2      cat1    val5
  row2      cat2    val6
  row2      cat3    val7
  row2      cat4    val8
</programlisting>

   <para>
    La fonction <function>crosstab</function> déclare renvoyer un <type>setof
    record</type>, donc les noms et types réels des colonnes doivent être
    définis dans la clause <literal>FROM</literal> de l'instruction
    <command>SELECT</command> appelante. Par exemple&nbsp;:
    statement, for example:
   </para>

   <programlisting>
    SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);
   </programlisting>

   <para>
    Cet exemple produit un ensemble ressemblant à ceci&nbsp;:
   </para>

   <programlisting>
           &lt;== value  columns  ==&gt;
row_name   category_1   category_2
 ---------+------------+------------
   row1        val1         val2
   row2        val5         val6
   </programlisting>

   <para>
    La clause <literal>FROM</literal> doit définir la sortie comme une
    colonne <structfield>row_name</structfield> (du même type que la première
    colonne du résultat de la requête SQL) suivie par N colonnes
    <structfield>value</structfield> (tous du même type de données que la
    troisième colonne du résultat de la requête SQL). Vous pouvez configurer
    autant de colonnes de valeurs en sortie que vous voulez. Les noms des
    colonnes en sortie n'ont pas d'importance en soi.
   </para>

   <para>
    La fonction <function>crosstab</function> produit une ligne en sortie
    pour chaque groupe consécutif de lignes en entrée avec la même valeur
    <structfield>row_name</structfield>. Elle remplit les colonnes de
    <structfield>value</structfield>, de gauche à droite, avec les champs
    <structfield>value</structfield> provenant de ces lignes. S'il y a moins
    de lignes dans un groupe que de colonnes <structfield>value</structfield>
    en sortie, les colonnes supplémentaires sont remplies avec des valeurs
    NULL&nbsp;; s'il y a trop de ligne, les colonnes en entrée supplémentaires
    sont ignorées.
   </para>

   <para>
    En pratique, la requête SQL devrait toujours spécifier <literal>ORDER BY
    1,2</literal> pour s'assurer que les lignes en entrée sont bien ordonnées,
    autrement dit que les valeurs de même <structfield>row_name</structfield>
    sont placées ensemble et son correctement ordonnées dans la ligne. Notez
    que <function>crosstab</function> ne fait pas attention à la deuxième
    colonne du résultat de la requête&nbsp;; elle est là pour permettre le
    tri, pour contrôler l'ordre dans lequel les valeurs de la troisième
    colonne apparaissent dans la page.
   </para>

   <para>
    Voici un exemple complet&nbsp;:
   </para>

   <programlisting>
CREATE TABLE ct(id SERIAL, rowid TEXT, attribute TEXT, value TEXT);
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att1','val1');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att2','val2');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att3','val3');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att4','val4');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att1','val5');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att2','val6');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att3','val7');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att4','val8');

SELECT *
FROM crosstab(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2')
AS ct(row_name text, category_1 text, category_2 text, category_3 text);

 row_name | category_1 | category_2 | category_3
----------+------------+------------+------------
 test1    | val2       | val3       |
 test2    | val6       | val7       |
(2 rows)
   </programlisting>

   <para>
    Vous pouvez toujours éviter d'avoir à écrire une clause
    <literal>FROM</literal> pour définir les colonnes en sortie, en définissant
    une fonction crosstab personnalisée qui a le type de ligne désiré en
    sortie en dur dans sa définition. Ceci est décrit dans la prochaine
    section. Une autre possibilité est d'embarquer la clause
    <literal>FROM</literal> requise dans la définition d'une vue.
   </para>

  </sect3>

  <sect3>
   <title><function>crosstab<replaceable>N</replaceable>(text)</function></title>

    <programlisting>
crosstab<replaceable>N</replaceable>(text sql)
    </programlisting>

    <para>
     Les fonctions <function>crosstab<replaceable>N</replaceable></function>
     sont des exemples de configuration de fonctions d'emballage pour la
     fonction généraliste <function>crosstab</function>. Cela vous permet de
     ne pas avoir à écrire les noms et types des colonnes dans la requête
     <command>SELECT</command> appelante. Le module
     <filename>tablefunc</filename> inclut
     <function>crosstab2</function>, <function>crosstab3</function> et
     <function>crosstab4</function>, dont les types de ligne en sortie sont
     définis ainsi&nbsp;:
    </para>

    <programlisting>
CREATE TYPE tablefunc_crosstab_N AS (
    row_name TEXT,
    category_1 TEXT,
    category_2 TEXT,
        .
        .
        .
    category_N TEXT
);
    </programlisting>

    <para>
     Du coup, ces fonctions peuvent être utilisées directement quand la
     requête en entrée produit des colonnes <structfield>row_name</structfield>
     et <structfield>value</structfield> de type <type>text</type>, et que vous
     voulez 2, 3 ou 4 colonnes de valeur en sortie. Autrement, elles se
     comportent exactement la fonction <function>crosstab</function> décrite
     précédemment.
    </para>

    <para>
     L'exemple de la section précédente pourrait aussi fonctionner ainsi&nbsp;:
    </para>

    <programlisting>
SELECT *
FROM crosstab3(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2');
    </programlisting>

    <para>
     Ces fonctions sont fournies principalement comme exemples. Vous pouvez
     créer vos propres types de retour et fonctions basées sur la fonction
     <function>crosstab()</function>. Il existe deux façons de le faire&nbsp;:
    </para>

    <itemizedlist>
     <listitem>
      <para>
       Créer un type composite décrivant les colonnes désirées en sortie,
       similaire aux exemples du script d'installation. Ensuite, définir un
       nom de fonction unique acceptant un paramètre de type <type>text</type>
       et renvoyant <type>setof nom_de_votre_type</type>, mais renvoyant à
       la fonction C <function>crosstab</function>. Par exemple, si votre
       source de données produit des noms de ligne qui sont de type
       <type>text</type>, et des valeurs qui sont de type <type>float8</type>,
       et que vous voulez cinq colonnes de valeurs&nbsp;:
      </para>

      <programlisting>
      CREATE TYPE my_crosstab_float8_5_cols AS (
          my_row_name text,
          my_category_1 float8,
          my_category_2 float8,
          my_category_3 float8,
          my_category_4 float8,
          my_category_5 float8
      );

      CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)
        RETURNS setof my_crosstab_float8_5_cols
        AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
      </programlisting>
     </listitem>

     <listitem>
      <para>
       Utiliser des paramètres <literal>OUT</literal> pour définir
       implicitement le type en retour. Le même exemple pourrait s'écrire
       ainsi&nbsp;:
      </para>

      <programlisting>
      CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(IN text,
          OUT my_row_name text,
          OUT my_category_1 float8,
          OUT my_category_2 float8,
          OUT my_category_3 float8,
          OUT my_category_4 float8,
          OUT my_category_5 float8)
        RETURNS setof record
        AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
      </programlisting>
     </listitem>
    </itemizedlist>

  </sect3>

  <sect3>
   <title><function>crosstab(text, text)</function></title>

   <programlisting>
crosstab(text source_sql, text category_sql)
   </programlisting>

   <para>
    La limite principale de la forme à un paramètre de
    <function>crosstab</function> est qu'elle traite toutes les valeurs d'un
    groupe de la même façon, en insérant chaque valeur dans la première
    colonne disponible. Si vous voulez les colonnes de valeur correspondant
    à des catégories spécifiques de données, et que certains groupes n'ont pas
    de données pour certaines des catégories, alors cela ne fonctionne pas.
    La forme à deux paramètres de la fonction <function>crosstab</function>
    gère ce cas en fournissant une liste explicite des catégories correspondant
    aux colonnes en sortie.
   </para>

   <para>
    <parameter>source_sql</parameter> est une instruction SQL qui produit
    l'ensemble source des données. Cette instruction doit renvoyer une colonne
    <structfield>row_name</structfield>, une colonne
    <structfield>category</structfield> et une colonne
    <structfield>value</structfield>. Elle pourrait aussi avoir une ou
    plusieurs colonnes <quote>extra</quote>. La colonne
    <structfield>row_name</structfield> doit être la première. Les colonnes
    <structfield>category</structfield> et <structfield>value</structfield>
    doivent être les deux dernières colonnes, dans cet ordre. Toutes les
    colonnes entre <structfield>row_name</structfield> et
    <structfield>category</structfield> sont traitées en <quote>extra</quote>.
    Les colonnes <quote>extra</quote> doivent être les mêmes pour toutes les
    lignes avec la même valeur <structfield>row_name</structfield>.
   </para>

   <para>
    Par exemple, <parameter>source_sql</parameter> produit un ensemble
    ressemblant à ceci&nbsp;:
   </para>
   <programlisting>
 SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;

     row_name    extra_col   cat    value
    ----------+------------+-----+---------
      row1         extra1    cat1    val1
      row1         extra1    cat2    val2
      row1         extra1    cat4    val4
      row2         extra2    cat1    val5
      row2         extra2    cat2    val6
      row2         extra2    cat3    val7
      row2         extra2    cat4    val8
   </programlisting>

   <para>
    <parameter>category_sql</parameter> est une instruction SQL qui produit
    l'ensemble des catégories. Cette instruction doit renvoyer seulement une
    colonne. Cela doit produire au moins une ligne, sinon une erreur sera
    générée. De plus, cela ne doit pas produire de valeurs dupliquées, sinon
    une erreur sera aussi générée. <parameter>category_sql</parameter> doit
    ressembler à ceci&nbsp;:
   </para>

   <programlisting>
SELECT DISTINCT cat FROM foo ORDER BY 1;
    cat
  -------
    cat1
    cat2
    cat3
    cat4
   </programlisting>

   <para>
    La fonction <function>crosstab</function> déclare renvoyer <type>setof
    record</type>, donc les noms et types réels des colonnes en sortie
    doivent être définis dans la clause <literal>FROM</literal> de la requête
    <command>SELECT</command> appelante, par exemple&nbsp;:
   </para>

   <programlisting>
    SELECT * FROM crosstab('...', '...')
      AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);
   </programlisting>

   <para>
    Ceci produira un résultat ressemblant à ceci&nbsp;:
   </para>

   <programlisting>
                              &lt;==  value  columns   ==&gt;
           row_name   extra   cat1   cat2   cat3   cat4
           ---------+-------+------+------+------+------
             row1     extra1  val1   val2          val4
             row2     extra2  val5   val6   val7   val8
   </programlisting>

   <para>
    La clause <literal>FROM</literal> doit définir le bon nombre de colonnes en
    sortie avec les bon types de données. S'il y a <replaceable>N</replaceable>
    colonnes dans le résultat de la requête <parameter>source_sql</parameter>,
    les <replaceable>N</replaceable>-2 premiers d'entre eux doivent
    correspondre aux <replaceable>N</replaceable>-2 premières colonnes en
    sortie. Les colonnes restantes en sortie doivent avoir le type de la
    dernière colonne du résultat de la requête The remaining output columns
    <parameter>source_sql</parameter>, et il doit y en avoir autant que de
    lignes dans le résultat de la requête <parameter>category_sql</parameter>.
   </para>

   <para>
    La fonction <function>crosstab</function> produit une ligne en sortie
    pour chaque groupe consécutif de lignes en entrée avec la même valeur
    <structfield>row_name</structfield>. La colonne en sortie
    <structfield>row_name</structfield> ainsi que toutes colonnes
    <quote>extra</quote> sont copiées à partir de la première ligne du
    groupe. Les colonnes <structfield>value</structfield> en sortie sont
    remplies avec les champs <structfield>value</structfield> à partir des
    lignes ayant une correspondance avec des valeurs
    <structfield>category</structfield>. Si la
    <structfield>category</structfield> d'une ligne ne correspond pas à une
    sortie de la requête <parameter>category_sql</parameter>, sa
    <structfield>value</structfield> est ignorée. Les colonnes en sortie dont
    la catégorie correspondante est absente de toute ligne en entrée du
    groupe sont remplies avec des valeurs NULL.
   </para>

   <para>
    En pratique, la requête <parameter>source_sql</parameter> doit toujours
    spécifier <literal>ORDER BY 1</literal> pour s'assurer ques les valeurs du
    même <structfield>row_name</structfield> sont assemblées. Néanmoins,
    l'ordre des catégories dans un groupe n'est pas important. De plus, il est
    essentiel que l'ordre du résultat de la requête
    <parameter>category_sql</parameter> corresponde à l'ordre des colonnes
    spécifiées en sortie.
   </para>

   <para>
    Voici deux exemples complets&nbsp;:
   </para>

   <programlisting>
create table sales(year int, month int, qty int);
insert into sales values(2007, 1, 1000);
insert into sales values(2007, 2, 1500);
insert into sales values(2007, 7, 500);
insert into sales values(2007, 11, 1500);
insert into sales values(2007, 12, 2000);
insert into sales values(2008, 1, 1000);

select * from crosstab(
  'select year, month, qty from sales order by 1',
  'select m from generate_series(1,12) m'
) as (
  year int,
  "Jan" int,
  "Feb" int,
  "Mar" int,
  "Apr" int,
  "May" int,
  "Jun" int,
  "Jul" int,
  "Aug" int,
  "Sep" int,
  "Oct" int,
  "Nov" int,
  "Dec" int
);
 year | Jan  | Feb  | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov  | Dec
------+------+------+-----+-----+-----+-----+-----+-----+-----+-----+------+------
 2007 | 1000 | 1500 |     |     |     |     | 500 |     |     |     | 1500 | 2000
 2008 | 1000 |      |     |     |     |     |     |     |     |     |      |
(2 rows)
   </programlisting>

   <programlisting>
CREATE TABLE cth(rowid text, rowdt timestamp, attribute text, val text);
INSERT INTO cth VALUES('test1','01 March 2003','temperature','42');
INSERT INTO cth VALUES('test1','01 March 2003','test_result','PASS');
INSERT INTO cth VALUES('test1','01 March 2003','volts','2.6987');
INSERT INTO cth VALUES('test2','02 March 2003','temperature','53');
INSERT INTO cth VALUES('test2','02 March 2003','test_result','FAIL');
INSERT INTO cth VALUES('test2','02 March 2003','test_startdate','01 March 2003');
INSERT INTO cth VALUES('test2','02 March 2003','volts','3.1234');

SELECT * FROM crosstab
(
  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',
  'SELECT DISTINCT attribute FROM cth ORDER BY 1'
)
AS
(
       rowid text,
       rowdt timestamp,
       temperature int4,
       test_result text,
       test_startdate timestamp,
       volts float8
);
 rowid |          rowdt           | temperature | test_result |      test_startdate      | volts
-------+--------------------------+-------------+-------------+--------------------------+--------
 test1 | Sat Mar 01 00:00:00 2003 |          42 | PASS        |                          | 2.6987
 test2 | Sun Mar 02 00:00:00 2003 |          53 | FAIL        | Sat Mar 01 00:00:00 2003 | 3.1234
(2 rows)
   </programlisting>

   <para>
    Vous pouvez créer des fonctions prédéfinies pour éviter d'avoir à écrire
    les noms et types des colonnes en résultat dans chaque requête. Voir les
    exemples dans la section précédente. La fonction C sous-jacente pour cette
    forme de <function>crosstab</function> est appelée
    <literal>crosstab_hash</literal>.
   </para>

  </sect3>

  <sect3>
   <title><function>connectby</function></title>

   <programlisting>
connectby(text relname, text keyid_fld, text parent_keyid_fld
          [, text orderby_fld ], text start_with, int max_depth
          [, text branch_delim ])
   </programlisting>

   <para>
    La fonction <function>connectby</function> réalise un affichage de données
    hiérarchiques stockées dans une table. La table doit avoir un champ clé
    qui identifie de façon unique les lignes et un champ clé qui référence
    le parent de chaque ligne. <function>connectby</function> peut afficher le
    sous-arbre à partir de n'importe quelle ligne.
   </para>

   <table>
    <title>Paramètres <function>connectby</function></title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Paramètre</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><parameter>relname</parameter></entry>
       <entry>Nom de la relation source</entry>
      </row>
      <row>
       <entry><parameter>keyid_fld</parameter></entry>
       <entry>Nom du champ clé</entry>
      </row>
      <row>
       <entry><parameter>parent_keyid_fld</parameter></entry>
       <entry>Nom du champ clé du parent</entry>
      </row>
      <row>
       <entry><parameter>orderby_fld</parameter></entry>
       <entry>Nom du champ des autres relations (optionnel)</entry>
      </row>
      <row>
       <entry><parameter>start_with</parameter></entry>
       <entry>Valeur de la clé de la ligne de début</entry>
      </row>
      <row>
       <entry><parameter>max_depth</parameter></entry>
       <entry>Profondeur maximum pour la descente, ou zéro pour une
       profondeur illimitée</entry>
      </row>
      <row>
       <entry><parameter>branch_delim</parameter></entry>
       <entry>Chaîne pour séparer les clés des branches (optionnel)</entry>
      </row>
      </tbody>
     </tgroup>
    </table>

    <para>
     Les champs clé et clé du parent peuvent être de tout type mais ils
     doivent être du même type. Notez que la valeur
     <parameter>start_with</parameter> doit être saisi comme une chaîne de
     caractères, quelque soit le type du champ clé.
    </para>

    <para>
     La fonction <function>connectby</function> déclare renvoyer un <type>setof
     record</type>, donc les noms et types réels des colonnes en sortie
     doivent être définis dans la clause <literal>FROM</literal> de
     l'instruction <command>SELECT</command> appelante, par exemple&nbsp;:
    </para>

    <programlisting>
    SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
      AS t(keyid text, parent_keyid text, level int, branch text, pos int);
    </programlisting>

    <para>
     Des deux premières colonnes en sortie sont utilisées pour la clé de la
     ligne en cours et la clé de son parent&nbsp;; elles doivent correspondre
     au type du champ clé de la table. La troisième colonne est la
     profondeur de l'arbre est doit être du type <type>integer</type>. Si un
     paramètre <parameter>branch_delim</parameter> est renseigné, la prochaine
     colonne en sortie est l'affichage de la branche et doit être de type
     <type>text</type>. Enfin, si le paramètre
     <parameter>orderby_fld</parameter> est renseigné, la dernière colonne en
     sortie est un numéro de série et doit être de type <type>integer</type>.
    </para>

    <para>
     La colonne <quote>branch</quote> en sortie affiche le chemin des clés
     utilisé pour atteindre la ligne actuelle. Les clés sont séparées
     par la chaîne <parameter>branch_delim</parameter> spécifiée. Si l'affichage
     des branches n'est pas voulu, omettez le paramètre
     <parameter>branch_delim</parameter> et la colonne branche dans la liste
     des colonnes en sortie.
     and the branch column in the output column list.
    </para>

    <para>
     Si l'ordre des relations du même parent est important, incluez le
     paramètre <parameter>orderby_fld</parameter> pour indiquer par quel
     champ ordonner les relations. Ce champs doit être de tout type de données
     triable. La liste des colonnes en sortie doit inclure une colonne numéro
     de série de type integer si, et seulement si,
     <parameter>orderby_fld</parameter> est spécifiée.
    </para>

    <para>
     Les paramètres représentant table et noms de champs sont copiés tels
     quel dans les requêtes SQL que <function>connectby</function> génère en
     interne. Du coup, ajoutez des guillemets doubles si les noms utilisent
     majuscules et minuscules ou s'ils contiennent des caractères spéciaux.
     Vous pouvez aussi avoir besoin de qualifier le nom de la table avec le
     nom du schéma.
    </para>

    <para>
     Dans les grosses tables, les performances seront faibles sauf si un index
     est créé sur le champ clé parent.
    </para>

    <para>
     Il est important que la chaîne <parameter>branch_delim</parameter>
     n'apparaisse pas dans les valeurs des clés, sinon
     <function>connectby</function> pourrait rapporter des erreurs de récursion
     infinie totalement erronées. Notez que si
     <parameter>branch_delim</parameter> n'est pas fourni, une valeur par défaut
     <literal>~</literal> est utilisé pour des raisons de détection de
     récursion.
     <!-- That pretty well sucks.  FIXME -->
    </para>

    <para>
     Voici un exemple&nbsp;:
    </para>

    <programlisting>
CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);

INSERT INTO connectby_tree VALUES('row1',NULL, 0);
INSERT INTO connectby_tree VALUES('row2','row1', 0);
INSERT INTO connectby_tree VALUES('row3','row1', 0);
INSERT INTO connectby_tree VALUES('row4','row2', 1);
INSERT INTO connectby_tree VALUES('row5','row2', 0);
INSERT INTO connectby_tree VALUES('row6','row4', 0);
INSERT INTO connectby_tree VALUES('row7','row3', 0);
INSERT INTO connectby_tree VALUES('row8','row6', 0);
INSERT INTO connectby_tree VALUES('row9','row5', 0);

-- with branch, without orderby_fld (order of results is not guaranteed)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text);
 keyid | parent_keyid | level |       branch
-------+--------------+-------+---------------------
 row2  |              |     0 | row2
 row4  | row2         |     1 | row2~row4
 row6  | row4         |     2 | row2~row4~row6
 row8  | row6         |     3 | row2~row4~row6~row8
 row5  | row2         |     1 | row2~row5
 row9  | row5         |     2 | row2~row5~row9
(6 rows)

-- without branch, without orderby_fld (order of results is not guaranteed)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int);
 keyid | parent_keyid | level
-------+--------------+-------
 row2  |              |     0
 row4  | row2         |     1
 row6  | row4         |     2
 row8  | row6         |     3
 row5  | row2         |     1
 row9  | row5         |     2
(6 rows)

-- with branch, with orderby_fld (notice that row5 comes before row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text, pos int);
 keyid | parent_keyid | level |       branch        | pos
-------+--------------+-------+---------------------+-----
 row2  |              |     0 | row2                |   1
 row5  | row2         |     1 | row2~row5           |   2
 row9  | row5         |     2 | row2~row5~row9      |   3
 row4  | row2         |     1 | row2~row4           |   4
 row6  | row4         |     2 | row2~row4~row6      |   5
 row8  | row6         |     3 | row2~row4~row6~row8 |   6
(6 rows)

-- without branch, with orderby_fld (notice that row5 comes before row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int, pos int);
 keyid | parent_keyid | level | pos
-------+--------------+-------+-----
 row2  |              |     0 |   1
 row5  | row2         |     1 |   2
 row9  | row5         |     2 |   3
 row4  | row2         |     1 |   4
 row6  | row4         |     2 |   5
 row8  | row6         |     3 |   6
(6 rows)
    </programlisting>
   </sect3>

 </sect2>

 <sect2>
  <title>Auteur</title>

  <para>
   Joe Conway
  </para>

 </sect2>

</sect1>
