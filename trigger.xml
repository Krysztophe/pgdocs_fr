<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <chapter id="triggers">
  <title>Déclencheurs (triggers)</title>

  <indexterm zone="triggers">
   <primary>trigger</primary>
  </indexterm>

  <para>
   Ce chapitre fournit des informations générales sur l'écriture des fonctions
   pour déclencheur. Les fonctions pour déclencheurs peuvent être écrites dans
   la plupart des langages de procédure disponibles incluant
   <application>PL/pgSQL</application> (<xref linkend="plpgsql"/>),
   <application>PL/Tcl</application> (<xref linkend="pltcl"/>),
   <application>PL/Perl</application> (<xref linkend="plperl"/>) et
   <application>PL/Python</application> (<xref linkend="plpython"/>). Après avoir
   lu ce chapitre, vous devriez consulter le chapitre sur votre langage de
   procédure favori pour découvrir les spécificités de l'écriture de déclencheurs dans ce langage.
  </para>

  <para>
   Il est aussi possible d'écrire une fonction déclencheur en C, bien que la plupart
   des gens trouvent plus facile d'utiliser un des langages de procédure. Il est 
   actuellement impossible d'écrire une fonction déclencheur dans le langage de
   fonction simple SQL.
  </para>

  <sect1 id="trigger-definition">
   <title>Aperçu du comportement des déclencheurs</title>

   <para>
    Un déclencheur spécifie que la base de données doit
    exécuter automatiquement une fonction donnée chaque fois qu'un certain type d'opération est
    exécuté. Les fonctions déclencheur peuvent être définies pour s'exécuter
    avant ou après une commande <command>INSERT</command>,
    <command>UPDATE</command> ou <command>DELETE</command>, soit une fois par
    ligne modifiée, soit une fois par expression <acronym>SQL</acronym>. Les
    triggers peuvent aussi être déclenchés par des instructions
    <command>TRUNCATE</command>. Si un événement déclencheur se produit, le
    gestionnaire de déclencheurs est appelé au bon moment pour gérer
    l'événement.
    </para>

   <para>
    La fonction déclencheur doit être définie avant que le déclencheur lui-même
    puisse être créé. La fonction déclencheur doit être déclarée comme une
    fonction ne prenant aucun argument et retournant un type <literal>trigger</literal>
    (la fonction déclencheur reçoit ses entrées via une structure
    <structname>TriggerData</structname> passée spécifiquement, et non pas sous la forme
    d'arguments ordinaires de fonctions).
   </para>

   <para>
    Une fois qu'une fonction déclencheur est créée, le déclencheur (trigger)
    est créé avec
    <xref linkend="sql-createtrigger" endterm="sql-createtrigger-title"/>.
    La même fonction déclencheur est utilisable par plusieurs déclencheurs.
   </para>

   <para>
    <productname>PostgreSQL</productname> offre des déclencheurs
    <firstterm>par ligne</firstterm> et <firstterm>par instruction</firstterm>. Avec un
    déclencheur mode ligne, la fonction du
    déclencheur est appelée une fois pour chaque ligne affectée par
    l'instruction qui a lancé le déclencheur. Au contraire, un déclencheur mode
    instruction n'est appelé qu'une seule fois lorsqu'une instruction appropriée
    est exécutée, quelque soit le nombre de lignes affectées par cette
    instruction. En particulier, une instruction n'affectant aucune ligne
    résultera toujours en l'exécution de tout déclencheur mode instruction
    applicable. Ces deux types sont quelque fois appelés respectivement des
    <firstterm>déclencheurs niveau ligne</firstterm> et des
    <firstterm>déclencheurs niveau instruction</firstterm>.
    Les triggers sur <command>TRUNCATE</command> peuvent seulement être définis
    au niveau instruction.
   </para>

   <para>
    Les déclencheurs sont aussi classifiés comme des déclencheurs
    <firstterm>avant</firstterm> et des déclencheurs <firstterm>après</firstterm>. Les déclencheurs
    avant au niveau instruction se déclenchent naturellement avant que
    l'instruction ne fasse quoi que ce soit alors que les déclencheurs après au
    niveau instruction sont exécutés à la fin de l'instruction. Les déclencheurs
    avant au niveau ligne s'exécutent immédiatement avant qu'une ligne particulière
    ne soit traitée alors que les déclencheurs après au niveau ligne s'exécutent
    à la fin de l'instruction (mais avant tout déclencheur après au niveau
    instruction).
   </para>

   <para>
   Les fonctions déclencheurs appelées par des déclencheurs niveau instruction
   devraient toujours renvoyer <symbol>NULL</symbol>. Les fonctions déclencheurs
   appelées par des déclencheurs niveau ligne peuvent renvoyer une ligne de la
   table (une valeur de type <structname>HeapTuple</structname>) vers
   l'exécuteur appelant, s'ils le veulent. Un déclencheur niveau ligne exécuté
   avant une opération a les choix suivants&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Il peut retourner un pointeur <symbol>NULL</symbol> pour sauter l'opération
       pour la ligne courante. Ceci donne comme instruction à l'exécuteur de ne pas exécuter
       l'opération niveau ligne qui a lancé le déclencheur (l'insertion ou la
       modification d'une ligne particulière de la table).
       </para>
     </listitem>

     <listitem>
      <para>
       Pour les déclencheurs <command>INSERT</command> et
       <command>UPDATE</command> de niveau ligne uniquement, la valeur de retour devient la
       ligne qui sera insérée ou remplacera la ligne en cours de mise à jour.
       Ceci permet à la fonction déclencheur de modifier la ligne en cours
       d'insertion ou de mise à jour.
      </para>
     </listitem>
    </itemizedlist>


    Un déclencheur avant niveau ligne qui ne serait pas conçu pour avoir l'un de
    ces comportements doit prendre garde à retourner la même ligne que celle
    qui lui a été passée comme nouvelle ligne (c'est-à-dire : pour des déclencheurs
    <command>INSERT</command> et <command>UPDATE</command> : la nouvelle
    (<varname>NEW</varname>) ligne ,et pour les déclencheurs
    <command>DELETE</command>) : l'ancienne
    (<varname>OLD</varname>) ligne .
   </para>

   <para>
    La valeur de retour est ignorée pour les déclencheurs niveau ligne lancés
    après une opération. Ils peuvent donc renvoyer la valeur
    <symbol>NULL</symbol>.
   </para>

   <para>
    Si plus d'un déclencheur est défini pour le même événement sur la même
    relation, les déclencheurs seront lancés dans l'ordre alphabétique de leur
    nom. Dans le cas de déclencheurs avant, la ligne 
    renvoyée par chaque déclencheur, qui a éventuellement été modifiée, devient l'argument du
    prochain déclencheur. Si un des déclencheurs avant renvoie un pointeur
    <symbol>NULL</symbol>, l'opération est abandonnée pour cette ligne et les
    déclencheurs suivants ne sont pas lancés.
   </para>

   <para>
    Les déclencheurs avant en mode ligne sont typiquement utilisés pour
    vérifier ou modifier les données qui seront insérées ou mises à jour. Par
    exemple, un déclencheur avant pourrait être utilisé pour insérer l'heure
    actuelle dans une colonne de type <type>timestamp</type> ou pour vérifier que deux
    éléments d'une ligne sont cohérents. Les déclencheurs après en mode ligne
    sont pour la plupart utilisés pour propager des mises à jour vers d'autres
    tables ou pour réaliser des tests de cohérence avec d'autres tables. La
    raison de cette division du travail est qu'un déclencheur après peut être
    certain qu'il voit la valeur finale de la ligne alors qu'un déclencheur
    avant ne l'est pas&nbsp;; il pourrait exister d'autres déclencheurs avant
    qui seront exécutés après lui. Si vous n'avez aucune raison spéciale pour le
    moment du déclenchement, le cas avant est plus efficace car l'information
    sur l'opération n'a pas besoin d'être sauvegardée jusqu'à la fin du
    traitement.
   </para>

   <para>
    Si une fonction déclencheur exécute des commandes SQL,
    alors ces commandes peuvent lancer à leur tour des déclencheurs. On appelle ceci un
    déclencheur en cascade. Il n'y a pas de limitation directe du nombre de
    niveaux de cascade. Il est possible que les cascades causent un appel
    récursif du même déclencheur&nbsp;; par exemple, un déclencheur
    <command>INSERT</command> pourrait exécuter une commande qui insère une
    ligne supplémentaire dans la même table, entraînant un nouveau lancement du
    déclencheur <command>INSERT</command>. Il est de la responsabilité du
    programmeur d'éviter les récursions infinies dans de tels scénarios.
   </para>

   <para>
    Quand un <indexterm><primary>trigger</primary><secondary>arguments</secondary></indexterm>
    déclencheur est défini, des arguments peuvent être spécifiés pour
    lui. L'objectif de l'inclusion d'arguments dans la définition du
    déclencheur est de permettre à différents déclencheurs ayant des exigences
    similaires d'appeler la même fonction. Par exemple, il pourrait y avoir une
    fonction déclencheur généralisée qui prend comme arguments deux noms de
    colonnes et place l'utilisateur courant dans l'une et un horodatage dans
    l'autre. Correctement écrit, cette fonction déclencheur serait indépendante
    de la table particulière sur laquelle il se déclenche. Ainsi, la même
    fonction pourrait être utilisée pour des événements
    <command>INSERT</command> sur n'importe quelle table ayant des colonnes
    adéquates, pour automatiquement suivre les créations d'enregistrements dans
    une table de transactions par exemple. Elle pourrait aussi être utilisée
    pour suivre les dernières mises à jours si elle est définie comme un
    déclencheur <command>UPDATE</command>.
   </para>

   <para>
    Chaque langage de programmation supportant les déclencheurs a sa propre
    méthode pour rendre les données en entrée disponible à la fonction du
    déclencheur. Cette donnée en entrée inclut le type d'événement du
    déclencheur (c'est-à-dire <command>INSERT</command> ou
    <command>UPDATE</command>) ainsi que tous les arguments listés dans
    <command>CREATE TRIGGER</command>. Pour un déclencheur niveau ligne, la donnée en
    entrée inclut aussi la ligne <varname>NEW</varname> pour les déclencheurs
    <command>INSERT</command> et <command>UPDATE</command> et/ou la ligne
    <varname>OLD</varname> pour les déclencheurs <command>UPDATE</command> et
    <command>DELETE</command>. Les déclencheurs niveau instruction n'ont
    actuellement aucun moyen pour examiner le(s) ligne(s) individuelle(s)
    modifiées par l'instruction.
   </para>

  </sect1>

  <sect1 id="trigger-datachanges">
   <title>Visibilité des modifications des données</title>

   <para>
    Si vous exécutez des commandes SQL dans votre fonction SQL et que ces
    commandes accèdent à la table pour laquelle vous créez ce déclencheur,
    alors vous avez besoin de connaître les règles de visibilité des données
    car elles déterminent si les commandes SQL voient les modifications de données pour
    lesquelles est exécuté le déclencheur. En bref&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
      Les déclencheurs niveau instruction suivent des règles de visibilité
      simples&nbsp;: aucune des modifications réalisées par une instruction
      n'est visible aux déclencheurs niveau instruction appelés avant
      l'instruction alors que toutes les modifications sont visibles aux
      déclencheurs après niveau instruction.
	     </para>
     </listitem>
     
     <listitem>
      <para>
      Les modifications de données (insertion, mise à jour ou suppression)
      lançant le déclencheur ne sont naturellement <emphasis>pas</emphasis>
      visibles aux commandes SQL exécutées dans un déclencheur avant en mode
      ligne parce qu'elles ne sont pas encore survenues.
      </para>
     </listitem>
     
     <listitem>
      <para>
      Néanmoins, les commandes SQL exécutées par un déclencheur avant en mode
      ligne <emphasis>verront</emphasis> les effets des modifications de données
      pour les lignes précédemment traitées dans la même commande externe. Ceci
      requiert une grande attention car l'ordre des événements de modification
      n'est en général pas prévisible&nbsp;; une commande SQL affectant
      plusieurs lignes pourrait visiter les lignes dans n'importe quel ordre.
      </para>
     </listitem>
     
     <listitem>
      <para>
      Quand un déclencheur après en mode ligne est exécuté, toutes les
      modifications de données réalisées par la commande externe sont déjà
      terminées et sont visibles par la fonction appelée par le déclencheur.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Si votre fonction trigger est écrite dans un des langages de procédures
    standard, alors les instructions ci-desus s'appliquent seulement si la
    fonction est déclarée <literal>VOLATILE</literal>. Les fonctions déclarées
    <literal>STABLE</literal> ou <literal>IMMUTABLE</literal> ne verront pas
    les modifications réalisées par la commande appelante dans tous les cas.
   </para>

   <para>
    Il existe plus d'informations sur les règles de visibilité des données dans
    la <xref linkend="spi-visibility"/>. L'exemple dans la <xref
    linkend="trigger-example"/> contient une démonstration de ces règles.
   </para>
  </sect1>

  <sect1 id="trigger-interface">
   <title>Écrire des fonctions déclencheurs en C</title>

   <indexterm zone="trigger-interface">
    <primary>trigger</primary>
    <secondary>en C</secondary>
   </indexterm>

   <para>
    Cette section décrit les détails de bas niveau de l'interface d'une fonction
    déclencheur. Ces informations ne sont nécessaires que lors de l'écriture
    d'une fonction déclencheur en C. Si vous utilisez un langage de plus haut
    niveau, ces détails sont gérés pour vous. Dans la plupart des cas, vous
    devez considérer l'utilisation d'un langage de procédure avant d'écrire
    vos déclencheurs en C. La documentation de chaque langage de procédures
    explique comment écrire un déclencheur dans ce langage.
   </para>

   <para>
    Les fonctions déclencheurs doivent utiliser la <quote>version 1</quote> de
    l'interface du gestionnaire de fonctions.
   </para>

   <para>
    Quand une fonction est appelée par le gestionnaire de déclencheur, elle ne
    reçoit aucun argument classique, mais un pointeur de <quote>contexte</quote>
    pointant sur une structure <structname>TriggerData</structname>. Les fonctions C
    peuvent vérifier si elles sont appelées par le gestionnaire de déclencheurs
    ou pas en exécutant la macro&nbsp;:
<programlisting>CALLED_AS_TRIGGER(fcinfo)
</programlisting>
    qui se décompose en&nbsp;:
<programlisting>((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))
</programlisting>
    Si elle retourne la valeur vraie, alors il est bon de convertir
    <literal>fcinfo-&gt;context</literal> en type <literal>TriggerData *</literal> et
de
    faire usage de la structure pointée <structname>TriggerData</structname>. La fonction
    <emphasis>ne</emphasis> doit <emphasis>pas</emphasis> modifier la
    structure <structname>TriggerData</structname> ou une donnée quelconque vers laquelle
    elle pointe.
   </para>

   <para>
    <structname>struct TriggerData</structname> est définie dans
    <filename>commands/trigger.h</filename>&nbsp;:

<programlisting>typedef struct TriggerData
{
    NodeTag       type;
    TriggerEvent  tg_event;
    Relation      tg_relation;
    HeapTuple     tg_trigtuple;
    HeapTuple     tg_newtuple;
    Trigger      *tg_trigger;
    Buffer        tg_trigtuplebuf;
    Buffer        tg_newtuplebuf;
} TriggerData;
</programlisting>

    où les membres sont définis comme suit&nbsp;:

    <variablelist>
     <varlistentry>
      <term><structfield>type</structfield></term>
      <listitem>
       <para>
        Toujours <literal>T_TriggerData</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_event</structfield></term>
      <listitem>
       <para>
	Décrit l'événement pour lequel la fonction est appelée. Vous pouvez utiliser
	les macros suivantes pour examiner <literal>tg_event</literal>&nbsp;:

	<variablelist>
	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_BEFORE(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Renvoie vrai si le déclencheur est lancé avant l'opération.
	   </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_AFTER(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Renvoie vrai si le déclencheur est lancé après l'opération.
	   </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_FOR_ROW(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Renvoie vrai si le déclencheur est lancé pour un événement en
            mode ligne.
	   </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_FOR_STATEMENT(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Renvoie vrai si le déclencheur est lancé pour un événement en
            mode instruction.
           </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_BY_INSERT(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Retourne vrai si le déclencheur est lancé par une commande 
	    <command>INSERT</command>.
	   </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_BY_UPDATE(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Retourne vrai si le déclencheur est lancé par une commande
            <command>UPDATE</command>.
	   </para>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term><literal>TRIGGER_FIRED_BY_DELETE(tg_event)</literal></term>
	  <listitem>
	   <para>
	    Retourne vrai si le déclencheur est lancé par une commande
            <command>DELETE</command>.
	   </para>
	  </listitem>
	 </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_TRUNCATE(tg_event)</literal></term>
          <listitem>
           <para>
            Renvoie true si le trigger a été déclenché par une commande
	    <command>TRUNCATE</command>.
           </para>
          </listitem>
         </varlistentry>
	</variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_relation</structfield></term>
      <listitem>
       <para>
	Un pointeur vers une structure décrivant la relation pour laquelle le
        déclencheur est lancé. Voir <filename>utils/rel.h</filename> pour les détails
        de cette structure. Les choses les plus intéressantes sont 
	<literal>tg_relation-&gt;rd_att</literal> (descripteur de nuplets de la
	relation) et <literal>tg_relation-&gt;rd_rel-&gt;relname</literal> (nom de la
	relation&nbsp;;
        le type n'est pas <type>char*</type> mais <type>NameData</type>&nbsp;; utilisez
        <literal>SPI_getrelname(tg_relation)</literal> pour obtenir un <type>char*</type>
	si vous avez besoin d'une copie du nom).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigtuple</structfield></term>
      <listitem>
       <para>
	Un pointeur vers la ligne pour laquelle le déclencheur a été lancé. Il
        s'agit de la ligne étant insérée, mise à jour ou effacée. Si ce
	déclencheur a été lancé pour une commande <command>INSERT</command> ou
        <command>DELETE</command>, c'est cette valeur que la fonction doit retourner si
        vous ne voulez pas remplacer la ligne par une ligne différente (dans le
        cas d'un <command>INSERT</command>) ou sauter l'opération.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtuple</structfield></term>
      <listitem>
       <para>
	Un pointeur vers la nouvelle version de la ligne, si le déclencheur a
        été lancé pour un <command>UPDATE</command> et <symbol>NULL</symbol> si c'est
        pour un <command>INSERT</command> ou un <command>DELETE</command>.
        C'est ce que la fonction doit retourner si l'événement est un
        <command>UPDATE</command> et que vous ne voulez pas remplacer cette
        ligne par une ligne différente ou bien sauter l'opération.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigger</structfield></term>
      <listitem>
       <para>
	Un pointeur vers une structure de type <structname>Trigger</structname>, définie
        dans <filename>utils/rel.h</filename>&nbsp;:

<programlisting>typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    bool        tgenabled;
    bool        tgisconstraint;
    Oid         tgconstrrelid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16       *tgattr;
    char      **tgargs;
} Trigger;
</programlisting>

       où <structfield>tgname</structfield> est le nom du déclencheur,
       <structfield>tgnargs</structfield> est le nombre d'arguments dans
       <structfield>tgargs</structfield> et <structfield>tgargs</structfield> est un tableau de
       pointeurs vers les arguments spécifiés dans l'expression contenant la
       commande <command>CREATE TRIGGER</command>. Les autres membres ne sont
       destinés qu'à un usage interne.
       </para>
      </listitem>
      </varlistentry>

      <varlistentry>
       <term><structfield>tg_trigtuplebuf</structfield></term>
        <listitem>
         <para>
          Le tampon contenant <structfield>tg_trigtuple</structfield> ou
          <symbol>InvalidBuffer</symbol> s'il n'existe pas une telle ligne ou si
          elle n'est pas stockée dans un tampon du disque.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><structfield>tg_newtuplebuf</structfield></term>
         <listitem>
          <para>
           Le tampon contenant <structfield>tg_newtuple</structfield> ou
           <symbol>InvalidBuffer</symbol> s'il n'existe pas une telle ligne ou
           si elle n'est pas stockée dans un tampon du disque.
	  </para>
         </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Une fonction déclencheur doit retourner soit un pointeur
    <structname>HeapTuple</structname> soit un pointeur <symbol>NULL</symbol> (<emphasis>pas</emphasis>
    une valeur SQL NULL, donc ne positionnez pas <parameter>isNull</parameter> à
    true). Faites attention de renvoyer soit un
    <structfield>tg_trigtuple</structfield> soit un <structfield>tg_newtuple</structfield>,
    comme approprié, si vous ne voulez pas changer la ligne en cours de
    modification.
   </para>

  </sect1>

  <sect1 id="trigger-example">
   <title>Un exemple complet</title>

   <para>
    Voici un exemple très simple de fonction déclencheur écrite en C (les
    exemples de déclencheurs écrits avec différents langages de procédures
    se trouvent dans la documentation de ceux-ci).
   </para>

   <para>
    La fonction <function>trigf</function> indique le nombre de lignes de la table
    <structname>ttest</structname> et saute l'opération si la commande tente d'insérer une
    valeur NULL dans la colonne <structfield>x</structfield> (ainsi le déclencheur agit
    comme une contrainte non NULL mais n'annule pas la transaction).
   </para>

   <para>
    Tout d'abord, la définition des tables&nbsp;:
<programlisting>CREATE TABLE ttest (
    x integer
);
</programlisting>
   </para>

   <para>
    Voici le code source de la fonction trigger :
<programlisting><![CDATA[#include "postgres.h"
#include "executor/spi.h"       /* nécessaire pour fonctionner avec SPI */
#include "commands/trigger.h"   /* ... et les déclencheurs */

extern Datum trigf(PG_FUNCTION_ARGS);

PG_FUNCTION_INFO_V1(trigf);

Datum
trigf(PG_FUNCTION_ARGS)
{
    TriggerData *trigdata = (TriggerData *) fcinfo->context;
    TupleDesc   tupdesc;
    HeapTuple   rettuple;
    char       *when;
    bool        checkNULL = false;
    bool        isNULL;
    int         ret, i;

    /* on s'assure que la fonction est appelée en tant que déclencheur */
    if (!CALLED_AS_TRIGGER(fcinfo))
        elog(ERROR, "trigf: not called by trigger manager");

    /* nuplet à retourner à l'exécuteur */
    if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))
        rettuple = trigdata->tg_newtuple;
    else
        rettuple = trigdata->tg_trigtuple;

    /* vérification des valeurs NULL */
    if (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event)
        && TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        checkNULL = true;

    if (TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        when = "before";
    else
        when = "after ";

    tupdesc = trigdata->tg_relation->rd_att;

    /* connexion au gestionnaire SPI */
    if ((ret = SPI_connect()) < 0)
        elog(ERROR, "trigf (fired %s): SPI_connect returned %d", when, ret);

    /* obtient le nombre de lignes dans la table */
    ret = SPI_exec("SELECT count(*) FROM ttest", 0);

    if (ret < 0)
        elog(ERROR, "trigf (fired %s): SPI_exec returned %d", when, ret);

    /* count(*) renvoie int8, prenez garde à bien convertir */
    i = DatumGetInt64(SPI_getbinval(SPI_tuptable->vals[0],
                                    SPI_tuptable->tupdesc,
                                    1,
                                    &isNULL));

    elog (INFO, "trigf (fired %s): there are %d rows in ttest", when, i);

    SPI_finish();

    if (checkNULL)
    {
        SPI_getbinval(rettuple, tupdesc, 1, &isNULL);
        if (isNULL)
            rettuple = NULL;
    }

    return PointerGetDatum(rettuple);
}
]]></programlisting>
   </para>

   <para>
    Après avoir compilé le code source (voir <xref
    linkend="dfunc"/>), déclarez la fonction et les
    déclencheurs&nbsp;:
<programlisting>CREATE FUNCTION trigf() RETURNS trigger
    AS '<replaceable>nomfichier</replaceable>'
    LANGUAGE C;

CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest 
    FOR EACH ROW EXECUTE PROCEDURE trigf();

CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest 
    FOR EACH ROW EXECUTE PROCEDURE trigf();
</programlisting>
   </para>

   <para>
    À présent, testez le fonctionnement du déclencheur&nbsp;:
<screen>=&gt; INSERT INTO ttest VALUES (NULL);
INFO:  trigf (fired before): there are 0 rows in ttest
INSERT 0 0

-- Insertion supprimée et déclencheur APRES non exécuté

=&gt; SELECT * FROM ttest;
 x
---
(0 rows)

=&gt; INSERT INTO ttest VALUES (1);
INFO:  trigf (fired before): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 1 rows in ttest
                                       ^^^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
INSERT 167793 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
(1 row)

=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
                                       ^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
INSERT 167794 1
=&gt; SELECT * FROM ttest;
 x
---
 1
 2
(2 rows)

=&gt; UPDATE ttest SET x = NULL WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
UPDATE 0
=&gt; UPDATE ttest SET x = 4 WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
UPDATE 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
 4
(2 rows)

=&gt; DELETE FROM ttest;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
                                       ^^^^^^
                       souvenez-vous de ce que nous avons dit sur la visibilité.
DELETE 2
=&gt; SELECT * FROM ttest;
 x
---
(0 rows)
</screen>

   </para>

   <para>
    Vous trouverez des exemples plus complexes dans 
    <filename>src/test/regress/regress.c</filename> et dans
    <filename>contrib/spi</filename>.
   </para>
  </sect1>
 </chapter>
