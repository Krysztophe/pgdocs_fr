<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/xindex.sgml,v 1.12 2005/09/15 07:03:25 guillaume Exp $
-->

<sect1 id="xindex">
 <title>Interfacer des extensions d'index</title>

  <para>
    Les procédures décrites jusqu'à maintenant permettent de définir de nouveaux
    types, de nouvelles fonctions et de nouveaux opérateurs. Néanmoins, nous ne
    pouvons pas encore définir un index sur une colonne d'un nouveau type de
    données. Pour cela, nous devons définir une <firstterm>classe d'opérateur</firstterm>
    pour le nouveau type de données. Plus loin dans cette section, nous
    illustrerons ce concept avec un exemple&nbsp;: une nouvelle classe
    d'opérateur pour la méthode d'indexation B-tree qui enregistre et trie des
    nombres complexes dans l'ordre ascendant des valeurs absolues.
  </para>

  <para>
   Les classes d'opérateur peuvent être groupées en <firstterm>familles
   d'opérateur</firstterm> pour afficher les relations entre classes
   compatibles sémantiquement.  Quand un seul type de données est impliqué,
   une classe d'opérateur est suffisant, donc nous allons nous fixer sur ce
   cas en premier puis retourner aux familles d'opérateur.
  </para>

 <sect2 id="xindex-opclass">
  <title>Méthodes d'indexation et classes d'opérateurs</title>

  <para>
   La table <classname>pg_am</classname> contient une ligne pour chaque méthode
   d'indexation (connue en interne comme méthode d'accès). Le support pour l'accès
   normal aux tables est implémenté dans <productname>PostgreSQL</productname>
   mais toutes les méthodes d'index sont décrites dans
   <classname>pg_am</classname>. Il est possible d'ajouter une nouvelle méthode
   d'indexation en définissant les routines d'interface nécessaires et en créant
   ensuite une ligne dans la table <classname>pg_am</classname> &mdash; mais ceci
   est au-delà du sujet de ce chapitre (voir le <xref linkend="indexam"/>).
  </para>

  <para>
   Les routines pour une méthode d'indexation n'ont pas à connaître directement
   les types de données sur lesquels opère la méthode d'indexation. Au lieu de
   cela, une <firstterm>classe d'opérateur</firstterm> identifie l'ensemble d'opérations
   que la méthode d'indexation doit utiliser pour fonctionner avec un type
   particulier de données. Les classes d'opérateurs sont ainsi dénommées parce
   qu'une de leur tâche est de spécifier l'ensemble des opérateurs de la clause
   <literal>WHERE</literal> utilisables avec un index (c'est-à-dire, qui peuvent être
   requalifiés en balayage d'index). Une classe d'opérateur peut également
   spécifier des <firstterm>procédures d'appui</firstterm>, nécessaires pour les
   opérations internes de la méthode d'indexation mais sans correspondance
   directe avec un quelconque opérateur de clause <literal>WHERE</literal> pouvant être
   utilisé avec l'index.
  </para>

  <para>
   Il est possible de définir plusieurs classes d'opérateurs pour le même
   type de données et la même méthode d'indexation. Ainsi, de multiples ensembles
   de sémantiques d'indexation peuvent être définis pour un seul type de
   données. Par exemple, un index B-tree exige qu'un tri ordonné soit défini
   pour chaque type de données auquel il peut s'appliquer. Il peut être utile
   pour un type de donnée de nombre complexe de disposer d'une classe
   d'opérateur B-tree qui trie les données selon la valeur absolue complexe, une
   autre selon la partie réelle, etc. Typiquement, une des classes d'opérateur
   sera considérée comme plus utile et sera marquée comme l'opérateur par défaut
   pour ce type de données et cette méthode d'indexation.
  </para>

  <para>
   Le même nom de classe d'opérateur peut être utilisé pour plusieurs méthodes
   d'indexation différentes (par exemple, les méthodes d'index B-tree et hash ont
   toutes les deux des classes d'opérateur nommées <literal>int4_ops</literal>)
   mais chacune de ces classes est une entité indépendante et doit être définie
   séparément.
  </para>
 </sect2>

 <sect2 id="xindex-strategies">
  <title>Stratégies des méthode d'indexation</title>

  <para>
   Les opérateurs associés à une classe d'opérateur sont identifiés par des
   <quote>numéros de stratégie</quote>, servant à identifier la sémantique de
   chaque opérateur dans le contexte de sa classe d'opérateur. Par exemple, les
   B-trees imposent un classement strict selon les clés, du plus petit au plus
   grand. Ainsi, des opérateurs comme <quote>plus petit que</quote> et <quote>plus
   grand que</quote> sont intéressants pour un B-tree. Comme
   <productname>PostgreSQL</productname> permet à l'utilisateur de définir des
   opérateurs, <productname>PostgreSQL</productname> ne peut pas rechercher le
   nom d'un opérateur (par exemple, <literal>&lt;</literal> ou <literal>&gt;=</literal>) et
   rapporter de quelle comparaison il s'agit. Au lieu de cela, la méthode
   d'indexation définit un ensemble de <quote>stratégies</quote>, qui peuvent être
   comprises comme des opérateurs généralisés. Chaque classe d'opérateur
   spécifie l'opérateur effectif correspondant à chaque stratégie pour un type
   de donnée particulier et pour une interprétation de la sémantique d'index.
  </para>

  <para>
   La méthode d'indexation B-tree définit cinq stratégies, qui sont exposées
   dans le <xref linkend="xindex-btree-strat-table"/>.
  </para>

   <table tocentry="1" id="xindex-btree-strat-table">
    <title>Stratégies B-tree</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Opération</entry>
       <entry>Numéro de stratégie</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>plus petit que</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>plus petit ou égal</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry>égal</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry>plus grand ou égal</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry>plus grand que</entry>
       <entry>5</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Les index de découpage permettent seulement des comparaisons d'égalité et
   utilisent ainsi une seule stratégie exposée dans le <xref
   linkend="xindex-hash-strat-table"/>.
  </para>

   <table tocentry="1" id="xindex-hash-strat-table">
    <title>Stratégies de découpage</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Opération</entry>
       <entry>Numéro de stratégie</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>égal à</entry>
       <entry>1</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Les index GiST sont plus flexibles&nbsp;: ils n'ont pas du tout un
   ensemble fixe de stratégies. À la place, la routine de support de
   <quote>cohérence</quote> de chaque classe d'opérateur GiST interprète les
   numéros de stratégie comme elle l'entend. Comme exemple, plusieurs des classes
   d'opérateurs  GiST indexe les objets géométriques à deux dimensions
   fournissant les stratégies <quote>R-tree</quote> affichées dans
   <xref linkend="xindex-rtree-strat-table"/>. Quatre d'entre elles sont des vrais
   tests à deux dimensions (surcharge, identique, contient, contenu par)&nbsp;;
   quatre autres considèrent seulement la direction X&nbsp;; et les quatre
   dernières fournissent les mêmes tests dans la direction Y.
  </para>

   <table tocentry="1" id="xindex-rtree-strat-table">
    <title>Stratégies <quote>R-tree</quote> pour GiST à deux dimensions</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Opération</entry>
       <entry>Numéro de stratégie</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>strictement à gauche de</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>ne s'étend pas à droite de</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry>surcharge</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry>ne s'étend pas à gauche de</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry>strictement à droite de</entry>
       <entry>5</entry>
      </row>
      <row>
       <entry>identique</entry>
       <entry>6</entry>
      </row>
      <row>
       <entry>contient</entry>
       <entry>7</entry>
      </row>
      <row>
       <entry>contenu par</entry>
       <entry>8</entry>
      </row>
      <row>
       <entry>ne s'étend pas au dessus</entry>
       <entry>9</entry>
      </row>
      <row>
       <entry>strictement en dessous</entry>
       <entry>10</entry>
      </row>
      <row>
       <entry>strictement au dessus</entry>
       <entry>11</entry>
      </row>
      <row>
       <entry>ne s'étend pas en dessous</entry>
       <entry>12</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Les index GIN sont similaires aux index GiST en flexibilité&nbsp;: ils n'ont
   pas un ensemble fixe de stratégie. À la place, les routines de support de
   chaque classe d'opérateur interprètent les numéros de stratégie suivant la
   définition du classe d'opérateur. Comme exemple, les numéros des stratégies
   utilisés par les classes d'opérateur sur des tableaux sont affichés dans
   <xref linkend="xindex-gin-array-strat-table"/>.
  </para>

   <table tocentry="1" id="xindex-gin-array-strat-table">
    <title>Stratégies des tableaux GIN</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Opération</entry>
       <entry>Numéro de stratégie</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>surcharge</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>contient</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry>est contenu par</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry>identique</entry>
       <entry>4</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Notez que tous les opérateurs de stratégie renvoient des valeurs de type
   booléen. Dans la pratique, tous les opérateurs définis comme stratégies de
   méthode d'indexation doivent renvoyer un type <type>boolean</type> puisqu'ils
   doivent apparaître au plus haut niveau d'une clause <literal>WHERE</literal> pour
   être utilisés avec un index.
  </para>
 </sect2>

 <sect2 id="xindex-support">
  <title>Routines d'appui des méthodes d'indexation</title>

  <para>
   Généralement, les stratégies n'apportent pas  assez d'informations au système
   pour indiquer comment utiliser un index. Dans la pratique, les méthodes
   d'indexation demandent des routines d'appui additionnelles pour fonctionner. Par
   exemple, les méthodes d'index B-tree doivent être capables de comparer deux
   clés et de déterminer laquelle est supérieure, égale ou inférieure à l'autre.
   De la même façon, la méthode d'indexation hash doit être capable de calculer
   les codes de hachage pour les valeurs de clés. Ces opérations ne
   correspondent pas à des opérateurs utilisés dans les commandes SQL&nbsp;; ce
   sont des routines administratives utilisées en interne par des méthodes
   d'index.
  </para>

  <para>
   Comme pour les stratégies, la classe d'opérateur énumère les fonctions
   spécifiques et le rôle qu'elles doivent jouer pour un
   type de donnée donné et une interprétation sémantique donnée. La méthode d'indexation
   définit l'ensemble des fonctions dont elle a besoin et la classe d'opérateur
   identifie les fonctions exactes à utiliser en les assignant aux
   <quote>numéros de fonction d'appui</quote> spécifiés par la méthode d'indexage.
  </para>

  <para>
   Les B-trees demandent une seule fonction d'appui, exposée dans le <xref
   linkend="xindex-btree-support-table"/>.
  </para>

   <table tocentry="1" id="xindex-btree-support-table">
    <title>Fonctions d'appui de B-tree</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Fonction</entry>
       <entry>Numéro d'appui</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        Comparer deux clés et renvoyer un entier inférieur à zéro, zéro ou
        supérieure à zéro indiquant si la première clé est inférieure, égale ou
        supérieure à la deuxième.
       </entry>
       <entry>1</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   De façon identique, les index de découpage requièrent une fonction d'appui
   exposée dans le <xref linkend="xindex-hash-support-table"/>.
  </para>

   <table tocentry="1" id="xindex-hash-support-table">
    <title>Fonctions d'appui pour découpage</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Fonction</entry>
       <entry>Numéro d'appui</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>Calculer la valeur de découpage pour une clé</entry>
       <entry>1</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Les index GiST requièrent sept fonctions d'appui exposées dans le <xref
   linkend="xindex-gist-support-table"/>.
  </para>

   <table tocentry="1" id="xindex-gist-support-table">
    <title>Fonctions d'appui pour GiST</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Fonction</entry>
       <entry>Numéro d'appui</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>consistency - détermine si la clé satisfait le qualifiant de la
	       requête</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>union - calcule l'union d'un ensemble de clés</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry>compress - calcule une représentation compressée d'une clé ou
	       d'une valeur à indexer</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry>decompress - calcule une représentation décompressée d'une clé
	   compressée</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry>penality - calcule la pénalité pour l'insertion d'une nouvelle
	       clé dans un sous-arbre avec la clé du sous-arbre indiqué</entry>
       <entry>5</entry>
      </row>
      <row>
       <entry>picksplit - détermine les entrées d'une page qui sont à déplacer
	       vers la nouvelle page et calcule les clés d'union pour les pages
	       résultantes</entry>
       <entry>6</entry>
      </row>
      <row>
       <entry>equal - compare deux clés et renvoie true si elles sont
	       identiques</entry>
       <entry>7</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Les index GIN requièrent quatre fonctions d'appui exposées dans le <xref
   linkend="xindex-gin-support-table"/>.
  </para>

   <table tocentry="1" id="xindex-gin-support-table">
    <title>Fonctions d'appui GIN</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Fonction</entry>
       <entry>Numéro d'appui</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
	compare - Compare deux clés et renvoie un entier plus petit que zéro,
	zéro ou plus grand que zéro, indiquant si la première clé est plus petit,
	égal à ou plus grand que la seconde.
       </entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>extractValue - extrait les clés à partir d'une condition de
        requête</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry>extractQuery - extrait les clés à partir d'une condition de
        requête</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry>consistent - détermine la valeur correspondant à la condition de
        requête</entry>
       <entry>4</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Contrairement aux opérateurs de stratégie, les fonctions d'appui renvoient le
    type de donnée, quelqu'il soit, que la méthode d'indexation particulière
    attend, par exemple, dans le cas de la fonction de comparaison des B-trees,
    un entier signé. Le nombre et le type des arguments pour chaque fonction de
    support peuvent dépendre de la méthode d'indexage. Pour les B-tree et les
    hash, les fonctions de support prennent les même types de données en entrée
    comme le font les opérateurs incluant dans la classe d'opérateur, bien que
    ce ne soit pas le cas pour la plupart des fonctions de support GIN et
    GiST.
   </para>
 </sect2>

 <sect2 id="xindex-example">
  <title>Exemple</title>

  <para>
   Maintenant que nous avons vu les idées, voici l'exemple promis de création
   d'une nouvelle classe d'opérateur. Cette classe d'opérateur encapsule les
   opérateurs qui trient les nombres complexes selon l'ordre de la valeur
   absolue, aussi avons-nous choisi le nom de
   <literal>complex_abs_ops</literal>. En premier lieu, nous avons besoin d'un
   ensemble d'opérateurs. La procédure pour définir des opérateurs a été
   discutée dans la <xref linkend="xoper"/>.  Pour une classe d'opérateur sur les
   B-trees, nous avons besoin des opérateurs&nbsp;:

   <itemizedlist spacing="compact">
    <listitem><simpara>valeur absolue less-than (stratégie 1)&nbsp;;</simpara></listitem>
    <listitem><simpara>valeur absolue less-than-or-equal (stratégie
     2)&nbsp;;</simpara></listitem>
    <listitem><simpara>valeur absolue equal (stratégie 3)&nbsp;;</simpara></listitem>
    <listitem><simpara>valeur absolue greater-than-or-equal (stratégie
     4)&nbsp;;</simpara></listitem>
    <listitem><simpara>valeur absolue greater-than (stratégie 5)&nbsp;;</simpara></listitem>
   </itemizedlist>
  </para>

  <para>
   Le plus simple moyen de définie un ensemble d'opérateurs de comparaison est
   d'écrire en premier la fonction de comparaison B-tree, puis d'écrire les
   autres fonctions en tant que wrapper de la fonction de support. Ceci réduit
   les risques de résultats incohérents pour les cas spécifiques. En suivant
   cette approche, nous devons tout d'abord écrire&nbsp;:

<programlisting>#define Mag(c) ((c)-&gt;x*(c)-&gt;x + (c)-&gt;y*(c)-&gt;y)

bool
complex_abs_eq(Complex *a, Complex *b)
{
    double amag = Mag(a), bmag = Mag(b);
    return (amag == bmag);
}
</programlisting>

   Maintenant, la fonction plus-petit-que ressemble à ceci&nbsp;:

<programlisting>PG_FUNCTION_INFO_V1(complex_abs_lt);

Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
    Complex    *a = (Complex *) PG_GETARG_POINTER(0);
    Complex    *b = (Complex *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) &lt; 0);
}
</programlisting>

   Les quatre autres fonctions diffèrent seulement sur la façon dont ils
   comparent le résultat de la fonction interne au zéro.
  </para>

  <para>
   Maintenant, déclarons en SQL les fonctions et les opérateurs basés sur ces
   fonctions&nbsp;:
<programlisting>CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
    AS '<replaceable>nom_fichier</replaceable>', 'complex_abs_lt'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR &lt; (
   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
   commutator = &gt; , negator = &gt;= ,
   restrict = scalarltsel, join = scalarltjoinsel
);
</programlisting>
   Il est important de spécifier les fonctions de sélectivité de restriction et
   de jointure, sinon l'optimiseur sera incapable de faire un usage effectif de
   l'index. Notez que les cas 'less-than', 'equal' et 'greater-than' doivent
   utiliser des fonctions différentes de sélectivité.
  </para>

  <para>
  Voici d'autres choses importantes à noter&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     Il ne peut y avoir qu'un seul opérateur nommé, disons, <literal>=</literal>
     et acceptant un type <type>complex</type> pour ses deux opérandes. Dans le
     cas présent, nous n'avons aucun autre opérateur <literal>=</literal> pour
     <type>complex</type> mais, si nous construisons un type de donnée
     fonctionnel, nous aurions certainement désiré que <literal>=</literal> soit
     l'opération ordinaire d'égalité pour les nombres complexes (et non pour
     l'égalité de leurs valeurs absolues). Dans ce cas, nous aurions eu besoin
     d'utiliser un autre nom d'opérateur pour notre fonction
     <function>complex_abs_eq</function>.
    </para>
   </listitem>

   <listitem>
    <para>
     Bien que <productname>PostgreSQL</productname> puisse se débrouiller avec
     des fonctions ayant le même nom SQL, tant qu'elles ont en argument des
     types de données différents, en C il ne peut exister qu'une fonction globale
     pour un nom donné. Aussi ne devons-nous pas donner un nom simple
     comme <filename>abs_eq</filename>. Habituellement, inclure le nom du type
     de données dans le nom de la fonction C est une bonne habitude pour ne
     pas provoquer de conflit avec des fonctions pour d'autres types de donnée.
    </para>
   </listitem>

   <listitem>
    <para>
     Nous aurions pu faire de  <filename>abs_eq</filename> le nom
     SQL de la fonction, en laissant à <productname>PostgreSQL</productname>
     le soin de la distinguer de toute autre fonction SQL de même nom par les
     types de données en argument. Pour la simplicité de l'exemple, nous
     donnerons à la fonction le même nom au niveau de C et au niveau de SQL.
    </para>
   </listitem>
  </itemizedlist>
  </para>

  <para>
   La prochaine étape est l'enregistrement de la routine d'appui nécessaire pour
   les  B-trees. Le code exemple C qui implémente ceci est dans le même fichier
   qui contient les fonctions d'opérateur. Voici comment déclarer la
   fonction&nbsp;:

<programlisting>CREATE FUNCTION complex_abs_cmp(complex, complex)
    RETURNS integer
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C;
</programlisting>
  </para>

  <para>
   Maintenant que nous avons les opérateurs requis et la routine d'appui, nous
   pouvons enfin créer la classe d'opérateur.

<programlisting>CREATE OPERATOR CLASS complex_abs_ops
    DEFAULT FOR TYPE complex USING btree AS
        OPERATOR        1       &lt; ,
        OPERATOR        2       &lt;= ,
        OPERATOR        3       = ,
        OPERATOR        4       &gt;= ,
        OPERATOR        5       &gt; ,
        FUNCTION        1       complex_abs_cmp(complex, complex);
</programlisting>
  </para>

  <para>
   Et c'est fait&nbsp;! Il devrait être possible maintenant de créer et
   d'utiliser les index B-tree sur les colonnes <type>complex</type>.
  </para>

  <para>
   Nous aurions pu écrire les entrées de l'opérateur de façon plus explicite
   comme dans&nbsp;:

   <programlisting>        OPERATOR        1       &lt; (complex, complex) ,
</programlisting>
   mais il n'y a pas besoin de faire ainsi quand les opérateurs prennent le même
   type de donnée que celui pour lequel la classe d'opérateur a été définie.
  </para>

  <para>
   Les exemples ci-dessus supposent que vous voulez que cette nouvelle classe
   d'opérateur soit la classe d'opérateur B-tree par défaut pour le type de
   donnée <type>complex</type>. Si vous ne voulez pas, supprimez simplement le
   mot <literal>DEFAULT</literal>.
  </para>
 </sect2>

 <sect2 id="xindex-opfamily">
 <title>Classes et familles d'opérateur</title>

 <para>
  Jusqu'à maintenant, nous avons supposé implicitement qu'une classe d'opérateur
  s'occupe d'un seul type de données. Bien qu'il ne peut y avoir qu'un seul
  type de données dans une colonne d'index particulière, il est souvent utile
  d'indexer les opérations qui comparent une colonne indexée à une valeur d'un
  type de données différent. De plus,
   if there is use for a cross-data-type operator in connection with an
   operator class, it is often the case that the other data type has a
   related operator class of its own.  It is helpful to make the connections
   between related classes explicit, because this can aid the planner in
   optimizing SQL queries (particularly for B-tree operator classes, since
   the planner contains a great deal of knowledge about how to work with them).
 </para>

  <para>
   To handle these needs, <productname>PostgreSQL</productname>
   uses the concept of an <firstterm>operator
   family</firstterm><indexterm><primary>operator family</primary></indexterm>.
   An operator family contains one or more operator classes, and can also
   contain indexable operators and corresponding support functions that
   belong to the family as a whole but not to any single class within the
   family.  We say that such operators and functions are <quote>loose</quote>
   within the family, as opposed to being bound into a specific class.
   Typically each operator class contains single-data-type operators
   while cross-data-type operators are loose in the family.
  </para>

  <para>
   All the operators and functions in an operator family must have compatible
   semantics, where the compatibility requirements are set by the index
   method.  You might therefore wonder why bother to single out particular
   subsets of the family as operator classes; and indeed for many purposes
   the class divisions are irrelevant and the family is the only interesting
   grouping.  The reason for defining operator classes is that they specify
   how much of the family is needed to support any particular index.
   If there is an index using an operator class, then that operator class
   cannot be dropped without dropping the index &mdash; but other parts of
   the operator family, namely other operator classes and loose operators,
   could be dropped.  Thus, an operator class should be specified to contain
   the minimum set of operators and functions that are reasonably needed
   to work with an index on a specific data type, and then related but
   non-essential operators can be added as loose members of the operator
   family.
  </para>

  <para>
   As an example, <productname>PostgreSQL</productname> has a built-in
   B-tree operator family <literal>integer_ops</literal>, which includes operator
   classes <literal>int8_ops</literal>, <literal>int4_ops</literal>, and
   <literal>int2_ops</literal> for indexes on <type>bigint</type> (<type>int8</type>),
   <type>integer</type> (<type>int4</type>), and <type>smallint</type> (<type>int2</type>)
   columns respectively.  The family also contains cross-data-type comparison
   operators allowing any two of these types to be compared, so that an index
   on one of these types can be searched using a comparison value of another
   type.  The family could be duplicated by these definitions:

<programlisting>
CREATE OPERATOR FAMILY integer_ops USING btree;

CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
  -- comparaisons int8 standard
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint8cmp(int8, int8) ;

CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
  -- comparaisons int4 standard
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint4cmp(int4, int4) ;

CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
  -- comparaisons int2 standard
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint2cmp(int2, int2) ;

ALTER OPERATOR FAMILY integer_ops USING btree ADD
  -- comparaisons inter-types int8 vs int2
  OPERATOR 1 &lt; (int8, int2) ,
  OPERATOR 2 &lt;= (int8, int2) ,
  OPERATOR 3 = (int8, int2) ,
  OPERATOR 4 &gt;= (int8, int2) ,
  OPERATOR 5 &gt; (int8, int2) ,
  FUNCTION 1 btint82cmp(int8, int2) ,

  -- comparaisons inter-types  int8 vs int4
  OPERATOR 1 &lt; (int8, int4) ,
  OPERATOR 2 &lt;= (int8, int4) ,
  OPERATOR 3 = (int8, int4) ,
  OPERATOR 4 &gt;= (int8, int4) ,
  OPERATOR 5 &gt; (int8, int4) ,
  FUNCTION 1 btint84cmp(int8, int4) ,

  -- comparaisons inter-types int4 vs int2
  OPERATOR 1 &lt; (int4, int2) ,
  OPERATOR 2 &lt;= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 &gt;= (int4, int2) ,
  OPERATOR 5 &gt; (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  -- comparaisons inter-types int4 vs int8
  OPERATOR 1 &lt; (int4, int8) ,
  OPERATOR 2 &lt;= (int4, int8) ,
  OPERATOR 3 = (int4, int8) ,
  OPERATOR 4 &gt;= (int4, int8) ,
  OPERATOR 5 &gt; (int4, int8) ,
  FUNCTION 1 btint48cmp(int4, int8) ,

  -- comparaisons inter-types int2 vs int8
  OPERATOR 1 &lt; (int2, int8) ,
  OPERATOR 2 &lt;= (int2, int8) ,
  OPERATOR 3 = (int2, int8) ,
  OPERATOR 4 &gt;= (int2, int8) ,
  OPERATOR 5 &gt; (int2, int8) ,
  FUNCTION 1 btint28cmp(int2, int8) ,

  -- comparaisons inter-types int2 vs int4
  OPERATOR 1 &lt; (int2, int4) ,
  OPERATOR 2 &lt;= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 &gt;= (int2, int4) ,
  OPERATOR 5 &gt; (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ;
</programlisting>

   Notice that this definition <quote>overloads</quote> the operator strategy and
   support function numbers: each number occurs multiple times within the
   family.  This is allowed so long as each instance of a
   particular number has distinct input data types.  The instances that have
   both input types equal to an operator class's input type are the
   primary operators and support functions for that operator class,
   and in most cases should be declared as part of the operator class rather
   than as loose members of the family.
  </para>

  <para>
   In a B-tree operator family, all the operators in the family must sort
   compatibly, meaning that the transitive laws hold across all the data types
   supported by the family: <quote>if A = B and B = C, then A =
   C</quote>, and <quote>if A &lt; B and B &lt; C, then A &lt; C</quote>.  For each
   operator in the family there must be a support function having the same
   two input data types as the operator.  It is recommended that a family be
   complete, i.e., for each combination of data types, all operators are
   included.  Each operator class should include just the non-cross-type
   operators and support function for its data type.
  </para>

  <para>
   To build a multiple-data-type hash operator family, compatible hash
   support functions must be created for each data type supported by the
   family.  Here compatibility means that the functions are guaranteed to
   return the same hash code for any two values that are considered equal
   by the family's equality operators, even when the values are of different
   types.  This is usually difficult to accomplish when the types have
   different physical representations, but it can be done in some cases.
   Notice that there is only one support function per data type, not one
   per equality operator.  It is recommended that a family be complete, i.e.,
   provide an equality operator for each combination of data types.
   Each operator class should include just the non-cross-type equality
   operator and the support function for its data type.
  </para>

  <para>
   GIN and GiST indexes do not have any explicit notion of cross-data-type
   operations.  The set of operators supported is just whatever the primary
   support functions for a given operator class can handle.
  </para>

  <note>
   <para>
    Prior to <productname>PostgreSQL</productname> 8.3, there was no concept
    of operator families, and so any cross-data-type operators intended to be
    used with an index had to be bound directly into the index's operator
    class.  While this approach still works, it is deprecated because it
    makes an index's dependencies too broad, and because the planner can
    handle cross-data-type comparisons more effectively when both data types
    have operators in the same operator family.
   </para>
  </note>

  </sect2>

 <sect2 id="xindex-opclass-dependencies">
  <title>Dépendances du système pour les classes d'opérateur</title>

   <indexterm>
    <primary>Opérateur d'ordonnancement</primary>
   </indexterm>

  <para>
   <productname>PostgreSQL</productname> utilise les classe d'opérateur pour
   inférer les propriétés des opérateurs de plusieurs autres façons que le seul
   usage avec les index. Donc, vous pouvez créer des classes
   d'opérateur même si vous n'avez pas l'intention d'indexer une quelconque
   colonne de votre type de donnée.
  </para>

  <para>
   En particulier, il existe des caractéristiques de SQL telles que
   <literal>ORDER BY</literal> et <literal>DISTINCT</literal> qui requièrent la comparaison et
   le tri des valeurs. Pour implémenter ces caractéristiques sur un type de
   donnée défini par l'utilisateur, <productname>PostgreSQL</productname>
   recherche la classe d'opérateur B-tree par défaut pour le type de donnée. Le
   membre <quote>equals</quote> de cette classe d'opérateur définit pour le système
   la notion d'égalité des valeurs pour <literal>GROUP BY</literal> et
   <literal>DISTINCT</literal>, et le tri ordonné imposé par la classe d'opérateur
   définit le <literal>ORDER BY</literal> par défaut.

  </para>

  <para>
   La comparaison des tableaux de types définis par l'utilisateur repose sur les
   sémantiques définies par la classe d'opérateur B-tree par défaut.
  </para>

  <para>
   S'il n'y a pas de classe d'opérateur B-tree par défaut pour le type de
   donnée, le système cherchera une classe d'opérateur de découpage. Mais
   puisque cette classe d'opérateur ne fournit que l'égalité, c'est en pratique
   seulement suffisant pour établir l'égalité de tableau.
  </para>

  <para>
   Quand il n'y a pas de classe d'opérateur par défaut pour un type de donnée,
   vous obtenez des erreurs telles que <quote>could not identify an ordering
   operator</quote> si vous essayez d'utiliser ces caractéristiques SQL avec le type
   de donnée.
  </para>

   <note>
    <para>
     Dans les versions de <productname>PostgreSQL</productname> antérieures à
     la 7.4, les opérations de tri et de groupement utilisaient implicitement
     les opérateurs nommés <literal>=</literal>, <literal>&lt;</literal> et
     <literal>&gt;</literal>. Le nouveau comportement qui repose sur les classes
     d'opérateurs par défaut évite d'avoir à faire une quelconque supposition
     sur le comportement des opérateurs avec des noms particuliers.
    </para>
   </note>
 </sect2>

 <sect2 id="xindex-opclass-features">
  <title>Caractéristiques spéciales des classes d'opérateur</title>

  <para>
   Il y a deux caractéristiques spéciales des classes d'opérateur dont nous
   n'avons pas encore parlées, essentiellement parce qu'elles ne sont pas utiles
   avec les méthodes d'index les plus communément utilisées.
  </para>

  <para>
   Normalement, déclarer un opérateur comme membre d'une classe ou d'une famille
   d'opérateur
   signifie que la méthode d'indexation peut retrouver exactement l'ensemble de
   lignes qui satisfait la condition <literal>WHERE</literal> utilisant cet opérateur.
   Par exemple&nbsp;:
<programlisting>SELECT * FROM table WHERE colonne_entier &lt; 4;
</programlisting>
   peut être accompli exactement par un index B-tree sur la colonne entière.
   Mais il y a des cas où un index est utile comme un guide inexact vers la
   colonne correspondante. Par exemple, si un index GiST enregistre seulement
   les rectangles limite des objets, alors il ne peut pas exactement satisfaire
   une condition <literal>WHERE</literal> qui teste le chevauchement entre des objets
   non rectangulaires comme des polygones. Cependant, nous pourrions utiliser
   l'index pour trouver des objets dont les rectangles limites chevauchent les
   limites de l'objet cible. Dans ce cas, l'index est dit être à perte
   pour l'opérateur, et nous ajoutons <literal>RECHECK</literal> à la clause
   <literal>OPERATOR</literal> dans la commande <command>CREATE OPERATOR CLASS</command>. 
   <literal>RECHECK</literal> est valide si l'index garantie de retourner toutes les
   lignes requises, plus peut-être des lignes supplémentaires pouvant être
   éliminées par le recours à l'opérateur original.
  </para>

  <para>
   Considérons à nouveau la situation où nous gardons seulement dans l'index le
   rectangle délimitant un objet complexe comme un polygone. Dans ce cas, il
   n'est pas très intéressant de conserver le polygone entier dans l'index -
   nous pouvons aussi bien conserver seulement un objet simple du type 
   <type>box</type>. Cette situation est exprimée par l'option <literal>STORAGE</literal>
   dans la commande <command>CREATE OPERATOR CLASS</command>&nbsp;: nous aurons à
   écrire quelque chose comme&nbsp;:

<programlisting>CREATE OPERATOR CLASS polygon_ops
    DEFAULT FOR TYPE polygon USING gist AS
        ...
        STORAGE box;
</programlisting>

   Actuellement, seule les méthodes d'indexation GIN et GiST supportent un type
   <literal>STORAGE</literal> qui soit différent du type de donnée de la
   colonne. Les routines d'appui de GiST pour la compression
   (<function>compress</function>) et la décompression
   (<function>decompress</function>) doivent s'occuper de la conversion du type
   de donnée quand <literal>STORAGE</literal> est utilisé. Avec GIN, le type
   <literal>STORAGE</literal> identifie le type des valeurs <quote>key</quote>,
   qui est normalement différent du type de la colonne indexée &mdash; par
   exemple, une classe d'opérateur pour des colonnes de tableaux d'entiers
   pourrait avoir des clés qui sont seulement des entiers. Les routines de
   support GIN <function>extractValue</function> et
   <function>extractQuery</function> sont responsables de l'extraction des clés
   à partir des valeurs indexées.
  </para>
 </sect2>

</sect1>
