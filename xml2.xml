<sect1 id="xml2">
 <title>xml2&nbsp;: fonctions de gestion du XML</title>
 
 <indexterm zone="xml2">
  <primary>xml2</primary>
 </indexterm>

 <sect2>
  <title>Notice d'obsolescence</title>
  <para>
    À partir de PostgreSQL 8.3, les fonctionnalités XML basées sur le standard
    SQL/XML sont dans le c½ur du serveur. Cela couvre la vérification de la
    syntaxe XML et les requêtes XPath, ce que fait aussi ce module (en dehors
    d'autres choses) mais l'API n'est pas du tout compatible. Il est prévu
    que ce module sera supprimé avec PostgreSQL 8.4 pour faire place à une
    nouvelle API standard, donc vous êtes encouragés à convertir vos
    applications. Si vous trouvez que des fonctionnalités de ce module ne sont
    pas disponibles dans un format adéquat avec la nouvelle API, merci
    d'expliquer votre problème sur la liste pgsql-hackers@postgresql.org pour
    que ce problème soit corrigé.
  </para>
 </sect2>
  
 <sect2>
  <title>Description des fonctions</title>
  <para>
   Le premier ensemble de fonctions concerne l'analyse du XML et les
   requêtes XPath&nbsp;:
  </para>

  <table>
   <title>Fonctions</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <programlisting>
        xml_is_well_formed(document) RETURNS bool
       </programlisting>
      </entry>
      <entry>
       <para>
        Ceci analyse un document fourni comme argument au format text et
	renvoie true si le document est du XML bien formé (notez qu'avant
	PostgreSQL 8.2, cette fonction était appelée xml_valid(). C'est un
	mauvais nom car un document bien formé n'est pas forcément un
	document valide en XML. L'ancien nom est toujours disponible mais
	est obsolète et sera supprimé en 8.3.)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <programlisting>
        xpath_string(document,query) RETURNS text
        xpath_number(document,query) RETURNS float4
        xpath_bool(document,query) RETURNS bool
       </programlisting>
      </entry>
      <entry>
       <para>
        Ces fonctions évaluent la requête XPath à partir du document fourni,
	et convertie le résultat dans le type spécifié.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <programlisting>
        xpath_nodeset(document,query,toptag,itemtag) RETURNS text
       </programlisting>
      </entry>
      <entry>
       <para>
       Cette fonction évalue la requête sur le document et enveloppe le
       résultat dans des balises XML. Si le résultat a plusieurs valeurs,
       la sortie ressemblera à ceci&nbsp;:
       </para>
       <literal>
        &lt;toptag>
        &lt;itemtag>Valeur 1 qui pourrait être un fragment XML&lt;/itemtag>
        &lt;itemtag>Valeur 2....&lt;/itemtag>
        &lt;/toptag>
       </literal>
       <para>
        Si toptag et/ou itemtag sont des chaînes vides, la balise adéquate
	est omise.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <programlisting>
        xpath_nodeset(document,query) RETURNS
       </programlisting>
      </entry>
      <entry>
       <para>
        Comme xpath_nodeset(document,query,toptag,itemtag) mais le texte
	omet les balises.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <programlisting>
        xpath_nodeset(document,query,itemtag) RETURNS
       </programlisting>
      </entry>
      <entry>
       <para>
        Comme xpath_nodeset(document,query,toptag,itemtag) mais le texte omet
	toptag.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <programlisting>
        xpath_list(document,query,seperator) RETURNS text
       </programlisting>
      </entry>
      <entry>
       <para>
        Cette fonction renvoie plusieurs valeurs séparées par le caractère
	indiqué, par exemple Valeur 1,Valeur 2,Valeur 3 sir le séparateur est
	une virgule.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <programlisting>
        xpath_list(document,query) RETURNS text
       </programlisting>
      </entry>
      <entry>
       Ceci est un emballage de la fonction ci-dessus avec la virgule comme
       séparateur.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect2>


 <sect2>
  <title><literal>xpath_table</literal></title>
  <para>
   Ceci est une fonction <acronym>SRF</acronym> qui évalue un ensemble
   de requêtes XPath sur un ensemble de documents et renvoie les résultats
   comme une table. Le champ de clé primaire de la table des documents est
   renvoyé comme première colonne des résultats pour que les résultats
   puissent être utilisés dans des jointures.
  </para>
  <para>
   La fonction prend cinq arguments, tous de type text.
  </para>
  <programlisting>
   xpath_table(key,document,relation,xpaths,criteria)
  </programlisting>
  <table>
   <title>Paramètres</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry><literal>key</literal></entry>
      <entry>
       <para>
        Le nom du champ de la clé primaire. C'est simplement le champ à
	utiliser comme première colonne de la table en sortie, autrement dit
	celle qui identifie l'enregistrement (voir la note ci-dessous sur les
	valeurs multiples).
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>document</literal></entry>
      <entry>
       <para>
        Le nom du champ contenant le document XML.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>relation</literal></entry>
      <entry>
       <para>
        Le nom de la table ou de la vue contenant les documents.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>xpaths</literal></entry>
      <entry>
       <para>
        Plusieurs expressions XPath séparées par des <literal>|</literal>
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>criteria</literal></entry>
      <entry>
       <para>
        Le contenu de la clause WHERE. Elle doit être spécifiée, donc
	utilisez true ou <literal>1=1</literal> si vous voulez traiter toutes
	les lignes de la relation.
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Ces paramètres (en dehors des chaînes XPath) sont simplement substitués dans
   une instruction SELECT, donc vous avez de la flexibilité. L'instruction
   est celle qui suit&nbsp;:
  </para>

  <para>
   <literal>
   SELECT &lt;key>,&lt;document> FROM &lt;relation> WHERE &lt;criteria>
   </literal>
  </para>

  <para>
   Donc les paramètres peuvent être tout ce qui est valide dans ces
   emplacements particuliers. Le résultat de ce SELECT a besoin de renvoyer
   exactement deux colonnes (ce qu'il fera sauf si vous essayer d'indiquer
   plusieurs champs pour la clé ou le document). Cette approche simpliste
   implique que vous validiez avant tout valeur fournie par un utilisateur
   pour éviter les attaques par injection de code SQL.
  </para>
 
  <para>
   En utilisant la fonction
  </para>
 
  <para>
   La fonction doit être utilisée dans une expression FROM. Ceci donne
   la forme suivante&nbsp;:
  </para>
 
  <programlisting><![CDATA[
SELECT * FROM
xpath_table('article_id', 
        'article_xml',
        'articles', 
        '/article/author|/article/pages|/article/title',
        'date_entered > ''2003-01-01'' ') 
AS t(article_id integer, author text, page_count integer, title text);
  ]]></programlisting>

  <para>
   La clause AS définit les noms et types des colonnes de la table virtuelle.
   S'il y a plus de requêtes XPath que de colonnes résultats, les requêtes
   supplémentaires seront ignorées, S'il y a plus de colonnes résultats que
   de requêtes XPath, les colonnes supplémentaires seront NULL.
  </para>

  <para>
   Notez que j'ai dit dans cet exemple que pages est un entier (integer). La
   fonction gère en interne les représentations textes, donc quand vous
   dites que vous voulez un entier en sortie, il prendre la représentation
   texte du résultat XPath et utilisera les fonctions en entrée de
   PostgreSQL pour la transformer en entier (ou tout type que la clause AS
   réclame). Vous obtiendrez une erreur s'il ne peut pas le faire - par
   exemple si le résultat est vide - donc rester sur du texte est préférable
   si vous pensez que vos données peuvent poser problème.
  </para>
  <para>
   L'instruction SELECT n'a pas besoin d'utiliser * seule, elle peut référencer
   les colonnes par nom ou les joindre à d'autres tables. La fonction
   produit une table virtuelle avec laquelle vous pouvez réaliser toutes les
   opérations que vous souhaitez (c'est-à-dire agrégation, jointure, tri, etc.)
   Donc nous pouvons aussi avoir&nbsp;:
  </para>

  <programlisting><![CDATA[
SELECT t.title, p.fullname, p.email 
FROM xpath_table('article_id','article_xml','articles',
            '/article/title|/article/author/@id',
            'xpath_string(article_xml,''/article/@date'') > ''2003-03-20'' ')
            AS t(article_id integer, title text, author_id integer), 
     tblPeopleInfo AS p 
WHERE t.author_id = p.person_id;
  ]]></programlisting>

  <para>
   comme exemple plus compliqué. Bien sûr, vous pouvez placer tout ceci dans
   une vue pour une utilisation plus simple.
  </para>
  <sect3>
   <title>Résultats à plusieurs valeurs</title>
   <para>
    La fonction xpath_table suppose que les résultats de chaque requête
    XPath ramènent plusieurs valeurs, donc le nombre de lignes renvoyées
    par la fonction pourrait ne pas être le même que le nombre de documents
    en entrée. La première ligne renvoyée contient le premier résultat de
    chaque requête, la deuxième le second résultat de chaque requête. Si
    une res requêtes a moins de valeur que les autres, NULL sera renvoyé.
   </para>
   <para>
    Dans certains cas, un utilisateur saura qu'une requête XPath renverra
    seulement un seul résultat, peut-être un identifiant unique de
    document) - si elle est utilisée avec une requête XPath renvoyant plusieurs
    résultats, le résultat sur une ligne apparaîtra seulement sur la première
    ligne du résultat. La solution à cela est d'utiliser le champ clé pour
    une jointure avec une requête XPath. Comme exemple&nbsp;:
   </para>
   
   <para>
    <literal>
    CREATE TABLE test
    (
      id int4 NOT NULL,
      xml text,
      CONSTRAINT pk PRIMARY KEY (id)
    ) 
    WITHOUT OIDS;
    
    INSERT INTO test VALUES (1, '&lt;doc num="C1">
    &lt;line num="L1">&lt;a>1&lt;/a>&lt;b>2&lt;/b>&lt;c>3&lt;/c>&lt;/line>
    &lt;line num="L2">&lt;a>11&lt;/a>&lt;b>22&lt;/b>&lt;c>33&lt;/c>&lt;/line>
    &lt;/doc>');
    
    INSERT INTO test VALUES (2, '&lt;doc num="C2">
    &lt;line num="L1">&lt;a>111&lt;/a>&lt;b>222&lt;/b>&lt;c>333&lt;/c>&lt;/line>
    &lt;line num="L2">&lt;a>111&lt;/a>&lt;b>222&lt;/b>&lt;c>333&lt;/c>&lt;/line>
    &lt;/doc>');
    </literal>
   </para>
  </sect3>
   
  <sect3>
   <title>La requête</title>
   
   <programlisting>
   SELECT * FROM  xpath_table('id','xml','test', 
   '/doc/@num|/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c','1=1') 
   AS t(id int4, doc_num varchar(10), line_num varchar(10), val1 int4, 
   val2 int4, val3 int4)
   WHERE id = 1 ORDER BY doc_num, line_num
   </programlisting>
   
   <para>
   donne le résultat&nbsp;:
   </para>
   
   <programlisting>
    id | doc_num | line_num | val1 | val2 | val3
   ----+---------+----------+------+------+------
     1 | C1      | L1       |    1 |    2 |    3
     1 |         | L2       |   11 |   22 |   33
   </programlisting>
   
   <para>
   Pour obtenir doc_num sur chaque ligne, la solution est d'utiliser deux appels
   à xpath_table et joindre les résultats&nbsp;:
   </para>
   
   <programlisting>
   SELECT t.*,i.doc_num FROM 
     xpath_table('id','xml','test',
      '/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c','1=1') 
           AS t(id int4, line_num varchar(10), val1 int4, val2 int4, val3 int4),
     xpath_table('id','xml','test','/doc/@num','1=1') 
           AS i(id int4, doc_num varchar(10))
   WHERE i.id=t.id AND i.id=1
   ORDER BY doc_num, line_num;
   </programlisting>
   
   <para>
   qui donne le résultat désiré&nbsp;:
   </para>
   
   <programlisting>
    id | line_num | val1 | val2 | val3 | doc_num
   ----+----------+------+------+------+---------
     1 | L1       |    1 |    2 |    3 | C1
     1 | L2       |   11 |   22 |   33 | C1
   (2 rows)
   </programlisting>
  </sect3>
 </sect2>

 <sect2>
  <title>Fonctions XSLT</title>
  <para>
   Les fonctions suivantes sont disponibles si libxslt est installé (ceci
   n'est pas détecté automatiquement, donc vous aurez besoin de corriger le
   Makefile).
  </para>

  <sect3>
   <title><literal>xslt_process</literal></title>
   <programlisting>
    xslt_process(document,stylesheet,paramlist) RETURNS text
   </programlisting>

   <para>
    Cette fonction applique la feuille de style XSLT au document et renvoie
    le résultat transformé. Le paramètre paramlist est une liste de paramètres
    à utiliser dans la transformation, spécifiée sous la forme
    'a=1,b=2'. Notez que c'est un code non stable et que l'analyse des
    paramètres est simpliste (c'est-à-dire que les valeurs des paramètres ne
    peuvent pas contenir de virgules&nbsp;!)
   </para>
   <para>
    De plus, notez que si le document ou les valeurs de la feuille de style
    ne commencent pas avec un &lt;, ils seront traités comme des URL et
    libxslt tentera de les récupérer. Donc, vous pouvez utiliser
    xslt_process comme moyen pour récupérer le contenu d'URL. Vous devez
    en comprendre les implications en terme de sécurité.
   </para> 
   <para>
    Il existe aussi une version de xslt_process à deux paramètres qui ne passe
    pas de paramètres pour la transformation.
   </para>
  </sect3>
 </sect2>

 <sect2>
  <title>Crédits</title>
  <para>
   Le développement de ce module a été sponsorisé par Torchbox Ltd.
   (www.torchbox.com)
   Il utilise la même licence BSD que PostgreSQL.
  </para>
  <para>
   Cette version des fonctions XML fournit à la fois les requêtes XPath
   et les fonctionnalités du XSLT. Il y a aussi une nouvelle fonction SRF
   qui permet un renvoi simple de plusieurs résultats XML. Notez que le code
   actuel ne fait pas particulièrement attention aux jeux de caractères. Ceci
   devra être corrigé un jour&nbsp;!
  </para>
  <para>
   Si vous avez des commentaires ou des suggestions, merci de me contacter
   sur mon adresse mail (<email>jgray@azuli.co.uk.</email>). Malheureusement,
   ce n'est pas mon travail principal, donc je ne garantis par une réponse
   rapide à votre demande&nbsp;!
  </para>
 </sect2>
</sect1>

