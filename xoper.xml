<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

 <sect1 id="xoper">
  <title>Opérateurs définis par l'utilisateur</title>

  <para> chaque opérateur est un <quote>sucre syntaxique</quote> pour l'appel
  d'une fonction sous-jacente qui effectue le véritable travail&nbsp;; aussi
  devez-vous en premier lieu créer cette fonction avant de pouvoir créer
  l'opérateur. Toutefois, un opérateur n'est pas <emphasis>simplement</emphasis>
  un <quote>sucre syntaxique</quote> car il apporte des informations
  supplémentaires qui aident le planificateur de requête à optimiser les
  requêtes utilisées par l'opérateur. La prochaine section est consacrée à
  l'explication de ces informations additionnelles. </para>

  <para>
   <productname>postgresql</productname> accepte les opérateurs unaire gauche,
   unaire droit et binaire. Les opérateurs peuvent être surchargés&nbsp;;
   c'est-à-dire que le même nom d'opérateur peut être utilisé pour différents 
   opérateurs à condition qu'ils aient des nombres et des types différents
   d'opérandes. Quand une requête est exécutée, le système détermine l'opérateur
   à appeler en fonction du nombre et des types d'opérandes fournis.
  </para>

  <para>
   Voici un exemple de création d'opérateur pour l'addition de deux nombres
   complexes. Nous supposons avoir déjà créé la définition du type
   <type>complex</type> (voir la <xref linkend="xtypes"/>). premièrement, nous
   avons besoin d'une fonction qui fasse le travail, ensuite nous pouvons
   définir l'opérateur&nbsp;:

<programlisting>CREATE FUNCTION complex_add(complex, complex)
    RETURNS complex
    AS '<replaceable>filename</replaceable>', 'complex_add'
    LANGUAGE C;

CREATE OPERATOR + ( leftarg = complex, rightarg = complex, procedure =
complex_add, commutator = + ); </programlisting> </para>

  <para>
   Maintenant nous pouvons exécuter la requête comme ceci&nbsp;:
     
<screen>SELECT (a + b) AS c FROM test_complex;

        c
-----------------
 (5.2,6.05)
 (133.42,144.95)
</screen>
  </para>

  <para>
   Nous avons montré comment créer un opérateur binaire. Pour créer des
   opérateurs unaires, il suffit d'omettre un des <literal>leftarg</literal> (pour un
   opérateur unaire gauche) ou <literal>rightarg</literal> (pour un opérateur unaire
   droit). La clause <literal>procedure</literal> et les clauses argument sont les
   seuls éléments requis dans la commande <command>create operator</command>. la
   clause <literal>commutator</literal> montrée dans l'exemple est une indication 
   optionnelle pour l'optimiseur de requête. Des détails supplémentaires sur la
   clause <literal>commutator</literal> et d'autres compléments d'optimisation sont
   donnés dans la prochaine section.
  </para>
 </sect1>

  <sect1 id="xoper-optimization">
   <title>Informations sur l'optimisation d'un opérateur</title>

   <para>
    Une définition d'opérateur <productname>PostgreSQL</productname> peut
    inclure plusieurs clauses optionnelles qui donnent au système des
    informations utiles sur le comportement de l'opérateur. Ces clauses
    devraient être fournies chaque fois que c'est utile car elles peuvent
    considérablement accélérer l'exécution des requêtes utilisant cet opérateur.
    Mais si vous le faites, vous devez être sûr de leur justesse&nbsp;! L'usage
    incorrect d'une clause d'optimisation peut être la cause de requêtes
    lentes, des sorties subtilement fausses ou d'autres effets
    pervers. Vous pouvez toujours abandonner une clause d'optimisation si vous
    n'êtes pas sûr d'elle&nbsp;; la seule conséquence est un possible
    ralentissement des requêtes.
   </para>
   
   <para>
    Des clauses additionnelles d'optimisation pourront être ajoutées dans les
    futures versions de <productname>postgresql</productname>. celles décrites
    ici sont toutes celles que cette version comprend.
   </para>

   <sect2>
    <title><literal>COMMUTATOR</literal></title>

    <para>
     Si elle est fournie, la clause <literal>commutator</literal> désigne un opérateur
    qui est le commutateur de l'opérateur en cours de définition. Nous disons
    qu'un opérateur A est le commutateur de l'opérateur B si (x A y) est égal à
    (y B x) pour toute valeur possible de x, y. Notez que B est aussi le
    commutateur de A. Par exemple, les opérateurs <literal>&lt;</literal> et
    <literal>&gt;</literal> pour un type particulier de données sont habituellement des
    commutateurs l'un pour l'autre, et l'opérateur <literal>+</literal> est
    habituellement commutatif avec lui-même. Mais l'opérateur <literal>-</literal> 
    n'est habituellement commutatif avec rien.
    </para>
    
    <para>
    Le type de l'opérande gauche d'un opérateur commuté est le même que
    l'opérande droit de son commutateur, et vice versa. Aussi
    <productname>postgresql</productname> n'a besoin que du nom de l'opérateur
    commutateur pour consulter le commutateur, et c'est tout ce qui doit être
    fourni à la clause <literal>commutator</literal> .
    </para>

    <para>
    Vous avez juste à définir un opérateur auto-commutateur. Mais les choses
    sont un peu plus compliquées quand vous définissez une paire de
    commutateurs&nbsp;: comment peut-on définir la référence du premier au
    second alors que ce dernier n'est pas encore défini&nbsp;? Il y a deux
    solutions à ce problème&nbsp;:
 
     <itemizedlist>
      <listitem>
       <para>
	Une façon d'opérer est d'omettre la clause <literal>commutator</literal> dans
	le premier opérateur que vous définissez et ensuite d'en insérer une
	dans la définition du second opérateur. Puisque
	<productname>postgresql</productname> sait que les opérateurs
	commutatifs vont par paire, quand il voit la seconde définition, il
	retourne instantanément remplir la clause <literal>commutator</literal>
	manquante dans la première définition.
       </para>
      </listitem>

      <listitem>
       <para>
	L'autre façon, plus directe, est de simplement inclure les clauses
	<literal>commutator</literal> dans les deux définitions. quand 
	<productname>postgresql</productname> traite la première définition et
	réalise que la clause <literal>commutator</literal> se réfère à un opérateur
	inexistant, le système va créer une entrée provisoire pour cet opérateur
	dans le catalogue système. Cette entrée sera pourvue seulement de
	données valides pour le nom de l'opérateur, les types d'opérande droit
	et gauche et le type du résultat, puisque c'est tout ce que
	<productname>postgresql</productname> peut déduire à ce point. la
	première entrée du catalogue pour l'opérateur sera liée à cette entrée
	provisoire. Plus tard, quand vous définirez le second opérateur, le
	système mettra à jour l'entrée provisoire avec les informations
	additionnelles fournies par la seconde définition. Si vous essayez
	d'utiliser l'opérateur provisoire avant qu'il ne soit complété, vous
	aurez juste un message d'erreur.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

   <sect2>
    <title><literal>NEGATOR</literal></title>

    <para>
    La clause <literal>negator</literal> dénomme un opérateur qui est l'opérateur de
    négation de l'opérateur en cours de définition. Nous disons qu'un opérateur
    A est l'opérateur de négation de l'opérateur B si tous les deux renvoient
    des résultats booléens et si (x A y) est égal à NOT (x B y) pour toutes les
    entrées possible x, y. Notez que B est aussi l'opérateur de négation de A.
    Par exemple, <literal>&lt;</literal> et <literal>&gt;=</literal> forment une paire
    d'opérateurs de négation pour la plupart des types de données. Un opérateur
    ne peut jamais être validé comme son propre opérateur de négation . 
    </para>

    <para>
    Au contraire des commutateurs, une paire d'opérateurs unaires peut être
    validée comme une paire d'opérateurs de négation réciproques&nbsp;; ce qui
    signifie que (A x) est égal à NOT (B x) pour tout x ou l'équivalent pour les
    opérateurs unaires à droite.   
    </para>

    <para>
    L'opérateur de négation d'un opérateur doit avoir les mêmes types
    d'opérandes gauche et/ou droit que l'opérateur à définir comme
    avec <literal>commutator</literal>. seul le nom de l'opérateur doit être donné
    dans la clause <literal>negator</literal>. 
    </para>

    <para>
    Définir un opérateur de négation est très utile pour l'optimiseur de
    requêtes car il permet de simplifier des expressions telles que <literal>not
    (x = y)</literal> en <literal>x &lt;&gt; y</literal>. ceci arrive souvent parce que les
    opérations <literal>not</literal> peuvent être insérées à la suite d'autres
    réarrangements.
    </para>

    <para>
    Des paires d'opérateurs de négation peuvent être définies en utilisant la
    même méthode que pour les commutateurs.
    </para>

  </sect2>

  <sect2>
   <title><literal>RESTRICT</literal></title>

   <para>
    La clause <literal>restrict</literal>, si elle est invoquée, nomme une fonction
    d'estimation de sélectivité de restriction pour cet opérateur (notez que
    c'est un nom de fonction, et non pas un nom d'opérateur). Les clauses
    <literal>restrict</literal> n'ont de sens que pour les opérateurs binaires qui
    renvoient un type <type>boolean</type>. un estimateur de sélectivité de
    restriction repose sur l'idée de prévoir quelle fraction des lignes dans une
    table satisfera une condition de clause <literal>where</literal> de la forme&nbsp;:
<programlisting>colonne OP constante
</programlisting>
    pour l'opérateur courant et une valeur constante particulière. Ceci aide
    l'optimiseur en lui donnant une idée du nombre de lignes qui sera éliminé
    par les clauses <literal>where</literal> qui ont cette forme (vous pouvez vous
    demander, qu'arrivera-t-il si la constante est à gauche&nbsp;? hé bien,
    c'est une des choses à laquelle sert le <literal>commutator</literal>...).
   </para>

   <para>
    L'écriture de nouvelles fonctions d'estimation de restriction de sélectivité
    est éloignée des objectifs de ce chapitre mais, heureusement, vous pouvez
    habituellement utiliser un des estimateurs standards du système pour
    beaucoup de vos propres opérateurs. Voici les estimateurs standards de
    restriction&nbsp;:
    <simplelist>
     <member><function>eqsel</function> pour <literal>=</literal></member>
     <member><function>neqsel</function> pour <literal>&lt;&gt;</literal></member>
     <member><function>scalarltsel</function> pour <literal>&lt;</literal> ou <literal>&lt;=</literal></member>
     <member><function>scalargtsel</function> pour <literal>&gt;</literal> ou <literal>&gt;=</literal></member>
   </simplelist>
    Ces catégories peuvent sembler un peu curieuses mais cela prend un sens si
    vous y réfléchissez. <literal>=</literal> acceptera typiquement une
    petite fraction des lignes d'une table&nbsp;; <literal>&lt;&gt;</literal> rejettera
    typiquement seulement une petite fraction des lignes de la table.
    <literal>&lt;</literal> acceptera une fraction des lignes en fonction de la
    situation de la constante donnée dans la gamme de valeurs de la colonne pour
    cette table (ce qui est justement l'information collectée par la commande
    <command>analyze</command> et rendue disponible pour l'estimateur de
    sélectivité). <literal>&lt;=</literal> acceptera une fraction légèrement plus
    grande que <literal>&lt;</literal> pour la même constante de comparaison mais elles
    sont assez proches pour ne pas valoir la peine d'être distinguées puisque
    nous ne risquons pas de toute façon de faire mieux qu'une grossière
    estimation. La même remarque s'applique à <literal>&gt;</literal> et
    <literal>&gt;=</literal>.
   </para>

   <para>
    Vous pouvez fréquemment vous en sortir à bon compte en utilisant soit
    <function>eqsel</function> ou <function>neqsel</function> pour des
    opérateurs qui ont une très grande ou une très faible sélectivité, même
    s'ils ne sont pas réellement égalité ou inégalité. Par exemple, les
    opérateurs géométriques d'égalité approchée utilisent
    <function>eqsel</function> en supposant habituellement qu'ils ne
    correspondent qu'à une petite fraction des entrées dans une table.
   </para>

   <para>
    Vous pouvez utiliser <function>scalarltsel</function> et <function>scalargtsel</function>
    pour des comparaisons de types de données qui possèdent un moyen de
    conversion en scalaires numériques pour les comparaisons de rang. Si
    possible, ajoutez le type de données à ceux acceptés par la fonction
    <function>convert_to_scalar()</function> dans
    <filename>src/backend/utils/adt/selfuncs.c</filename> (finalement, cette
    fonction devrait être remplacée par des fonctions pour chaque type de
    données identifié grâce à une colonne du catalogue système
    <classname>pg_type</classname>&nbsp;; mais cela n'a pas encore été fait). si vous
    ne faites pas ceci, les choses fonctionneront mais les estimations de
    l'optimiseur ne seront pas aussi bonnes qu'elles pourraient l'être.
   </para>

   <para>
    D'autres fonctions d'estimation de sélectivité conçues pour les opérateurs
    géométriques sont placées dans
    <filename>src/backend/utils/adt/geo_selfuncs.c</filename>&nbsp;:
    <function>areasel</function>, <function>positionsel</function> et
    <function>contsel</function>. lors de cette rédaction, ce sont seulement
    des fragments mais vous pouvez vouloir les utiliser (ou mieux les
    améliorer).
   </para>
   </sect2>

   <sect2>
    <title><literal>JOIN</literal></title>

    <para>
     La clause <literal>join</literal>, si elle est invoquée, nomme une fonction
     d'estimation de sélectivité de jointure pour l'opérateur (notez que c'est
     un nom de fonction, et non pas un nom d'opérateur). Les clauses
     <literal>join</literal> n'ont de sens que pour les opérateurs binaires qui
     renvoient un type <type>boolean</type>. un estimateur de sélectivité de
     jointure repose sur l'idée de prévoir quelle fraction des lignes dans une
     paire de tables satisfera une condition de clause
     <literal>where</literal> de la forme&nbsp;:
<programlisting>table1.colonne1 OP table2.colonne2
</programlisting>
     pour l'opérateur courant. Comme pour la clause <literal>restrict</literal>,
     ceci aide considérablement l'optimiseur en lui indiquant parmi plusieurs
     séquences de jointure possibles laquelle prendra vraisemblablement le moins
     de travail.
    </para>

    <para>
     Comme précédemment, ce chapitre n'essaiera pas d'expliquer comment écrire
     une fonction d'estimation de sélectivité de jointure mais suggérera
     simplement d'utiliser un des estimateurs standard s'il est
     applicable&nbsp;:
     <simplelist>
      <member><function>eqjoinsel</function> pour <literal>=</literal></member>
      <member><function>neqjoinsel</function> pour <literal>&lt;&gt;</literal></member>
      <member><function>scalarltjoinsel</function> pour <literal>&lt;</literal> ou <literal>&lt;=</literal></member>
      <member><function>scalargtjoinsel</function> pour <literal>&gt;</literal> ou <literal>&gt;=</literal></member>
      <member><function>areajoinsel</function> pour des comparaisons basées sur une aire 2d</member>
      <member><function>positionjoinsel</function> pour des comparaisons basées sur une position 2d </member>
      <member><function>contjoinsel</function> pour des comparaisons basées sur un appartenance 2d</member>
     </simplelist>
    </para>
   </sect2>

   <sect2>
    <title><literal>HASHES</literal></title>

    <para>
     La clause <literal>hashes</literal> indique au système qu'il est permis
     d'utiliser la méthode de jointure-découpage pour une jointure basée sur cet
     opérateur. <literal>hashes</literal> n'a de sens que pour un opérateur binaire qui
     renvoie un <literal>boolean</literal> et en pratique l'opérateur égalité doit
     représenter l'égalité pour certains types de données ou paire de type de données.
    </para>

    <para>
     La jointure-découpage repose sur l'hypothèse que l'opérateur de jointure
     peut seulement renvoyer la valeur vrai pour des paires de valeurs droite et
     gauche qui correspondent au même code de découpage. Si deux valeurs sont
     placées dans deux différents paquets (<quote>buckets</quote>), la jointure
     ne pourra jamais les comparer avec la supposition implicite que le 
     résultat de l'opérateur de jointure doit être faux. Ainsi, il n'y a aucun
     sens à spécifier <literal>hashes</literal> pour des opérateurs qui ne
     représentent pas une certaine forme d'égalité. Dans la plupart des cas, il
     est seulement pratique de supporter le hachage pour les opérateurs qui
     prennent le même type de données sur chaque côté. Néanmoins, quelque
     fois, il est possible de concevoir des fonctions de hachage compatibles
     pour deux type de données, voire plus&nbsp;; c'est-à-dire pour les
     fonctions qui généreront les mêmes codes de hachage pour des valeurs
     égales même si elles ont des représentations différentes. Par exemple,
     il est assez simple d'arranger cette propriété lors du hachage d'entiers
     de largeurs différentes.
    </para>

    <para>
     Pour être marqué <literal>hashes</literal>, l'opérateur de jointure doit
     apparaître dans une famille d'opérateurs d'index de découpage. Ceci n'est
     pas rendu obligatoire quand vous créez l'opérateur, puisque évidemment la
     classe référençant l'opérateur peut ne pas encore exister. Mais les
     tentatives d'utilisation de l'opérateur dans les jointure-découpage
     échoueront à l'exécution si une telle famille d'opérateur n'existe pas. Le
     système a besoin de la famille d'opérateur pour définir la fonction de
     découpage spécifique au type de données d'entrée de l'opérateur. Bien sûr,
     vous devez également créer des fonctions de découpage appropriées avant de
     pouvoir créer la famille d'opérateur.
    </para>

    <para>
     On doit apporter une grande attention à la préparation des fonctions de
     découpage parce qu'il y a des processus dépendants de la machine qui
     peuvent ne pas faire les choses correctement. Par exemple, si votre type de
     données est une structure dans laquelle peuvent se trouver des bits de
     remplissage sans intérêt, vous ne pouvez pas simplement passer la structure
     complète à la fonction <function>hash_any</function> (à moins d'écrire vos autres
     opérateurs et fonctions de façon à s'assurer que les bits inutilisés sont
     toujours zéro, ce qui est la stratégie recommandée). Un autre exemple est
     fourni sur les machines qui respectent le standard de virgule-flottante
     <acronym>ieee</acronym>, le zéro négatif et le zéro positif sont des valeurs
     différentes (les motifs de bit sont différents) mais ils sont définis pour
     être égaux. Si une valeur flottante peut contenir un zéro négatif, alors
     une étape supplémentaire est nécessaire pour s'assurer qu'elle génère la
     même valeur de découpage qu'un zéro positif.
    </para>

    <para>
     Un opérateur joignable par hachage doit avoir un commutateur (lui-même
     si les types de données des deux opérandes sont identiques, ou un
     opérateur d'égalité relatif dans le cas contraire) qui apparaît dans la
     même famille d'opérateur. Si ce n'est pas le cas, des erreurs du
     planificateur pourraient apparaître quand l'opérateur est utilisé. De plus,
     une bonne idée (mais pas obligatoire) est qu'une famille d'opérateur de
     hachage supporte les tupes de données multiples pour fournir des
     opérateurs d'égalité pour chaque combinaison des types de données&nbsp;;
     cela permet une meilleure optimisation.
    </para>

    <note>
    <para>
     La fonction sous-jacente à un opérateur de jointure-découpage doit être
     marquée immuable ou stable. Si elle est volatile, le système n'essaiera
     jamais d'utiliser l'opérateur pour une jointure hachage.
    </para>
    </note>

    <note>
    <para>
     Si un opérateur de jointure-hachage a une fonction sous-jacente marquée
     stricte, la fonction doit également être complète&nbsp;: cela signifie
     qu'elle doit renvoyer TRUE ou FALSE, jamais NULL, pour n'importe quelle
     double entrée non NULL. Si cette règle n'est pas respectée, l'optimisation
     de découpage des opérations <literal>in</literal> peut générer des résultats
     faux (spécifiquement, <literal>in</literal> devrait renvoyer false quand la
     réponse correcte devrait être NULL&nbsp;; ou bien il devrait renvoyer une
     erreur indiquant qu'il ne s'attendait pas à un résultat NULL).
    </para>
    </note>

   </sect2>

   <sect2>
    <title><literal>MERGES</literal></title>

    <para> La clause <literal>merges</literal>, si elle est présente, indique au
    système qu'il est permis d'utiliser la méthode de jointure-union pour une
    jointure basée sur cet opérateur. <literal>merges</literal> n'a de sens que pour un
    opérateur binaire qui renvoie un <literal>boolean</literal> et, en pratique, cet
    opérateur doit représenter l'égalité pour des types de données ou des paires
    de types de données. </para>

    <para> La jointure-union est fondée sur le principe d'ordonner les tables
    gauche et droite et ensuite de les comparer en parallèle. Ainsi, les deux
    types de données doivent être capable d'être pleinement ordonnées, et
    l'opérateur de jointure doit pouvoir réussir seulement pour des paires de
    valeurs tombant à la <quote>même place</quote> dans l'ordre de tri. En pratique,
    cela signifie que l'opérateur de jointure doit se comporter comme
    l'opérateur égalité. Mais il est possible de faire une jointure-union sur
    deux types de données distincts tant qu'ils sont logiquement compatibles.
    Par exemple, l'opérateur d'égalité
    <type>smallint</type>-contre-<type>integer</type> est susceptible d'opérer
    une jointure-union. Nous avons seulement besoin d'opérateurs de tri qui
    organisent les deux types de données en séquences logiquement comparables.
    </para>

    <para>
     Pour être marqué <literal>MERGES</literal>, l'opérateur de jointure doit
     apparaître en tant que membre d'égalité d'une famille opérateur d'index
     btree. Ceci n'est pas forcé quand vous créez l'opérateur puisque, bien
     sûr, la famille d'opérateur référente n'existe pas encore. Mais
     l'opérateur ne sera pas utilisé pour les jointures de fusion sauf si
     une famille d'opérateur correspondante est trouvée. L'option
     <literal>MERGES</literal> agit en fait comme une aide pour le planificateur
     lui indiquant qu'il est intéressant de chercher une famille d'opérateur
     correspondant.
    </para>

    <para>
     Un opérateur joignable par fusion doit avoir un commutateur
     (lui-même si les types de données des deux opérateurs sont identiques,
     ou un opérateur d'égalité en relation dans le cas contraire) qui
     apparaîtdans la même famille d'opérateur.  Si ce n'est pas le cas, des
     erreurs du
     planificateur pourraient apparaître quand l'opérateur est utilisé. De plus,
     une bonne idée (mais pas obligatoire) est qu'une famille d'opérateur de
     hachage supporte les tupes de données multiples pour fournir des
     opérateurs d'égalité pour chaque combinaison des types de données&nbsp;;
     cela permet une meilleure optimisation.
    </para>

    <note>
    <para>
     La fonction sous-jacente à un opérateur de jointure-union doit être marquée
     immuable ou stable. Si elle est volatile, le système n'essaiera jamais
     d'utiliser l'opérateur pour une jointure union.
    </para>
    </note>

   </sect2>
  </sect1>
